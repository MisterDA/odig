<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Matrix (archimedes.Archimedes.Matrix)</title><link rel="stylesheet" href="../../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../../index.html">archimedes</a> &#x00BB; <a href="../index.html">Archimedes</a> &#x00BB; Matrix</nav><h1>Module <code>Archimedes.Matrix</code></h1><p>Module implementing affine transformations and various operations on them.</p><h3 id="base-elements-of-a-plot"><a href="#base-elements-of-a-plot" class="anchor"></a>Base elements of a plot</h3></header><dl><dt class="spec type" id="type-affine"><a href="#type-affine" class="anchor"></a><code><span class="keyword">type</span> affine</code><code> = </code><code>{</code><table class="record"><tr id="type-affine.xx" class="anchored"><td class="def field"><a href="#type-affine.xx" class="anchor"></a><code><span class="keyword">mutable</span> xx : float;</code></td></tr><tr id="type-affine.yx" class="anchored"><td class="def field"><a href="#type-affine.yx" class="anchor"></a><code><span class="keyword">mutable</span> yx : float;</code></td></tr><tr id="type-affine.xy" class="anchored"><td class="def field"><a href="#type-affine.xy" class="anchor"></a><code><span class="keyword">mutable</span> xy : float;</code></td></tr><tr id="type-affine.yy" class="anchored"><td class="def field"><a href="#type-affine.yy" class="anchor"></a><code><span class="keyword">mutable</span> yy : float;</code></td></tr><tr id="type-affine.x0" class="anchored"><td class="def field"><a href="#type-affine.x0" class="anchor"></a><code><span class="keyword">mutable</span> x0 : float;</code></td></tr><tr id="type-affine.y0" class="anchored"><td class="def field"><a href="#type-affine.y0" class="anchor"></a><code><span class="keyword">mutable</span> y0 : float;</code></td></tr></table><code>}</code></dt><dd><p>Holds an affine transformation, such as a scale, rotation, shear, or a combination of those. The transformation of a point (x, y) is given by:</p><pre><code class="ml">x_new = xx *. x +. xy *. y +. x0;
y_new = yx *. x +. yy *. y +. y0;      </code></pre></dd></dl><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> t</code><code> = <a href="index.html#type-affine">affine</a></code></dt></dl><dl><dt class="spec exception" id="exception-Not_invertible"><a href="#exception-Not_invertible" class="anchor"></a><code><span class="keyword">exception</span> </code><code><span class="exception">Not_invertible</span></code></dt></dl><dl><dt class="spec value" id="val-make_identity"><a href="#val-make_identity" class="anchor"></a><code><span class="keyword">val</span> make_identity : unit <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>make_identity()</code> returns the identity transformation.</p></dd></dl><dl><dt class="spec value" id="val-make_translate"><a href="#val-make_translate" class="anchor"></a><code><span class="keyword">val</span> make_translate : x:float <span>&#45;&gt;</span> y:float <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>make_translate tx ty</code> returns a transformation that translates by <code>tx</code> and <code>ty</code> in the X and Y dimensions, respectively.</p></dd></dl><dl><dt class="spec value" id="val-make_scale"><a href="#val-make_scale" class="anchor"></a><code><span class="keyword">val</span> make_scale : x:float <span>&#45;&gt;</span> y:float <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>make_scale sx sy</code> returns a transformation that scales by <code>sx</code> and <code>sy</code> in the X and Y dimensions, respectively.</p></dd></dl><dl><dt class="spec value" id="val-make_rotate"><a href="#val-make_rotate" class="anchor"></a><code><span class="keyword">val</span> make_rotate : angle:float <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>make_rotate radians</code> returns a transformation that rotates by <code>radians</code>.</p></dd></dl><dl><dt class="spec value" id="val-set_to_identity"><a href="#val-set_to_identity" class="anchor"></a><code><span class="keyword">val</span> set_to_identity : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Sets the current transformation to the identity transformation.</p></dd></dl><dl><dt class="spec value" id="val-copy"><a href="#val-copy" class="anchor"></a><code><span class="keyword">val</span> copy : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>copy matrix</code> returns a copy of <code>matrix</code>.</p></dd></dl><dl><dt class="spec value" id="val-blit"><a href="#val-blit" class="anchor"></a><code><span class="keyword">val</span> blit : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>blit m1 m2</code> copies the content of <code>m1</code> into <code>m2</code>.</p></dd></dl><dl><dt class="spec value" id="val-translate"><a href="#val-translate" class="anchor"></a><code><span class="keyword">val</span> translate : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> x:float <span>&#45;&gt;</span> y:float <span>&#45;&gt;</span> unit</code></dt><dd><p><code>translate m tx ty</code> applies a translation by <code>tx</code>, <code>ty</code> to the transformation in <code>m</code>. The effect of the new transformation is to <i>first</i> translate the coordinates by <code>tx</code> and <code>ty</code>, then apply the original transformation to the coordinates.</p></dd></dl><dl><dt class="spec value" id="val-scale"><a href="#val-scale" class="anchor"></a><code><span class="keyword">val</span> scale : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> x:float <span>&#45;&gt;</span> y:float <span>&#45;&gt;</span> unit</code></dt><dd><p><code>scale m sx sy</code> applies scaling by <code>sx</code>, <code>sy</code> to the transformation in <code>m</code>. The effect of the new transformation is to <i>first</i> scale the coordinates by <code>sx</code> and <code>sy</code>, then apply the original transformation to the coordinates.</p></dd></dl><dl><dt class="spec value" id="val-rotate"><a href="#val-rotate" class="anchor"></a><code><span class="keyword">val</span> rotate : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> angle:float <span>&#45;&gt;</span> unit</code></dt><dd><p><code>rotate m radians</code> applies rotation by <code>radians</code> to the transformation in <code>m</code>. The effect of the new transformation is to <i>first</i> rotate the coordinates by <code>radians</code>, then apply the original transformation to the coordinates.</p></dd></dl><dl><dt class="spec value" id="val-invert"><a href="#val-invert" class="anchor"></a><code><span class="keyword">val</span> invert : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>invert m</code> changes <code>matrix</code> to be the inverse of it's original value. Not all transformation matrices have inverses; if the matrix collapses points together (it is degenerate), then it has no inverse and this function will raise <a href="index.html#exception-Not_invertible"><code>Matrix.Not_invertible</code></a>.</p></dd></dl><dl><dt class="spec value" id="val-det"><a href="#val-det" class="anchor"></a><code><span class="keyword">val</span> det : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> float</code></dt><dd><p><code>det m</code> returns the determinant of the linear part of <code>m</code>. It is the (signed) area that gets the unit square after transformation.</p></dd></dl><dl><dt class="spec value" id="val-mul"><a href="#val-mul" class="anchor"></a><code><span class="keyword">val</span> mul : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>multiply b a</code> multiplies the affine transformations in <code>a</code> and <code>b</code> together and return the result. The effect of the resulting transformation is to <i>first</i> apply the transformation in <code>a</code> to the coordinates and then apply the transformation in <code>b</code> to the coordinates.</p><p>BEWARE that the order of the arguments is different from e.g. <code>Cairo.Matrix.multiply</code>.</p></dd></dl><dl><dt class="spec value" id="val-mul_in"><a href="#val-mul_in" class="anchor"></a><code><span class="keyword">val</span> mul_in : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>mul_in c b a</code> computes <code>mul b a</code> and put the result in <code>c</code>.</p></dd></dl><dl><dt class="spec value" id="val-transform_point"><a href="#val-transform_point" class="anchor"></a><code><span class="keyword">val</span> transform_point : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> x:float <span>&#45;&gt;</span> y:float <span>&#45;&gt;</span> float * float</code></dt><dd><p><code>transform_point m x y</code> transforms the point (<code>x</code>, <code>y</code>) by <code>m</code>.</p></dd></dl><dl><dt class="spec value" id="val-transform_distance"><a href="#val-transform_distance" class="anchor"></a><code><span class="keyword">val</span> transform_distance : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> dx:float <span>&#45;&gt;</span> dy:float <span>&#45;&gt;</span> float * float</code></dt><dd><p><code>transform_distance m dx dy</code> transforms the distance vector (<code>dx</code>,<code>dy</code>) by <code>m</code>. This is similar to <a href="index.html#val-transform_point"><code>Matrix.transform_point</code></a> except that the translation components of the transformation are ignored. The calculation of the returned vector is as follows:</p><pre><code class="ml">dx2 = dx1 * xx + dy1 * xy;
dy2 = dx1 * yx + dy1 * yy;</code></pre><p>Affine transformations are position invariant, so the same vector always transforms to the same vector. If (x1,y1) transforms to (x2,y2) then (x1+dx1,y1+dy1) will transform to (x2+dx2,y2+dy2) for all values of dx1 and dy1.</p></dd></dl><dl><dt class="spec value" id="val-inv_transform_point"><a href="#val-inv_transform_point" class="anchor"></a><code><span class="keyword">val</span> inv_transform_point : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> x:float <span>&#45;&gt;</span> y:float <span>&#45;&gt;</span> float * float</code></dt><dd><p>Makes the inverse transformation of a point.</p></dd></dl><dl><dt class="spec value" id="val-inv_transform_distance"><a href="#val-inv_transform_distance" class="anchor"></a><code><span class="keyword">val</span> inv_transform_distance : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> dx:float <span>&#45;&gt;</span> dy:float <span>&#45;&gt;</span> float * float</code></dt><dd><p>Makes the inverse transformation of a distance.</p></dd></dl><dl><dt class="spec value" id="val-has_shear"><a href="#val-has_shear" class="anchor"></a><code><span class="keyword">val</span> has_shear : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p>Tests whether the transformation has shears. This is also the case if the transformation does a rotation.</p></dd></dl><dl><dt class="spec type" id="type-rectangle"><a href="#type-rectangle" class="anchor"></a><code><span class="keyword">type</span> rectangle</code><code> = </code><code>{</code><table class="record"><tr id="type-rectangle.x" class="anchored"><td class="def field"><a href="#type-rectangle.x" class="anchor"></a><code>x : float;</code></td><td class="doc"><p>X coordinate of the left side of the rectangle</p></td></tr><tr id="type-rectangle.y" class="anchored"><td class="def field"><a href="#type-rectangle.y" class="anchor"></a><code>y : float;</code></td><td class="doc"><p>Y coordinate of the the top side of the rectangle</p></td></tr><tr id="type-rectangle.w" class="anchored"><td class="def field"><a href="#type-rectangle.w" class="anchor"></a><code>w : float;</code></td><td class="doc"><p>width of the rectangle <code>&gt;= 0</code>.</p></td></tr><tr id="type-rectangle.h" class="anchored"><td class="def field"><a href="#type-rectangle.h" class="anchor"></a><code>h : float;</code></td><td class="doc"><p>height of the rectangle <code>&gt;= 0</code>.</p></td></tr></table><code>}</code></dt><dd><p>A data structure for holding a rectangle.</p></dd></dl><dl><dt class="spec value" id="val-transform_rectangle"><a href="#val-transform_rectangle" class="anchor"></a><code><span class="keyword">val</span> transform_rectangle : ?&#8288;dist_basepoint:bool <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-rectangle">rectangle</a> <span>&#45;&gt;</span> <a href="index.html#type-rectangle">rectangle</a></code></dt><dd><p>Transformation of rectangles. This returns the smallest rectangle containing the transformation of the rectangle argument by the matrix. The optional argument <code>dist_basepoint</code> has the following meaning:</p><ul><li>Not specified: transform the base point as a point.</li><li>Specified as <code>true</code>: transform the base point as a distance.</li><li>Specified as <code>false</code>: no transformation of the base point.</li></ul></dd></dl><dl><dt class="spec module" id="module-Homothety"><a href="#module-Homothety" class="anchor"></a><code><span class="keyword">module</span> <a href="Homothety/index.html">Homothety</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Transformations that are the composition of translations and inhomogeneous dilations (different scaling factors are allowed in each canonical direction).</p></dd></dl></div></body></html>