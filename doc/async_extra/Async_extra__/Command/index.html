<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Command (async_extra.Async_extra__.Command)</title><link rel="stylesheet" href="../../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../../index.html">async_extra</a> &#x00BB; <a href="../index.html">Async_extra__</a> &#x00BB; Command</nav><h1>Module <code>Async_extra__.Command</code></h1></header><aside><p><code>Async.Command</code> is <a href="../../../core/Core/Command/index.html"><span><code>Core.Command</code></span></a> with additional Async functions.</p></aside><div><div class="spec include"><div class="doc"><details open="open"><summary><span class="def"><code><span class="keyword">include</span> <span class="keyword">module</span> <span class="keyword">type</span> <span class="keyword">of</span> <a href="../../../core/Core/index.html#module-Command">Core.Command</a> <span class="keyword">with</span> <span class="keyword">type</span> <a href="../../../core/Core/index.html#module-Command">Command</a>.t = <a href="../../../core/Core/Command/index.html#type-t">Core.Command.t</a> <span class="keyword">with</span> <span class="keyword">module</span> <a href="../../../core/Core/index.html#module-Command">Command</a>.Spec = <a href="../../../core/Core/Command/index.html#module-Spec">Core.Command.Spec</a></code></span></summary><div class="spec module" id="module-Arg_type"><a href="#module-Arg_type" class="anchor"></a><code><span class="keyword">module</span> <a href="Arg_type/index.html">Arg_type</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><div class="spec module" id="module-Flag"><a href="#module-Flag" class="anchor"></a><code><span class="keyword">module</span> <a href="Flag/index.html">Flag</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><div class="spec module" id="module-Anons"><a href="#module-Anons" class="anchor"></a><code><span class="keyword">module</span> <a href="Anons/index.html">Anons</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><div class="spec module" id="module-Param"><a href="#module-Param" class="anchor"></a><code><span class="keyword">module</span> <a href="Param/index.html">Param</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><div class="spec module" id="module-Let_syntax"><a href="#module-Let_syntax" class="anchor"></a><code><span class="keyword">module</span> <a href="Let_syntax/index.html">Let_syntax</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><div class="spec module" id="module-Spec"><a href="#module-Spec" class="anchor"></a><code><span class="keyword">module</span> <a href="Spec/index.html">Spec</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> t</code><code> = <a href="../../../core/Core/Command/index.html#type-t">Core.Command.t</a></code></dt><dt class="spec type" id="type-basic_spec_command"><a href="#type-basic_spec_command" class="anchor"></a><code><span class="keyword">type</span> ('main, 'result) basic_spec_command</code><code> = summary:string <span>&#45;&gt;</span> ?&#8288;readme:(unit <span>&#45;&gt;</span> string) <span>&#45;&gt;</span> (<span class="type-var">'main</span>, unit <span>&#45;&gt;</span> <span class="type-var">'result</span>) <a href="../../../core/Core__Command/Spec/index.html#type-t">Spec.t</a> <span>&#45;&gt;</span> <span class="type-var">'main</span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt></dl><dl><dt class="spec value" id="val-basic_spec"><a href="#val-basic_spec" class="anchor"></a><code><span class="keyword">val</span> basic_spec : (<span class="type-var">'main</span>, unit) <a href="index.html#type-basic_spec_command">basic_spec_command</a></code></dt></dl><dl><dt class="spec type" id="type-basic_command"><a href="#type-basic_command" class="anchor"></a><code><span class="keyword">type</span> 'result basic_command</code><code> = summary:string <span>&#45;&gt;</span> ?&#8288;readme:(unit <span>&#45;&gt;</span> string) <span>&#45;&gt;</span> (unit <span>&#45;&gt;</span> <span class="type-var">'result</span>) <a href="../../../core/Core__Command/Param/index.html#type-t">Param.t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt></dl><dl><dt class="spec value" id="val-basic"><a href="#val-basic" class="anchor"></a><code><span class="keyword">val</span> basic : unit <a href="index.html#type-basic_command">basic_command</a></code></dt><dt class="spec value" id="val-group"><a href="#val-group" class="anchor"></a><code><span class="keyword">val</span> group : summary:string <span>&#45;&gt;</span> ?&#8288;readme:(unit <span>&#45;&gt;</span> string) <span>&#45;&gt;</span> ?&#8288;preserve_subcommand_order:unit <span>&#45;&gt;</span> ?&#8288;body:(path:string list <span>&#45;&gt;</span> unit) <span>&#45;&gt;</span> (string * <a href="index.html#type-t">t</a>) list <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-lazy_group"><a href="#val-lazy_group" class="anchor"></a><code><span class="keyword">val</span> lazy_group : summary:string <span>&#45;&gt;</span> ?&#8288;readme:(unit <span>&#45;&gt;</span> string) <span>&#45;&gt;</span> ?&#8288;preserve_subcommand_order:unit <span>&#45;&gt;</span> ?&#8288;body:(path:string list <span>&#45;&gt;</span> unit) <span>&#45;&gt;</span> (string * <a href="index.html#type-t">t</a>) list <a href="../../../core_kernel/Core_kernel/Lazy/index.html#type-t">Core__.Import.Lazy.t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-exec"><a href="#val-exec" class="anchor"></a><code><span class="keyword">val</span> exec : summary:string <span>&#45;&gt;</span> ?&#8288;readme:(unit <span>&#45;&gt;</span> string) <span>&#45;&gt;</span> ?&#8288;child_subcommand:string list <span>&#45;&gt;</span> path_to_exe:[ `Absolute of string | `Relative_to_argv0 of string | `Relative_to_me of string ] <span>&#45;&gt;</span> unit <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-of_lazy"><a href="#val-of_lazy" class="anchor"></a><code><span class="keyword">val</span> of_lazy : <a href="index.html#type-t">t</a> <a href="../../../core_kernel/Core_kernel/Lazy/index.html#type-t">Core__.Import.Lazy.t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-summary"><a href="#val-summary" class="anchor"></a><code><span class="keyword">val</span> summary : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> string</code></dt></dl><div class="spec module" id="module-Shape"><a href="#module-Shape" class="anchor"></a><code><span class="keyword">module</span> <a href="Shape/index.html">Shape</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><dl><dt class="spec value" id="val-shape"><a href="#val-shape" class="anchor"></a><code><span class="keyword">val</span> shape : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../../../core/Core__Command/Shape/index.html#type-t">Shape.t</a></code></dt><dt class="spec value" id="val-run"><a href="#val-run" class="anchor"></a><code><span class="keyword">val</span> run : ?&#8288;version:string <span>&#45;&gt;</span> ?&#8288;build_info:string <span>&#45;&gt;</span> ?&#8288;argv:string list <span>&#45;&gt;</span> ?&#8288;extend:(string list <span>&#45;&gt;</span> string list) <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt></dl><div class="spec module" id="module-Deprecated"><a href="#module-Deprecated" class="anchor"></a><code><span class="keyword">module</span> <a href="Deprecated/index.html">Deprecated</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div></details></div></div></div><dl><dt class="spec type" id="type-with_options"><a href="#type-with_options" class="anchor"></a><code><span class="keyword">type</span> 'a with_options</code><code> = ?&#8288;extract_exn:bool <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt></dl><dl><dt class="spec value" id="val-async"><a href="#val-async" class="anchor"></a><code><span class="keyword">val</span> async : unit <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_extra__.Import.Deferred.t</a> <a href="index.html#type-basic_command">basic_command</a> <a href="index.html#type-with_options">with_options</a></code></dt><dd><p><code>async</code> is like <code>Core.Command.basic</code>, except that the main function it expects returns <code>unit Deferred.t</code>, instead of <code>unit</code>. <code>async</code> will also start the Async scheduler before main is run, and will stop the scheduler when main returns.</p><p><code>async</code> also handles top-level exceptions by wrapping the user-supplied function in a <code>Monitor.try_with</code>. If an exception is raised, it will print it to stderr and call <code>shutdown 1</code>. The <code>extract_exn</code> argument is passed along to <code>Monitor.try_with</code>; by default it is <code>false</code>.</p></dd></dl><dl><dt class="spec value" id="val-async_spec"><a href="#val-async_spec" class="anchor"></a><code><span class="keyword">val</span> async_spec : (<span class="type-var">'a</span>, unit <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_extra__.Import.Deferred.t</a>) <a href="index.html#type-basic_spec_command">basic_spec_command</a> <a href="index.html#type-with_options">with_options</a></code></dt><dt class="spec value" id="val-async_or_error"><a href="#val-async_or_error" class="anchor"></a><code><span class="keyword">val</span> async_or_error : unit <a href="../../../async_kernel/Async_kernel__/Deferred_or_error/index.html#type-t">Async_extra__.Import.Deferred.Or_error.t</a> <a href="index.html#type-basic_command">basic_command</a> <a href="index.html#type-with_options">with_options</a></code></dt><dd><p><code>async_or_error</code> is like <code>async</code>, except that the main function it expects may return an error, in which case it prints out the error message and shuts down with exit code 1.</p></dd></dl><dl><dt class="spec value" id="val-async_spec_or_error"><a href="#val-async_spec_or_error" class="anchor"></a><code><span class="keyword">val</span> async_spec_or_error : (<span class="type-var">'a</span>, unit <a href="../../../async_kernel/Async_kernel__/Deferred_or_error/index.html#type-t">Async_extra__.Import.Deferred.Or_error.t</a>) <a href="index.html#type-basic_spec_command">basic_spec_command</a> <a href="index.html#type-with_options">with_options</a></code></dt></dl><aside><p>Staged functions allow the main function to be separated into two stages. The first part is guaranteed to run before the Async scheduler is started, and the second part will run after the scheduler is started. This is useful if the main function runs code that relies on the fact that threads have not been created yet (e.g., <code>Daemon.daemonize</code>).</p><p>As an example:</p><pre><code class="ml">let main () =
  assert (not (Scheduler.is_running ()));
  stage (fun `Scheduler_started -&gt;
    assert (Scheduler.is_running ());
    Deferred.unit
  )</code></pre></aside><dl><dt class="spec type" id="type-staged"><a href="#type-staged" class="anchor"></a><code><span class="keyword">type</span> 'r staged</code><code> = ([ `Scheduler_started ] <span>&#45;&gt;</span> <span class="type-var">'r</span>) <a href="../../../base/Base/Staged/index.html#type-t">Core.Staged.t</a></code></dt></dl><div class="spec module" id="module-Staged"><a href="#module-Staged" class="anchor"></a><code><span class="keyword">module</span> <a href="Staged/index.html">Staged</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><aside><p>To create an <code>Arg_type.t</code> that uses auto-completion and uses Async to compute the possible completions, one should use</p><pre><code class="ml">Arg_type.create ~complete of_string</code></pre><p>where <code>complete</code> wraps its Async operations in <code>Thread_safe.block_on_async</code>. With this, the <code>complete</code> function is only called when the executable is auto-completing, not for ordinary execution. This improves performance, and also means that the Async scheduler isn't started for ordinary execution of the command, which makes it possible for the command to daemonize (which requires the scheduler to not have been started).</p></aside></div></body></html>