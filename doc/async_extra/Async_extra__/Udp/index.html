<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Udp (async_extra.Async_extra__.Udp)</title><link rel="stylesheet" href="../../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../../index.html">async_extra</a> &#x00BB; <a href="../index.html">Async_extra__</a> &#x00BB; Udp</nav><h1>Module <code>Async_extra__.Udp</code></h1></header><aside><p>A grab-bag of performance-oriented, UDP-oriented network tools. These provide some convenience, but they are more complex than basic applications require.</p><p>Defaults are chosen for typical UDP applications. Buffering is via <code>Iobuf</code> conventions, where a typical packet-handling loop iteration is read -&gt; <code>flip_lo</code> -&gt; process -&gt; <code>reset</code>.</p><p>While these functions are oriented toward UDP, they work with any files that satisfy <code>Fd.supports_nonblock</code>.</p><p>For zero-copy <code>Bigstring.t</code> transfers, we must ensure no buffering between the receive loop and caller. So an interface like <code>Tcp.connect</code>, with something like <code>(Bigstring.t * Socket.Address.Inet.t) Pipe.Reader.t</code>, won't work. Instead, we use synchronous callbacks.</p></aside><dl><dt class="spec type" id="type-write_buffer"><a href="#type-write_buffer" class="anchor"></a><code><span class="keyword">type</span> write_buffer</code><code> = (<a href="../../../core/Core/index.html#type-read_write">Core.read_write</a>, <a href="../../../core/Core/Iobuf/index.html#type-seek">Core.Iobuf.seek</a>) <a href="../../../core/Core/Iobuf/index.html#type-t">Core.Iobuf.t</a></code></dt></dl><dl><dt class="spec value" id="val-default_capacity"><a href="#val-default_capacity" class="anchor"></a><code><span class="keyword">val</span> default_capacity : int</code></dt><dd><p>The default buffer capacity for UDP-oriented buffers is 1472, determined as the typical Ethernet MTU (1500 octets) less the typical UDP header length (28). Using buffers of this size, one avoids accidentally creating messages that will be dropped on send because they exceed the MTU, and can receive the largest corresponding UDP message.</p><p>While this number is merely typical and not guaranteed to work in all cases, defining it in one place makes it easy to share and change. For example, another MTU in common use is 9000 for Jumbo frames, so the value of <code>default_capacity</code> might change to 8972 in the future.</p></dd></dl><dl><dt class="spec module" id="module-Config"><a href="#module-Config" class="anchor"></a><code><span class="keyword">module</span> <a href="Config/index.html">Config</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>A typical receive loop implicitly calls <code>Iobuf.flip_lo</code> before calling its callback to prepare a packet buffer for reading by the callback and <code>Iobuf.reset</code> afterward to prepare for the next iteration.</p></dd></dl><dl><dt class="spec value" id="val-sendto_sync"><a href="#val-sendto_sync" class="anchor"></a><code><span class="keyword">val</span> sendto_sync : unit <span>&#45;&gt;</span> (<a href="../../../async_unix/Async_unix/Fd/index.html#type-t">Async_extra__.Import.Fd.t</a> <span>&#45;&gt;</span> ([&gt; <a href="../../../core/Core/index.html#type-read">Core.read</a> ], <a href="../../../core/Core/Iobuf/index.html#type-seek">Core.Iobuf.seek</a>) <a href="../../../core/Core/Iobuf/index.html#type-t">Core.Iobuf.t</a> <span>&#45;&gt;</span> <a href="../../../async_unix/Async_unix__Unix_syscalls/Socket/Address/Inet/index.html#type-t">Async_extra__.Import.Socket.Address.Inet.t</a> <span>&#45;&gt;</span> <a href="../../../core/Core__Syscall_result/Unit/index.html#type-t">Async_extra__.Import.Unix.Syscall_result.Unit.t</a>) <a href="../../../core_kernel/Core_kernel/Or_error/index.html#type-t">Core.Or_error.t</a></code></dt><dd><p><code>sendto_sync sock buf addr</code> does not try again if <code>sock</code> is not ready to write. Instead, it returns <code>EWOULDBLOCK</code> immediately.</p><p>Short writes are distinguished by <code>buf</code> not being empty afterward.</p><p>See also <span class="xref-unresolved" title="unresolved reference to &quot;Iobuf.sendto_nonblocking_no_sigpipe&quot;"><code>Iobuf</code>.sendto_nonblocking_no_sigpipe</span> and <span class="xref-unresolved" title="unresolved reference to &quot;Bigstring.sendto_nonblocking_no_sigpipe&quot;"><code>Bigstring</code>.sendto_nonblocking_no_sigpipe</span>.</p><dl><dt>raises Failure</dt><dd><p>on internal errors but return <code>Unix.error</code> via <code>Unix.Syscall_result.Unit.t</code> rather than raising <code>Unix_error</code>.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-send_sync"><a href="#val-send_sync" class="anchor"></a><code><span class="keyword">val</span> send_sync : unit <span>&#45;&gt;</span> (<a href="../../../async_unix/Async_unix/Fd/index.html#type-t">Async_extra__.Import.Fd.t</a> <span>&#45;&gt;</span> ([&gt; <a href="../../../core/Core/index.html#type-read">Core.read</a> ], <a href="../../../core/Core/Iobuf/index.html#type-seek">Core.Iobuf.seek</a>) <a href="../../../core/Core/Iobuf/index.html#type-t">Core.Iobuf.t</a> <span>&#45;&gt;</span> <a href="../../../core/Core__Syscall_result/Unit/index.html#type-t">Async_extra__.Import.Unix.Syscall_result.Unit.t</a>) <a href="../../../core_kernel/Core_kernel/Or_error/index.html#type-t">Core.Or_error.t</a></code></dt><dd><p><code>send_sync sock buf</code> has identical semantics to <code>sendto_sync</code>, but is intended for connected UDP sockets (and therefore does not require a &quot;to&quot; address).</p><p>See also <span class="xref-unresolved" title="unresolved reference to &quot;Iobuf.send_nonblocking_no_sigpipe&quot;"><code>Iobuf</code>.send_nonblocking_no_sigpipe</span> and <span class="xref-unresolved" title="unresolved reference to &quot;Bigstring.send_nonblocking_no_sigpipe&quot;"><code>Bigstring</code>.send_nonblocking_no_sigpipe</span>.</p><dl><dt>raises Failure</dt><dd><p>on internal errors but return <code>Unix.error</code> via <code>Unix.Syscall_result.Unit.t</code> rather than raising <code>Unix_error</code>.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-sendto"><a href="#val-sendto" class="anchor"></a><code><span class="keyword">val</span> sendto : unit <span>&#45;&gt;</span> (<a href="../../../async_unix/Async_unix/Fd/index.html#type-t">Async_extra__.Import.Fd.t</a> <span>&#45;&gt;</span> ([&gt; <a href="../../../core/Core/index.html#type-read">Core.read</a> ], <a href="../../../core/Core/Iobuf/index.html#type-seek">Core.Iobuf.seek</a>) <a href="../../../core/Core/Iobuf/index.html#type-t">Core.Iobuf.t</a> <span>&#45;&gt;</span> <a href="../../../async_unix/Async_unix__Unix_syscalls/Socket/Address/Inet/index.html#type-t">Async_extra__.Import.Socket.Address.Inet.t</a> <span>&#45;&gt;</span> unit <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_extra__.Import.Deferred.t</a>) <a href="../../../core_kernel/Core_kernel/Or_error/index.html#type-t">Core.Or_error.t</a></code></dt><dd><p><code>sendto sock buf addr</code> retries if <code>sock</code> is not ready to write.</p><dl><dt>raises Unix_error</dt><dd><p>in the case of Unix output errors and <code>Failure</code> on internal errors.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-send"><a href="#val-send" class="anchor"></a><code><span class="keyword">val</span> send : unit <span>&#45;&gt;</span> (<a href="../../../async_unix/Async_unix/Fd/index.html#type-t">Async_extra__.Import.Fd.t</a> <span>&#45;&gt;</span> ([&gt; <a href="../../../core/Core/index.html#type-read">Core.read</a> ], <a href="../../../core/Core/Iobuf/index.html#type-seek">Core.Iobuf.seek</a>) <a href="../../../core/Core/Iobuf/index.html#type-t">Core.Iobuf.t</a> <span>&#45;&gt;</span> unit <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_extra__.Import.Deferred.t</a>) <a href="../../../core_kernel/Core_kernel/Or_error/index.html#type-t">Core.Or_error.t</a></code></dt><dd><p><code>send sock buf</code> retries if <code>sock</code> is not ready to write.</p><dl><dt>raises Unix_error</dt><dd><p>in the case of Unix output errors and <code>Failure</code> on internal errors.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-bind"><a href="#val-bind" class="anchor"></a><code><span class="keyword">val</span> bind : ?&#8288;ifname:string <span>&#45;&gt;</span> <a href="../../../async_unix/Async_unix__Unix_syscalls/Socket/Address/Inet/index.html#type-t">Async_extra__.Import.Socket.Address.Inet.t</a> <span>&#45;&gt;</span> ([ `Bound ], <a href="../../../async_unix/Async_unix__Unix_syscalls/Socket/Address/Inet/index.html#type-t">Async_extra__.Import.Socket.Address.Inet.t</a>) <a href="../../../async_unix/Async_unix__Unix_syscalls/Socket/index.html#type-t">Async_extra__.Import.Socket.t</a></code></dt><dd><p><code>bind address</code> creates a socket bound to address, and, if <code>address</code> is a multicast address, joins the multicast group.</p></dd></dl><dl><dt class="spec value" id="val-bind_any"><a href="#val-bind_any" class="anchor"></a><code><span class="keyword">val</span> bind_any : unit <span>&#45;&gt;</span> ([ `Bound ], <a href="../../../async_unix/Async_unix__Unix_syscalls/Socket/Address/Inet/index.html#type-t">Async_extra__.Import.Socket.Address.Inet.t</a>) <a href="../../../async_unix/Async_unix__Unix_syscalls/Socket/index.html#type-t">Async_extra__.Import.Socket.t</a></code></dt></dl><div class="spec module" id="module-Loop_result"><a href="#module-Loop_result" class="anchor"></a><code><span class="keyword">module</span> <a href="Loop_result/index.html">Loop_result</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><dl><dt class="spec value" id="val-recvfrom_loop"><a href="#val-recvfrom_loop" class="anchor"></a><code><span class="keyword">val</span> recvfrom_loop : ?&#8288;config:<a href="Config/index.html#type-t">Config.t</a> <span>&#45;&gt;</span> <a href="../../../async_unix/Async_unix/Fd/index.html#type-t">Async_extra__.Import.Fd.t</a> <span>&#45;&gt;</span> (<a href="index.html#type-write_buffer">write_buffer</a> <span>&#45;&gt;</span> <a href="../../../async_unix/Async_unix__Unix_syscalls/Socket/Address/Inet/index.html#type-t">Async_extra__.Import.Socket.Address.Inet.t</a> <span>&#45;&gt;</span> unit) <span>&#45;&gt;</span> <a href="Loop_result/index.html#type-t">Loop_result.t</a> <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_extra__.Import.Deferred.t</a></code></dt><dd><p>Loops, including <code>recvfrom_loop</code>, terminate normally when the socket is closed.</p></dd></dl><dl><dt class="spec value" id="val-recvfrom_loop_with_buffer_replacement"><a href="#val-recvfrom_loop_with_buffer_replacement" class="anchor"></a><code><span class="keyword">val</span> recvfrom_loop_with_buffer_replacement : ?&#8288;config:<a href="Config/index.html#type-t">Config.t</a> <span>&#45;&gt;</span> <a href="../../../async_unix/Async_unix/Fd/index.html#type-t">Async_extra__.Import.Fd.t</a> <span>&#45;&gt;</span> (<a href="index.html#type-write_buffer">write_buffer</a> <span>&#45;&gt;</span> <a href="../../../async_unix/Async_unix__Unix_syscalls/Socket/Address/Inet/index.html#type-t">Async_extra__.Import.Socket.Address.Inet.t</a> <span>&#45;&gt;</span> <a href="index.html#type-write_buffer">write_buffer</a>) <span>&#45;&gt;</span> <a href="Loop_result/index.html#type-t">Loop_result.t</a> <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_extra__.Import.Deferred.t</a></code></dt><dd><p><code>recvfrom_loop_with_buffer_replacement callback</code> calls <code>callback</code> synchronously on each message received. <code>callback</code> returns the packet buffer for subsequent iterations, so it can replace the initial packet buffer when necessary. This enables immediate buffer reuse in the common case and fallback to allocation if we want to save the packet buffer for asynchronous processing.</p></dd></dl><dl><dt class="spec value" id="val-read_loop"><a href="#val-read_loop" class="anchor"></a><code><span class="keyword">val</span> read_loop : ?&#8288;config:<a href="Config/index.html#type-t">Config.t</a> <span>&#45;&gt;</span> <a href="../../../async_unix/Async_unix/Fd/index.html#type-t">Async_extra__.Import.Fd.t</a> <span>&#45;&gt;</span> (<a href="index.html#type-write_buffer">write_buffer</a> <span>&#45;&gt;</span> unit) <span>&#45;&gt;</span> <a href="Loop_result/index.html#type-t">Loop_result.t</a> <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_extra__.Import.Deferred.t</a></code></dt><dt class="spec value" id="val-read_loop_with_buffer_replacement"><a href="#val-read_loop_with_buffer_replacement" class="anchor"></a><code><span class="keyword">val</span> read_loop_with_buffer_replacement : ?&#8288;config:<a href="Config/index.html#type-t">Config.t</a> <span>&#45;&gt;</span> <a href="../../../async_unix/Async_unix/Fd/index.html#type-t">Async_extra__.Import.Fd.t</a> <span>&#45;&gt;</span> (<a href="index.html#type-write_buffer">write_buffer</a> <span>&#45;&gt;</span> <a href="index.html#type-write_buffer">write_buffer</a>) <span>&#45;&gt;</span> <a href="Loop_result/index.html#type-t">Loop_result.t</a> <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_extra__.Import.Deferred.t</a></code></dt><dt class="spec value" id="val-recvmmsg_loop"><a href="#val-recvmmsg_loop" class="anchor"></a><code><span class="keyword">val</span> recvmmsg_loop : (?&#8288;config:<a href="Config/index.html#type-t">Config.t</a> <span>&#45;&gt;</span> ?&#8288;max_count:int <span>&#45;&gt;</span> ?&#8288;on_wouldblock:(unit <span>&#45;&gt;</span> unit) <span>&#45;&gt;</span> <a href="../../../async_unix/Async_unix/Fd/index.html#type-t">Async_extra__.Import.Fd.t</a> <span>&#45;&gt;</span> (<a href="index.html#type-write_buffer">write_buffer</a> array <span>&#45;&gt;</span> count:int <span>&#45;&gt;</span> unit) <span>&#45;&gt;</span> <a href="Loop_result/index.html#type-t">Loop_result.t</a> <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_extra__.Import.Deferred.t</a>) <a href="../../../core_kernel/Core_kernel/Or_error/index.html#type-t">Core.Or_error.t</a></code></dt><dd><p><code>recvmmsg_loop ~socket callback</code> iteratively receives up to <code>max_count</code> packets at a time on <code>socket</code> and passes them to <code>callback</code>. Each packet is up to <code>Iobuf.capacity</code> bytes.</p><p><code>callback bufs ~count</code> processes <code>count</code> packets synchronously.</p><p><code>Config.init config</code> is used as a prototype for <code>bufs</code> and as one of the elements.</p></dd></dl><dl><dt class="spec value" id="val-default_recvmmsg_loop_max_count"><a href="#val-default_recvmmsg_loop_max_count" class="anchor"></a><code><span class="keyword">val</span> default_recvmmsg_loop_max_count : int</code></dt></dl></div></body></html>