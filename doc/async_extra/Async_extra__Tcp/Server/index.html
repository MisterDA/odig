<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Server (async_extra.Async_extra__Tcp.Server)</title><link rel="stylesheet" href="../../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../../index.html">async_extra</a> &#x00BB; <a href="../index.html">Async_extra__Tcp</a> &#x00BB; Server</nav><h1>Module <code>Async_extra__Tcp.Server</code></h1><p>A <code>Server.t</code> represents a TCP server listening on a socket.</p></header><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> ('address, 'listening_on) t</code><code> <span class="keyword">constraint</span> <span class="type-var">'address</span> = [&lt; Async_extra__.Import.Socket.Address.t ]</code></dt></dl><div><div class="spec include"><div class="doc"><details open="open"><summary><span class="def"><code><span class="keyword">include</span> <span class="keyword">sig</span> ... <span class="keyword">end</span></code></span></summary><dl><dt class="spec value" id="val-sexp_of_t"><a href="#val-sexp_of_t" class="anchor"></a><code><span class="keyword">val</span> sexp_of_t : (<span class="type-var">'address</span> <span>&#45;&gt;</span> <a href="../../../sexplib0/Sexplib0/Sexp/index.html#type-t">Ppx_sexp_conv_lib.Sexp.t</a>) <span>&#45;&gt;</span> (<span class="type-var">'listening_on</span> <span>&#45;&gt;</span> <a href="../../../sexplib0/Sexplib0/Sexp/index.html#type-t">Ppx_sexp_conv_lib.Sexp.t</a>) <span>&#45;&gt;</span> (<span class="type-var">'address</span>, <span class="type-var">'listening_on</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../../../sexplib0/Sexplib0/Sexp/index.html#type-t">Ppx_sexp_conv_lib.Sexp.t</a></code></dt></dl></details></div></div></div><dl><dt class="spec type" id="type-inet"><a href="#type-inet" class="anchor"></a><code><span class="keyword">type</span> inet</code><code> = (<a href="../../../async_unix/Async_unix__Unix_syscalls/Socket/Address/Inet/index.html#type-t">Async_extra__.Import.Socket.Address.Inet.t</a>, int) <a href="index.html#type-t">t</a></code></dt></dl><div><div class="spec include"><div class="doc"><details open="open"><summary><span class="def"><code><span class="keyword">include</span> <span class="keyword">sig</span> ... <span class="keyword">end</span></code></span></summary><dl><dt class="spec value" id="val-sexp_of_inet"><a href="#val-sexp_of_inet" class="anchor"></a><code><span class="keyword">val</span> sexp_of_inet : <a href="index.html#type-inet">inet</a> <span>&#45;&gt;</span> <a href="../../../sexplib0/Sexplib0/Sexp/index.html#type-t">Ppx_sexp_conv_lib.Sexp.t</a></code></dt></dl></details></div></div></div><dl><dt class="spec type" id="type-unix"><a href="#type-unix" class="anchor"></a><code><span class="keyword">type</span> unix</code><code> = (<a href="../../../async_unix/Async_unix__Unix_syscalls/Socket/Address/Unix/index.html#type-t">Async_extra__.Import.Socket.Address.Unix.t</a>, string) <a href="index.html#type-t">t</a></code></dt></dl><div><div class="spec include"><div class="doc"><details open="open"><summary><span class="def"><code><span class="keyword">include</span> <span class="keyword">sig</span> ... <span class="keyword">end</span></code></span></summary><dl><dt class="spec value" id="val-sexp_of_unix"><a href="#val-sexp_of_unix" class="anchor"></a><code><span class="keyword">val</span> sexp_of_unix : <a href="index.html#type-unix">unix</a> <span>&#45;&gt;</span> <a href="../../../sexplib0/Sexplib0/Sexp/index.html#type-t">Ppx_sexp_conv_lib.Sexp.t</a></code></dt></dl></details></div></div></div><dl><dt class="spec value" id="val-invariant"><a href="#val-invariant" class="anchor"></a><code><span class="keyword">val</span> invariant : (<span class="type-var">_</span>, <span class="type-var">_</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-listening_on"><a href="#val-listening_on" class="anchor"></a><code><span class="keyword">val</span> listening_on : (<span class="type-var">_</span>, <span class="type-var">'listening_on</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'listening_on</span></code></dt><dt class="spec value" id="val-listening_on_address"><a href="#val-listening_on_address" class="anchor"></a><code><span class="keyword">val</span> listening_on_address : (<span class="type-var">'address</span>, <span class="type-var">_</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'address</span></code></dt><dt class="spec value" id="val-close"><a href="#val-close" class="anchor"></a><code><span class="keyword">val</span> close : ?&#8288;close_existing_connections:bool <span>&#45;&gt;</span> (<span class="type-var">_</span>, <span class="type-var">_</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_extra__.Import.Deferred.t</a></code></dt><dd><p><code>close t</code> starts closing the listening socket, and returns a deferred that becomes determined after <code>Fd.close_finished fd</code> on the socket's <code>fd</code>. It is guaranteed that <code>t</code>'s client handler will never be called after <code>close t</code>. It is ok to call <code>close</code> multiple times on the same <code>t</code>; calls subsequent to the initial call will have no effect, but will return the same deferred as the original call.</p><p>With <code>~close_existing_connections:true</code>, <code>close</code> closes the sockets of all existing connections. <code>close</code> does not (and cannot) stop the handlers handling the connections, but they will of course be unable to write to or read from the socket. The result of <code>close</code> becomes determined when all the socket file descriptors are closed and the socket's <code>fd</code> is closed.</p></dd></dl><dl><dt class="spec value" id="val-close_finished"><a href="#val-close_finished" class="anchor"></a><code><span class="keyword">val</span> close_finished : (<span class="type-var">_</span>, <span class="type-var">_</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_extra__.Import.Deferred.t</a></code></dt><dd><p><code>close_finished</code> becomes determined after <code>Fd.close_finished fd</code> on the socket's <code>fd</code>, i.e., the same deferred that <code>close</code> returns. <code>close_finished</code> differs from <code>close</code> in that it does not have the side effect of initiating a close.</p></dd></dl><dl><dt class="spec value" id="val-is_closed"><a href="#val-is_closed" class="anchor"></a><code><span class="keyword">val</span> is_closed : (<span class="type-var">_</span>, <span class="type-var">_</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>is_closed t</code> returns <code>true</code> iff <code>close t</code> has been called.</p></dd></dl><dl><dt class="spec type" id="type-create_options"><a href="#type-create_options" class="anchor"></a><code><span class="keyword">type</span> ('address, 'listening_on, 'callback) create_options</code><code> = ?&#8288;max_connections:int <span>&#45;&gt;</span> ?&#8288;max_accepts_per_batch:int <span>&#45;&gt;</span> ?&#8288;backlog:int <span>&#45;&gt;</span> ?&#8288;socket:([ `Unconnected ], <span class="type-var">'address</span>) <a href="../../../async_unix/Async_unix__Unix_syscalls/Socket/index.html#type-t">Async_extra__.Import.Socket.t</a> <span>&#45;&gt;</span> on_handler_error:[ `Raise | `Ignore | `Call of <span class="type-var">'address</span> <span>&#45;&gt;</span> exn <span>&#45;&gt;</span> unit ] <span>&#45;&gt;</span> (<span class="type-var">'address</span>, <span class="type-var">'listening_on</span>) <a href="../Where_to_listen/index.html#type-t">Where_to_listen.t</a> <span>&#45;&gt;</span> <span class="type-var">'callback</span> <span>&#45;&gt;</span> (<span class="type-var">'address</span>, <span class="type-var">'listening_on</span>) <a href="index.html#type-t">t</a> <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_extra__.Import.Deferred.t</a></code></dt><dd><p>Options for server creation:</p><p><code>backlog</code> is the number of clients that can have a connection pending, as with <a href="../../../ocaml/Unix/index.html#val-listen"><code>Unix.listen</code></a>. Additional connections may be rejected, ignored, or enqueued anyway, depending on OS, version, and configuration.</p><p><code>max_connections</code> is the maximum number of clients that can be connected simultaneously. The server will not call <code>accept</code> unless the number of clients is less than <code>max_connections</code>, although of course potential clients can have a connection pending.</p><p><code>max_accepts_per_batch</code> is the maximum number of connections that the server will retrieve per blocking <a href="../../../ocaml/Unix/index.html#val-accept"><code>Unix.accept</code></a> call. Servers that must handle a large number of connections tend to observe a stall in connection accept rates when under heavy load. Increasing <code>max_accepts_per_batch</code> will ameliorate this effect, increasing connection accept rates and overall throughput at the cost of increased contention for resources amongst connections. Servers that are under light load or ones that only service a small number of connections at a time should see little to no difference in behavior for different values of <code>max_accepts_per_branch</code>.</p><p>Supplying <code>socket</code> causes the server to use <code>socket</code> rather than create a new socket. In this usage, creation does not set <code>Socket.Opt.reuseaddr</code> to <code>true</code>; if you want that, you must set <code>reuseaddr</code> before creation.</p><p><code>on_handler_error</code> determines what happens if the handler throws an exception. If an exception is raised by on_handler_error (either explicitly via <code>`Raise</code>, or in the closure passed to <code>`Call</code>) no further connections will be accepted.</p></dd></dl><dl><dt class="spec value" id="val-create_sock"><a href="#val-create_sock" class="anchor"></a><code><span class="keyword">val</span> create_sock : (<span class="type-var">'address</span>, <span class="type-var">'listening_on</span>, <span class="type-var">'address</span> <span>&#45;&gt;</span> ([ `Active ], <span class="type-var">'address</span>) <a href="../../../async_unix/Async_unix__Unix_syscalls/Socket/index.html#type-t">Async_extra__.Import.Socket.t</a> <span>&#45;&gt;</span> unit <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_extra__.Import.Deferred.t</a>) <a href="index.html#type-create_options">create_options</a></code></dt><dd><p><code>create_sock where_to_listen handler</code> starts a server listening to a socket as specified by <code>where_to_listen</code>. It returns a server once the socket is ready to accept connections. The server calls <code>handler address socket</code> for each client that connects. If the deferred returned by <code>handler</code> is ever determined, or <code>handler</code> raises an exception, then <code>socket</code> is closed.</p><p>The server will stop accepting and close the listening socket when an error handler raises (either via <code>`Raise</code> or <code>`Call f</code> where <code>f</code> raises), or if <code>close</code> is called.</p></dd></dl><dl><dt class="spec value" id="val-create"><a href="#val-create" class="anchor"></a><code><span class="keyword">val</span> create : ?&#8288;buffer_age_limit:<a href="../../../async_unix/Async_unix/Writer/index.html#type-buffer_age_limit">Async_extra__.Import.Writer.buffer_age_limit</a> <span>&#45;&gt;</span> (<span class="type-var">'address</span>, <span class="type-var">'listening_on</span>, <span class="type-var">'address</span> <span>&#45;&gt;</span> <a href="../../../async_unix/Async_unix/Reader/index.html#type-t">Async_extra__.Import.Reader.t</a> <span>&#45;&gt;</span> <a href="../../../async_unix/Async_unix/Writer/index.html#type-t">Async_extra__.Import.Writer.t</a> <span>&#45;&gt;</span> unit <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_extra__.Import.Deferred.t</a>) <a href="index.html#type-create_options">create_options</a></code></dt><dd><p><code>create where_to_listen handler</code> is a convenience wrapper around <code>create_sock</code> that pass a reader and writer for the client socket to the callback. If the deferred returned by <code>handler</code> is ever determined, or <code>handler</code> raises an exception, then the reader and writer are closed.</p><p><code>buffer_age_limit</code> passes on to the underlying writer option of the same name.</p></dd></dl><dl><dt class="spec value" id="val-listening_socket"><a href="#val-listening_socket" class="anchor"></a><code><span class="keyword">val</span> listening_socket : (<span class="type-var">'address</span>, <span class="type-var">_</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> ([ `Passive ], <span class="type-var">'address</span>) <a href="../../../async_unix/Async_unix__Unix_syscalls/Socket/index.html#type-t">Async_extra__.Import.Socket.t</a></code></dt><dd><p><code>listening_socket t</code> accesses the listening socket, which should be used with care. An anticipated use is with <span class="xref-unresolved" title="unresolved reference to &quot;Udp.bind_to_interface_exn&quot;"><code>Udp</code>.bind_to_interface_exn</span>. Accepting connections on the socket directly will circumvent <code>max_connections</code> and <code>on_handler_error</code>, however, and is not recommended.</p></dd></dl><dl><dt class="spec value" id="val-num_connections"><a href="#val-num_connections" class="anchor"></a><code><span class="keyword">val</span> num_connections : (<span class="type-var">_</span>, <span class="type-var">_</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int</code></dt><dt class="spec value" id="val-set_drop_incoming_connections"><a href="#val-set_drop_incoming_connections" class="anchor"></a><code><span class="keyword">val</span> set_drop_incoming_connections : (<span class="type-var">_</span>, <span class="type-var">_</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool <span>&#45;&gt;</span> unit</code></dt><dd><p><code>set_drop_incoming_connections</code> configures whether each incoming connection will be immediately dropped or not. This is a hack to effectively get a &quot;pause listening&quot; feature. We can't reliably use <code>backlog</code> and <code>max_num_connections</code> to reject incoming connections. For example, if we reach <code>max_num_connections</code>, we won't call <code>accept</code> but OS might still establish TCP connection. The client will see the connection as established but no data will be exchanged and we'd have to rely on TCP retransmit timeouts to close the connection. In many cases we would prefer to accept and then immediately close the connection. This is an intermediate solution until we do a more principled solution (but much more complicated) when we close the listening socket and then later <code>bind</code> and <code>listen</code> again when we decide to unpause the server.</p><p><code>drop_incoming_connections</code> is set to false.</p></dd></dl></div></body></html>