<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Throttle (async_kernel.Async_kernel.Throttle)</title><link rel="stylesheet" href="../../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../../index.html">async_kernel</a> &#x00BB; <a href="../index.html">Async_kernel</a> &#x00BB; Throttle</nav><h1>Module <code>Async_kernel.Throttle</code></h1><p>A way to limit the number of concurrent computations.</p><p>A throttle is essentially a pipe to which one can feed jobs.</p><p>A throttle schedules asynchronous jobs so that at any point in time no more than <code>max_concurrent_jobs</code> jobs are running. A job <code>f</code> is considered to be running from the time <code>f ()</code> is executed until the deferred returned by <code>f ()</code> becomes determined, or <code>f ()</code> raises. The throttle initiates jobs on a first-come first-served basis.</p><p>One can use <code>create_with</code> to create a throttle with &quot;resources&quot; that one would like to make available to concurrent jobs and to guarantee that different jobs access different resources.</p><p>A throttle is killed if one of its jobs throws an exception, and the throttle has <code>continue_on_error = false</code>. A throttle can also be explicitly <code>kill</code>ed. If a throttle is killed, then all jobs in it that haven't yet started are aborted, i.e., they will not start and will become determined with <code>`Aborted</code>. Jobs that had already started will continue, and return <code>`Ok</code> or <code>`Raised</code> as usual when they finish. Jobs enqueued into a killed throttle will be immediately aborted.</p></header><div class="spec module" id="module-Deferred"><a href="#module-Deferred" class="anchor"></a><code><span class="keyword">module</span> Deferred = <a href="../../Async_kernel__/index.html#module-Deferred1">Async_kernel__.Deferred1</a></code></div><dl><dt class="spec module" id="module-T2"><a href="#module-T2" class="anchor"></a><code><span class="keyword">module</span> <a href="T2/index.html">T2</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>We use a phantom type to distinguish between throttles, which have <code>max_concurrent_jobs &gt;= 1</code>, and sequencers, which have <code>max_concurrent_jobs = 1</code>. All operations are available on both. We make the distinction because it is sometimes useful to know from the type of a throttle that it is a sequencer and that at most one job can be running at a time.</p></dd></dl><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> 'a t</code><code> = (<span class="type-var">'a</span>, [ `throttle ]) <a href="T2/index.html#type-t">T2.t</a></code></dt></dl><div><div class="spec include"><div class="doc"><details open="open"><summary><span class="def"><code><span class="keyword">include</span> <span class="keyword">sig</span> ... <span class="keyword">end</span></code></span></summary><dl><dt class="spec value" id="val-sexp_of_t"><a href="#val-sexp_of_t" class="anchor"></a><code><span class="keyword">val</span> sexp_of_t : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <a href="../../../sexplib0/Sexplib0/Sexp/index.html#type-t">Ppx_sexp_conv_lib.Sexp.t</a>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../../../sexplib0/Sexplib0/Sexp/index.html#type-t">Ppx_sexp_conv_lib.Sexp.t</a></code></dt></dl></details></div></div></div><div><div class="spec include"><div class="doc"><details open="open"><summary><span class="def"><code><span class="keyword">include</span> <a href="../../../base/Base/Invariant/index.html#module-type-S1">Core_kernel.Invariant.S1</a> <span class="keyword">with</span> <span class="keyword">type</span> 'a <a href="../../../base/Base/Invariant/module-type-S1/index.html#type-t">t</a> := <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></span></summary><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> 'a t</code></dt></dl><dl><dt class="spec value" id="val-invariant"><a href="#val-invariant" class="anchor"></a><code><span class="keyword">val</span> invariant : <span class="type-var">'a</span> <a href="../../../base/Base__/Invariant_intf/index.html#type-inv">Base__.Invariant_intf.inv</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <a href="../../../base/Base__/Invariant_intf/index.html#type-inv">Base__.Invariant_intf.inv</a></code></dt></dl></details></div></div></div><dl><dt class="spec value" id="val-create"><a href="#val-create" class="anchor"></a><code><span class="keyword">val</span> create : continue_on_error:bool <span>&#45;&gt;</span> max_concurrent_jobs:int <span>&#45;&gt;</span> unit <a href="index.html#type-t">t</a></code></dt><dd><p><code>create ~continue_on_error ~max_concurrent_jobs</code> returns a throttle that will run up to <code>max_concurrent_jobs</code> concurrently.</p><p>If some job raises an exception, then the throttle will be killed, unless <code>continue_on_error</code> is true.</p></dd></dl><dl><dt class="spec value" id="val-create_with"><a href="#val-create_with" class="anchor"></a><code><span class="keyword">val</span> create_with : continue_on_error:bool <span>&#45;&gt;</span> <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>create_with ~continue_on_error job_resources</code> returns a throttle that will run up to <code>List.length job_resources</code> concurrently, and will ensure that all running jobs are supplied distinct elements of <code>job_resources</code>.</p></dd></dl><dl><dt class="spec type" id="type-outcome"><a href="#type-outcome" class="anchor"></a><code><span class="keyword">type</span> 'a outcome</code> = <code>[ </code><table class="variant"><tr id="type-outcome.Ok" class="anchored"><td class="def constructor"><a href="#type-outcome.Ok" class="anchor"></a><code>| </code><code>`Ok <span class="keyword">of</span> <span class="type-var">'a</span></code></td></tr><tr id="type-outcome.Aborted" class="anchored"><td class="def constructor"><a href="#type-outcome.Aborted" class="anchor"></a><code>| </code><code>`Aborted</code></td></tr><tr id="type-outcome.Raised" class="anchored"><td class="def constructor"><a href="#type-outcome.Raised" class="anchor"></a><code>| </code><code>`Raised <span class="keyword">of</span> exn</code></td></tr></table><code> ]</code></dt></dl><div><div class="spec include"><div class="doc"><details open="open"><summary><span class="def"><code><span class="keyword">include</span> <span class="keyword">sig</span> ... <span class="keyword">end</span></code></span></summary><dl><dt class="spec value" id="val-sexp_of_outcome"><a href="#val-sexp_of_outcome" class="anchor"></a><code><span class="keyword">val</span> sexp_of_outcome : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <a href="../../../sexplib0/Sexplib0/Sexp/index.html#type-t">Ppx_sexp_conv_lib.Sexp.t</a>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-outcome">outcome</a> <span>&#45;&gt;</span> <a href="../../../sexplib0/Sexplib0/Sexp/index.html#type-t">Ppx_sexp_conv_lib.Sexp.t</a></code></dt></dl></details></div></div></div><dl><dt class="spec value" id="val-enqueue'"><a href="#val-enqueue'" class="anchor"></a><code><span class="keyword">val</span> enqueue' : (<span class="type-var">'a</span>, <span class="type-var">_</span>) <a href="T2/index.html#type-t">T2.t</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="../../Async_kernel__/Deferred1/index.html#type-t">Deferred.t</a>) <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-outcome">outcome</a> <a href="../../Async_kernel__/Deferred1/index.html#type-t">Deferred.t</a></code></dt><dd><p><code>enqueue t job</code> schedules <code>job</code> to be run as soon as possible. Jobs are guaranteed to be started in the order they are <code>enqueue</code>d and to not be started during the call to <code>enqueue</code>. If <code>t</code> is dead, then <code>job</code> will be immediately aborted (for <code>enqueue</code>, this will send an exception to the monitor in effect).</p></dd></dl><dl><dt class="spec value" id="val-enqueue"><a href="#val-enqueue" class="anchor"></a><code><span class="keyword">val</span> enqueue : (<span class="type-var">'a</span>, <span class="type-var">_</span>) <a href="T2/index.html#type-t">T2.t</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="../../Async_kernel__/Deferred1/index.html#type-t">Deferred.t</a>) <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="../../Async_kernel__/Deferred1/index.html#type-t">Deferred.t</a></code></dt><dt class="spec value" id="val-monad_sequence_how"><a href="#val-monad_sequence_how" class="anchor"></a><code><span class="keyword">val</span> monad_sequence_how : ?&#8288;how:<a href="../Monad_sequence/index.html#type-how">Monad_sequence.how</a> <span>&#45;&gt;</span> f:(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="../../Async_kernel__/Deferred1/index.html#type-t">Deferred.t</a>) <span>&#45;&gt;</span> (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="../../Async_kernel__/Deferred1/index.html#type-t">Deferred.t</a>) <a href="../../../base/Base/Staged/index.html#type-t">Core_kernel.Staged.t</a></code></dt><dd><p><code>monad_sequence_how ~how ~f</code> returns a function that behaves like <code>f</code>, except that it uses a throttle to limit the number of concurrent invocations that can be running simultaneously. The throttle has <code>continue_on_error = false</code>.</p></dd></dl><dl><dt class="spec value" id="val-monad_sequence_how2"><a href="#val-monad_sequence_how2" class="anchor"></a><code><span class="keyword">val</span> monad_sequence_how2 : ?&#8288;how:<a href="../Monad_sequence/index.html#type-how">Monad_sequence.how</a> <span>&#45;&gt;</span> f:(<span class="type-var">'a1</span> <span>&#45;&gt;</span> <span class="type-var">'a2</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="../../Async_kernel__/Deferred1/index.html#type-t">Deferred.t</a>) <span>&#45;&gt;</span> (<span class="type-var">'a1</span> <span>&#45;&gt;</span> <span class="type-var">'a2</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="../../Async_kernel__/Deferred1/index.html#type-t">Deferred.t</a>) <a href="../../../base/Base/Staged/index.html#type-t">Core_kernel.Staged.t</a></code></dt><dt class="spec value" id="val-prior_jobs_done"><a href="#val-prior_jobs_done" class="anchor"></a><code><span class="keyword">val</span> prior_jobs_done : (<span class="type-var">_</span>, <span class="type-var">_</span>) <a href="T2/index.html#type-t">T2.t</a> <span>&#45;&gt;</span> unit <a href="../../Async_kernel__/Deferred1/index.html#type-t">Deferred.t</a></code></dt><dd><p><code>prior_jobs_done t</code> becomes determined when all of the jobs that were previously enqueued in <code>t</code> have completed.</p></dd></dl><dl><dt class="spec value" id="val-max_concurrent_jobs"><a href="#val-max_concurrent_jobs" class="anchor"></a><code><span class="keyword">val</span> max_concurrent_jobs : (<span class="type-var">_</span>, <span class="type-var">_</span>) <a href="T2/index.html#type-t">T2.t</a> <span>&#45;&gt;</span> int</code></dt><dd><p><code>max_concurrent_jobs t</code> returns the maximum number of jobs that <code>t</code> will run concurrently.</p></dd></dl><dl><dt class="spec value" id="val-num_jobs_running"><a href="#val-num_jobs_running" class="anchor"></a><code><span class="keyword">val</span> num_jobs_running : (<span class="type-var">_</span>, <span class="type-var">_</span>) <a href="T2/index.html#type-t">T2.t</a> <span>&#45;&gt;</span> int</code></dt><dd><p><code>num_jobs_running t</code> returns the number of jobs that <code>t</code> is currently running. It is guaranteed that if <code>num_jobs_running t &lt; max_concurrent_jobs t</code> then <code>num_jobs_waiting_to_start t = 0</code>. That is, the throttle always uses its maximum concurrency if possible.</p></dd></dl><dl><dt class="spec value" id="val-num_jobs_waiting_to_start"><a href="#val-num_jobs_waiting_to_start" class="anchor"></a><code><span class="keyword">val</span> num_jobs_waiting_to_start : (<span class="type-var">_</span>, <span class="type-var">_</span>) <a href="T2/index.html#type-t">T2.t</a> <span>&#45;&gt;</span> int</code></dt><dd><p><code>num_jobs_waiting_to_start t</code> returns the number of jobs that have been <code>enqueue</code>d but have not yet started.</p></dd></dl><dl><dt class="spec value" id="val-capacity_available"><a href="#val-capacity_available" class="anchor"></a><code><span class="keyword">val</span> capacity_available : (<span class="type-var">_</span>, <span class="type-var">_</span>) <a href="T2/index.html#type-t">T2.t</a> <span>&#45;&gt;</span> unit <a href="../../Async_kernel__/Deferred1/index.html#type-t">Deferred.t</a></code></dt><dd><p><code>capacity_available t</code> becomes determined the next time that <code>t</code> has fewer than <code>max_concurrent_jobs t</code> running, and hence an <code>enqueue</code>d job would start immediately.</p></dd></dl><dl><dt class="spec value" id="val-kill"><a href="#val-kill" class="anchor"></a><code><span class="keyword">val</span> kill : (<span class="type-var">_</span>, <span class="type-var">_</span>) <a href="T2/index.html#type-t">T2.t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>kill t</code> kills <code>t</code>, which aborts all enqueued jobs that haven't started and all jobs enqueued in the future. <code>kill</code> also initiates the <code>at_kill</code> clean functions.</p><p>If <code>t</code> has already been killed, then calling <code>kill t</code> has no effect.</p></dd></dl><dl><dt class="spec value" id="val-is_dead"><a href="#val-is_dead" class="anchor"></a><code><span class="keyword">val</span> is_dead : (<span class="type-var">_</span>, <span class="type-var">_</span>) <a href="T2/index.html#type-t">T2.t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>is_dead t</code> returns <code>true</code> if <code>t</code> was killed, either by <code>kill</code> or by an unhandled exception in a job.</p></dd></dl><dl><dt class="spec value" id="val-at_kill"><a href="#val-at_kill" class="anchor"></a><code><span class="keyword">val</span> at_kill : (<span class="type-var">'a</span>, <span class="type-var">_</span>) <a href="T2/index.html#type-t">T2.t</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span> <span>&#45;&gt;</span> unit <a href="../../Async_kernel__/Deferred1/index.html#type-t">Deferred.t</a>) <span>&#45;&gt;</span> unit</code></dt><dd><p><code>at_kill t clean</code> runs <code>clean</code> on each resource when <code>t</code> is killed, either by <code>kill</code> or by an unhandled exception. <code>clean</code> is called on each resource as it becomes available, i.e., immediately if the resource isn't currently in use, otherwise when the job currently using the resource finishes. If a call to <code>clean</code> fails, the exception is raised to the monitor in effect when <code>at_kill</code> was called.</p></dd></dl><dl><dt class="spec value" id="val-cleaned"><a href="#val-cleaned" class="anchor"></a><code><span class="keyword">val</span> cleaned : (<span class="type-var">_</span>, <span class="type-var">_</span>) <a href="T2/index.html#type-t">T2.t</a> <span>&#45;&gt;</span> unit <a href="../../Async_kernel__/Deferred1/index.html#type-t">Deferred.t</a></code></dt><dd><p><code>cleaned t</code> becomes determined after <code>t</code> is killed, all its running jobs have completed, and all <code>at_kill</code> clean functions have completed.</p></dd></dl><dl><dt class="spec module" id="module-Sequencer"><a href="#module-Sequencer" class="anchor"></a><code><span class="keyword">module</span> <a href="Sequencer/index.html">Sequencer</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>A sequencer is a throttle that is specialized to only allow one job at a time and to, by default, not continue on error.</p></dd></dl></div></body></html>