<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Intf (async_parallel.Async_parallel_deprecated.Intf)</title><link rel="stylesheet" href="../../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../../index.html">async_parallel</a> &#x00BB; <a href="../index.html">Async_parallel_deprecated</a> &#x00BB; Intf</nav><h1>Module <code>Async_parallel_deprecated.Intf</code></h1></header><dl><dt class="spec value" id="val-init"><a href="#val-init" class="anchor"></a><code><span class="keyword">val</span> init : ?&#8288;cluster:<a href="../Import/Cluster/index.html#type-t">Import.Cluster.t</a> <span>&#45;&gt;</span> ?&#8288;close_stdout_and_stderr:bool <span>&#45;&gt;</span> ?&#8288;fail_if_async_has_been_initialized:bool <span>&#45;&gt;</span> unit <span>&#45;&gt;</span> unit</code></dt><dd><p><code>init</code> initializes the system and creates the master process. <code>master_init</code>, if specified, is called in the master process and may be used for cleanup/initialization such as closing file descriptors. <code>init</code> should be called before any threads are created. If your program daemonizes, call <code>init</code> after you daemonize, but before you start the async scheduler. <code>init</code> may only be called once.</p><p>If <code>cluster</code> is specified, and it specifies a set of host names or ips that you can ssh to without a password, and have permission to run programs on, then a master process will also be started on every machine in the cluster, and worker processes may be spawned on any machine in the cluster. Note that in ord</p></dd></dl><dl><dt class="spec value" id="val-shutdown"><a href="#val-shutdown" class="anchor"></a><code><span class="keyword">val</span> shutdown : unit <span>&#45;&gt;</span> unit <a href="../../../core_kernel/Core_kernel/Or_error/index.html#type-t">Core.Or_error.t</a> <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async.Deferred.t</a></code></dt><dd><p><code>shutdown</code> requests that the master process kill all workers and then shutdown. It then waits for the master process to exit. <code>shutdown</code> returns <code>Ok ()</code> when the master exits without problems; otherwise it returns an error.</p></dd></dl><dl><dt class="spec value" id="val-run"><a href="#val-run" class="anchor"></a><code><span class="keyword">val</span> run : ?&#8288;buffer_age_limit:[ `At_most of <a href="../../../core_kernel/Core_kernel__Time_intf/module-type-S/Time/Span/index.html#type-t">Core.Time.Span.t</a> | `Unlimited ] <span>&#45;&gt;</span> ?&#8288;where:[ `Local | `On of string | `F of unit <span>&#45;&gt;</span> string ] <span>&#45;&gt;</span> (unit <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async.Deferred.t</a>) <span>&#45;&gt;</span> (<span class="type-var">'a</span>, string) <a href="../../../core_kernel/Core_kernel/Result/index.html#type-t">Core.Result.t</a> <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async.Deferred.t</a></code></dt><dd><p>Run the specified closure in another process and return its result.</p><p>If <code>where</code> is specified, it controls which machine the process is spawned on. The default is the local machine. You must have passed a list of machines to init in order to use `On, or `Random_on. An exception will be raised if you try to use a machine you didn't pass to init.</p><p>The closure you pass may not contain custom blocks with unimplemented serialization functions or Abstract values. Anything you can't pass to Marshal, you can't pass to spawn.</p></dd></dl><dl><dt class="spec value" id="val-spawn"><a href="#val-spawn" class="anchor"></a><code><span class="keyword">val</span> spawn : ?&#8288;buffer_age_limit:<a href="../../../async_unix/Async_unix/Writer/index.html#type-buffer_age_limit">Async.Writer.buffer_age_limit</a> <span>&#45;&gt;</span> ?&#8288;where:[ `Local | `On of string | `F of unit <span>&#45;&gt;</span> string ] <span>&#45;&gt;</span> ((<span class="type-var">'a</span>, <span class="type-var">'b</span>) <a href="../Hub/index.html#type-t">Hub.t</a> <span>&#45;&gt;</span> <span class="type-var">'c</span> <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async.Deferred.t</a>) <span>&#45;&gt;</span> ((<span class="type-var">'a</span>, <span class="type-var">'b</span>) <a href="../Channel/index.html#type-t">Channel.t</a> * (<span class="type-var">'c</span>, string) <a href="../../../core_kernel/Core_kernel/Result/index.html#type-t">Core.Result.t</a> <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async.Deferred.t</a>) <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async.Deferred.t</a></code></dt><dd><p><code>spawn f</code> spawns a process running <code>f</code>, supplying <code>f</code> a hub that it may use to communicate with other processes. <code>f</code> should listen to the hub to receive messages from the clients. <code>spawn</code> returns a channel connected to <code>f</code>'s hub, and a deferred that will become determined if <code>f</code> returns.</p><p>There is no guarantee that the deferred returned by this function will become determined before the spawned process runs, as such the following code is a race, and may never return.</p><p>| spawn (fun hub -&gt; Hub.send_to_all hub `Hello; Deferred.never ()) | &gt;&gt;= fun (channel, _) -&gt; | Channel.read channel | &gt;&gt;= fun `Hello -&gt; | ...</p><p>It IS however guaranteed that the spawned process is listening when the deferred returned by this function is returned, it is theirfore recommended that the spawning process initiate the first communication.</p><p>If <code>where</code> is specified, it controls which machine the process is spawned on. The default is the local machine. You must have passed a list of machines to init in order to use `On, or `Random_on. An exception will be raised if you try to use a machine you didn't pass to init.</p><p>The closure you pass may not contain custom blocks with unimplemented serialization functions or Abstract values. Anything you can't pass to Marshal, you can't pass to spawn.</p></dd></dl><dl><dt class="spec value" id="val-hub"><a href="#val-hub" class="anchor"></a><code><span class="keyword">val</span> hub : ?&#8288;buffer_age_limit:<a href="../../../async_unix/Async_unix/Writer/index.html#type-buffer_age_limit">Async.Writer.buffer_age_limit</a> <span>&#45;&gt;</span> unit <span>&#45;&gt;</span> (<span class="type-var">_</span>, <span class="type-var">_</span>) <a href="../Hub/index.html#type-t">Hub.t</a> <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async.Deferred.t</a></code></dt><dd><p>create a new hub.</p></dd></dl><dl><dt class="spec value" id="val-is_worker_machine"><a href="#val-is_worker_machine" class="anchor"></a><code><span class="keyword">val</span> is_worker_machine : unit <span>&#45;&gt;</span> bool</code></dt><dd><p>returns true if this is a worker machine. See the notes on running on multiple machines in Std.ml.</p></dd></dl><dl><dt class="spec value" id="val-round_robin"><a href="#val-round_robin" class="anchor"></a><code><span class="keyword">val</span> round_robin : [&gt; `F of unit <span>&#45;&gt;</span> string ]</code></dt><dt class="spec value" id="val-random"><a href="#val-random" class="anchor"></a><code><span class="keyword">val</span> random : [&gt; `F of unit <span>&#45;&gt;</span> string ]</code></dt><dt class="spec value" id="val-random_in"><a href="#val-random_in" class="anchor"></a><code><span class="keyword">val</span> random_in : string list <span>&#45;&gt;</span> [&gt; `F of unit <span>&#45;&gt;</span> string ]</code></dt></dl></div></body></html>