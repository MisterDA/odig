<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Rpc (async_rpc_kernel.Async_rpc_kernel.Rpc)</title><link rel="stylesheet" href="../../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../../index.html">async_rpc_kernel</a> &#x00BB; <a href="../index.html">Async_rpc_kernel</a> &#x00BB; Rpc</nav><h1>Module <code>Async_rpc_kernel.Rpc</code></h1><p>A library for building asynchronous RPC-style protocols.</p><p>The approach here is to have a separate representation of the server-side implementation of an RPC (An <code>Implementation.t</code>) and the interface that it exports (either an <code>Rpc.t</code>, a <code>State_rpc.t</code> or a <code>Pipe_rpc.t</code>, but we'll refer to them generically as RPC interfaces). A server builds the <code>Implementation.t</code> out of an RPC interface and a function for implementing the RPC, while the client dispatches a request using the same RPC interface.</p><p>The <code>Implementation.t</code> hides the type of the query and the response, whereas the <code>Rpc.t</code> is polymorphic in the query and response type. This allows you to build a <code>Implementations.t</code> out of a list of <code>Implementation.t</code>s.</p><p>Each RPC also comes with a version number. This is meant to allow support of multiple different versions of what is essentially the same RPC. You can think of it as an extension to the name of the RPC, and in fact, each RPC is uniquely identified by its (name, version) pair. RPCs with the same name but different versions should implement similar functionality.</p></header><div class="spec module" id="module-Description"><a href="#module-Description" class="anchor"></a><code><span class="keyword">module</span> <a href="Description/index.html">Description</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><dl><dt class="spec module" id="module-Implementation"><a href="#module-Implementation" class="anchor"></a><code><span class="keyword">module</span> <a href="Implementation/index.html">Implementation</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>A <code>'connection_state Implementation.t</code> is something that knows how to respond to one query, given a <code>'connection_state</code>. That is, you can create a <code>'connection_state
    Implementation.t</code> by providing a function which takes a query *and* a <code>'connection_state</code> and provides a response.</p></dd></dl><dl><dt class="spec module" id="module-Implementations"><a href="#module-Implementations" class="anchor"></a><code><span class="keyword">module</span> <a href="Implementations/index.html">Implementations</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>A <code>'connection_state Implementations.t</code> is something that knows how to respond to many different queries. It is conceptually a package of <code>'connection_state
    Implementation.t</code>s.</p></dd></dl><div class="spec module" id="module-Transport"><a href="#module-Transport" class="anchor"></a><code><span class="keyword">module</span> Transport = <a href="../../Async_rpc_kernel__/index.html#module-Transport">Async_rpc_kernel__.Transport</a></code></div><div class="spec module" id="module-Connection"><a href="#module-Connection" class="anchor"></a><code><span class="keyword">module</span> <a href="Connection/index.html">Connection</a> : <a href="../../Async_rpc_kernel__/Connection_intf/index.html#module-type-S">Async_rpc_kernel__.Connection_intf.S</a></code></div><div class="spec module" id="module-Rpc"><a href="#module-Rpc" class="anchor"></a><code><span class="keyword">module</span> <a href="Rpc/index.html">Rpc</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><div class="spec module" id="module-Pipe_close_reason"><a href="#module-Pipe_close_reason" class="anchor"></a><code><span class="keyword">module</span> <a href="Pipe_close_reason/index.html">Pipe_close_reason</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><div class="spec module" id="module-Pipe_rpc"><a href="#module-Pipe_rpc" class="anchor"></a><code><span class="keyword">module</span> <a href="Pipe_rpc/index.html">Pipe_rpc</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><dl><dt class="spec module" id="module-State_rpc"><a href="#module-State_rpc" class="anchor"></a><code><span class="keyword">module</span> <a href="State_rpc/index.html">State_rpc</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>A state rpc is an easy way for two processes to synchronize a data structure by sending updates over the wire. It's basically a pipe rpc that sends/receives an initial state of the data structure, and then updates, and applies the updates under the covers.</p></dd></dl><dl><dt class="spec module" id="module-One_way"><a href="#module-One_way" class="anchor"></a><code><span class="keyword">module</span> <a href="One_way/index.html">One_way</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>An RPC that has no response. Error handling is trickier here than it is for RPCs with responses, as there is no reasonable place to put an error if something goes wrong. Because of this, in the event of an error such as dispatching to an unimplemented RPC, the connection will be shut down. Similarly, if the implementation raises an exception, the connection will be shut down.</p></dd></dl><div class="spec module" id="module-Any"><a href="#module-Any" class="anchor"></a><code><span class="keyword">module</span> <a href="Any/index.html">Any</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div></div></body></html>