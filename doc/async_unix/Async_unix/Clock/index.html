<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Clock (async_unix.Async_unix.Clock)</title><link rel="stylesheet" href="../../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../../index.html">async_unix</a> &#x00BB; <a href="../index.html">Async_unix</a> &#x00BB; Clock</nav><h1>Module <code>Async_unix.Clock</code></h1><p>A <span class="xref-unresolved" title="unresolved reference to &quot;Async_kernel.Clock_intf.Clock&quot;"><span><code>Clock</code></span></span> based on <code>Core.Time</code>.</p></header><div><div class="spec include"><div class="doc"><details open="open"><summary><span class="def"><code><span class="keyword">include</span> <a href="../../../async_kernel/Async_kernel/Clock_ns/index.html#module-type-Clock">Async_kernel.Clock_ns.Clock</a> <span class="keyword">with</span> <span class="keyword">module</span> <a href="../../../async_kernel/Async_kernel/Clock_ns/module-type-Clock/Time/index.html">Time</a> := <a href="../../../core/Core/index.html#module-Time">Core.Time</a></code></span></summary><div class="spec module" id="module-Time"><a href="#module-Time" class="anchor"></a><code><span class="keyword">module</span> <a href="Time/index.html">Time</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><dl><dt class="spec value" id="val-run_at"><a href="#val-run_at" class="anchor"></a><code><span class="keyword">val</span> run_at : <a href="Time/index.html#type-t">Time.t</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span> <span>&#45;&gt;</span> unit) <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>run_at time f a</code> runs <code>f a</code> as soon as possible after <code>time</code>. If <code>time</code> is in the past, then <code>run_at</code> will immediately schedule a job <code>t</code> that will run <code>f a</code>. In no situation will <code>run_at</code> actually call <code>f</code> itself. The call to <code>f</code> will always be in another job.</p></dd></dl><dl><dt class="spec value" id="val-run_after"><a href="#val-run_after" class="anchor"></a><code><span class="keyword">val</span> run_after : <a href="Time/Span/index.html#type-t">Time.Span.t</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span> <span>&#45;&gt;</span> unit) <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>run_after</code> is like <code>run_at</code>, except that one specifies a time span rather than an absolute time.</p></dd></dl><dl><dt class="spec value" id="val-at"><a href="#val-at" class="anchor"></a><code><span class="keyword">val</span> at : <a href="Time/index.html#type-t">Time.t</a> <span>&#45;&gt;</span> unit <a href="../../../async_kernel/Async_kernel__/Deferred1/index.html#type-t">Async_kernel__.Clock_intf.Deferred.t</a></code></dt><dd><p><code>at time</code> returns a deferred <code>d</code> that will become determined as soon as possible after <code>time</code></p></dd></dl><dl><dt class="spec value" id="val-after"><a href="#val-after" class="anchor"></a><code><span class="keyword">val</span> after : <a href="Time/Span/index.html#type-t">Time.Span.t</a> <span>&#45;&gt;</span> unit <a href="../../../async_kernel/Async_kernel__/Deferred1/index.html#type-t">Async_kernel__.Clock_intf.Deferred.t</a></code></dt><dd><p><code>after</code> is like <code>at</code>, except that one specifies a time span rather than an absolute time. If you set up a lot of <code>after</code> events at the beginning of your program they will trigger at the same time. Use <code>Time.Span.randomize</code> to even them out.</p></dd></dl><dl><dt class="spec value" id="val-with_timeout"><a href="#val-with_timeout" class="anchor"></a><code><span class="keyword">val</span> with_timeout : <a href="Time/Span/index.html#type-t">Time.Span.t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="../../../async_kernel/Async_kernel__/Deferred1/index.html#type-t">Async_kernel__.Clock_intf.Deferred.t</a> <span>&#45;&gt;</span> [ `Timeout | `Result of <span class="type-var">'a</span> ] <a href="../../../async_kernel/Async_kernel__/Deferred1/index.html#type-t">Async_kernel__.Clock_intf.Deferred.t</a></code></dt><dd><p><code>with_timeout span d</code> returns a deferred that will become determined after either <code>span</code> elapses or <code>d</code> is determined, returning either <code>`Timeout</code> or <code>`Result</code> depending on which one succeeded first. At the time the returned deferred becomes determined, both things may have happened, in which case <code>`Result</code> is given preference.</p></dd></dl><dl><dt class="spec module" id="module-Event"><a href="#module-Event" class="anchor"></a><code><span class="keyword">module</span> <a href="Event/index.html">Event</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Events provide variants of <code>run_at</code> and <code>run_after</code> with the ability to abort or reschedule an event that hasn't yet happened. Once an event happens or is aborted, Async doesn't use any space for tracking it.</p></dd></dl><dl><dt class="spec value" id="val-at_varying_intervals"><a href="#val-at_varying_intervals" class="anchor"></a><code><span class="keyword">val</span> at_varying_intervals : ?&#8288;stop:unit <a href="../../../async_kernel/Async_kernel__/Deferred1/index.html#type-t">Async_kernel__.Clock_intf.Deferred.t</a> <span>&#45;&gt;</span> (unit <span>&#45;&gt;</span> <a href="Time/Span/index.html#type-t">Time.Span.t</a>) <span>&#45;&gt;</span> unit <a href="../../../async_kernel/Async_kernel__/Async_stream/index.html#type-t">Async_kernel__.Async_stream.t</a></code></dt><dd><p><code>at_varying_intervals f ?stop</code> returns a stream whose next element becomes determined by calling <code>f ()</code> and waiting for that amount of time, and then looping to determine subsequent elements. The stream will end after <code>stop</code> becomes determined.</p></dd></dl><dl><dt class="spec value" id="val-at_intervals"><a href="#val-at_intervals" class="anchor"></a><code><span class="keyword">val</span> at_intervals : ?&#8288;start:<a href="Time/index.html#type-t">Time.t</a> <span>&#45;&gt;</span> ?&#8288;stop:unit <a href="../../../async_kernel/Async_kernel__/Deferred1/index.html#type-t">Async_kernel__.Clock_intf.Deferred.t</a> <span>&#45;&gt;</span> <a href="Time/Span/index.html#type-t">Time.Span.t</a> <span>&#45;&gt;</span> unit <a href="../../../async_kernel/Async_kernel__/Async_stream/index.html#type-t">Async_kernel__.Async_stream.t</a></code></dt><dd><p><code>at_intervals interval ?start ?stop</code> returns a stream whose elements will become determined at nonnegative integer multiples of <code>interval</code> after the <code>start</code> time, until <code>stop</code> becomes determined:</p><pre>        start + 0 * interval
        start + 1 * interval
        start + 2 * interval
        start + 3 * interval
        ...</pre><p>Note that only elements that are strictly in the future ever become determined. In particular, if <code>start</code> is not in the future, or <code>start</code> is not provided, then there will be no element before the <code>interval</code> has passed.</p><p>If the interval is too small or the CPU is too loaded, <code>at_intervals</code> will skip until the next upcoming multiple of <code>interval</code> after <code>start</code>.</p></dd></dl><dl><dt class="spec value" id="val-every'"><a href="#val-every'" class="anchor"></a><code><span class="keyword">val</span> every' : ?&#8288;start:unit <a href="../../../async_kernel/Async_kernel__/Deferred1/index.html#type-t">Async_kernel__.Clock_intf.Deferred.t</a> <span>&#45;&gt;</span> ?&#8288;stop:unit <a href="../../../async_kernel/Async_kernel__/Deferred1/index.html#type-t">Async_kernel__.Clock_intf.Deferred.t</a> <span>&#45;&gt;</span> ?&#8288;continue_on_error:bool <span>&#45;&gt;</span> ?&#8288;finished:unit <a href="../../../async_kernel/Async_kernel/Ivar/index.html#type-t">Async_kernel.Ivar.t</a> <span>&#45;&gt;</span> <a href="Time/Span/index.html#type-t">Time.Span.t</a> <span>&#45;&gt;</span> (unit <span>&#45;&gt;</span> unit <a href="../../../async_kernel/Async_kernel__/Deferred1/index.html#type-t">Async_kernel__.Clock_intf.Deferred.t</a>) <span>&#45;&gt;</span> unit</code></dt><dd><p><code>every' ?start ?stop span f</code> runs <code>f ()</code> every <code>span</code> amount of time starting when <code>start</code> becomes determined and stopping when <code>stop</code> becomes determined. <code>every</code> waits until the result of <code>f ()</code> becomes determined before waiting for the next <code>span</code>.</p><p>It is guaranteed that if <code>stop</code> becomes determined, even during evaluation of <code>f</code>, then <code>f</code> will not be called again by a subsequent iteration of the loop.</p><p>It is an error for <code>span</code> to be nonpositive.</p><p>With <code>~continue_on_error:true</code>, when <code>f</code> asynchronously raises, iteration continues. With <code>~continue_on_error:false</code>, if <code>f</code> asynchronously raises, then iteration only continues when the result of <code>f</code> becomes determined.</p><p>Exceptions raised by <code>f</code> are always sent to monitor in effect when <code>every'</code> was called, even with <code>~continue_on_error:true</code>.</p><p>If <code>finished</code> is supplied, <code>every'</code> will fill it once all of the following become determined: <code>start</code>, <code>stop</code>, and the result of the final call to <code>f</code>.</p></dd></dl><dl><dt class="spec value" id="val-every"><a href="#val-every" class="anchor"></a><code><span class="keyword">val</span> every : ?&#8288;start:unit <a href="../../../async_kernel/Async_kernel__/Deferred1/index.html#type-t">Async_kernel__.Clock_intf.Deferred.t</a> <span>&#45;&gt;</span> ?&#8288;stop:unit <a href="../../../async_kernel/Async_kernel__/Deferred1/index.html#type-t">Async_kernel__.Clock_intf.Deferred.t</a> <span>&#45;&gt;</span> ?&#8288;continue_on_error:bool <span>&#45;&gt;</span> <a href="Time/Span/index.html#type-t">Time.Span.t</a> <span>&#45;&gt;</span> (unit <span>&#45;&gt;</span> unit) <span>&#45;&gt;</span> unit</code></dt><dd><p><code>every ?start ?stop span f</code> is <code>every' ?start ?stop span (fun () -&gt; f (); return ())</code>.</p></dd></dl><dl><dt class="spec value" id="val-run_at_intervals'"><a href="#val-run_at_intervals'" class="anchor"></a><code><span class="keyword">val</span> run_at_intervals' : ?&#8288;start:<a href="Time/index.html#type-t">Time.t</a> <span>&#45;&gt;</span> ?&#8288;stop:unit <a href="../../../async_kernel/Async_kernel__/Deferred1/index.html#type-t">Async_kernel__.Clock_intf.Deferred.t</a> <span>&#45;&gt;</span> ?&#8288;continue_on_error:bool <span>&#45;&gt;</span> <a href="Time/Span/index.html#type-t">Time.Span.t</a> <span>&#45;&gt;</span> (unit <span>&#45;&gt;</span> unit <a href="../../../async_kernel/Async_kernel__/Deferred1/index.html#type-t">Async_kernel__.Clock_intf.Deferred.t</a>) <span>&#45;&gt;</span> unit</code></dt><dd><p><code>run_at_intervals' ?start ?stop span f</code> runs <code>f()</code> at increments of <code>start + i *
      span</code> for nonnegative integers <code>i</code>, until <code>stop</code> becomes determined. <code>run_at_intervals'</code> waits for the result of <code>f</code> to become determined before waiting for the next interval.</p><p>Exceptions raised by <code>f</code> are always sent to monitor in effect when <code>run_at_intervals'</code> was called, even with <code>~continue_on_error:true</code>.</p></dd></dl><dl><dt class="spec value" id="val-run_at_intervals"><a href="#val-run_at_intervals" class="anchor"></a><code><span class="keyword">val</span> run_at_intervals : ?&#8288;start:<a href="Time/index.html#type-t">Time.t</a> <span>&#45;&gt;</span> ?&#8288;stop:unit <a href="../../../async_kernel/Async_kernel__/Deferred1/index.html#type-t">Async_kernel__.Clock_intf.Deferred.t</a> <span>&#45;&gt;</span> ?&#8288;continue_on_error:bool <span>&#45;&gt;</span> <a href="Time/Span/index.html#type-t">Time.Span.t</a> <span>&#45;&gt;</span> (unit <span>&#45;&gt;</span> unit) <span>&#45;&gt;</span> unit</code></dt><dd><p><code>run_at_intervals ?start ?stop ?continue_on_error span f</code> is equivalent to:</p><pre><code class="ml">run_at_intervals' ?start ?stop ?continue_on_error span
  (fun () -&gt; f (); return ()) </code></pre></dd></dl></details></div></div></div></div></body></html>