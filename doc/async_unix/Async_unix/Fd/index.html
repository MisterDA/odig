<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Fd (async_unix.Async_unix.Fd)</title><link rel="stylesheet" href="../../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../../index.html">async_unix</a> &#x00BB; <a href="../index.html">Async_unix</a> &#x00BB; Fd</nav><h1>Module <code>Async_unix.Fd</code></h1><p>An <code>Fd.t</code> is a wrapper around a Unix file descriptor, with additional information about the kind of file descriptor and logic to ensure that we don't use a file descriptor that has been closed, or close a file descriptor that is in use.</p><p>Since Async uses multiple threads to make read/write and other system calls on file descriptors, and Unix reuses descriptors after they are closed, Async has to be very careful that the file descriptor passed to a system call is referring to the file it intends, and not some other completely unrelated file that Unix has decided to assign to the same descriptor.</p><p>Provided that one only accesses a file descriptor within the context of the functions below, <code>Fd</code> guarantees that the file descriptor will not have been closed/reused and will correspond to the same file that it did when the <code>Fd.t</code> was created:</p><pre>      with_file_descr
      with_file_descr_deferred
      syscall
      syscall_exn
      syscall_result_exn
      syscall_in_thread
      syscall_in_thread_exn</pre><p>The <code>Fd</code> module keeps track of which of these functions are currently accessing the file descriptor, and ensures that any close happens after they complete. Also, once close has been called, it refuses to provide further access to the file descriptor, either by returning a variant <code>`Already_closed</code> or by raising an exception.</p><p>Some of the above functions take an optional <code>?nonblocking:bool</code> argument. The default is <code>false</code>, but if it is set to <code>true</code>, then before supplying the underlying <code>file_descr</code>, the <code>Fd</code> module will first call <code>Unix.set_nonblock file_descr</code>, if it hasn't previously done so on that file descriptor. This is intended to support making nonblocking system calls (e.g., connect, read, write) directly within Async, without releasing the OCaml lock or the Async lock, and without using another thread.</p></header><div class="spec module" id="module-Kind"><a href="#module-Kind" class="anchor"></a><code><span class="keyword">module</span> <a href="Kind/index.html">Kind</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> t</code></dt></dl><div><div class="spec include"><div class="doc"><details open="open"><summary><span class="def"><code><span class="keyword">include</span> <span class="keyword">sig</span> ... <span class="keyword">end</span></code></span></summary><dl><dt class="spec value" id="val-sexp_of_t"><a href="#val-sexp_of_t" class="anchor"></a><code><span class="keyword">val</span> sexp_of_t : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../../../sexplib0/Sexplib0/Sexp/index.html#type-t">Ppx_sexp_conv_lib.Sexp.t</a></code></dt></dl></details></div></div></div><dl><dt class="spec value" id="val-info"><a href="#val-info" class="anchor"></a><code><span class="keyword">val</span> info : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../../../core_kernel/Core_kernel/Info/index.html#type-t">Core.Info.t</a></code></dt><dt class="spec value" id="val-to_string"><a href="#val-to_string" class="anchor"></a><code><span class="keyword">val</span> to_string : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> string</code></dt><dd><p><code>to_string t</code> returns a pretty sexp of the representation of <code>t</code>.</p></dd></dl><dl><dt class="spec value" id="val-create"><a href="#val-create" class="anchor"></a><code><span class="keyword">val</span> create : ?&#8288;avoid_nonblock_if_possible:bool <span>&#45;&gt;</span> <a href="Kind/index.html#type-t">Kind.t</a> <span>&#45;&gt;</span> <a href="../../../core/Core__Core_unix/File_descr/index.html#type-t">Core.Unix.File_descr.t</a> <span>&#45;&gt;</span> <a href="../../../core_kernel/Core_kernel/Info/index.html#type-t">Core.Info.t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>create ?support_nonblock kind file_descr</code> creates a new <code>t</code> of the underlying kind and file descriptor.</p><p>We thought about using <code>fstat()</code> rather than requiring the user to supply the kind. But <code>fstat</code> can block, which would require putting this in a thread, which has some consequences, and it isn't clear that it gets us that much. Also, <code>create</code> is mostly used within the Async implementation -- clients shouldn't need it unless they are mixing Async and non-Async code.</p><p>If <code>avoid_nonblock_if_possible</code>, then Async will treat the file descriptor as blocking if it can (more precisely, if it's not a bound socket).</p></dd></dl><dl><dt class="spec value" id="val-kind"><a href="#val-kind" class="anchor"></a><code><span class="keyword">val</span> kind : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="Kind/index.html#type-t">Kind.t</a></code></dt><dd><p><code>kind t</code> returns the kind of file descriptor that <code>t</code> is.</p></dd></dl><dl><dt class="spec value" id="val-supports_nonblock"><a href="#val-supports_nonblock" class="anchor"></a><code><span class="keyword">val</span> supports_nonblock : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>supports_nonblock t</code> returns true if <code>t</code> supports nonblocking system calls.</p></dd></dl><dl><dt class="spec value" id="val-clear_nonblock"><a href="#val-clear_nonblock" class="anchor"></a><code><span class="keyword">val</span> clear_nonblock : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>clear_nonblock t</code> clears the <code>nonblocking</code> flag on <code>t</code> and causes Async to treat the fd as though it doesn't support nonblocking I/O. This is useful for applications that want to share a file descriptor between Async and non-Async code and want to avoid <code>EWOULDBLOCK</code> or <code>EAGAIN</code> being seen by the non-Async code, which would then cause a <code>Sys_blocked_io</code> exception.</p><p><code>clear_nonblock t</code> has no effect if <code>not (supports_nonblock t)</code>.</p></dd></dl><dl><dt class="spec module" id="module-Close"><a href="#module-Close" class="anchor"></a><code><span class="keyword">module</span> <a href="Close/index.html">Close</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>The <code>Close</code> module exists to collect <code>close</code> and its associated types, so they can be easily reused elsewhere, e.g., <code>Unix_syscalls</code>.</p></dd></dl><div><div class="spec include"><div class="doc"><details open="open"><summary><span class="def"><code><span class="keyword">include</span> <span class="keyword">module</span> <span class="keyword">type</span> <span class="keyword">of</span> <a href="index.html#module-Close">Close</a></code></span></summary><dl><dt class="spec type" id="type-socket_handling"><a href="#type-socket_handling" class="anchor"></a><code><span class="keyword">type</span> socket_handling</code><code> = </code><table class="variant"><tr id="type-socket_handling.Shutdown_socket" class="anchored"><td class="def constructor"><a href="#type-socket_handling.Shutdown_socket" class="anchor"></a><code>| </code><code><span class="constructor">Shutdown_socket</span></code></td></tr><tr id="type-socket_handling.Do_not_shutdown_socket" class="anchored"><td class="def constructor"><a href="#type-socket_handling.Do_not_shutdown_socket" class="anchor"></a><code>| </code><code><span class="constructor">Do_not_shutdown_socket</span></code></td></tr></table></dt><dt class="spec type" id="type-file_descriptor_handling"><a href="#type-file_descriptor_handling" class="anchor"></a><code><span class="keyword">type</span> file_descriptor_handling</code><code> = </code><table class="variant"><tr id="type-file_descriptor_handling.Close_file_descriptor" class="anchored"><td class="def constructor"><a href="#type-file_descriptor_handling.Close_file_descriptor" class="anchor"></a><code>| </code><code><span class="constructor">Close_file_descriptor</span> <span class="keyword">of</span> <a href="index.html#type-socket_handling">socket_handling</a></code></td></tr><tr id="type-file_descriptor_handling.Do_not_close_file_descriptor" class="anchored"><td class="def constructor"><a href="#type-file_descriptor_handling.Do_not_close_file_descriptor" class="anchor"></a><code>| </code><code><span class="constructor">Do_not_close_file_descriptor</span></code></td></tr></table></dt></dl><dl><dt class="spec value" id="val-close"><a href="#val-close" class="anchor"></a><code><span class="keyword">val</span> close : ?&#8288;file_descriptor_handling:<a href="index.html#type-file_descriptor_handling">file_descriptor_handling</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_unix__.Import.Deferred.t</a></code></dt><dd><p><code>close t</code> prevents further use of <code>t</code>, and makes <code>shutdown()</code> and <code>close()</code> system calls on <code>t</code>'s underlying file descriptor according to the <code>file_descriptor_handling</code> argument and whether or not <code>t</code> is a socket, i.e., <code>kind
      t = Socket `Active</code>:</p><pre>        | file_descriptor_handling                     | shutdown() | close() |
        |----------------------------------------------+------------+---------|
        | Do_not_close_file_descriptor                 | no         | no      |
        | Close_file_descriptor Shutdown_socket        | if socket  | yes     |
        | Close_file_descriptor Do_not_shutdown_socket | no         | yes     |</pre><p>The result of <code>close</code> becomes determined once the system calls complete. It is OK to call <code>close</code> multiple times on the same <code>t</code>; calls subsequent to the initial call will have no effect, but will return the same deferred as the original call.</p></dd></dl></details></div></div></div><dl><dt class="spec value" id="val-close_started"><a href="#val-close_started" class="anchor"></a><code><span class="keyword">val</span> close_started : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_unix__.Import.Deferred.t</a></code></dt><dd><p><code>close_started t</code> becomes determined when <code>close t</code> is called.</p></dd></dl><dl><dt class="spec value" id="val-close_finished"><a href="#val-close_finished" class="anchor"></a><code><span class="keyword">val</span> close_finished : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_unix__.Import.Deferred.t</a></code></dt><dd><p><code>close_finished</code> returns the same result as <code>close</code>, but differs in that it does not have the side effect of initiating a close.</p></dd></dl><dl><dt class="spec value" id="val-is_closed"><a href="#val-is_closed" class="anchor"></a><code><span class="keyword">val</span> is_closed : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>is_closed t</code> returns <code>true</code> iff <code>close t</code> has been called.</p></dd></dl><dl><dt class="spec value" id="val-with_close"><a href="#val-with_close" class="anchor"></a><code><span class="keyword">val</span> with_close : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> f:(<a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_unix__.Import.Deferred.t</a>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_unix__.Import.Deferred.t</a></code></dt><dd><p><code>with_close t f</code> applies <code>f</code> to <code>t</code>, returns the result of <code>f</code>, and closes <code>t</code>.</p></dd></dl><dl><dt class="spec value" id="val-is_open"><a href="#val-is_open" class="anchor"></a><code><span class="keyword">val</span> is_open : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>is_open t</code> is <code>not (is_closed t</code>)</p></dd></dl><dl><dt class="spec value" id="val-stdin"><a href="#val-stdin" class="anchor"></a><code><span class="keyword">val</span> stdin : unit <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>stdin</code>, <code>stdout</code>, and <code>stderr</code> are wrappers around the standard Unix file descriptors.</p></dd></dl><dl><dt class="spec value" id="val-stdout"><a href="#val-stdout" class="anchor"></a><code><span class="keyword">val</span> stdout : unit <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-stderr"><a href="#val-stderr" class="anchor"></a><code><span class="keyword">val</span> stderr : unit <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-with_file_descr"><a href="#val-with_file_descr" class="anchor"></a><code><span class="keyword">val</span> with_file_descr : ?&#8288;nonblocking:bool <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<a href="../../../core/Core__Core_unix/File_descr/index.html#type-t">Core.Unix.File_descr.t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span>) <span>&#45;&gt;</span> [ `Ok of <span class="type-var">'a</span> | `Already_closed | `Error of exn ]</code></dt><dd><p><code>with_file_descr t f</code> runs <code>f</code> on the file descriptor underlying <code>t</code>, if <code>is_open t</code>, and returns <code>`Ok</code> or <code>`Error</code> according to <code>f</code>. If <code>is_closed t</code>, then it does not call <code>f</code> and returns <code>`Already_closed</code>.</p></dd></dl><dl><dt class="spec value" id="val-with_file_descr_exn"><a href="#val-with_file_descr_exn" class="anchor"></a><code><span class="keyword">val</span> with_file_descr_exn : ?&#8288;nonblocking:bool <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<a href="../../../core/Core__Core_unix/File_descr/index.html#type-t">Core.Unix.File_descr.t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p><code>with_file_descr_exn</code> is like <code>with_file_descr</code> except that it raises rather than return <code>`Already_closed</code> or <code>`Error</code>.</p></dd></dl><dl><dt class="spec value" id="val-with_file_descr_deferred"><a href="#val-with_file_descr_deferred" class="anchor"></a><code><span class="keyword">val</span> with_file_descr_deferred : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<a href="../../../core/Core__Core_unix/File_descr/index.html#type-t">Core.Unix.File_descr.t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_unix__.Import.Deferred.t</a>) <span>&#45;&gt;</span> [ `Ok of <span class="type-var">'a</span> | `Already_closed | `Error of exn ] <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_unix__.Import.Deferred.t</a></code></dt><dd><p><code>with_file_descr_deferred t f</code> runs <code>f</code> on the file descriptor underlying <code>t</code>, if <code>is_open t</code>, and returns <code>`Ok</code> or <code>`Error</code> according to <code>f</code>. If <code>is_closed t</code>, then it does not call <code>f</code> and returns <code>`Already_closed</code>. It ensures that the file descriptor underlying <code>t</code> is not closed until the result of <code>f</code> becomes determined (or <code>f</code> raises).</p></dd></dl><dl><dt class="spec value" id="val-with_file_descr_deferred_exn"><a href="#val-with_file_descr_deferred_exn" class="anchor"></a><code><span class="keyword">val</span> with_file_descr_deferred_exn : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<a href="../../../core/Core__Core_unix/File_descr/index.html#type-t">Core.Unix.File_descr.t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_unix__.Import.Deferred.t</a>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_unix__.Import.Deferred.t</a></code></dt><dd><p><code>with_file_descr_deferred_exn</code> is like <code>with_file_descr_deferred</code>, except that it raises rather than return <code>`Already_closed</code> or <code>`Error</code>.</p></dd></dl><dl><dt class="spec value" id="val-interruptible_ready_to"><a href="#val-interruptible_ready_to" class="anchor"></a><code><span class="keyword">val</span> interruptible_ready_to : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> [ `Read | `Write ] <span>&#45;&gt;</span> interrupt:unit <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_unix__.Import.Deferred.t</a> <span>&#45;&gt;</span> [ `Bad_fd | `Closed | `Interrupted | `Ready ] <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_unix__.Import.Deferred.t</a></code></dt><dd><p><code>interruptible_ready_to t read_write ~interrupt</code> returns a deferred that will become determined when the file descriptor underlying <code>t</code> can be read from or written to without blocking, or when <code>interrupt</code> becomes determined.</p></dd></dl><dl><dt class="spec value" id="val-ready_to"><a href="#val-ready_to" class="anchor"></a><code><span class="keyword">val</span> ready_to : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> [ `Read | `Write ] <span>&#45;&gt;</span> [ `Bad_fd | `Closed | `Ready ] <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_unix__.Import.Deferred.t</a></code></dt><dd><p><code>ready_to t read_write</code> is like <code>interruptible_ready_to</code>, but without the possibility of interruption.</p></dd></dl><dl><dt class="spec value" id="val-interruptible_every_ready_to"><a href="#val-interruptible_every_ready_to" class="anchor"></a><code><span class="keyword">val</span> interruptible_every_ready_to : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> [ `Read | `Write ] <span>&#45;&gt;</span> interrupt:unit <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_unix__.Import.Deferred.t</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span> <span>&#45;&gt;</span> unit) <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> [ `Bad_fd | `Closed | `Unsupported | `Interrupted ] <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_unix__.Import.Deferred.t</a></code></dt><dd><p><code>interruptible_every_ready_to t read_write ~interrupt f a</code> enqueues a job to run <code>f a</code> every time the file descriptor underlying <code>t</code> can be read from or written to without blocking and returns a deferred that will become determined when <code>interrupt</code> becomes determined or the file descriptor is closed.</p></dd></dl><dl><dt class="spec value" id="val-every_ready_to"><a href="#val-every_ready_to" class="anchor"></a><code><span class="keyword">val</span> every_ready_to : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> [ `Read | `Write ] <span>&#45;&gt;</span> (<span class="type-var">'a</span> <span>&#45;&gt;</span> unit) <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> [ `Bad_fd | `Closed | `Unsupported ] <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_unix__.Import.Deferred.t</a></code></dt><dd><p><code>every_ready_to t read_write f x</code> is like <code>interruptible_every_ready_to</code>, but without the possibility of interruption.</p></dd></dl><dl><dt class="spec value" id="val-syscall"><a href="#val-syscall" class="anchor"></a><code><span class="keyword">val</span> syscall : ?&#8288;nonblocking:bool <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<a href="../../../core/Core__Core_unix/File_descr/index.html#type-t">Core.Unix.File_descr.t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span>) <span>&#45;&gt;</span> [ `Already_closed | `Ok of <span class="type-var">'a</span> | `Error of exn ]</code></dt><dd><p><code>syscall t f</code> runs <code>Async_unix.syscall</code> with <code>f</code> on the file descriptor underlying <code>t</code>, if <code>is_open t</code>, and returns <code>`Ok</code> or <code>`Error</code> according to <code>f</code>. If <code>is_closed t</code>, it does not call <code>f</code> and returns <code>`Already_closed</code>.</p></dd></dl><dl><dt class="spec value" id="val-syscall_exn"><a href="#val-syscall_exn" class="anchor"></a><code><span class="keyword">val</span> syscall_exn : ?&#8288;nonblocking:bool <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<a href="../../../core/Core__Core_unix/File_descr/index.html#type-t">Core.Unix.File_descr.t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p><code>syscall_exn t f</code> is like <code>syscall</code>, except it raises rather than return <code>`Already_closed</code> or <code>`Error</code>.</p></dd></dl><dl><dt class="spec value" id="val-syscall_result_exn"><a href="#val-syscall_result_exn" class="anchor"></a><code><span class="keyword">val</span> syscall_result_exn : ?&#8288;nonblocking:bool <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> (<a href="../../../core/Core__Core_unix/File_descr/index.html#type-t">Core.Unix.File_descr.t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="../../../core/Core__/Syscall_result/index.html#type-t">Core.Unix.Syscall_result.t</a>) <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="../../../core/Core__/Syscall_result/index.html#type-t">Core.Unix.Syscall_result.t</a></code></dt><dd><p><code>syscall_result_exn t f a</code> is like <code>syscall_exn</code>, except it does not allocate except in exceptional cases. <code>a</code> is passed unchanged to <code>f</code>, and should be used to eliminate allocations due to closure capture.</p></dd></dl><dl><dt class="spec value" id="val-syscall_in_thread"><a href="#val-syscall_in_thread" class="anchor"></a><code><span class="keyword">val</span> syscall_in_thread : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> name:string <span>&#45;&gt;</span> (<a href="../../../core/Core__Core_unix/File_descr/index.html#type-t">Core.Unix.File_descr.t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span>) <span>&#45;&gt;</span> [ `Already_closed | `Ok of <span class="type-var">'a</span> | `Error of exn ] <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_unix__.Import.Deferred.t</a></code></dt><dd><p><code>syscall_in_thread t f</code> runs <code>In_thread.syscall</code> with <code>f</code> on the file descriptor underlying <code>t</code>, if <code>is_open t</code>, and returns a deferred that becomes determined with <code>`Ok</code> or <code>`Error</code> when the system call completes. If <code>is_closed t</code>, it does not call <code>f</code> and returns <code>`Already_closed</code>.</p></dd></dl><dl><dt class="spec value" id="val-syscall_in_thread_exn"><a href="#val-syscall_in_thread_exn" class="anchor"></a><code><span class="keyword">val</span> syscall_in_thread_exn : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> name:string <span>&#45;&gt;</span> (<a href="../../../core/Core__Core_unix/File_descr/index.html#type-t">Core.Unix.File_descr.t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_unix__.Import.Deferred.t</a></code></dt><dd><p><code>syscall_in_thread_exn</code> is like <code>syscall_in_thread</code>, except it raises rather than return <code>`Already_closed</code> or <code>`Error</code>.</p></dd></dl><dl><dt class="spec value" id="val-of_in_channel"><a href="#val-of_in_channel" class="anchor"></a><code><span class="keyword">val</span> of_in_channel : <a href="../../../stdio/Stdio/In_channel/index.html#type-t">Core.In_channel.t</a> <span>&#45;&gt;</span> <a href="Kind/index.html#type-t">Kind.t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>of_in_channel</code> and <code>of_out_channel</code> create an fd from their underlying file descriptor.</p></dd></dl><dl><dt class="spec value" id="val-of_out_channel"><a href="#val-of_out_channel" class="anchor"></a><code><span class="keyword">val</span> of_out_channel : <a href="../../../stdio/Stdio/Out_channel/index.html#type-t">Core.Out_channel.t</a> <span>&#45;&gt;</span> <a href="Kind/index.html#type-t">Kind.t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-of_in_channel_auto"><a href="#val-of_in_channel_auto" class="anchor"></a><code><span class="keyword">val</span> of_in_channel_auto : <a href="../../../stdio/Stdio/In_channel/index.html#type-t">Core.In_channel.t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_unix__.Import.Deferred.t</a></code></dt><dd><p><code>of_in_channel_auto ic</code> is just like <code>of_in_channel</code>, but uses <code>fstat</code> to determine the kind. It makes some assumptions about sockets, specifically it assumes that a socket is either listening or connected to something (and it uses <code>getsockopt</code> to find out which). Don't pass an <code>in_channel</code> containing an unconnected non-listening socket.</p></dd></dl><dl><dt class="spec value" id="val-of_out_channel_auto"><a href="#val-of_out_channel_auto" class="anchor"></a><code><span class="keyword">val</span> of_out_channel_auto : <a href="../../../stdio/Stdio/Out_channel/index.html#type-t">Core.Out_channel.t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_unix__.Import.Deferred.t</a></code></dt><dd><p><code>of_out_channel_auto ic</code> is just like <code>of_out_channel</code>, but uses <code>fstat</code> to determine the kind. It makes some assumptions about sockets, specifically it assumes that a socket is either listening or connected to something (and it uses <code>getsockopt</code> to find out which). Don't pass an <code>in_channel</code> containing an unconnected non listening socket.</p></dd></dl><dl><dt class="spec value" id="val-file_descr_exn"><a href="#val-file_descr_exn" class="anchor"></a><code><span class="keyword">val</span> file_descr_exn : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../../../core/Core__Core_unix/File_descr/index.html#type-t">Core.Unix.File_descr.t</a></code></dt><dd><p><code>file_descr_exn t</code> returns the file descriptor underlying <code>t</code>, unless <code>is_closed t</code>, in which case it raises. One must be very careful when using this function, and should try not to, since any uses of the resulting file descriptor are unknown to the <code>Fd</code> module, and hence can violate the guarantee it is trying to enforce.</p></dd></dl><dl><dt class="spec value" id="val-to_int_exn"><a href="#val-to_int_exn" class="anchor"></a><code><span class="keyword">val</span> to_int_exn : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int</code></dt><dd><p><code>to_int_exn t</code> returns the the underlying file descriptor as an int. It has the same caveats as <code>file_descr_exn</code>.</p></dd></dl><dl><dt class="spec value" id="val-replace"><a href="#val-replace" class="anchor"></a><code><span class="keyword">val</span> replace : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="Kind/index.html#type-t">Kind.t</a> <span>&#45;&gt;</span> <a href="../../../core_kernel/Core_kernel/Info/index.html#type-t">Core.Info.t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>replace t kind</code> is for internal use only, by <code>Unix_syscalls</code>. It is used when one wants to reuse a file descriptor in an fd with a new kind.</p></dd></dl></div></body></html>