<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Shutdown (async_unix.Async_unix.Shutdown)</title><link rel="stylesheet" href="../../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../../index.html">async_unix</a> &#x00BB; <a href="../index.html">Async_unix</a> &#x00BB; Shutdown</nav><h1>Module <code>Async_unix.Shutdown</code></h1><p>For shutting down an Async program.</p></header><dl><dt class="spec value" id="val-shutdown"><a href="#val-shutdown" class="anchor"></a><code><span class="keyword">val</span> shutdown : ?&#8288;force:unit <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_unix__.Import.Deferred.t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> unit</code></dt><dd><p><code>shutdown ?force status</code> initiates shutdown, which runs all the <code>at_shutdown</code> functions, waits for them to finish, and then exits with the supplied status. The <code>at_shutdown</code> functions can block -- one can use <code>~force</code> to forcibly exit (with status 1) if the <code>at_shutdown</code> functions do not finish in a reasonable amount of time.</p><p>By default, <code>force</code> is <code>after (sec 10.)</code>.</p><p>Repeated calls to <code>shutdown</code> with the same status will have no effect. Any call to <code>shutdown</code> with nonzero status will cause that to be the status that is exited with. A call to <code>shutdown</code> with different nonzero status from the original call will raise.</p></dd></dl><dl><dt class="spec value" id="val-shutdown_on_unhandled_exn"><a href="#val-shutdown_on_unhandled_exn" class="anchor"></a><code><span class="keyword">val</span> shutdown_on_unhandled_exn : unit <span>&#45;&gt;</span> unit</code></dt><dd><p><code>shutdown_on_unhandled_exn ()</code> arranges things so that whenever there is an asynchronous unhandled exception, an error message is printed to stderr and <code>shutdown
    1</code> is called. This is useful when one wants to ensure that <code>at_shutdown</code> handlers run when there is an unhandled exception. Calling <code>shutdown_on_unhandled_exn</code> ensures that <code>Scheduler.go</code> will not raise due to an unhandled exception, and instead that the program will exit once <code>at_shutdown</code> handlers finish.</p></dd></dl><dl><dt class="spec value" id="val-exit"><a href="#val-exit" class="anchor"></a><code><span class="keyword">val</span> exit : ?&#8288;force:unit <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_unix__.Import.Deferred.t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <span class="type-var">_</span> <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_unix__.Import.Deferred.t</a></code></dt><dd><p><code>exit ?force status</code> is <code>shutdown ?force status; Deferred.never ()</code>.</p><p>We do not have an exit function that returns a non-deferred:</p><pre><code class="ml">val exit : ?force:unit Deferred.t -&gt; int -&gt; _ </code></pre><p>Such a function should not exist, for the same reason that we do not have:</p><pre><code class="ml">val block : 'a Deferred.t -&gt; 'a </code></pre><p>The semantics of such an exit function would allow one to block a running Async job, and to switch to another one (to run the <code>at_shutdown</code> handlers), without expressing that switch in the type system via a <code>Deferred.t</code>. That would eliminate all the nice reasoning guarantees that Async gives about concurrent jobs.</p></dd></dl><dl><dt class="spec value" id="val-default_force"><a href="#val-default_force" class="anchor"></a><code><span class="keyword">val</span> default_force : unit <span>&#45;&gt;</span> unit <span>&#45;&gt;</span> unit <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_unix__.Import.Deferred.t</a></code></dt><dd><p><code>default_force</code> returns the default <code>force</code> value used by <code>shutdown</code> and <code>exit</code>.</p></dd></dl><dl><dt class="spec value" id="val-set_default_force"><a href="#val-set_default_force" class="anchor"></a><code><span class="keyword">val</span> set_default_force : (unit <span>&#45;&gt;</span> unit <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_unix__.Import.Deferred.t</a>) <span>&#45;&gt;</span> unit</code></dt><dd><p><code>set_default_force f</code> sets the default <code>force</code> value used by <code>shutdown</code> and <code>exit</code> to <code>f</code>. Initially, the default value is <code>fun () -&gt; after (sec 10.)</code>. A subsequent call to <code>shutdown</code> or <code>exit</code> that doesn't supply <code>~force</code> will call <code>f</code> and will force shutdown when its result becomes determined.</p><p><code>set_default_force</code> has no effect if <code>shutdown</code> or <code>exit</code> has already been called, or if the next call to <code>shutdown</code> or <code>exit</code> supplies <code>~force</code>.</p><p><code>set_default_force</code> is useful for applications that call <code>shutdown</code> indirectly via a library, yet want to modify its behavior.</p></dd></dl><dl><dt class="spec value" id="val-shutting_down"><a href="#val-shutting_down" class="anchor"></a><code><span class="keyword">val</span> shutting_down : unit <span>&#45;&gt;</span> [ `No | `Yes of int ]</code></dt><dd><p><code>shutting_down ()</code> reports whether we are currently shutting down, and if so, with what status.</p></dd></dl><dl><dt class="spec value" id="val-at_shutdown"><a href="#val-at_shutdown" class="anchor"></a><code><span class="keyword">val</span> at_shutdown : (unit <span>&#45;&gt;</span> unit <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_unix__.Import.Deferred.t</a>) <span>&#45;&gt;</span> unit</code></dt><dd><p><code>at_shutdown f</code> causes <code>f ()</code> to be run when <code>shutdown</code> is called, and for <code>shutdown</code> to wait until the returned deferred finishes. If <code>f</code> raises (synchronously or asynchronously), then the exception is printed to stderr and the program exits nonzero, irrespective of the status supplied to <code>shutdown</code>.</p><p>If <code>shutdown</code> has already been called, then calling <code>at_shutdown f</code> does nothing.</p><p>The functions supplied to <code>at_shutdown</code> are run in parallel on shutdown.</p></dd></dl><dl><dt class="spec value" id="val-don't_finish_before"><a href="#val-don't_finish_before" class="anchor"></a><code><span class="keyword">val</span> don't_finish_before : unit <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_unix__.Import.Deferred.t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>don't_finish_before d</code> causes <code>shutdown</code> to wait until <code>d</code> becomes determined before finishing. It is like <code>at_shutdown (fun _ -&gt; d)</code>, except it is more efficient, and will not take any space once <code>d</code> is determined. There is a single <code>at_shutdown</code> shared among all deferreds supplied to <code>don't_finish_before</code>. <code>don't_finish_before</code> does not override the <code>force</code> argument passed to shutdown.</p></dd></dl></div></body></html>