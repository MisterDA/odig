<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>In_thread (async_unix.Async_unix__.In_thread)</title><link rel="stylesheet" href="../../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../../index.html">async_unix</a> &#x00BB; <a href="../index.html">Async_unix__</a> &#x00BB; In_thread</nav><h1>Module <code>Async_unix__.In_thread</code></h1></header><aside><p>The <code>In_thread</code> module has functions for interaction between the Async world and other (kernel) threads. The name is to remind us to think about threads and race conditions.</p><p>All threads come from the one thread pool used for all Async-managed threads.</p></aside><div class="spec module" id="module-Priority"><a href="#module-Priority" class="anchor"></a><code><span class="keyword">module</span> Priority : <span class="keyword">module</span> <span class="keyword">type</span> <span class="keyword">of</span> <a href="../../../core/Core/Linux_ext/index.html#module-Priority">Core.Linux_ext.Priority</a> <span class="keyword">with</span> <span class="keyword">type</span> <a href="../../../core/Core/Linux_ext/index.html#module-Priority">Priority</a>.t = <a href="../../../core/Core__Linux_ext/Priority/index.html#type-t">Core.Linux_ext.Priority.t</a></code></div><div class="spec module" id="module-Helper_thread"><a href="#module-Helper_thread" class="anchor"></a><code><span class="keyword">module</span> <a href="Helper_thread/index.html">Helper_thread</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><dl><dt class="spec value" id="val-pipe_of_squeue"><a href="#val-pipe_of_squeue" class="anchor"></a><code><span class="keyword">val</span> pipe_of_squeue : <span class="type-var">'a</span> <a href="../../../core/Core/Squeue/index.html#type-t">Core.Squeue.t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="../../../async_kernel/Async_kernel__Pipe/Reader/index.html#type-t">Async_kernel.Pipe.Reader.t</a></code></dt><dd><p><code>pipe_of_squeue squeue</code> returns a pipe <code>p</code> and consumes the contents <code>squeue</code>, placing them in <code>p</code>. It repeatedly grabs everything from <code>squeue</code>, places it in <code>p</code>, and then waits for pushback on <code>p</code>.</p></dd></dl><dl><dt class="spec value" id="val-run"><a href="#val-run" class="anchor"></a><code><span class="keyword">val</span> run : ?&#8288;priority:<a href="../../../core/Core__Linux_ext/Priority/index.html#type-t">Priority.t</a> <span>&#45;&gt;</span> ?&#8288;thread:<a href="Helper_thread/index.html#type-t">Helper_thread.t</a> <span>&#45;&gt;</span> ?&#8288;when_finished:[ `Take_the_async_lock | `Notify_the_scheduler | `Best ] <span>&#45;&gt;</span> ?&#8288;name:string <span>&#45;&gt;</span> (unit <span>&#45;&gt;</span> <span class="type-var">'a</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_kernel.Deferred.t</a></code></dt><dd><p><code>run ?priority ?thread ?name f</code> runs <code>f ()</code> in a separate thread outside Async and returns the result as a Deferred in the Async world. If <code>f ()</code> raises an exception (asynchronously, since it is another thread) then that exception will be raised to the monitor that called <code>run</code>.</p><p>WARNING: Async code MUST NOT be used from within <code>f</code>. By Async code we mean pretty-much all functions of libraries making use of Async. Only a few functions of the Async library can be called inside <code>In_thread.run</code>. These are explicitly marked as such, using the phrase &quot;thread-safe&quot;.</p><p>If <code>thread</code> is not supplied, then any thread from the thread pool could be used. If you need to run routines in a specific thread (as is required by some libraries like Sqlite), you should create a helper thread and supply it to <code>run</code>.</p><p>If <code>priority</code> is supplied, the priority of the thread in the linux scheduler will be set to <code>priority</code> for the duration of <code>f ()</code>, provided the thread is allowed to do so (see <code>man setpriority</code>).</p><p>If you call <code>run</code> several times with the same helper thread, the <code>f ()</code> calls will run in sequence, in the order in which they are supplied to <code>run</code>. Each <code>f ()</code> will complete (return or raise) before another <code>f ()</code> starts.</p><p>For example, if you do:</p><pre><code class="ml">let () =
  run ~thread f1;
  run ~thread f2;
  run ~thread f3; </code></pre><p>Then the thread will run <code>f1 ()</code> to completion, then <code>f2 ()</code> to completion, then <code>f3 ()</code> to completion.</p><p>If <code>name</code> is supplied, the name of the thread will be set to it for the duration of the execution of <code>f ()</code>.</p><p><code>when_finished</code> describes how the helper thread behaves once <code>f ()</code> has completed:</p><ul><li>with <code>`Take_the_lock</code> it takes the Async lock and runs a cycle immediately</li><li>with <code>`Notify_the_scheduler</code> it just notifies the scheduler that the result is ready</li><li>with <code>`Best</code> it tries to take the lock and run a cycle, but will fallback to <code>`Notify_the_scheduler</code> method if the Async lock is already held by someone else. The default is <code>`Best</code>, and one shouldn't need to change it -- it is useful only for unit testing.</li></ul></dd></dl><dl><dt class="spec value" id="val-syscall"><a href="#val-syscall" class="anchor"></a><code><span class="keyword">val</span> syscall : name:string <span>&#45;&gt;</span> (unit <span>&#45;&gt;</span> <span class="type-var">'a</span>) <span>&#45;&gt;</span> (<span class="type-var">'a</span>, exn) <a href="../../../core_kernel/Core_kernel/Result/index.html#type-t">Core.Result.t</a> <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_kernel.Deferred.t</a></code></dt><dd><p><code>syscall f</code> runs f, which should be a single system call, and returns the result, handling the restarting of interrupted system calls. To avoid race conditions, the <code>f</code> supplied to <code>syscall</code> should just make a system call. That way, everything else is done holding the Async lock.</p></dd></dl><dl><dt class="spec value" id="val-syscall_exn"><a href="#val-syscall_exn" class="anchor"></a><code><span class="keyword">val</span> syscall_exn : name:string <span>&#45;&gt;</span> (unit <span>&#45;&gt;</span> <span class="type-var">'a</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_kernel.Deferred.t</a></code></dt></dl></div></body></html>