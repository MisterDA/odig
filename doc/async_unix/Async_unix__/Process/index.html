<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Process (async_unix.Async_unix__.Process)</title><link rel="stylesheet" href="../../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../../index.html">async_unix</a> &#x00BB; <a href="../index.html">Async_unix__</a> &#x00BB; Process</nav><h1>Module <code>Async_unix__.Process</code></h1></header><aside><p><code>Async.Process</code> is for creating child processes of the current process, and communicating with children via their stdin, stdout, and stderr. <code>Async.Process</code> is the Async analog of <code>Core.Unix.create_process</code> and related functions.</p></aside><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> t</code></dt></dl><div><div class="spec include"><div class="doc"><details open="open"><summary><span class="def"><code><span class="keyword">include</span> <span class="keyword">sig</span> ... <span class="keyword">end</span></code></span></summary><dl><dt class="spec value" id="val-sexp_of_t"><a href="#val-sexp_of_t" class="anchor"></a><code><span class="keyword">val</span> sexp_of_t : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../../../sexplib0/Sexplib0/Sexp/index.html#type-t">Ppx_sexp_conv_lib.Sexp.t</a></code></dt></dl></details></div></div></div><dl><dt class="spec value" id="val-pid"><a href="#val-pid" class="anchor"></a><code><span class="keyword">val</span> pid : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../../../core_kernel/Core_kernel/Pid/index.html#type-t">Core.Pid.t</a></code></dt><dd><p>accessors</p></dd></dl><dl><dt class="spec value" id="val-stdin"><a href="#val-stdin" class="anchor"></a><code><span class="keyword">val</span> stdin : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../../Async_unix/Writer/index.html#type-t">Async_unix.Writer.t</a></code></dt><dt class="spec value" id="val-stdout"><a href="#val-stdout" class="anchor"></a><code><span class="keyword">val</span> stdout : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../../Async_unix/Reader/index.html#type-t">Async_unix.Reader.t</a></code></dt><dt class="spec value" id="val-stderr"><a href="#val-stderr" class="anchor"></a><code><span class="keyword">val</span> stderr : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../../Async_unix/Reader/index.html#type-t">Async_unix.Reader.t</a></code></dt></dl><dl><dt class="spec type" id="type-env"><a href="#type-env" class="anchor"></a><code><span class="keyword">type</span> env</code><code> = <a href="../../../core/Core__/Core_unix/index.html#type-env">Core.Unix.env</a></code></dt></dl><div><div class="spec include"><div class="doc"><details open="open"><summary><span class="def"><code><span class="keyword">include</span> <span class="keyword">sig</span> ... <span class="keyword">end</span></code></span></summary><dl><dt class="spec value" id="val-env_of_sexp"><a href="#val-env_of_sexp" class="anchor"></a><code><span class="keyword">val</span> env_of_sexp : <a href="../../../sexplib0/Sexplib0/Sexp/index.html#type-t">Ppx_sexp_conv_lib.Sexp.t</a> <span>&#45;&gt;</span> <a href="index.html#type-env">env</a></code></dt><dt class="spec value" id="val-sexp_of_env"><a href="#val-sexp_of_env" class="anchor"></a><code><span class="keyword">val</span> sexp_of_env : <a href="index.html#type-env">env</a> <span>&#45;&gt;</span> <a href="../../../sexplib0/Sexplib0/Sexp/index.html#type-t">Ppx_sexp_conv_lib.Sexp.t</a></code></dt></dl></details></div></div></div><dl><dt class="spec type" id="type-create"><a href="#type-create" class="anchor"></a><code><span class="keyword">type</span> 'a create</code><code> = ?&#8288;buf_len:int <span>&#45;&gt;</span> ?&#8288;env:<a href="index.html#type-env">env</a> <span>&#45;&gt;</span> ?&#8288;stdin:string <span>&#45;&gt;</span> ?&#8288;working_dir:string <span>&#45;&gt;</span> prog:string <span>&#45;&gt;</span> args:string list <span>&#45;&gt;</span> unit <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_unix__.Import.Deferred.t</a></code></dt><dd><p><code>create ~prog ~args ()</code> uses <code>fork</code> and <code>exec</code> to create a child process that runs the executable <code>prog</code> with <code>args</code> as arguments. It creates pipes to communicate with the child process's <code>stdin</code>, <code>stdout</code>, and <code>stderr</code>.</p><p>Unlike <code>exec</code>, <code>args</code> should not include <code>prog</code> as the first argument.</p><p>If <code>buf_len</code> is supplied, it determines the size of the reader and writer buffers used to communicate with the child process's <code>stdin</code>, <code>stdout</code>, and <code>stderr</code>.</p><p>If <code>stdin</code> is supplied, then the writer to the child's stdin will have <code>~raise_when_consumer_leaves:false</code> and <code>~buffer_age_limit:`Unlimited</code>, which makes it more robust.</p><p><code>env</code> specifies the environment of the child process.</p><p>If <code>working_dir</code> is supplied, then the child process will <code>chdir()</code> there before calling <code>exec()</code>.</p><p><code>create</code> returns <code>Error</code> if it is unable to create the child process. This can happen in any number of situations (unable to fork, unable to create the pipes, unable to cd to <code>working_dir</code>, etc.). <code>create</code> does not return <code>error</code> if <code>exec</code> fails; instead, it returns <code>OK t</code>, where <code>wait t</code> returns an <code>Error</code>.</p></dd></dl><dl><dt class="spec value" id="val-create"><a href="#val-create" class="anchor"></a><code><span class="keyword">val</span> create : <a href="index.html#type-t">t</a> <a href="../../../core_kernel/Core_kernel/Or_error/index.html#type-t">Core.Or_error.t</a> <a href="index.html#type-create">create</a></code></dt><dt class="spec value" id="val-create_exn"><a href="#val-create_exn" class="anchor"></a><code><span class="keyword">val</span> create_exn : <a href="index.html#type-t">t</a> <a href="index.html#type-create">create</a></code></dt><dt class="spec value" id="val-wait"><a href="#val-wait" class="anchor"></a><code><span class="keyword">val</span> wait : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../../../core/Core__Core_unix/Exit_or_signal/index.html#type-t">Core.Unix.Exit_or_signal.t</a> <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_unix__.Import.Deferred.t</a></code></dt><dd><p><code>wait t = Unix.waitpid (pid t)</code></p></dd></dl><div class="spec module" id="module-Output"><a href="#module-Output" class="anchor"></a><code><span class="keyword">module</span> <a href="Output/index.html">Output</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><dl><dt class="spec value" id="val-collect_output_and_wait"><a href="#val-collect_output_and_wait" class="anchor"></a><code><span class="keyword">val</span> collect_output_and_wait : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="Output/index.html#type-t">Output.t</a> <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_unix__.Import.Deferred.t</a></code></dt><dd><p><code>collect_output_and_wait t</code> closes <code>stdin t</code> and then begins collecting the output produced on <code>t</code>'s <code>stdout</code> and <code>stderr</code>, continuing to collect output until <code>t</code> terminates and the pipes for <code>stdout</code> and <code>stderr</code> are closed. Usually when <code>t</code> terminates, the pipes are closed; however, <code>t</code> could fork other processes which survive after <code>t</code> terminates and in turn keep the pipes open -- <code>wait</code> will not become determined until both pipes are closed in all descendant processes.</p></dd></dl><dl><dt class="spec type" id="type-run"><a href="#type-run" class="anchor"></a><code><span class="keyword">type</span> 'a run</code><code> = ?&#8288;accept_nonzero_exit:int list <span>&#45;&gt;</span> ?&#8288;env:<a href="index.html#type-env">env</a> <span>&#45;&gt;</span> ?&#8288;stdin:string <span>&#45;&gt;</span> ?&#8288;working_dir:string <span>&#45;&gt;</span> prog:string <span>&#45;&gt;</span> args:string list <span>&#45;&gt;</span> unit <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_unix__.Import.Deferred.t</a></code></dt><dd><p><code>run</code> <code>create</code>s a process, feeds it <code>stdin</code> if provided, and <code>wait</code>s for it to complete. If the process exits with an acceptable status, then <code>run</code> returns its stdout. If the process exits unacceptably, then <code>run</code> returns an error indicating what went wrong that includes stdout and stderr.</p><p>Acceptable statuses are zero, and any nonzero values specified in <code>accept_nonzero_exit</code>.</p><p>Some care is taken so that an error displays nicely as a sexp---in particular, if the child's output can already be parsed as a sexp, then it will display as a sexp (rather than a sexp embedded in a string). Also, if the output isn't a sexp, it will be split on newlines into a list of strings, so that it displays on multiple lines rather than a single giant line with embedded &quot;\n&quot;'s.</p><p><code>run_lines</code> is like <code>run</code> but returns the lines of stdout as a string list, using <code>String.split_lines</code>.</p><p><code>run_expect_no_output</code> is like <code>run</code> but expects the command to produce no output, and returns an error if the command does produce output.</p></dd></dl><dl><dt class="spec value" id="val-run"><a href="#val-run" class="anchor"></a><code><span class="keyword">val</span> run : string <a href="../../../core_kernel/Core_kernel/Or_error/index.html#type-t">Core.Or_error.t</a> <a href="index.html#type-run">run</a></code></dt><dt class="spec value" id="val-run_exn"><a href="#val-run_exn" class="anchor"></a><code><span class="keyword">val</span> run_exn : string <a href="index.html#type-run">run</a></code></dt><dt class="spec value" id="val-run_lines"><a href="#val-run_lines" class="anchor"></a><code><span class="keyword">val</span> run_lines : string list <a href="../../../core_kernel/Core_kernel/Or_error/index.html#type-t">Core.Or_error.t</a> <a href="index.html#type-run">run</a></code></dt><dt class="spec value" id="val-run_lines_exn"><a href="#val-run_lines_exn" class="anchor"></a><code><span class="keyword">val</span> run_lines_exn : string list <a href="index.html#type-run">run</a></code></dt><dt class="spec value" id="val-run_expect_no_output"><a href="#val-run_expect_no_output" class="anchor"></a><code><span class="keyword">val</span> run_expect_no_output : unit <a href="../../../core_kernel/Core_kernel/Or_error/index.html#type-t">Core.Or_error.t</a> <a href="index.html#type-run">run</a></code></dt><dt class="spec value" id="val-run_expect_no_output_exn"><a href="#val-run_expect_no_output_exn" class="anchor"></a><code><span class="keyword">val</span> run_expect_no_output_exn : unit <a href="index.html#type-run">run</a></code></dt></dl><dl><dt class="spec type" id="type-collect"><a href="#type-collect" class="anchor"></a><code><span class="keyword">type</span> 'a collect</code><code> = ?&#8288;accept_nonzero_exit:int list <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_unix__.Import.Deferred.t</a></code></dt><dd><p><code>collect_stdout_and_wait</code> and <code>collect_stdout_lines_and_wait</code> are like <code>run</code> and <code>run_lines</code> but work from an existing process instead of creating a new one.</p></dd></dl><dl><dt class="spec value" id="val-collect_stdout_and_wait"><a href="#val-collect_stdout_and_wait" class="anchor"></a><code><span class="keyword">val</span> collect_stdout_and_wait : string <a href="../../../core_kernel/Core_kernel/Or_error/index.html#type-t">Core.Or_error.t</a> <a href="index.html#type-collect">collect</a></code></dt><dt class="spec value" id="val-collect_stdout_and_wait_exn"><a href="#val-collect_stdout_and_wait_exn" class="anchor"></a><code><span class="keyword">val</span> collect_stdout_and_wait_exn : string <a href="index.html#type-collect">collect</a></code></dt><dt class="spec value" id="val-collect_stdout_lines_and_wait"><a href="#val-collect_stdout_lines_and_wait" class="anchor"></a><code><span class="keyword">val</span> collect_stdout_lines_and_wait : string list <a href="../../../core_kernel/Core_kernel/Or_error/index.html#type-t">Core.Or_error.t</a> <a href="index.html#type-collect">collect</a></code></dt><dt class="spec value" id="val-collect_stdout_lines_and_wait_exn"><a href="#val-collect_stdout_lines_and_wait_exn" class="anchor"></a><code><span class="keyword">val</span> collect_stdout_lines_and_wait_exn : string list <a href="index.html#type-collect">collect</a></code></dt></dl></div></body></html>