<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Atd_ast (atd.Atd_ast)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../index.html">atd</a> &#x00BB; Atd_ast</nav><h1>Module <code>Atd_ast</code></h1><p>Abstract syntax tree (AST) representing ATD data</p></header><dl><dt class="spec type" id="type-loc"><a href="#type-loc" class="anchor"></a><code><span class="keyword">type </span>loc</code><code><span class="keyword"> = </span>Lexing.position<span class="keyword"> * </span>Lexing.position</code></dt><dd><p>A location in the source code.</p></dd></dl><dl><dt class="spec exception" id="exception-Atd_error"><a href="#exception-Atd_error" class="anchor"></a><code><span class="keyword">exception </span></code><code><span class="exception">Atd_error</span><span class="keyword"> of </span>string</code></dt><dd><p>Exception raised by functions of the <code>atd</code> library and indicating errors.</p></dd></dl><dl><dt class="spec type" id="type-annot"><a href="#type-annot" class="anchor"></a><code><span class="keyword">type </span>annot</code><code><span class="keyword"> = </span><a href="index.html#type-annot_section">annot_section</a> list</code></dt><dd><p>An annotation, consisting of a sequence of sections. <code>Atd_annot</code> provides utilities for handling annotations.</p></dd></dl><dl><dt class="spec type" id="type-annot_section"><a href="#type-annot_section" class="anchor"></a><code><span class="keyword">and </span>annot_section</code><code><span class="keyword"> = </span>string<span class="keyword"> * </span>(<a href="index.html#type-loc">loc</a><span class="keyword"> * </span><a href="index.html#type-annot_field">annot_field</a> list)</code></dt><dd><p>represents a single annotation within edgy brackets. <code>&lt;&quot;foo&quot; bar baz=&quot;123&quot;&gt;</code> in ATD syntax translates to:</p><pre>(&quot;foo&quot;, (loc1, [ (&quot;bar&quot;, (loc2, None));
                 (&quot;baz&quot;, (loc3, Some &quot;123&quot;)) ] ))</pre></dd></dl><dl><dt class="spec type" id="type-annot_field"><a href="#type-annot_field" class="anchor"></a><code><span class="keyword">and </span>annot_field</code><code><span class="keyword"> = </span>string<span class="keyword"> * </span>(<a href="index.html#type-loc">loc</a><span class="keyword"> * </span>string option)</code></dt><dd><p>An annotation field, i.e. a key with an optional value within an annotation.</p></dd></dl><dl><dt class="spec type" id="type-full_module"><a href="#type-full_module" class="anchor"></a><code><span class="keyword">type </span>full_module</code><code><span class="keyword"> = </span><a href="index.html#type-module_head">module_head</a><span class="keyword"> * </span><a href="index.html#type-module_body">module_body</a></code></dt><dd><p>Contents of an ATD file.</p></dd></dl><dl><dt class="spec type" id="type-module_head"><a href="#type-module_head" class="anchor"></a><code><span class="keyword">and </span>module_head</code><code><span class="keyword"> = </span><a href="index.html#type-loc">loc</a><span class="keyword"> * </span><a href="index.html#type-annot">annot</a></code></dt><dd><p>The head of an ATD file is just a list of annotations.</p></dd></dl><dl><dt class="spec type" id="type-module_body"><a href="#type-module_body" class="anchor"></a><code><span class="keyword">and </span>module_body</code><code><span class="keyword"> = </span><a href="index.html#type-module_item">module_item</a> list</code></dt><dd><p>The body of an ATD file is a list of type definitions. Type definitions are implicitely mutually recursive. They can be sorted based on dependencies using <span class="xref-unresolved" title="unresolved reference to &quot;Atd_util.tsort&quot;"><code>Atd_util</code>.tsort</span>.</p></dd></dl><dl><dt class="spec type" id="type-module_item"><a href="#type-module_item" class="anchor"></a><code><span class="keyword">and </span>module_item</code><span class="keyword"> = </span><code>[ </code><table class="variant"><tr id="type-module_item.Type" class="anchored"><td class="def constructor"><a href="#type-module_item.Type" class="anchor"></a><code><span class="keyword">| </span></code><code>`Type<span class="keyword"> of </span><a href="index.html#type-type_def">type_def</a></code></td></tr></table><code> ]</code></dt><dd><p>There is currently only one kind of module items, that is single type definitions.</p></dd></dl><dl><dt class="spec type" id="type-type_def"><a href="#type-type_def" class="anchor"></a><code><span class="keyword">and </span>type_def</code><code><span class="keyword"> = </span><a href="index.html#type-loc">loc</a><span class="keyword"> * </span>(string<span class="keyword"> * </span><a href="index.html#type-type_param">type_param</a><span class="keyword"> * </span><a href="index.html#type-annot">annot</a>)<span class="keyword"> * </span><a href="index.html#type-type_expr">type_expr</a></code></dt><dd><p>A type definition.</p></dd></dl><dl><dt class="spec type" id="type-type_param"><a href="#type-type_param" class="anchor"></a><code><span class="keyword">and </span>type_param</code><code><span class="keyword"> = </span>string list</code></dt><dd><p>List of type variables without the tick.</p></dd></dl><dl><dt class="spec type" id="type-type_expr"><a href="#type-type_expr" class="anchor"></a><code><span class="keyword">and </span>type_expr</code><span class="keyword"> = </span><code>[ </code><table class="variant"><tr id="type-type_expr.Sum" class="anchored"><td class="def constructor"><a href="#type-type_expr.Sum" class="anchor"></a><code><span class="keyword">| </span></code><code>`Sum<span class="keyword"> of </span><a href="index.html#type-loc">loc</a><span class="keyword"> * </span><a href="index.html#type-variant">variant</a> list<span class="keyword"> * </span><a href="index.html#type-annot">annot</a></code></td></tr><tr id="type-type_expr.Record" class="anchored"><td class="def constructor"><a href="#type-type_expr.Record" class="anchor"></a><code><span class="keyword">| </span></code><code>`Record<span class="keyword"> of </span><a href="index.html#type-loc">loc</a><span class="keyword"> * </span><a href="index.html#type-field">field</a> list<span class="keyword"> * </span><a href="index.html#type-annot">annot</a></code></td></tr><tr id="type-type_expr.Tuple" class="anchored"><td class="def constructor"><a href="#type-type_expr.Tuple" class="anchor"></a><code><span class="keyword">| </span></code><code>`Tuple<span class="keyword"> of </span><a href="index.html#type-loc">loc</a><span class="keyword"> * </span><a href="index.html#type-cell">cell</a> list<span class="keyword"> * </span><a href="index.html#type-annot">annot</a></code></td></tr><tr id="type-type_expr.List" class="anchored"><td class="def constructor"><a href="#type-type_expr.List" class="anchor"></a><code><span class="keyword">| </span></code><code>`List<span class="keyword"> of </span><a href="index.html#type-loc">loc</a><span class="keyword"> * </span><a href="index.html#type-type_expr">type_expr</a><span class="keyword"> * </span><a href="index.html#type-annot">annot</a></code></td></tr><tr id="type-type_expr.Option" class="anchored"><td class="def constructor"><a href="#type-type_expr.Option" class="anchor"></a><code><span class="keyword">| </span></code><code>`Option<span class="keyword"> of </span><a href="index.html#type-loc">loc</a><span class="keyword"> * </span><a href="index.html#type-type_expr">type_expr</a><span class="keyword"> * </span><a href="index.html#type-annot">annot</a></code></td></tr><tr id="type-type_expr.Nullable" class="anchored"><td class="def constructor"><a href="#type-type_expr.Nullable" class="anchor"></a><code><span class="keyword">| </span></code><code>`Nullable<span class="keyword"> of </span><a href="index.html#type-loc">loc</a><span class="keyword"> * </span><a href="index.html#type-type_expr">type_expr</a><span class="keyword"> * </span><a href="index.html#type-annot">annot</a></code></td></tr><tr id="type-type_expr.Shared" class="anchored"><td class="def constructor"><a href="#type-type_expr.Shared" class="anchor"></a><code><span class="keyword">| </span></code><code>`Shared<span class="keyword"> of </span><a href="index.html#type-loc">loc</a><span class="keyword"> * </span><a href="index.html#type-type_expr">type_expr</a><span class="keyword"> * </span><a href="index.html#type-annot">annot</a></code></td></tr><tr id="type-type_expr.Wrap" class="anchored"><td class="def constructor"><a href="#type-type_expr.Wrap" class="anchor"></a><code><span class="keyword">| </span></code><code>`Wrap<span class="keyword"> of </span><a href="index.html#type-loc">loc</a><span class="keyword"> * </span><a href="index.html#type-type_expr">type_expr</a><span class="keyword"> * </span><a href="index.html#type-annot">annot</a></code></td></tr><tr id="type-type_expr.Name" class="anchored"><td class="def constructor"><a href="#type-type_expr.Name" class="anchor"></a><code><span class="keyword">| </span></code><code>`Name<span class="keyword"> of </span><a href="index.html#type-loc">loc</a><span class="keyword"> * </span><a href="index.html#type-type_inst">type_inst</a><span class="keyword"> * </span><a href="index.html#type-annot">annot</a></code></td></tr><tr id="type-type_expr.Tvar" class="anchored"><td class="def constructor"><a href="#type-type_expr.Tvar" class="anchor"></a><code><span class="keyword">| </span></code><code>`Tvar<span class="keyword"> of </span><a href="index.html#type-loc">loc</a><span class="keyword"> * </span>string</code></td></tr></table><code> ]</code></dt><dd><p>A type expression is one of the following:</p><ul><li><code>`Sum</code>: a sum type (within square brackets)</li><li><code>`Record</code>: a record type (within curly braces)</li><li><code>`Tuple</code>: a tuple (within parentheses)</li><li><code>`List</code>: a list type written <code>list</code> with its parameter e.g. <code>int list</code></li><li><code>`Option</code>: an option type written <code>option</code> with its parameter e.g. <code>string option</code></li><li><code>`Nullable</code>: adds a null value to a type. <code>`Option</code> should be preferred over <code>`Nullable</code> since it makes it possible to distinguish <code>Some None</code> from <code>None</code>.</li><li><code>`Shared</code>: values for which sharing must be preserved. Such type expressions may not be parametrized. Values may only be shared if the source location of the type expression is the same.</li><li><code>`Wrap</code>: optional wrapping of a type. For example, a timestamp represented as a string can be wrapped within a proper time type. In that case, the wrapper would parse the timestamp and convert it into the internal representation of its choice. Unwrapping would consist in converting it back to a string.</li><li><code>`Name</code>: a type name other than <code>list</code> or <code>option</code>, including the predefined types <code>unit</code>, <code>bool</code>, <code>int</code>, <code>float</code>, <code>string</code> and <code>abstract</code>.</li><li><code>`Tvar</code>: a type variable identifier without the tick</li></ul></dd></dl><dl><dt class="spec type" id="type-type_inst"><a href="#type-type_inst" class="anchor"></a><code><span class="keyword">and </span>type_inst</code><code><span class="keyword"> = </span><a href="index.html#type-loc">loc</a><span class="keyword"> * </span>string<span class="keyword"> * </span><a href="index.html#type-type_expr">type_expr</a> list</code></dt><dd><p>A type name and its arguments</p></dd></dl><dl><dt class="spec type" id="type-variant"><a href="#type-variant" class="anchor"></a><code><span class="keyword">and </span>variant</code><span class="keyword"> = </span><code>[ </code><table class="variant"><tr id="type-variant.Variant" class="anchored"><td class="def constructor"><a href="#type-variant.Variant" class="anchor"></a><code><span class="keyword">| </span></code><code>`Variant<span class="keyword"> of </span><a href="index.html#type-loc">loc</a><span class="keyword"> * </span>(string<span class="keyword"> * </span><a href="index.html#type-annot">annot</a>)<span class="keyword"> * </span><a href="index.html#type-type_expr">type_expr</a> option</code></td></tr><tr id="type-variant.Inherit" class="anchored"><td class="def constructor"><a href="#type-variant.Inherit" class="anchor"></a><code><span class="keyword">| </span></code><code>`Inherit<span class="keyword"> of </span><a href="index.html#type-loc">loc</a><span class="keyword"> * </span><a href="index.html#type-type_expr">type_expr</a></code></td></tr></table><code> ]</code></dt><dd><p>A single variant or an <code>inherit</code> statement. <code>`Inherit</code> statements can be expanded into variants using <code>Atd_inherit</code> or at loading time using the <code>inherit_variant</code> option offered by the <code>Atd_util</code> functions.</p></dd></dl><dl><dt class="spec type" id="type-cell"><a href="#type-cell" class="anchor"></a><code><span class="keyword">and </span>cell</code><code><span class="keyword"> = </span><a href="index.html#type-loc">loc</a><span class="keyword"> * </span><a href="index.html#type-type_expr">type_expr</a><span class="keyword"> * </span><a href="index.html#type-annot">annot</a></code></dt><dd><p>Tuple cell. Note that annotations placed before the type expression are supported and represented here, such as the third cell in <code>(float * float * &lt;ocaml default=&quot;0.0&quot;&gt; float)</code>.</p></dd></dl><dl><dt class="spec type" id="type-field_kind"><a href="#type-field_kind" class="anchor"></a><code><span class="keyword">and </span>field_kind</code><span class="keyword"> = </span><code>[ </code><table class="variant"><tr id="type-field_kind.Required" class="anchored"><td class="def constructor"><a href="#type-field_kind.Required" class="anchor"></a><code><span class="keyword">| </span></code><code>`Required</code></td></tr><tr id="type-field_kind.Optional" class="anchored"><td class="def constructor"><a href="#type-field_kind.Optional" class="anchor"></a><code><span class="keyword">| </span></code><code>`Optional</code></td></tr><tr id="type-field_kind.With_default" class="anchored"><td class="def constructor"><a href="#type-field_kind.With_default" class="anchor"></a><code><span class="keyword">| </span></code><code>`With_default</code></td></tr></table><code> ]</code></dt><dd><p>Different kinds of record fields based on the</p><ul><li><code>`Required</code>: required field, e.g. <code>id : string</code></li><li><code>`Optional</code>: optional field without a default value, e.g. <code>?name : string option</code>. The ATD type of the field value must be an option type.</li><li><code>`With_default</code>: optional field with a default value, e.g. <code>~websites : string list</code>. The default value may be implicit or specified explicitely using annotations. Each target language that cannot omit fields may have to specify the default in its own syntax.</li></ul><p>Sample ATD file:</p><pre>type level = [ Beginner | Advanced | Expert ]

type user = \{
  id : string;

  ?name : string option;
    (* Field may be omitted when no value is set, if permitted
       by the target language. *)

  ~websites : string list;
    (* Implicit default: empty list.
       Field may be omitted if the field value is
       equal to the default value and the
       target language permits it. *)

  ~level &lt;ocaml default=&quot;`Beginner&quot;&gt; : level;
    (* Explicit default for `ocaml'.
       For instance there is no `json' annotation because
       the default for undefined `JSON' fields would be to omit them. *)
}</pre></dd></dl><dl><dt class="spec type" id="type-field"><a href="#type-field" class="anchor"></a><code><span class="keyword">and </span>field</code><span class="keyword"> = </span><code>[ </code><table class="variant"><tr id="type-field.Field" class="anchored"><td class="def constructor"><a href="#type-field.Field" class="anchor"></a><code><span class="keyword">| </span></code><code>`Field<span class="keyword"> of </span><a href="index.html#type-loc">loc</a><span class="keyword"> * </span>(string<span class="keyword"> * </span><a href="index.html#type-field_kind">field_kind</a><span class="keyword"> * </span><a href="index.html#type-annot">annot</a>)<span class="keyword"> * </span><a href="index.html#type-type_expr">type_expr</a></code></td></tr><tr id="type-field.Inherit" class="anchored"><td class="def constructor"><a href="#type-field.Inherit" class="anchor"></a><code><span class="keyword">| </span></code><code>`Inherit<span class="keyword"> of </span><a href="index.html#type-loc">loc</a><span class="keyword"> * </span><a href="index.html#type-type_expr">type_expr</a></code></td></tr></table><code> ]</code></dt><dd><p>A single record field or an <code>inherit</code> statement. <code>`Inherit</code> statements can be expanded into fields using <code>Atd_inherit</code> or at loading time using the <code>inherit_fields</code> option offered by the <code>Atd_util</code> functions.</p></dd></dl><dl><dt class="spec value" id="val-loc_of_type_expr"><a href="#val-loc_of_type_expr" class="anchor"></a><code><span class="keyword">val </span>loc_of_type_expr : <a href="index.html#type-type_expr">type_expr</a> <span>&#45;&gt;</span> <a href="index.html#type-loc">loc</a></code></dt><dd><p>Extract the source location of any type expression.</p></dd></dl><dl><dt class="spec value" id="val-set_type_expr_loc"><a href="#val-set_type_expr_loc" class="anchor"></a><code><span class="keyword">val </span>set_type_expr_loc : <a href="index.html#type-loc">loc</a> <span>&#45;&gt;</span> <a href="index.html#type-type_expr">type_expr</a> <span>&#45;&gt;</span> <a href="index.html#type-type_expr">type_expr</a></code></dt><dd><p>Replace the location of the given expression. This is a shallow substitution. Sub-expressions are not affected.</p></dd></dl><dl><dt class="spec value" id="val-string_of_loc"><a href="#val-string_of_loc" class="anchor"></a><code><span class="keyword">val </span>string_of_loc : <a href="index.html#type-loc">loc</a> <span>&#45;&gt;</span> string</code></dt><dd><p>Convert a location into a human-readable string such as <code>File &quot;foo.atd&quot;, line 123, characters 40-45</code>.</p></dd></dl><dl><dt class="spec value" id="val-error"><a href="#val-error" class="anchor"></a><code><span class="keyword">val </span>error : string <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p><code>error s</code> is a shorthand for <code>raise (Atd_error s)</code>.</p></dd></dl><dl><dt class="spec value" id="val-error_at"><a href="#val-error_at" class="anchor"></a><code><span class="keyword">val </span>error_at : <a href="index.html#type-loc">loc</a> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p><code>error_at loc s</code> raises <code>Atd_error s'</code> where <code>s'</code> is the location followed by <code>s</code>.</p></dd></dl><dl><dt class="spec value" id="val-dummy_loc"><a href="#val-dummy_loc" class="anchor"></a><code><span class="keyword">val </span>dummy_loc : <a href="index.html#type-loc">loc</a></code></dt><dd><p>Dummy value for predefined constructs that are not associated with a useful source location. Should not show up in error messages.</p></dd></dl><dl><dt class="spec value" id="val-annot_of_type_expr"><a href="#val-annot_of_type_expr" class="anchor"></a><code><span class="keyword">val </span>annot_of_type_expr : <a href="index.html#type-type_expr">type_expr</a> <span>&#45;&gt;</span> <a href="index.html#type-annot">annot</a></code></dt><dd><p>Return the annotations associated with a type expression. Note that there can be annotations in a variety of places, not just after type expressions.</p></dd></dl><dl><dt class="spec value" id="val-map_annot"><a href="#val-map_annot" class="anchor"></a><code><span class="keyword">val </span>map_annot : (<a href="index.html#type-annot">annot</a> <span>&#45;&gt;</span> <a href="index.html#type-annot">annot</a>) <span>&#45;&gt;</span> <a href="index.html#type-type_expr">type_expr</a> <span>&#45;&gt;</span> <a href="index.html#type-type_expr">type_expr</a></code></dt><dd><p>Replacement of the annotations associated with a type expression. This is a shallow transformation. Sub-expressions are not affected.</p></dd></dl><dl><dt class="spec value" id="val-map_all_annot"><a href="#val-map_all_annot" class="anchor"></a><code><span class="keyword">val </span>map_all_annot : (<a href="index.html#type-annot">annot</a> <span>&#45;&gt;</span> <a href="index.html#type-annot">annot</a>) <span>&#45;&gt;</span> <a href="index.html#type-full_module">full_module</a> <span>&#45;&gt;</span> <a href="index.html#type-full_module">full_module</a></code></dt><dd><p>Replacement of all annotations occurring in an ATD module.</p></dd></dl><dl><dt class="spec value" id="val-fold"><a href="#val-fold" class="anchor"></a><code><span class="keyword">val </span>fold : (<a href="index.html#type-type_expr">type_expr</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span>) <span>&#45;&gt;</span> <a href="index.html#type-type_expr">type_expr</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p>Iteration and accumulation over each <code>type_expr</code> node within a given <code>type_expr</code>.</p></dd></dl><dl><dt class="spec value" id="val-extract_type_names"><a href="#val-extract_type_names" class="anchor"></a><code><span class="keyword">val </span>extract_type_names : ?&#8288;ignorable:string list <span>&#45;&gt;</span> <a href="index.html#type-type_expr">type_expr</a> <span>&#45;&gt;</span> string list</code></dt><dd><p>Extract all the type names occurring in a type expression under <code>`Name</code>, without duplicates.</p><dl><dt>parameter ignorable</dt><dd><p>specifies a list of type names to exclude from the result</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-is_parametrized"><a href="#val-is_parametrized" class="anchor"></a><code><span class="keyword">val </span>is_parametrized : <a href="index.html#type-type_expr">type_expr</a> <span>&#45;&gt;</span> bool</code></dt><dd><p>Test whether a type expression contains type variables (<code>`Tvar</code>).</p></dd></dl></div></body></html>