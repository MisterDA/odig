<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Atd_expand (atd.Atd_expand)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../index.html">atd</a> &#x00BB; Atd_expand</nav><h1>Module <code>Atd_expand</code></h1><p>Monomorphization of type definitions</p></header><dl><dt class="spec type" id="type-original_types"><a href="#type-original_types" class="anchor"></a><code><span class="keyword">type </span>original_types</code><code><span class="keyword"> = </span>(string, string<span class="keyword"> * </span>int) Hashtbl.t</code></dt><dd><p>To support the generation of annotations for types that are created during the monomorphization process, a mapping must be kept connecting the monomorphic type name to the original polymorphic one, including its original number of parameters.</p><p>This table is only used in producing those annotations to support the Atdgen command line option -o-name-overlap. It can probably be ignored for most uses of expand_module_body.</p></dd></dl><dl><dt class="spec value" id="val-expand_module_body"><a href="#val-expand_module_body" class="anchor"></a><code><span class="keyword">val </span>expand_module_body : ?&#8288;prefix:string <span>&#45;&gt;</span> ?&#8288;keep_poly:bool <span>&#45;&gt;</span> ?&#8288;debug:bool <span>&#45;&gt;</span> Atd_ast.module_body <span>&#45;&gt;</span> Atd_ast.module_body<span class="keyword"> * </span><a href="index.html#type-original_types">original_types</a></code></dt><dd><p>Monomorphization of type expressions.</p><dl><dt>parameter prefix</dt><dd><p>prefix to use for new type names. Default is <code>&quot;_&quot;</code>.</p></dd></dl><dl><dt>parameter keep_poly</dt><dd><p>return definitions for the parametrized types. Default is <code>false</code>.</p></dd></dl><dl><dt>parameter debug</dt><dd><p>keep meaningful but non ATD-compliant names for new type names. Default is <code>false</code>.</p><p>The goal is to inline each parametrized type definition as much as possible, allowing code generators to create more efficient code directly:</p><pre>  type ('a, 'b) t = [ Foo of 'a | Bar of 'b ]
  type int_t = (int, int) t</pre><p>becomes:</p><pre>  type int_t = _1
  type _1 = [ Foo of int | Bar of int ]</pre><p>A secondary goal is to factor out type subexpressions in order for the code generators to produce less code:</p><pre>  type x = \{ x : int list }
  type y = \{ y : int list option }</pre><p>becomes:</p><pre>  type x = \{ x : _1 }
  type y = \{ y : _2 }
  type _1 = int list   (* `int list' now occurs only once *)
  type _2 = _1 option</pre><p>By default, only parameterless type definitions are returned. The <code>keep_poly</code> option allows to return parametrized type definitions as well.</p><p>Input:</p><pre>  type 'a abs = abstract
  type int_abs = int abs
  type 'a tree = [ Leaf of 'a | Node of ('a tree * 'a tree) ]
  type t = int tree
  type x = [ Foo | Bar ] tree</pre><p>Output (pseudo-syntax where quoted strings indicate unique type identifiers):</p><pre>  type &quot;int abs&quot; = int abs
  type int_abs = &quot;int abs&quot;

  type 'a tree = [ Leaf of 'a | Node of ('a tree * 'a tree) ]
    (* only if keep_poly = true *)

  type &quot;int tree&quot; = [ Leaf of int | Node of (&quot;int tree&quot; * &quot;int tree&quot;) ]
  type t = &quot;int tree&quot;
  type &quot;[ Foo | Bar ] tree&quot; =
    [ Leaf of [ Foo | Bar ]
    | Node of (&quot;[ Foo | Bar ] tree&quot; * &quot;[ Foo | Bar ] tree&quot;) ]
  type x = &quot;[ Foo | Bar ] tree&quot;</pre></dd></dl></dd></dl></div></body></html>