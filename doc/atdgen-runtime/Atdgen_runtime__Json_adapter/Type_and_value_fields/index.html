<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Type_and_value_fields (atdgen-runtime.Atdgen_runtime__Json_adapter.Type_and_value_fields)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../../index.html">atdgen-runtime</a> &#x00BB; <a href="../index.html">Atdgen_runtime__Json_adapter</a> &#x00BB; Type_and_value_fields</nav><h1>Module <code>Atdgen_runtime__Json_adapter.Type_and_value_fields</code></h1><p>Support for the retired tag_field feature. This converts the following</p><pre><code class="ml">{
  &quot;id&quot;: &quot;abc123&quot;,
  &quot;type&quot;: &quot;User&quot;,
  &quot;payload&quot;: 17
}</code></pre><p>into</p><pre><code class="ml">{
  &quot;id&quot;: &quot;abc123&quot;,
  &quot;type&quot;: &quot;User&quot;,
  &quot;payload&quot;: [ &quot;User&quot;, 17 ]
}</code></pre><p>As illustrated, two parameters need to be specified: the name of the field that holds the tag of the variant (<code>&quot;type&quot;</code> in the example) and the name of the field that holds the value associated with that tag (<code>&quot;payload&quot;</code> in the example).</p><p>If the value is missing, we'll use the representation of an enum, i.e. a json string:</p><pre><code class="ml">{
  &quot;id&quot;: &quot;abc124&quot;,
  &quot;type&quot;: &quot;Event&quot;,
}</code></pre><p>becomes</p><pre><code class="ml">{
  &quot;id&quot;: &quot;abc124&quot;,
  &quot;type&quot;: &quot;Event&quot;,
  &quot;payload&quot;: &quot;Event&quot;
}</code></pre><p>Additionally, a catch-all case is supported if <code>known_tags</code> is specified. Given the following ATD type definitions:</p><pre><code class="ml">type t = {
  id: string;
  payload: payload;
} &lt;json adapter.ocaml=&quot;My_adapter&quot;&gt;

type payload = [
  | User of int
  | Event

  (* catch-all *)
  | Unknown of (string * json nullable)
]</code></pre><p>and the module <code>My_adapter</code> defined as follows:</p><pre><code class="ml">module My_adapter = Atdgen_runtime.Json_adapter.Type_and_value_fields.Make(
  struct
    let type_field_name = &quot;type&quot;
    let value_field_name = &quot;payload&quot;
    let known_tags = Some [&quot;User&quot;; &quot;Event&quot;]
  end
)</code></pre><p>and given the following json input:</p><pre><code class="ml">{
  &quot;id&quot;: &quot;abc124&quot;,
  &quot;type&quot;: &quot;Group&quot;,
  &quot;payload&quot;: {}
}</code></pre><p>we obtain this normalized json, compatible with the type definitions:</p><pre><code class="ml">{
  &quot;id&quot;: &quot;abc124&quot;,
  &quot;payload&quot;: [&quot;Unknown&quot;, [&quot;Group&quot;, {}]]
}</code></pre><p>If there's no payload, it is treated as if it were <code>null</code>. Given the following:</p><pre><code class="ml">{
  &quot;id&quot;: &quot;abc124&quot;,
  &quot;type&quot;: &quot;Thing&quot;
}</code></pre><p>we get this normalized json:</p><pre><code class="ml">{
  &quot;id&quot;: &quot;abc124&quot;,
  &quot;payload&quot;: [&quot;Unknown&quot;, [&quot;Thing&quot;, null]]
}</code></pre></header><div class="spec module-type" id="module-type-Param"><a href="#module-type-Param" class="anchor"></a><code><span class="keyword">module type </span><a href="module-type-Param/index.html">Param</a> = <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><dl><dt class="spec module" id="module-Make"><a href="#module-Make" class="anchor"></a><code><span class="keyword">module </span><a href="Make/index.html">Make</a> : <span class="keyword">functor</span> (<a href="Make/argument-1-Param/index.html">Param</a> : <a href="index.html#module-type-Param">Param</a>) <span>&#45;&gt;</span> <a href="../index.html#module-type-S">S</a></code></dt><dd><p>Functor needed to produce a module using the correct parameters.</p></dd></dl></div></body></html>