<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Json (atdgen-runtime.Atdgen_runtime__Util.Json)</title><link rel="stylesheet" href="../../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../../index.html">atdgen-runtime</a> &#x00BB; <a href="../index.html">Atdgen_runtime__Util</a> &#x00BB; Json</nav><h1>Module <code>Atdgen_runtime__Util.Json</code></h1></header><dl><dt class="spec type" id="type-reader"><a href="#type-reader" class="anchor"></a><code><span class="keyword">type</span> 'a reader</code><code> = <a href="../../../yojson/Yojson/Safe/index.html#type-lexer_state">Yojson.Safe.lexer_state</a> <span>&#45;&gt;</span> <a href="../../../ocaml/Stdlib/Lexing/index.html#type-lexbuf">Stdlib.Lexing.lexbuf</a> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p>Type of a <code>read_</code> function as produced by <code>atdgen -json</code>.</p><p>In versions of yojson greater than 1.0.1, type <code>Yojson.Safe.lexer_state</code> is equivalent to <code>Yojson.lexer_state</code>, <code>Yojson.Basic.lexer_state</code> and <code>Yojson.Raw.lexer_state</code>.</p></dd></dl><dl><dt class="spec type" id="type-writer"><a href="#type-writer" class="anchor"></a><code><span class="keyword">type</span> 'a writer</code><code> = <a href="../../../biniou/Bi_outbuf/index.html#type-t">Bi_outbuf.t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> unit</code></dt><dd><p>Type of a <code>write_</code> function as produced by <code>atdgen -json</code>.</p></dd></dl><dl><dt class="spec value" id="val-from_lexbuf"><a href="#val-from_lexbuf" class="anchor"></a><code><span class="keyword">val</span> from_lexbuf : ?&#8288;stream:bool <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-reader">reader</a> <span>&#45;&gt;</span> <a href="../../../yojson/Yojson/Safe/index.html#type-lexer_state">Yojson.Safe.lexer_state</a> <span>&#45;&gt;</span> <a href="../../../ocaml/Stdlib/Lexing/index.html#type-lexbuf">Stdlib.Lexing.lexbuf</a> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p>Read a JSON value from a lexbuf.</p><dl><dt>parameter stream</dt><dd><p>if <code>true</code>, the JSON parser will not try to consume whitespace until the end of file. Default is <code>false</code>, which raises a <code>Yojson.Json_error</code> exception if the valid JSON value is followed by anything other than standard JSON whitespace.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-from_string"><a href="#val-from_string" class="anchor"></a><code><span class="keyword">val</span> from_string : ?&#8288;buf:<a href="../../../biniou/Bi_outbuf/index.html#type-t">Bi_outbuf.t</a> <span>&#45;&gt;</span> ?&#8288;fname:string <span>&#45;&gt;</span> ?&#8288;lnum:int <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-reader">reader</a> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p>Convert a JSON value from a string.</p><dl><dt>parameter buf</dt><dd><p>buffer used to accumulate string data during the lexing phase.</p></dd></dl><dl><dt>parameter fname</dt><dd><p>input file name to be used in error messages. It does not have to be the name of a real file, it can be something like <code>&quot;&lt;stdin&gt;&quot;</code>.</p></dd></dl><dl><dt>parameter lnum</dt><dd><p>line number to assign to the first line of input. For example <code>lnum=10</code> means that an error on the first line of input will be reported as an error on line 10. Default: 1.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-from_channel"><a href="#val-from_channel" class="anchor"></a><code><span class="keyword">val</span> from_channel : ?&#8288;buf:<a href="../../../biniou/Bi_outbuf/index.html#type-t">Bi_outbuf.t</a> <span>&#45;&gt;</span> ?&#8288;fname:string <span>&#45;&gt;</span> ?&#8288;lnum:int <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-reader">reader</a> <span>&#45;&gt;</span> <a href="../../../ocaml/Stdlib/index.html#type-in_channel">Stdlib.in_channel</a> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p>Read a JSON value from a channel.</p><dl><dt>parameter buf</dt><dd><p>buffer used to accumulate string data during the lexing phase.</p></dd></dl><dl><dt>parameter fname</dt><dd><p>input file name to be used in error messages. It does not have to be the name of a real file, it can be something like <code>&quot;&lt;stdin&gt;&quot;</code>.</p></dd></dl><dl><dt>parameter lnum</dt><dd><p>line number to assign to the first line of input. For example <code>lnum=10</code> means that an error on the first line of input will be reported as an error on line 10. Default: 1.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-from_file"><a href="#val-from_file" class="anchor"></a><code><span class="keyword">val</span> from_file : ?&#8288;buf:<a href="../../../biniou/Bi_outbuf/index.html#type-t">Bi_outbuf.t</a> <span>&#45;&gt;</span> ?&#8288;fname:string <span>&#45;&gt;</span> ?&#8288;lnum:int <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-reader">reader</a> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p>Read a JSON value from a channel.</p><dl><dt>parameter buf</dt><dd><p>buffer used to accumulate string data during the lexing phase.</p></dd></dl><dl><dt>parameter fname</dt><dd><p>input file name to be used in error messages. It is intended to represent the source file if it is different from the input file.</p></dd></dl><dl><dt>parameter lnum</dt><dd><p>line number to assign to the first line of input. For example <code>lnum=10</code> means that an error on the first line of input will be reported as an error on line 10. Default: 1.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-stream_from_lexbuf"><a href="#val-stream_from_lexbuf" class="anchor"></a><code><span class="keyword">val</span> stream_from_lexbuf : ?&#8288;fin:(unit <span>&#45;&gt;</span> unit) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-reader">reader</a> <span>&#45;&gt;</span> <a href="../../../yojson/Yojson/Safe/index.html#type-lexer_state">Yojson.Safe.lexer_state</a> <span>&#45;&gt;</span> <a href="../../../ocaml/Stdlib/Lexing/index.html#type-lexbuf">Stdlib.Lexing.lexbuf</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="../../../ocaml/Stdlib/Stream/index.html#type-t">Stdlib.Stream.t</a></code></dt><dd><p>Read a stream of JSON values from a lexbuf.</p><dl><dt>parameter fin</dt><dd><p>finalization function executed once when the end of the stream is reached either because there is no more input or because of an exception. This is typically used to close the input channel, e.g. <code>fun () -&gt; close_in_noerr ic</code>.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-stream_from_string"><a href="#val-stream_from_string" class="anchor"></a><code><span class="keyword">val</span> stream_from_string : ?&#8288;buf:<a href="../../../biniou/Bi_outbuf/index.html#type-t">Bi_outbuf.t</a> <span>&#45;&gt;</span> ?&#8288;fin:(unit <span>&#45;&gt;</span> unit) <span>&#45;&gt;</span> ?&#8288;fname:string <span>&#45;&gt;</span> ?&#8288;lnum:int <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-reader">reader</a> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="../../../ocaml/Stdlib/Stream/index.html#type-t">Stdlib.Stream.t</a></code></dt><dd><p>Read a stream of JSON values from a channel. Values do not have to be separated by newline characters.</p><dl><dt>parameter buf</dt><dd><p>buffer used to accumulate string data during the lexing phase.</p></dd></dl><dl><dt>parameter fin</dt><dd><p>finalization function executed once when the end of the stream is reached either because there is no more input or because of an exception. This is typically used to free the underlying resources, if any.</p></dd></dl><dl><dt>parameter fname</dt><dd><p>input file name to be used in error messages. It does not have to be the name of a real file, it can be something like <code>&quot;&lt;stdin&gt;&quot;</code>.</p></dd></dl><dl><dt>parameter lnum</dt><dd><p>line number to assign to the first line of input. For example <code>lnum=10</code> means that an error on the first line of input will be reported as an error on line 10. Default: 1.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-stream_from_channel"><a href="#val-stream_from_channel" class="anchor"></a><code><span class="keyword">val</span> stream_from_channel : ?&#8288;buf:<a href="../../../biniou/Bi_outbuf/index.html#type-t">Bi_outbuf.t</a> <span>&#45;&gt;</span> ?&#8288;fin:(unit <span>&#45;&gt;</span> unit) <span>&#45;&gt;</span> ?&#8288;fname:string <span>&#45;&gt;</span> ?&#8288;lnum:int <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-reader">reader</a> <span>&#45;&gt;</span> <a href="../../../ocaml/Stdlib/index.html#type-in_channel">Stdlib.in_channel</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="../../../ocaml/Stdlib/Stream/index.html#type-t">Stdlib.Stream.t</a></code></dt><dd><p>Read a stream of JSON values from a channel. Values do not have to be separated by newline characters.</p><dl><dt>parameter buf</dt><dd><p>buffer used to accumulate string data during the lexing phase.</p></dd></dl><dl><dt>parameter fin</dt><dd><p>finalization function executed once when the end of the stream is reached either because there is no more input or because of an exception. This is typically used to close the input channel, e.g. <code>fun () -&gt; close_in_noerr ic</code>.</p></dd></dl><dl><dt>parameter fname</dt><dd><p>input file name to be used in error messages. It does not have to be the name of a real file, it can be something like <code>&quot;&lt;stdin&gt;&quot;</code>.</p></dd></dl><dl><dt>parameter lnum</dt><dd><p>line number to assign to the first line of input. For example <code>lnum=10</code> means that an error on the first line of input will be reported as an error on line 10. Default: 1.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-stream_from_file"><a href="#val-stream_from_file" class="anchor"></a><code><span class="keyword">val</span> stream_from_file : ?&#8288;buf:<a href="../../../biniou/Bi_outbuf/index.html#type-t">Bi_outbuf.t</a> <span>&#45;&gt;</span> ?&#8288;fin:(unit <span>&#45;&gt;</span> unit) <span>&#45;&gt;</span> ?&#8288;fname:string <span>&#45;&gt;</span> ?&#8288;lnum:int <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-reader">reader</a> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="../../../ocaml/Stdlib/Stream/index.html#type-t">Stdlib.Stream.t</a></code></dt><dd><p>Read a stream of JSON values from a file. Values do not have to be separated by newline characters.</p><dl><dt>parameter buf</dt><dd><p>buffer used to accumulate string data during the lexing phase.</p></dd></dl><dl><dt>parameter fin</dt><dd><p>finalization function executed once when the end of the stream is reached either because there is no more input or because of an exception. This can be used to remove the input file if it was temporary, e.g. <code>fun () -&gt; Sys.remove fname</code>.</p></dd></dl><dl><dt>parameter fname</dt><dd><p>input file name to be used in error messages. It is intended to represent the source file if it is different from the input file.</p></dd></dl><dl><dt>parameter lnum</dt><dd><p>line number to assign to the first line of input. For example <code>lnum=10</code> means that an error on the first line of input will be reported as an error on line 10. Default: 1.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-list_from_string"><a href="#val-list_from_string" class="anchor"></a><code><span class="keyword">val</span> list_from_string : ?&#8288;buf:<a href="../../../biniou/Bi_outbuf/index.html#type-t">Bi_outbuf.t</a> <span>&#45;&gt;</span> ?&#8288;fin:(unit <span>&#45;&gt;</span> unit) <span>&#45;&gt;</span> ?&#8288;fname:string <span>&#45;&gt;</span> ?&#8288;lnum:int <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-reader">reader</a> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <span class="type-var">'a</span> list</code></dt><dd><p>Read a list of JSON values from a channel. Values do not have to be separated by newline characters.</p><dl><dt>parameter buf</dt><dd><p>buffer used to accumulate string data during the lexing phase.</p></dd></dl><dl><dt>parameter fin</dt><dd><p>finalization function executed once when the end of the stream is reached either because there is no more input or because of an exception. This is typically used to free the underlying resources, if any.</p></dd></dl><dl><dt>parameter fname</dt><dd><p>input file name to be used in error messages. It does not have to be the name of a real file, it can be something like <code>&quot;&lt;stdin&gt;&quot;</code>.</p></dd></dl><dl><dt>parameter lnum</dt><dd><p>line number to assign to the first line of input. For example <code>lnum=10</code> means that an error on the first line of input will be reported as an error on line 10. Default: 1.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-list_from_channel"><a href="#val-list_from_channel" class="anchor"></a><code><span class="keyword">val</span> list_from_channel : ?&#8288;buf:<a href="../../../biniou/Bi_outbuf/index.html#type-t">Bi_outbuf.t</a> <span>&#45;&gt;</span> ?&#8288;fin:(unit <span>&#45;&gt;</span> unit) <span>&#45;&gt;</span> ?&#8288;fname:string <span>&#45;&gt;</span> ?&#8288;lnum:int <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-reader">reader</a> <span>&#45;&gt;</span> <a href="../../../ocaml/Stdlib/index.html#type-in_channel">Stdlib.in_channel</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> list</code></dt><dd><p>Read a list of JSON values from a channel. Values do not have to be separated by newline characters.</p><dl><dt>parameter buf</dt><dd><p>buffer used to accumulate string data during the lexing phase.</p></dd></dl><dl><dt>parameter fin</dt><dd><p>finalization function executed once when the end of the stream is reached either because there is no more input or because of an exception. This is typically used to close the input channel, e.g. <code>fun () -&gt; close_in_noerr ic</code>.</p></dd></dl><dl><dt>parameter fname</dt><dd><p>input file name to be used in error messages. It does not have to be the name of a real file, it can be something like <code>&quot;&lt;stdin&gt;&quot;</code>.</p></dd></dl><dl><dt>parameter lnum</dt><dd><p>line number to assign to the first line of input. For example <code>lnum=10</code> means that an error on the first line of input will be reported as an error on line 10. Default: 1.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-list_from_file"><a href="#val-list_from_file" class="anchor"></a><code><span class="keyword">val</span> list_from_file : ?&#8288;buf:<a href="../../../biniou/Bi_outbuf/index.html#type-t">Bi_outbuf.t</a> <span>&#45;&gt;</span> ?&#8288;fname:string <span>&#45;&gt;</span> ?&#8288;lnum:int <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-reader">reader</a> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <span class="type-var">'a</span> list</code></dt><dd><p>Read a list of JSON values from a file. Values do not have to be separated by newline characters.</p><dl><dt>parameter buf</dt><dd><p>buffer used to accumulate string data during the lexing phase.</p></dd></dl><dl><dt>parameter fname</dt><dd><p>input file name to be used in error messages. It is intended to represent the source file if it is different from the input file.</p></dd></dl><dl><dt>parameter lnum</dt><dd><p>line number to assign to the first line of input. For example <code>lnum=10</code> means that an error on the first line of input will be reported as an error on line 10. Default: 1.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-to_string"><a href="#val-to_string" class="anchor"></a><code><span class="keyword">val</span> to_string : ?&#8288;len:int <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-writer">writer</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> string</code></dt><dd><p>Write a JSON value to a string.</p><dl><dt>parameter len</dt><dd><p>output buffer length.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-to_channel"><a href="#val-to_channel" class="anchor"></a><code><span class="keyword">val</span> to_channel : ?&#8288;len:int <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-writer">writer</a> <span>&#45;&gt;</span> <a href="../../../ocaml/Stdlib/index.html#type-out_channel">Stdlib.out_channel</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> unit</code></dt><dd><p>Write a JSON value to a channel.</p><dl><dt>parameter len</dt><dd><p>output buffer length.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-to_file"><a href="#val-to_file" class="anchor"></a><code><span class="keyword">val</span> to_file : ?&#8288;len:int <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-writer">writer</a> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> unit</code></dt><dd><p>Write a JSON value to a file.</p><dl><dt>parameter len</dt><dd><p>output buffer length.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-stream_to_string"><a href="#val-stream_to_string" class="anchor"></a><code><span class="keyword">val</span> stream_to_string : ?&#8288;len:int <span>&#45;&gt;</span> ?&#8288;lf:string <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-writer">writer</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="../../../ocaml/Stdlib/Stream/index.html#type-t">Stdlib.Stream.t</a> <span>&#45;&gt;</span> string</code></dt><dd><p>Write a stream of values to a string.</p><dl><dt>parameter len</dt><dd><p>output buffer length.</p></dd></dl><dl><dt>parameter lf</dt><dd><p>additional element terminator. Default: <code>&quot;\n&quot;</code>.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-stream_to_channel"><a href="#val-stream_to_channel" class="anchor"></a><code><span class="keyword">val</span> stream_to_channel : ?&#8288;len:int <span>&#45;&gt;</span> ?&#8288;lf:string <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-writer">writer</a> <span>&#45;&gt;</span> <a href="../../../ocaml/Stdlib/index.html#type-out_channel">Stdlib.out_channel</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="../../../ocaml/Stdlib/Stream/index.html#type-t">Stdlib.Stream.t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Write a stream of values to a channel.</p><dl><dt>parameter len</dt><dd><p>output buffer length.</p></dd></dl><dl><dt>parameter lf</dt><dd><p>additional element terminator. Default: <code>&quot;\n&quot;</code>.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-stream_to_file"><a href="#val-stream_to_file" class="anchor"></a><code><span class="keyword">val</span> stream_to_file : ?&#8288;len:int <span>&#45;&gt;</span> ?&#8288;lf:string <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-writer">writer</a> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="../../../ocaml/Stdlib/Stream/index.html#type-t">Stdlib.Stream.t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Write a stream of values to a file.</p><dl><dt>parameter len</dt><dd><p>output buffer length.</p></dd></dl><dl><dt>parameter lf</dt><dd><p>additional element terminator. Default: <code>&quot;\n&quot;</code>.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-list_to_string"><a href="#val-list_to_string" class="anchor"></a><code><span class="keyword">val</span> list_to_string : ?&#8288;len:int <span>&#45;&gt;</span> ?&#8288;lf:string <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-writer">writer</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> list <span>&#45;&gt;</span> string</code></dt><dd><p>Write a list of values to a string.</p><dl><dt>parameter len</dt><dd><p>output buffer length.</p></dd></dl><dl><dt>parameter lf</dt><dd><p>additional element terminator. Default: <code>&quot;\n&quot;</code>.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-list_to_channel"><a href="#val-list_to_channel" class="anchor"></a><code><span class="keyword">val</span> list_to_channel : ?&#8288;len:int <span>&#45;&gt;</span> ?&#8288;lf:string <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-writer">writer</a> <span>&#45;&gt;</span> <a href="../../../ocaml/Stdlib/index.html#type-out_channel">Stdlib.out_channel</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> list <span>&#45;&gt;</span> unit</code></dt><dd><p>Write a list of values to a channel.</p><dl><dt>parameter len</dt><dd><p>output buffer length.</p></dd></dl><dl><dt>parameter lf</dt><dd><p>additional element terminator. Default: <code>&quot;\n&quot;</code>.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-list_to_file"><a href="#val-list_to_file" class="anchor"></a><code><span class="keyword">val</span> list_to_file : ?&#8288;len:int <span>&#45;&gt;</span> ?&#8288;lf:string <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-writer">writer</a> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <span class="type-var">'a</span> list <span>&#45;&gt;</span> unit</code></dt><dd><p>Write a list of values to a file.</p><dl><dt>parameter len</dt><dd><p>output buffer length.</p></dd></dl><dl><dt>parameter lf</dt><dd><p>additional element terminator. Default: <code>&quot;\n&quot;</code>.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-preset_unknown_field_handler"><a href="#val-preset_unknown_field_handler" class="anchor"></a><code><span class="keyword">val</span> preset_unknown_field_handler : string <span>&#45;&gt;</span> string <span>&#45;&gt;</span> unit</code></dt><dd><p><code>preset_unknown_field_handler src_loc field_name</code> raises a <code>Failure</code> exception with a message containing the location of the type definition in the source ATD file (<code>src_loc</code>) and the name of the field (<code>field_name</code>).</p></dd></dl><dl><dt class="spec value" id="val-unknown_field_handler"><a href="#val-unknown_field_handler" class="anchor"></a><code><span class="keyword">val</span> unknown_field_handler : (string <span>&#45;&gt;</span> string <span>&#45;&gt;</span> unit) <a href="../../../ocaml/Stdlib/index.html#type-ref">Stdlib.ref</a></code></dt><dd><p>Function called when an unknown JSON field is encountered if the code was generated by atdgen -json-strict-fields. Its preset behavior is to call <code>preset_unknown_field_handler</code> which raises a <code>Failure</code> exception.</p><p>Usage: <code>!Atdgen_runtime.Util.Json.unknown_field_handler src_loc field_name</code> where <code>src_loc</code> is the location of the type definition in the source ATD file and <code>field_name</code> is the unknown JSON field name.</p></dd></dl></div></body></html>