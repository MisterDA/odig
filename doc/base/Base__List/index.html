<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Base__List (base.Base__List)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../index.html">base</a> &#x00BB; Base__List</nav><h1>Module <code>Base__List</code></h1><p>List operations.</p><p>OCaml's lists are immutable, singly-linked lists, which therefore give fast access to the front of the list, and slow (i.e., O(n)) access to the back of the list. The comparison functions on lists are lexicographic.</p></header><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type </span>'a t</code><code><span class="keyword"> = </span><span class="type-var">'a</span> list</code></dt></dl><div><div class="spec include"><div class="doc"><details open="open"><summary><span class="def"><code><span class="keyword">include </span><span class="keyword">sig</span> ... <span class="keyword">end</span></code></span></summary><dl><dt class="spec value" id="val-t_of_sexp"><a href="#val-t_of_sexp" class="anchor"></a><code><span class="keyword">val </span>t_of_sexp : (Base__.Sexplib.Sexp.t <span>&#45;&gt;</span> <span class="type-var">'a</span>) <span>&#45;&gt;</span> Base__.Sexplib.Sexp.t <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-sexp_of_t"><a href="#val-sexp_of_t" class="anchor"></a><code><span class="keyword">val </span>sexp_of_t : (<span class="type-var">'a</span> <span>&#45;&gt;</span> Base__.Sexplib.Sexp.t) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> Base__.Sexplib.Sexp.t</code></dt><dt class="spec value" id="val-hash_fold_t"><a href="#val-hash_fold_t" class="anchor"></a><code><span class="keyword">val </span>hash_fold_t : (Base__.Ppx_hash_lib.Std.Hash.state <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> Base__.Ppx_hash_lib.Std.Hash.state) <span>&#45;&gt;</span> Base__.Ppx_hash_lib.Std.Hash.state <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> Base__.Ppx_hash_lib.Std.Hash.state</code></dt><dt class="spec value" id="val-compare"><a href="#val-compare" class="anchor"></a><code><span class="keyword">val </span>compare : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> int) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int</code></dt></dl></details></div></div></div><div><div class="spec include"><div class="doc"><details open="open"><summary><span class="def"><code><span class="keyword">include </span>Base__.Container.S1<span class="keyword"> with </span><span class="keyword">type </span>'a <a href="index.html">Base__List</a>.t := <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></span></summary><dl><dt class="spec value" id="val-mem"><a href="#val-mem" class="anchor"></a><code><span class="keyword">val </span>mem : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> equal:(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> bool</code></dt><dt class="spec value" id="val-length"><a href="#val-length" class="anchor"></a><code><span class="keyword">val </span>length : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int</code></dt><dt class="spec value" id="val-is_empty"><a href="#val-is_empty" class="anchor"></a><code><span class="keyword">val </span>is_empty : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dt class="spec value" id="val-iter"><a href="#val-iter" class="anchor"></a><code><span class="keyword">val </span>iter : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> f:(<span class="type-var">'a</span> <span>&#45;&gt;</span> unit) <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-fold"><a href="#val-fold" class="anchor"></a><code><span class="keyword">val </span>fold : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> init:<span class="type-var">'accum</span> <span>&#45;&gt;</span> f:(<span class="type-var">'accum</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'accum</span>) <span>&#45;&gt;</span> <span class="type-var">'accum</span></code></dt><dt class="spec value" id="val-fold_result"><a href="#val-fold_result" class="anchor"></a><code><span class="keyword">val </span>fold_result : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> init:<span class="type-var">'accum</span> <span>&#45;&gt;</span> f:(<span class="type-var">'accum</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> (<span class="type-var">'accum</span>, <span class="type-var">'e</span>) Base__.Result.t) <span>&#45;&gt;</span> (<span class="type-var">'accum</span>, <span class="type-var">'e</span>) Base__.Result.t</code></dt><dt class="spec value" id="val-fold_until"><a href="#val-fold_until" class="anchor"></a><code><span class="keyword">val </span>fold_until : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> init:<span class="type-var">'accum</span> <span>&#45;&gt;</span> f:(<span class="type-var">'accum</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> (<span class="type-var">'accum</span>, <span class="type-var">'stop</span>) Base__.Container_intf.Continue_or_stop.t) <span>&#45;&gt;</span> (<span class="type-var">'accum</span>, <span class="type-var">'stop</span>) Base__.Container_intf.Finished_or_stopped_early.t</code></dt><dt class="spec value" id="val-exists"><a href="#val-exists" class="anchor"></a><code><span class="keyword">val </span>exists : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> f:(<span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> bool</code></dt><dt class="spec value" id="val-for_all"><a href="#val-for_all" class="anchor"></a><code><span class="keyword">val </span>for_all : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> f:(<span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> bool</code></dt><dt class="spec value" id="val-count"><a href="#val-count" class="anchor"></a><code><span class="keyword">val </span>count : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> f:(<span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> int</code></dt><dt class="spec value" id="val-sum"><a href="#val-sum" class="anchor"></a><code><span class="keyword">val </span>sum : (<span class="keyword">module </span>Base__.Commutative_group.S <span class="keyword">with</span> <span class="keyword">type </span>t <span class="keyword">=</span> <span class="type-var">'sum</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> f:(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'sum</span>) <span>&#45;&gt;</span> <span class="type-var">'sum</span></code></dt><dt class="spec value" id="val-find"><a href="#val-find" class="anchor"></a><code><span class="keyword">val </span>find : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> f:(<span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <span class="type-var">'a</span> option</code></dt><dt class="spec value" id="val-find_map"><a href="#val-find_map" class="anchor"></a><code><span class="keyword">val </span>find_map : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> f:(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> option) <span>&#45;&gt;</span> <span class="type-var">'b</span> option</code></dt><dt class="spec value" id="val-to_list"><a href="#val-to_list" class="anchor"></a><code><span class="keyword">val </span>to_list : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> list</code></dt><dt class="spec value" id="val-to_array"><a href="#val-to_array" class="anchor"></a><code><span class="keyword">val </span>to_array : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> array</code></dt><dt class="spec value" id="val-min_elt"><a href="#val-min_elt" class="anchor"></a><code><span class="keyword">val </span>min_elt : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> cmp:(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> int) <span>&#45;&gt;</span> <span class="type-var">'a</span> option</code></dt><dt class="spec value" id="val-max_elt"><a href="#val-max_elt" class="anchor"></a><code><span class="keyword">val </span>max_elt : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> cmp:(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> int) <span>&#45;&gt;</span> <span class="type-var">'a</span> option</code></dt></dl></details></div></div></div><div><div class="spec include"><div class="doc"><details open="open"><summary><span class="def"><code><span class="keyword">include </span>Base__.Monad.S<span class="keyword"> with </span><span class="keyword">type </span>'a <a href="index.html">Base__List</a>.t := <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></span></summary><dl><dt class="spec value" id="val-(&gt;&gt;=)"><a href="#val-(&gt;&gt;=)" class="anchor"></a><code><span class="keyword">val </span>(&gt;&gt;=) : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a>) <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-(&gt;&gt;|)"><a href="#val-(&gt;&gt;|)" class="anchor"></a><code><span class="keyword">val </span>(&gt;&gt;|) : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>) <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a></code></dt></dl><div class="spec module" id="module-Monad_infix"><a href="#module-Monad_infix" class="anchor"></a><code><span class="keyword">module </span><a href="Monad_infix/index.html">Monad_infix</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><dl><dt class="spec value" id="val-bind"><a href="#val-bind" class="anchor"></a><code><span class="keyword">val </span>bind : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> f:(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a>) <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-return"><a href="#val-return" class="anchor"></a><code><span class="keyword">val </span>return : <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-map"><a href="#val-map" class="anchor"></a><code><span class="keyword">val </span>map : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> f:(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>) <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-join"><a href="#val-join" class="anchor"></a><code><span class="keyword">val </span>join : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-ignore_m"><a href="#val-ignore_m" class="anchor"></a><code><span class="keyword">val </span>ignore_m : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-all"><a href="#val-all" class="anchor"></a><code><span class="keyword">val </span>all : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> list <span>&#45;&gt;</span> <span class="type-var">'a</span> list <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-all_ignore"><a href="#val-all_ignore" class="anchor"></a><code><span class="keyword">val </span>all_ignore : unit <a href="index.html#type-t">t</a> list <span>&#45;&gt;</span> unit <a href="index.html#type-t">t</a></code></dt></dl><div class="spec module" id="module-Let_syntax"><a href="#module-Let_syntax" class="anchor"></a><code><span class="keyword">module </span><a href="Let_syntax/index.html">Let_syntax</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div></details></div></div></div><dl><dt class="spec module" id="module-Or_unequal_lengths"><a href="#module-Or_unequal_lengths" class="anchor"></a><code><span class="keyword">module </span><a href="Or_unequal_lengths/index.html">Or_unequal_lengths</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p><code>Or_unequal_lengths</code> is used for functions that take multiple lists and that only make sense if all the lists have the same length, e.g. <code>iter2</code>, <code>map3</code>. Such functions check the list lengths prior to doing anything else, and return <code>Unequal_lengths</code> if not all the lists have the same length.</p></dd></dl><dl><dt class="spec value" id="val-of_list"><a href="#val-of_list" class="anchor"></a><code><span class="keyword">val </span>of_list : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>of_list</code> is the identity function. It is useful so that the <code>List</code> module matches the same signature that other container modules do, namely:</p><pre><code class="ml">val of_list : 'a List.t -&gt; 'a t</code></pre></dd></dl><dl><dt class="spec value" id="val-nth"><a href="#val-nth" class="anchor"></a><code><span class="keyword">val </span>nth : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <span class="type-var">'a</span> option</code></dt><dt class="spec value" id="val-nth_exn"><a href="#val-nth_exn" class="anchor"></a><code><span class="keyword">val </span>nth_exn : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p>Return the <code>n</code>-th element of the given list. The first element (head of the list) is at position 0. Raise if the list is too short or <code>n</code> is negative.</p></dd></dl><dl><dt class="spec value" id="val-rev"><a href="#val-rev" class="anchor"></a><code><span class="keyword">val </span>rev : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p>List reversal.</p></dd></dl><dl><dt class="spec value" id="val-rev_append"><a href="#val-rev_append" class="anchor"></a><code><span class="keyword">val </span>rev_append : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>List.rev_append l1 l2</code> reverses <code>l1</code> and concatenates it to <code>l2</code>. This is equivalent to <code>(</code><span class="xref-unresolved" title="unresolved reference to &quot;List.rev&quot;"><code>List</code>.rev</span><code> l1) @ l2</code>, but <code>rev_append</code> is more efficient.</p></dd></dl><dl><dt class="spec value" id="val-unordered_append"><a href="#val-unordered_append" class="anchor"></a><code><span class="keyword">val </span>unordered_append : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>List.unordered_append l1 l2</code> has the same elements as <code>l1 @ l2</code>, but in some unspecified order. Generally takes time proportional to length of first list, but is O(1) if either list is empty.</p></dd></dl><dl><dt class="spec value" id="val-rev_map"><a href="#val-rev_map" class="anchor"></a><code><span class="keyword">val </span>rev_map : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> f:(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>) <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>List.rev_map l ~f</code> gives the same result as <span class="xref-unresolved" title="unresolved reference to &quot;List.rev&quot;"><code>List</code>.rev</span><code> (</code><span class="xref-unresolved" title="unresolved reference to &quot;ListLabels.map&quot;"><code>ListLabels</code>.map</span><code> f l)</code>, but is more efficient.</p></dd></dl><dl><dt class="spec value" id="val-fold_left"><a href="#val-fold_left" class="anchor"></a><code><span class="keyword">val </span>fold_left : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> init:<span class="type-var">'b</span> <span>&#45;&gt;</span> f:(<span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>) <span>&#45;&gt;</span> <span class="type-var">'b</span></code></dt><dd><p><code>fold_left</code> is the same as <code>fold</code>, and one should always use <code>fold</code> rather than <code>fold_left</code>, except in functors that are parameterized over a more general signature where this equivalence does not hold.</p></dd></dl><dl><dt class="spec value" id="val-iter2_exn"><a href="#val-iter2_exn" class="anchor"></a><code><span class="keyword">val </span>iter2_exn : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> f:(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> unit) <span>&#45;&gt;</span> unit</code></dt><dd><p><code>List.iter2 [a1; ...; an] [b1; ...; bn] ~f</code> calls in turn <code>f a1 b1; ...; f an bn</code>. The exn version will raise if the two lists have different lengths.</p></dd></dl><dl><dt class="spec value" id="val-iter2"><a href="#val-iter2" class="anchor"></a><code><span class="keyword">val </span>iter2 : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> f:(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> unit) <span>&#45;&gt;</span> unit <a href="Or_unequal_lengths/index.html#type-t">Or_unequal_lengths.t</a></code></dt><dt class="spec value" id="val-rev_map2_exn"><a href="#val-rev_map2_exn" class="anchor"></a><code><span class="keyword">val </span>rev_map2_exn : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> f:(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'c</span>) <span>&#45;&gt;</span> <span class="type-var">'c</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>List.rev_map2_exn l1 l2 ~f</code> gives the same result as <code>List.rev (List.map2_exn l1 l2 ~f)</code>, but is more efficient.</p></dd></dl><dl><dt class="spec value" id="val-rev_map2"><a href="#val-rev_map2" class="anchor"></a><code><span class="keyword">val </span>rev_map2 : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> f:(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'c</span>) <span>&#45;&gt;</span> <span class="type-var">'c</span> <a href="index.html#type-t">t</a> <a href="Or_unequal_lengths/index.html#type-t">Or_unequal_lengths.t</a></code></dt><dt class="spec value" id="val-fold2_exn"><a href="#val-fold2_exn" class="anchor"></a><code><span class="keyword">val </span>fold2_exn : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> init:<span class="type-var">'c</span> <span>&#45;&gt;</span> f:(<span class="type-var">'c</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'c</span>) <span>&#45;&gt;</span> <span class="type-var">'c</span></code></dt><dd><p><code>List.fold2 ~f ~init:a [b1; ...; bn] [c1; ...; cn]</code> is <code>f (... (f (f a b1 c1) b2 c2) ...) bn cn</code>. The exn version will raise if the two lists have different lengths.</p></dd></dl><dl><dt class="spec value" id="val-fold2"><a href="#val-fold2" class="anchor"></a><code><span class="keyword">val </span>fold2 : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> init:<span class="type-var">'c</span> <span>&#45;&gt;</span> f:(<span class="type-var">'c</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'c</span>) <span>&#45;&gt;</span> <span class="type-var">'c</span> <a href="Or_unequal_lengths/index.html#type-t">Or_unequal_lengths.t</a></code></dt><dt class="spec value" id="val-for_alli"><a href="#val-for_alli" class="anchor"></a><code><span class="keyword">val </span>for_alli : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> f:(int <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> bool</code></dt><dd><p>Like <span class="xref-unresolved" title="unresolved reference to &quot;List.for_all&quot;"><code>List</code>.for_all</span>, but passes the index as an argument.</p></dd></dl><dl><dt class="spec value" id="val-for_all2_exn"><a href="#val-for_all2_exn" class="anchor"></a><code><span class="keyword">val </span>for_all2_exn : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> f:(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> bool</code></dt><dd><p>Like <span class="xref-unresolved" title="unresolved reference to &quot;List.for_all&quot;"><code>List</code>.for_all</span>, but for a two-argument predicate. The exn version will raise if the two lists have different lengths.</p></dd></dl><dl><dt class="spec value" id="val-for_all2"><a href="#val-for_all2" class="anchor"></a><code><span class="keyword">val </span>for_all2 : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> f:(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> bool <a href="Or_unequal_lengths/index.html#type-t">Or_unequal_lengths.t</a></code></dt><dt class="spec value" id="val-existsi"><a href="#val-existsi" class="anchor"></a><code><span class="keyword">val </span>existsi : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> f:(int <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> bool</code></dt><dd><p>Like <span class="xref-unresolved" title="unresolved reference to &quot;List.exists&quot;"><code>List</code>.exists</span>, but passes the index as an argument.</p></dd></dl><dl><dt class="spec value" id="val-exists2_exn"><a href="#val-exists2_exn" class="anchor"></a><code><span class="keyword">val </span>exists2_exn : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> f:(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> bool</code></dt><dd><p>Like <span class="xref-unresolved" title="unresolved reference to &quot;List.exists&quot;"><code>List</code>.exists</span>, but for a two-argument predicate. The exn version will raise if the two lists have different lengths.</p></dd></dl><dl><dt class="spec value" id="val-exists2"><a href="#val-exists2" class="anchor"></a><code><span class="keyword">val </span>exists2 : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> f:(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> bool <a href="Or_unequal_lengths/index.html#type-t">Or_unequal_lengths.t</a></code></dt><dt class="spec value" id="val-filter"><a href="#val-filter" class="anchor"></a><code><span class="keyword">val </span>filter : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> f:(<span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>filter l ~f</code> returns all the elements of the list <code>l</code> that satisfy the predicate <code>p</code>. The order of the elements in the input list is preserved.</p></dd></dl><dl><dt class="spec value" id="val-rev_filter"><a href="#val-rev_filter" class="anchor"></a><code><span class="keyword">val </span>rev_filter : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> f:(<span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Like <code>filter</code>, but reverses the order of the input list</p></dd></dl><dl><dt class="spec value" id="val-filteri"><a href="#val-filteri" class="anchor"></a><code><span class="keyword">val </span>filteri : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> f:(int <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-partition_map"><a href="#val-partition_map" class="anchor"></a><code><span class="keyword">val </span>partition_map : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> f:(<span class="type-var">'a</span> <span>&#45;&gt;</span> [ `Fst of <span class="type-var">'b</span><span class="keyword"> | </span>`Snd of <span class="type-var">'c</span> ]) <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a><span class="keyword"> * </span><span class="type-var">'c</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>partition_map t ~f</code> partitions <code>t</code> according to <code>f</code>.</p></dd></dl><dl><dt class="spec value" id="val-partition3_map"><a href="#val-partition3_map" class="anchor"></a><code><span class="keyword">val </span>partition3_map : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> f:(<span class="type-var">'a</span> <span>&#45;&gt;</span> [ `Fst of <span class="type-var">'b</span><span class="keyword"> | </span>`Snd of <span class="type-var">'c</span><span class="keyword"> | </span>`Trd of <span class="type-var">'d</span> ]) <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a><span class="keyword"> * </span><span class="type-var">'c</span> <a href="index.html#type-t">t</a><span class="keyword"> * </span><span class="type-var">'d</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-partition_tf"><a href="#val-partition_tf" class="anchor"></a><code><span class="keyword">val </span>partition_tf : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> f:(<span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a><span class="keyword"> * </span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>partition_tf l ~f</code> returns a pair of lists <code>(l1, l2)</code>, where <code>l1</code> is the list of all the elements of <code>l</code> that satisfy the predicate <code>p</code>, and <code>l2</code> is the list of all the elements of <code>l</code> that do not satisfy <code>p</code>. The order of the elements in the input list is preserved. The &quot;tf&quot; suffix is mnemonic to remind readers at a call that the result is (trues, falses).</p></dd></dl><dl><dt class="spec value" id="val-split_n"><a href="#val-split_n" class="anchor"></a><code><span class="keyword">val </span>split_n : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a><span class="keyword"> * </span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>split_n [e1; ...; em] n</code> is <code>([e1; ...; en], [en+1; ...; em])</code>.</p><ul><li>If <code>n &gt; m</code>, <code>([e1; ...; em], [])</code> is returned.</li><li>If <code>n &lt; 0</code>, <code>([], [e1; ...; em])</code> is returned.</li></ul></dd></dl><dl><dt class="spec value" id="val-sort"><a href="#val-sort" class="anchor"></a><code><span class="keyword">val </span>sort : cmp:(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> int) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Sort a list in increasing order according to a comparison function. The comparison function must return 0 if its arguments compare as equal, a positive integer if the first is greater, and a negative integer if the first is smaller (see Array.sort for a complete specification). For example, <span class="xref-unresolved" title="unresolved reference to &quot;Pervasives.compare&quot;"><code>Pervasives</code>.compare</span> is a suitable comparison function.</p><p>The current implementation uses Merge Sort. It runs in linear heap space and logarithmic stack space.</p><p>Presently, the sort is stable, meaning that two equal elements in the input will be in the same order in the output.</p></dd></dl><dl><dt class="spec value" id="val-stable_sort"><a href="#val-stable_sort" class="anchor"></a><code><span class="keyword">val </span>stable_sort : cmp:(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> int) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Like <code>sort</code>, but guaranteed to be stable</p></dd></dl><dl><dt class="spec value" id="val-merge"><a href="#val-merge" class="anchor"></a><code><span class="keyword">val </span>merge : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> cmp:(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> int) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Merge two lists: assuming that <code>l1</code> and <code>l2</code> are sorted according to the comparison function <code>cmp</code>, <code>merge cmp l1 l2</code> will return a sorted list containing all the elements of <code>l1</code> and <code>l2</code>. If several elements compare equal, the elements of <code>l1</code> will be before the elements of <code>l2</code>.</p></dd></dl><dl><dt class="spec value" id="val-hd"><a href="#val-hd" class="anchor"></a><code><span class="keyword">val </span>hd : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> option</code></dt><dt class="spec value" id="val-tl"><a href="#val-tl" class="anchor"></a><code><span class="keyword">val </span>tl : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> option</code></dt><dt class="spec value" id="val-hd_exn"><a href="#val-hd_exn" class="anchor"></a><code><span class="keyword">val </span>hd_exn : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p>Return the first element of the given list. Raise if the list is empty.</p></dd></dl><dl><dt class="spec value" id="val-tl_exn"><a href="#val-tl_exn" class="anchor"></a><code><span class="keyword">val </span>tl_exn : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Return the given list without its first element. Raise if the list is empty.</p></dd></dl><dl><dt class="spec value" id="val-findi"><a href="#val-findi" class="anchor"></a><code><span class="keyword">val </span>findi : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> f:(int <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> (int<span class="keyword"> * </span><span class="type-var">'a</span>) option</code></dt><dt class="spec value" id="val-find_exn"><a href="#val-find_exn" class="anchor"></a><code><span class="keyword">val </span>find_exn : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> f:(<span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p><code>find_exn t ~f</code> returns the first element of <code>t</code> that satisfies <code>f</code>. It raises <code>Not_found</code> if there is no such element.</p></dd></dl><dl><dt class="spec value" id="val-find_map_exn"><a href="#val-find_map_exn" class="anchor"></a><code><span class="keyword">val </span>find_map_exn : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> f:(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> option) <span>&#45;&gt;</span> <span class="type-var">'b</span></code></dt><dd><p>Returns the first evaluation of <code>f</code> that returns <code>Some</code>. Raises <code>Not_found</code> if <code>f</code> always returns <code>None</code>.</p></dd></dl><dl><dt class="spec value" id="val-find_mapi"><a href="#val-find_mapi" class="anchor"></a><code><span class="keyword">val </span>find_mapi : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> f:(int <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> option) <span>&#45;&gt;</span> <span class="type-var">'b</span> option</code></dt><dd><p>Like <code>find_map</code> and <code>find_map_exn</code>, but pass the index as an argument.</p></dd></dl><dl><dt class="spec value" id="val-find_mapi_exn"><a href="#val-find_mapi_exn" class="anchor"></a><code><span class="keyword">val </span>find_mapi_exn : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> f:(int <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> option) <span>&#45;&gt;</span> <span class="type-var">'b</span></code></dt><dt class="spec value" id="val-append"><a href="#val-append" class="anchor"></a><code><span class="keyword">val </span>append : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p>E.g. <code>append [1; 2] [3; 4; 5]</code> is <code>[1; 2; 3; 4; 5]</code></p></dd></dl><dl><dt class="spec value" id="val-map"><a href="#val-map" class="anchor"></a><code><span class="keyword">val </span>map : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> f:(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>) <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>List.map f [a1; ...; an]</code> applies function <code>f</code> to <code>a1</code>, <code>a2</code>, ..., <code>an</code>, in order, and builds the list <code>[f a1; ...; f an]</code> with the results returned by <code>f</code>.</p></dd></dl><dl><dt class="spec value" id="val-concat_map"><a href="#val-concat_map" class="anchor"></a><code><span class="keyword">val </span>concat_map : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> f:(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a>) <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>concat_map t ~f</code> is <code>concat (map t ~f)</code>, except that there is no guarantee about the order in which <code>f</code> is applied to the elements of <code>t</code>.</p></dd></dl><dl><dt class="spec value" id="val-concat_mapi"><a href="#val-concat_mapi" class="anchor"></a><code><span class="keyword">val </span>concat_mapi : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> f:(int <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a>) <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>concat_mapi t ~f</code> is like concat_map, but passes the index as an argument</p></dd></dl><dl><dt class="spec value" id="val-map2_exn"><a href="#val-map2_exn" class="anchor"></a><code><span class="keyword">val </span>map2_exn : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> f:(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'c</span>) <span>&#45;&gt;</span> <span class="type-var">'c</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>List.map2 [a1; ...; an] [b1; ...; bn] ~f</code> is <code>[f a1 b1; ...; f an bn]</code>. The exn version will raise if the two lists have different lengths.</p></dd></dl><dl><dt class="spec value" id="val-map2"><a href="#val-map2" class="anchor"></a><code><span class="keyword">val </span>map2 : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> f:(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'c</span>) <span>&#45;&gt;</span> <span class="type-var">'c</span> <a href="index.html#type-t">t</a> <a href="Or_unequal_lengths/index.html#type-t">Or_unequal_lengths.t</a></code></dt><dt class="spec value" id="val-rev_map3_exn"><a href="#val-rev_map3_exn" class="anchor"></a><code><span class="keyword">val </span>rev_map3_exn : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'c</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> f:(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'c</span> <span>&#45;&gt;</span> <span class="type-var">'d</span>) <span>&#45;&gt;</span> <span class="type-var">'d</span> <a href="index.html#type-t">t</a></code></dt><dd><p>analogous to <code>rev_map2</code></p></dd></dl><dl><dt class="spec value" id="val-rev_map3"><a href="#val-rev_map3" class="anchor"></a><code><span class="keyword">val </span>rev_map3 : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'c</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> f:(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'c</span> <span>&#45;&gt;</span> <span class="type-var">'d</span>) <span>&#45;&gt;</span> <span class="type-var">'d</span> <a href="index.html#type-t">t</a> <a href="Or_unequal_lengths/index.html#type-t">Or_unequal_lengths.t</a></code></dt><dt class="spec value" id="val-map3_exn"><a href="#val-map3_exn" class="anchor"></a><code><span class="keyword">val </span>map3_exn : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'c</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> f:(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'c</span> <span>&#45;&gt;</span> <span class="type-var">'d</span>) <span>&#45;&gt;</span> <span class="type-var">'d</span> <a href="index.html#type-t">t</a></code></dt><dd><p>analogous to <code>map2</code></p></dd></dl><dl><dt class="spec value" id="val-map3"><a href="#val-map3" class="anchor"></a><code><span class="keyword">val </span>map3 : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'c</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> f:(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'c</span> <span>&#45;&gt;</span> <span class="type-var">'d</span>) <span>&#45;&gt;</span> <span class="type-var">'d</span> <a href="index.html#type-t">t</a> <a href="Or_unequal_lengths/index.html#type-t">Or_unequal_lengths.t</a></code></dt><dt class="spec value" id="val-rev_map_append"><a href="#val-rev_map_append" class="anchor"></a><code><span class="keyword">val </span>rev_map_append : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> f:(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>) <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>rev_map_append l1 l2 ~f</code> reverses <code>l1</code> mapping <code>f</code> over each element, and appends the result to the front of <code>l2</code>.</p></dd></dl><dl><dt class="spec value" id="val-fold_right"><a href="#val-fold_right" class="anchor"></a><code><span class="keyword">val </span>fold_right : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> f:(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>) <span>&#45;&gt;</span> init:<span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'b</span></code></dt><dd><p><code>List.fold_right [a1; ...; an] ~f ~init:b</code> is <code>f a1 (f a2 (... (f an b) ...))</code>.</p></dd></dl><dl><dt class="spec value" id="val-unzip"><a href="#val-unzip" class="anchor"></a><code><span class="keyword">val </span>unzip : (<span class="type-var">'a</span><span class="keyword"> * </span><span class="type-var">'b</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a><span class="keyword"> * </span><span class="type-var">'b</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Transform a list of pairs into a pair of lists: <code>unzip [(a1,b1); ...; (an,bn)]</code> is <code>([a1; ...; an], [b1; ...; bn])</code>.</p></dd></dl><dl><dt class="spec value" id="val-unzip3"><a href="#val-unzip3" class="anchor"></a><code><span class="keyword">val </span>unzip3 : (<span class="type-var">'a</span><span class="keyword"> * </span><span class="type-var">'b</span><span class="keyword"> * </span><span class="type-var">'c</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a><span class="keyword"> * </span><span class="type-var">'b</span> <a href="index.html#type-t">t</a><span class="keyword"> * </span><span class="type-var">'c</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-zip"><a href="#val-zip" class="anchor"></a><code><span class="keyword">val </span>zip : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span><span class="keyword"> * </span><span class="type-var">'b</span>) <a href="index.html#type-t">t</a> option</code></dt><dd><p>Transform a pair of lists into an (optional) list of pairs: <code>zip [a1; ...; an] [b1; ...; bn]</code> is <code>[(a1,b1); ...; (an,bn)]</code>. Returns None if the two lists have different lengths.</p></dd></dl><dl><dt class="spec value" id="val-zip_exn"><a href="#val-zip_exn" class="anchor"></a><code><span class="keyword">val </span>zip_exn : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span><span class="keyword"> * </span><span class="type-var">'b</span>) <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-mapi"><a href="#val-mapi" class="anchor"></a><code><span class="keyword">val </span>mapi : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> f:(int <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>) <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a></code></dt><dd><p>mapi is just like map, but it also passes in the index of each element as the first argument to the mapped function. Tail-recursive.</p></dd></dl><dl><dt class="spec value" id="val-rev_mapi"><a href="#val-rev_mapi" class="anchor"></a><code><span class="keyword">val </span>rev_mapi : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> f:(int <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>) <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-iteri"><a href="#val-iteri" class="anchor"></a><code><span class="keyword">val </span>iteri : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> f:(int <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> unit) <span>&#45;&gt;</span> unit</code></dt><dd><p>iteri is just like iter, but it also passes in the index of each element as the first argument to the iter'd function. Tail-recursive.</p></dd></dl><dl><dt class="spec value" id="val-foldi"><a href="#val-foldi" class="anchor"></a><code><span class="keyword">val </span>foldi : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> init:<span class="type-var">'b</span> <span>&#45;&gt;</span> f:(int <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>) <span>&#45;&gt;</span> <span class="type-var">'b</span></code></dt><dd><p>foldi is just like fold, but it also passes in the index of each element as the first argument to the folded function. Tail-recursive.</p></dd></dl><dl><dt class="spec value" id="val-reduce_exn"><a href="#val-reduce_exn" class="anchor"></a><code><span class="keyword">val </span>reduce_exn : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> f:(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p><code>reduce_exn [a1; ...; an] ~f</code> is <code>f (... (f (f a1 a2) a3) ...) an</code>. It fails on the empty list. Tail recursive.</p></dd></dl><dl><dt class="spec value" id="val-reduce"><a href="#val-reduce" class="anchor"></a><code><span class="keyword">val </span>reduce : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> f:(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span> option</code></dt><dt class="spec value" id="val-reduce_balanced"><a href="#val-reduce_balanced" class="anchor"></a><code><span class="keyword">val </span>reduce_balanced : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> f:(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span> option</code></dt><dd><p><code>reduce_balanced</code> returns the same value as <code>reduce</code> when <code>f</code> is associative, but differs in that the tree of nested applications of <code>f</code> has logarithmic depth.</p><p>This is useful when your <code>'a</code> grows in size as you reduce it and <code>f</code> becomes more expensive with bigger inputs. For example, <code>reduce_balanced ~f:(^)</code> takes <code>n*log(n)</code> time, while <code>reduce ~f:(^)</code> takes quadratic time.</p></dd></dl><dl><dt class="spec value" id="val-reduce_balanced_exn"><a href="#val-reduce_balanced_exn" class="anchor"></a><code><span class="keyword">val </span>reduce_balanced_exn : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> f:(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dt class="spec value" id="val-group"><a href="#val-group" class="anchor"></a><code><span class="keyword">val </span>group : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> break:(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <a href="index.html#type-t">t</a></code></dt><dd><p><code>group l ~break</code> returns a list of lists (i.e., groups) whose concatenation is equal to the original list. Each group is broken where break returns true on a pair of successive elements.</p><p>Example</p><p>group ~break:(&lt;&gt;) <code>'M';'i';'s';'s';'i';'s';'s';'i';'p';'p';'i'</code> -&gt;</p><p><code>['M'];['i'];['s';'s'];['i'];['s';'s'];['i'];['p';'p'];['i']</code></p></dd></dl><dl><dt class="spec value" id="val-groupi"><a href="#val-groupi" class="anchor"></a><code><span class="keyword">val </span>groupi : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> break:(int <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <a href="index.html#type-t">t</a></code></dt><dd><p>This is just like group, except that you get the index in the original list of the current element along with the two elements.</p><p>Example, group the chars of Mississippi into triples</p><p>groupi ~break:(fun i _ _ -&gt; i mod 3 = 0) <code>'M';'i';'s';'s';'i';'s';'s';'i';'p';'p';'i'</code> -&gt;</p><p><code>['M'; 'i'; 's']; ['s'; 'i'; 's']; ['s'; 'i'; 'p']; ['p'; 'i']</code></p></dd></dl><dl><dt class="spec value" id="val-last"><a href="#val-last" class="anchor"></a><code><span class="keyword">val </span>last : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> option</code></dt><dd><p>The final element of a list. The _exn version raises on the empty list.</p></dd></dl><dl><dt class="spec value" id="val-last_exn"><a href="#val-last_exn" class="anchor"></a><code><span class="keyword">val </span>last_exn : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dt class="spec value" id="val-is_prefix"><a href="#val-is_prefix" class="anchor"></a><code><span class="keyword">val </span>is_prefix : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> prefix:<span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> equal:(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> bool</code></dt><dd><p><code>is_prefix xs ~prefix</code> returns <code>true</code> if <code>xs</code> starts with <code>prefix</code>.</p></dd></dl><dl><dt class="spec value" id="val-find_consecutive_duplicate"><a href="#val-find_consecutive_duplicate" class="anchor"></a><code><span class="keyword">val </span>find_consecutive_duplicate : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> equal:(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> (<span class="type-var">'a</span><span class="keyword"> * </span><span class="type-var">'a</span>) option</code></dt><dd><p><code>find_consecutive_duplicate t ~equal</code> returns the first pair of consecutive elements <code>(a1, a2)</code> in <code>t</code> such that <code>equal a1 a2</code>. They are returned in the same order as they appear in <code>t</code>. <code>equal</code> need not be an equivalence relation; it is simply used as a predicate on consecutive elements.</p></dd></dl><dl><dt class="spec value" id="val-remove_consecutive_duplicates"><a href="#val-remove_consecutive_duplicates" class="anchor"></a><code><span class="keyword">val </span>remove_consecutive_duplicates : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> equal:(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>remove_consecutive_duplicates</code>. The same list with consecutive duplicates removed. The relative order of the other elements is unaffected. The element kept from a run of duplicates is the last one.</p></dd></dl><dl><dt class="spec value" id="val-dedup"><a href="#val-dedup" class="anchor"></a><code><span class="keyword">val </span>dedup : ?&#8288;compare:(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> int) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>dedup</code> (de-duplicate). The same list with duplicates removed, but the order is not guaranteed.</p></dd></dl><dl><dt class="spec value" id="val-contains_dup"><a href="#val-contains_dup" class="anchor"></a><code><span class="keyword">val </span>contains_dup : ?&#8288;compare:(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> int) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>contains_dup</code> True if there are any two elements in the list which are the same.</p></dd></dl><dl><dt class="spec value" id="val-find_a_dup"><a href="#val-find_a_dup" class="anchor"></a><code><span class="keyword">val </span>find_a_dup : ?&#8288;compare:(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> int) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> option</code></dt><dd><p><code>find_a_dup</code> returns a duplicate from the list (no guarantees about which duplicate you get), or None if there are no dups.</p></dd></dl><dl><dt class="spec value" id="val-find_all_dups"><a href="#val-find_all_dups" class="anchor"></a><code><span class="keyword">val </span>find_all_dups : ?&#8288;compare:(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> int) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> list</code></dt><dd><p><code>find_all_dups</code> returns a list of all elements that occur more than once, with no guarantees about order.</p></dd></dl><dl><dt class="spec exception" id="exception-Duplicate_found"><a href="#exception-Duplicate_found" class="anchor"></a><code><span class="keyword">exception </span></code><code><span class="exception">Duplicate_found</span><span class="keyword"> of </span>unit <span>&#45;&gt;</span> Base__.Sexp.t<span class="keyword"> * </span>string</code></dt><dd><p>only raised in <code>exn_if_dup</code> below</p></dd></dl><dl><dt class="spec value" id="val-exn_if_dup"><a href="#val-exn_if_dup" class="anchor"></a><code><span class="keyword">val </span>exn_if_dup : ?&#8288;compare:(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> int) <span>&#45;&gt;</span> ?&#8288;context:string <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> to_sexp:(<span class="type-var">'a</span> <span>&#45;&gt;</span> Base__.Sexp.t) <span>&#45;&gt;</span> unit</code></dt><dd><p><code>exn_if_dup ?compare ?context t ~to_sexp</code> will run <code>find_a_dup</code> on <code>t</code>, and raise <code>Duplicate_found</code> if a duplicate is found. The <code>context</code> is the second argument of the exception</p></dd></dl><dl><dt class="spec value" id="val-count"><a href="#val-count" class="anchor"></a><code><span class="keyword">val </span>count : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> f:(<span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> int</code></dt><dd><p><code>count l ~f</code> is the number of elements in <code>l</code> that satisfy the predicate <code>f</code>.</p></dd></dl><dl><dt class="spec value" id="val-counti"><a href="#val-counti" class="anchor"></a><code><span class="keyword">val </span>counti : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> f:(int <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> int</code></dt><dt class="spec value" id="val-range"><a href="#val-range" class="anchor"></a><code><span class="keyword">val </span>range : ?&#8288;stride:int <span>&#45;&gt;</span> ?&#8288;start:[ `inclusive<span class="keyword"> | </span>`exclusive ] <span>&#45;&gt;</span> ?&#8288;stop:[ `inclusive<span class="keyword"> | </span>`exclusive ] <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int <a href="index.html#type-t">t</a></code></dt><dd><p><code>range ?stride ?start ?stop start_i stop_i</code> is the list of integers from <code>start_i</code> to <code>stop_i</code>, stepping by <code>stride</code>. If <code>stride</code> &lt; 0 then we need <code>start_i</code> &gt; <code>stop_i</code> for the result to be nonempty (or <code>start_i</code> = <code>stop_i</code> in the case where both bounds are inclusive).</p></dd></dl><dl><dt class="spec value" id="val-range'"><a href="#val-range'" class="anchor"></a><code><span class="keyword">val </span>range' : compare:(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> int) <span>&#45;&gt;</span> stride:(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span>) <span>&#45;&gt;</span> ?&#8288;start:[ `inclusive<span class="keyword"> | </span>`exclusive ] <span>&#45;&gt;</span> ?&#8288;stop:[ `inclusive<span class="keyword"> | </span>`exclusive ] <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>range'</code> is analogous to <code>range</code> for general start/stop/stride types. <code>range'</code> raises if <code>stride x</code> returns <code>x</code> or if the direction that <code>stride x</code> moves <code>x</code> changes from one call to the next.</p></dd></dl><dl><dt class="spec value" id="val-init"><a href="#val-init" class="anchor"></a><code><span class="keyword">val </span>init : int <span>&#45;&gt;</span> f:(int <span>&#45;&gt;</span> <span class="type-var">'a</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>init n ~f</code> is <code>[(f 0); (f 1); ...; (f (n-1))]</code>. It is an error if <code>n &lt; 0</code>. <code>List.init</code> applies <code>f</code> to values in decreasing order; starting with <code>n-1</code>, and ending with <code>0</code>. This is the opposite order to <code>Array.init</code>.</p></dd></dl><dl><dt class="spec value" id="val-rev_filter_map"><a href="#val-rev_filter_map" class="anchor"></a><code><span class="keyword">val </span>rev_filter_map : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> f:(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> option) <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>rev_filter_map l ~f</code> is the reversed sublist of <code>l</code> containing only elements for which <code>f</code> returns <code>Some e</code>.</p></dd></dl><dl><dt class="spec value" id="val-rev_filter_mapi"><a href="#val-rev_filter_mapi" class="anchor"></a><code><span class="keyword">val </span>rev_filter_mapi : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> f:(int <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> option) <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a></code></dt><dd><p>rev_filter_mapi is just like rev_filter_map, but it also passes in the index of each element as the first argument to the mapped function. Tail-recursive.</p></dd></dl><dl><dt class="spec value" id="val-filter_map"><a href="#val-filter_map" class="anchor"></a><code><span class="keyword">val </span>filter_map : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> f:(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> option) <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>filter_map l ~f</code> is the sublist of <code>l</code> containing only elements for which <code>f</code> returns <code>Some e</code>.</p></dd></dl><dl><dt class="spec value" id="val-filter_mapi"><a href="#val-filter_mapi" class="anchor"></a><code><span class="keyword">val </span>filter_mapi : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> f:(int <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> option) <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a></code></dt><dd><p>filter_mapi is just like filter_map, but it also passes in the index of each element as the first argument to the mapped function. Tail-recursive.</p></dd></dl><dl><dt class="spec value" id="val-filter_opt"><a href="#val-filter_opt" class="anchor"></a><code><span class="keyword">val </span>filter_opt : <span class="type-var">'a</span> option <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>filter_opt l</code> is the sublist of <code>l</code> containing only elements which are <code>Some e</code>. In other words, <code>filter_opt l</code> = <code>filter_map ~f:ident l</code>.</p></dd></dl><dl><dt class="spec module" id="module-Assoc"><a href="#module-Assoc" class="anchor"></a><code><span class="keyword">module </span><a href="Assoc/index.html">Assoc</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Interpret a list of (key, value) pairs as a map in which only the first occurrence of a key affects the semantics, i.e.:</p></dd></dl><aside><p>Note that <code>sub</code>, unlike <code>slice</code>, doesn't use python-style indices!</p></aside><dl><dt class="spec value" id="val-sub"><a href="#val-sub" class="anchor"></a><code><span class="keyword">val </span>sub : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> pos:int <span>&#45;&gt;</span> len:int <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>sub pos len l</code> is the <code>len</code>-element sublist of <code>l</code>, starting at <code>pos</code>.</p></dd></dl><dl><dt class="spec value" id="val-slice"><a href="#val-slice" class="anchor"></a><code><span class="keyword">val </span>slice : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>slice l start stop</code> returns a new list including elements <code>l.(start)</code> through <code>l.(stop-1)</code>, normalized python-style.</p></dd></dl><dl><dt class="spec value" id="val-take"><a href="#val-take" class="anchor"></a><code><span class="keyword">val </span>take : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>take l n</code> returns the first <code>n</code> elements of <code>l</code>, or all of <code>l</code> if <code>n &gt; length l</code>. <code>take l n = fst (split_n l n)</code>.</p></dd></dl><dl><dt class="spec value" id="val-drop"><a href="#val-drop" class="anchor"></a><code><span class="keyword">val </span>drop : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>drop l n</code> returns <code>l</code> without the first <code>n</code> elements, or the empty list if <code>n &gt; length l</code>. <code>drop l n = snd (split_n l n)</code>.</p></dd></dl><dl><dt class="spec value" id="val-take_while"><a href="#val-take_while" class="anchor"></a><code><span class="keyword">val </span>take_while : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> f:(<span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>take_while l ~f</code> returns the longest prefix of <code>l</code> for which <code>f</code> is <code>true</code>.</p></dd></dl><dl><dt class="spec value" id="val-drop_while"><a href="#val-drop_while" class="anchor"></a><code><span class="keyword">val </span>drop_while : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> f:(<span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>drop_while l ~f</code> drops the longest prefix of <code>l</code> for which <code>f</code> is <code>true</code>.</p></dd></dl><dl><dt class="spec value" id="val-split_while"><a href="#val-split_while" class="anchor"></a><code><span class="keyword">val </span>split_while : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> f:(<span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a><span class="keyword"> * </span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>split_while xs ~f = (take_while xs ~f, drop_while xs ~f)</code></p></dd></dl><dl><dt class="spec value" id="val-concat"><a href="#val-concat" class="anchor"></a><code><span class="keyword">val </span>concat : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Concatenate a list of lists. The elements of the argument are all concatenated together (in the same order) to give the result. Tail recursive over outer and inner lists.</p></dd></dl><dl><dt class="spec value" id="val-concat_no_order"><a href="#val-concat_no_order" class="anchor"></a><code><span class="keyword">val </span>concat_no_order : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Like <code>concat</code>, but faster and without preserving any ordering (i.e. for lists that are essentially viewed as multi-sets.</p></dd></dl><dl><dt class="spec value" id="val-cons"><a href="#val-cons" class="anchor"></a><code><span class="keyword">val </span>cons : <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-cartesian_product"><a href="#val-cartesian_product" class="anchor"></a><code><span class="keyword">val </span>cartesian_product : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span><span class="keyword"> * </span><span class="type-var">'b</span>) <a href="index.html#type-t">t</a></code></dt><dd><p>Returns a list with all possible pairs -- if the input lists have length len1 and len2, the resulting list will have length len1*len2.</p></dd></dl><dl><dt class="spec value" id="val-permute"><a href="#val-permute" class="anchor"></a><code><span class="keyword">val </span>permute : ?&#8288;random_state:Base__.Random.State.t <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>permute ?random_state t</code> returns a permutation of <code>t</code>.</p><p><code>permute</code> side affects <code>random_state</code> by repeated calls to <code>Random.State.int</code>. If <code>random_state</code> is not supplied, <code>permute</code> uses <code>Random.State.default</code>.</p></dd></dl><dl><dt class="spec value" id="val-random_element"><a href="#val-random_element" class="anchor"></a><code><span class="keyword">val </span>random_element : ?&#8288;random_state:Base__.Random.State.t <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> option</code></dt><dd><p><code>random_element ?random_state t</code> is <code>None</code> if <code>t</code> is empty, else it is <code>Some x</code> for some <code>x</code> chosen uniformly at random from <code>t</code>.</p><p><code>random_element</code> side affects <code>random_state</code> by calling <code>Random.State.int</code>. If <code>random_state</code> is not supplied, <code>random_element</code> uses <code>Random.State.default</code>.</p></dd></dl><dl><dt class="spec value" id="val-random_element_exn"><a href="#val-random_element_exn" class="anchor"></a><code><span class="keyword">val </span>random_element_exn : ?&#8288;random_state:Base__.Random.State.t <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dt class="spec value" id="val-is_sorted"><a href="#val-is_sorted" class="anchor"></a><code><span class="keyword">val </span>is_sorted : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> compare:(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> int) <span>&#45;&gt;</span> bool</code></dt><dd><p><code>is_sorted t ~compare</code> returns <code>true</code> iff forall adjacent <code>a1; a2</code> in <code>t</code>, <code>compare a1
    a2 &lt;= 0</code>.</p><p><code>is_sorted_strictly</code> is similar, except it uses <code>&lt;</code> instead of <code>&lt;=</code>.</p></dd></dl><dl><dt class="spec value" id="val-is_sorted_strictly"><a href="#val-is_sorted_strictly" class="anchor"></a><code><span class="keyword">val </span>is_sorted_strictly : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> compare:(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> int) <span>&#45;&gt;</span> bool</code></dt><dt class="spec value" id="val-equal"><a href="#val-equal" class="anchor"></a><code><span class="keyword">val </span>equal : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> equal:(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> bool</code></dt></dl><div class="spec module" id="module-Infix"><a href="#module-Infix" class="anchor"></a><code><span class="keyword">module </span><a href="Infix/index.html">Infix</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><dl><dt class="spec value" id="val-transpose"><a href="#val-transpose" class="anchor"></a><code><span class="keyword">val </span>transpose : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <a href="index.html#type-t">t</a> option</code></dt><dd><p><code>transpose m</code> transposes the rows and columns of the matrix <code>m</code>, considered as either a row of column lists or (dually) a column of row lists.</p><p>Example,</p><p>transpose <code>[1;2;3];[4;5;6]</code> = <code>[1;4];[2;5];[3;6]</code></p><p>On non-empty rectangular matrices, <code>transpose</code> is an involution (i.e., <code>transpose (transpose m) = m</code>). Transpose returns None when called on lists of lists with non-uniform lengths. *</p></dd></dl><dl><dt class="spec value" id="val-transpose_exn"><a href="#val-transpose_exn" class="anchor"></a><code><span class="keyword">val </span>transpose_exn : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <a href="index.html#type-t">t</a></code></dt><dd><p><code>transpose_exn</code> transposes the rows and columns of its argument, throwing an exception if the list is not rectangular. *</p></dd></dl><dl><dt class="spec value" id="val-intersperse"><a href="#val-intersperse" class="anchor"></a><code><span class="keyword">val </span>intersperse : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> sep:<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>intersperse xs ~sep</code> places <code>sep</code> between adjacent elements of <code>xs</code>. e.g. <code>intersperse [1;2;3] ~sep:0 = [1;0;2;0;3]</code></p></dd></dl></div></body></html>