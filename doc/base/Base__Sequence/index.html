<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Base__Sequence (base.Base__Sequence)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../index.html">base</a> &#x00BB; Base__Sequence</nav><h1>Module <code>Base__Sequence</code></h1><p>A sequence of elements that can be produced one at a time, on demand, normally with no sharing.</p><p>The elements are computed on demand, possibly repeating work if they are demanded multiple times. A sequence can be built by unfolding from some initial state, which will in practice often be other containers.</p><p>Most functions constructing a sequence will not immediately compute any elements of the sequence. These functions will always return in O(1), but traversing the resulting sequence may be more expensive. The most they will do immediately is generate a new internal state and a new step function.</p><p>Functions that transform existing sequences sometimes have to reconstruct some suffix of the input sequence, even if it is unmodified. For example, calling <code>drop 1</code> will return a sequence with a slightly larger state and whose elements all cost slightly more to traverse. Because this is sometimes undesirable (for example, applying <code>drop
    1</code> n times will cost O(n) per element traversed in the result), there are also more eager versions of many functions (whose names are suffixed with <code>_eagerly</code>) that do more work up front. A function has the <code>_eagerly</code> suffix iff it matches both of these conditions:</p><ul><li>It might consume an element from an input <code>t</code> before returning.</li></ul><ul><li>It only returns a <code>t</code> (not paired with something else, not wrapped in an <code>option</code>, etc.). If it returns anything other than a <code>t</code> and it has at least one <code>t</code> input, it's probably demanding elements from the input <code>t</code> anyway.</li></ul><p>Only <code>*_exn</code> functions can raise exceptions, except if the function underlying the sequence (the <code>f</code> passed to <code>unfold</code>) raises, in which case the exception will cascade.</p></header><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type </span>+'a t</code></dt></dl><div><div class="spec include"><div class="doc"><details open="open"><summary><span class="def"><code><span class="keyword">include </span><span class="keyword">sig</span> ... <span class="keyword">end</span></code></span></summary><dl><dt class="spec value" id="val-sexp_of_t"><a href="#val-sexp_of_t" class="anchor"></a><code><span class="keyword">val </span>sexp_of_t : (<span class="type-var">'a</span> <span>&#45;&gt;</span> Base__.Sexplib.Sexp.t) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> Base__.Sexplib.Sexp.t</code></dt><dt class="spec value" id="val-compare"><a href="#val-compare" class="anchor"></a><code><span class="keyword">val </span>compare : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> int) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int</code></dt></dl></details></div></div></div><dl><dt class="spec type" id="type-sequence"><a href="#type-sequence" class="anchor"></a><code><span class="keyword">type </span>'a sequence</code><code><span class="keyword"> = </span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt></dl><div><div class="spec include"><div class="doc"><details open="open"><summary><span class="def"><code><span class="keyword">include </span>Base__.Container.S1<span class="keyword"> with </span><span class="keyword">type </span>'a <a href="index.html">Base__Sequence</a>.t := <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></span></summary><dl><dt class="spec value" id="val-mem"><a href="#val-mem" class="anchor"></a><code><span class="keyword">val </span>mem : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> equal:(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> bool</code></dt><dt class="spec value" id="val-length"><a href="#val-length" class="anchor"></a><code><span class="keyword">val </span>length : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int</code></dt><dt class="spec value" id="val-is_empty"><a href="#val-is_empty" class="anchor"></a><code><span class="keyword">val </span>is_empty : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dt class="spec value" id="val-iter"><a href="#val-iter" class="anchor"></a><code><span class="keyword">val </span>iter : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> f:(<span class="type-var">'a</span> <span>&#45;&gt;</span> unit) <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-fold"><a href="#val-fold" class="anchor"></a><code><span class="keyword">val </span>fold : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> init:<span class="type-var">'accum</span> <span>&#45;&gt;</span> f:(<span class="type-var">'accum</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'accum</span>) <span>&#45;&gt;</span> <span class="type-var">'accum</span></code></dt><dt class="spec value" id="val-fold_result"><a href="#val-fold_result" class="anchor"></a><code><span class="keyword">val </span>fold_result : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> init:<span class="type-var">'accum</span> <span>&#45;&gt;</span> f:(<span class="type-var">'accum</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> (<span class="type-var">'accum</span>, <span class="type-var">'e</span>) Base__.Result.t) <span>&#45;&gt;</span> (<span class="type-var">'accum</span>, <span class="type-var">'e</span>) Base__.Result.t</code></dt><dt class="spec value" id="val-fold_until"><a href="#val-fold_until" class="anchor"></a><code><span class="keyword">val </span>fold_until : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> init:<span class="type-var">'accum</span> <span>&#45;&gt;</span> f:(<span class="type-var">'accum</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> (<span class="type-var">'accum</span>, <span class="type-var">'stop</span>) Base__.Container_intf.Continue_or_stop.t) <span>&#45;&gt;</span> (<span class="type-var">'accum</span>, <span class="type-var">'stop</span>) Base__.Container_intf.Finished_or_stopped_early.t</code></dt><dt class="spec value" id="val-exists"><a href="#val-exists" class="anchor"></a><code><span class="keyword">val </span>exists : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> f:(<span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> bool</code></dt><dt class="spec value" id="val-for_all"><a href="#val-for_all" class="anchor"></a><code><span class="keyword">val </span>for_all : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> f:(<span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> bool</code></dt><dt class="spec value" id="val-count"><a href="#val-count" class="anchor"></a><code><span class="keyword">val </span>count : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> f:(<span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> int</code></dt><dt class="spec value" id="val-sum"><a href="#val-sum" class="anchor"></a><code><span class="keyword">val </span>sum : (<span class="keyword">module </span>Base__.Commutative_group.S <span class="keyword">with</span> <span class="keyword">type </span>t <span class="keyword">=</span> <span class="type-var">'sum</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> f:(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'sum</span>) <span>&#45;&gt;</span> <span class="type-var">'sum</span></code></dt><dt class="spec value" id="val-find"><a href="#val-find" class="anchor"></a><code><span class="keyword">val </span>find : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> f:(<span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <span class="type-var">'a</span> option</code></dt><dt class="spec value" id="val-find_map"><a href="#val-find_map" class="anchor"></a><code><span class="keyword">val </span>find_map : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> f:(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> option) <span>&#45;&gt;</span> <span class="type-var">'b</span> option</code></dt><dt class="spec value" id="val-to_list"><a href="#val-to_list" class="anchor"></a><code><span class="keyword">val </span>to_list : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> list</code></dt><dt class="spec value" id="val-to_array"><a href="#val-to_array" class="anchor"></a><code><span class="keyword">val </span>to_array : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> array</code></dt><dt class="spec value" id="val-min_elt"><a href="#val-min_elt" class="anchor"></a><code><span class="keyword">val </span>min_elt : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> cmp:(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> int) <span>&#45;&gt;</span> <span class="type-var">'a</span> option</code></dt><dt class="spec value" id="val-max_elt"><a href="#val-max_elt" class="anchor"></a><code><span class="keyword">val </span>max_elt : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> cmp:(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> int) <span>&#45;&gt;</span> <span class="type-var">'a</span> option</code></dt></dl></details></div></div></div><div><div class="spec include"><div class="doc"><details open="open"><summary><span class="def"><code><span class="keyword">include </span>Base__.Monad.S<span class="keyword"> with </span><span class="keyword">type </span>'a <a href="index.html">Base__Sequence</a>.t := <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></span></summary><dl><dt class="spec value" id="val-(&gt;&gt;=)"><a href="#val-(&gt;&gt;=)" class="anchor"></a><code><span class="keyword">val </span>(&gt;&gt;=) : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a>) <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-(&gt;&gt;|)"><a href="#val-(&gt;&gt;|)" class="anchor"></a><code><span class="keyword">val </span>(&gt;&gt;|) : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>) <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a></code></dt></dl><div class="spec module" id="module-Monad_infix"><a href="#module-Monad_infix" class="anchor"></a><code><span class="keyword">module </span><a href="Monad_infix/index.html">Monad_infix</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><dl><dt class="spec value" id="val-bind"><a href="#val-bind" class="anchor"></a><code><span class="keyword">val </span>bind : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> f:(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a>) <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-return"><a href="#val-return" class="anchor"></a><code><span class="keyword">val </span>return : <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-map"><a href="#val-map" class="anchor"></a><code><span class="keyword">val </span>map : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> f:(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>) <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-join"><a href="#val-join" class="anchor"></a><code><span class="keyword">val </span>join : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-ignore_m"><a href="#val-ignore_m" class="anchor"></a><code><span class="keyword">val </span>ignore_m : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-all"><a href="#val-all" class="anchor"></a><code><span class="keyword">val </span>all : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> list <span>&#45;&gt;</span> <span class="type-var">'a</span> list <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-all_ignore"><a href="#val-all_ignore" class="anchor"></a><code><span class="keyword">val </span>all_ignore : unit <a href="index.html#type-t">t</a> list <span>&#45;&gt;</span> unit <a href="index.html#type-t">t</a></code></dt></dl><div class="spec module" id="module-Let_syntax"><a href="#module-Let_syntax" class="anchor"></a><code><span class="keyword">module </span><a href="Let_syntax/index.html">Let_syntax</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div></details></div></div></div><dl><dt class="spec value" id="val-empty"><a href="#val-empty" class="anchor"></a><code><span class="keyword">val </span>empty : <span class="type-var">_</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>empty</code> is a sequence with no elements.</p></dd></dl><dl><dt class="spec value" id="val-next"><a href="#val-next" class="anchor"></a><code><span class="keyword">val </span>next : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span><span class="keyword"> * </span><span class="type-var">'a</span> <a href="index.html#type-t">t</a>) option</code></dt><dd><p><code>next</code> returns the next element of a sequence and the next tail if the sequence is not finished. It is the most primitive way to walk over a sequence.</p></dd></dl><dl><dt class="spec module" id="module-Step"><a href="#module-Step" class="anchor"></a><code><span class="keyword">module </span><a href="Step/index.html">Step</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>A <code>Step</code> describes the next step of the sequence construction. <code>Done</code> indicates the sequence is finished. <code>Skip</code> indicates the sequence continues with another state without producing the next element yet. <code>Yield</code> outputs an element and introduces a new state.</p></dd></dl><dl><dt class="spec value" id="val-unfold_step"><a href="#val-unfold_step" class="anchor"></a><code><span class="keyword">val </span>unfold_step : init:<span class="type-var">'s</span> <span>&#45;&gt;</span> f:(<span class="type-var">'s</span> <span>&#45;&gt;</span> (<span class="type-var">'a</span>, <span class="type-var">'s</span>) <a href="Step/index.html#type-t">Step.t</a>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>unfold_step ~init ~f</code> constructs a sequence by giving an initial state <code>init</code> and a function <code>f</code> explaining how to continue the next step from a given state.</p></dd></dl><dl><dt class="spec value" id="val-unfold"><a href="#val-unfold" class="anchor"></a><code><span class="keyword">val </span>unfold : init:<span class="type-var">'s</span> <span>&#45;&gt;</span> f:(<span class="type-var">'s</span> <span>&#45;&gt;</span> (<span class="type-var">'a</span><span class="keyword"> * </span><span class="type-var">'s</span>) option) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>unfold ~init f</code> is a simplified version of <code>unfold_step</code> that does not allow <code>Skip</code>.</p></dd></dl><dl><dt class="spec value" id="val-unfold_with"><a href="#val-unfold_with" class="anchor"></a><code><span class="keyword">val </span>unfold_with : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> init:<span class="type-var">'s</span> <span>&#45;&gt;</span> f:(<span class="type-var">'s</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> (<span class="type-var">'b</span>, <span class="type-var">'s</span>) <a href="Step/index.html#type-t">Step.t</a>) <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>unfold_with t ~init ~f</code> folds a state through the sequence <code>t</code> to create a new sequence</p></dd></dl><dl><dt class="spec value" id="val-unfold_with_and_finish"><a href="#val-unfold_with_and_finish" class="anchor"></a><code><span class="keyword">val </span>unfold_with_and_finish : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> init:<span class="type-var">'s_a</span> <span>&#45;&gt;</span> running_step:(<span class="type-var">'s_a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> (<span class="type-var">'b</span>, <span class="type-var">'s_a</span>) <a href="Step/index.html#type-t">Step.t</a>) <span>&#45;&gt;</span> inner_finished:(<span class="type-var">'s_a</span> <span>&#45;&gt;</span> <span class="type-var">'s_b</span>) <span>&#45;&gt;</span> finishing_step:(<span class="type-var">'s_b</span> <span>&#45;&gt;</span> (<span class="type-var">'b</span>, <span class="type-var">'s_b</span>) <a href="Step/index.html#type-t">Step.t</a>) <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>unfold_with_and_finish t ~init ~running_step ~inner_finished ~finishing_step</code> folds a state through <code>t</code> to create a new sequence (like <code>unfold_with t ~init ~f:running_step</code>), and then continues the new sequence by unfolding the final state (like <code>unfold_step ~init:(inner_finished final_state) ~f:finishing_step</code>).</p></dd></dl><dl><dt class="spec value" id="val-nth"><a href="#val-nth" class="anchor"></a><code><span class="keyword">val </span>nth : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <span class="type-var">'a</span> option</code></dt><dd><p>return the nth element</p></dd></dl><dl><dt class="spec value" id="val-nth_exn"><a href="#val-nth_exn" class="anchor"></a><code><span class="keyword">val </span>nth_exn : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dt class="spec value" id="val-mapi"><a href="#val-mapi" class="anchor"></a><code><span class="keyword">val </span>mapi : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> f:(int <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>) <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-filteri"><a href="#val-filteri" class="anchor"></a><code><span class="keyword">val </span>filteri : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> f:(int <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-filter"><a href="#val-filter" class="anchor"></a><code><span class="keyword">val </span>filter : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> f:(<span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-merge"><a href="#val-merge" class="anchor"></a><code><span class="keyword">val </span>merge : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> cmp:(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> int) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>merge t1 t2 ~cmp</code> merges two sorted sequences <code>t1</code> and <code>t2</code>, returning a sorted sequence, all according to <code>cmp</code>. If two elements are equal, the one from <code>t1</code> is preferred. The behavior is undefined if the inputs aren't sorted.</p></dd></dl><div class="spec module" id="module-Merge_with_duplicates_element"><a href="#module-Merge_with_duplicates_element" class="anchor"></a><code><span class="keyword">module </span><a href="Merge_with_duplicates_element/index.html">Merge_with_duplicates_element</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><dl><dt class="spec value" id="val-merge_with_duplicates"><a href="#val-merge_with_duplicates" class="anchor"></a><code><span class="keyword">val </span>merge_with_duplicates : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> cmp:(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> int) <span>&#45;&gt;</span> (<span class="type-var">'a</span>, <span class="type-var">'b</span>) <a href="Merge_with_duplicates_element/index.html#type-t">Merge_with_duplicates_element.t</a> <a href="index.html#type-t">t</a></code></dt><dd><p><code>merge_with_duplicates_element t1 t2 ~cmp</code> is like <code>merge</code>, except that for each element it indicates which input(s) the element comes from, using <code>Merge_with_duplicates_element</code>.</p></dd></dl><dl><dt class="spec value" id="val-hd"><a href="#val-hd" class="anchor"></a><code><span class="keyword">val </span>hd : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> option</code></dt><dt class="spec value" id="val-hd_exn"><a href="#val-hd_exn" class="anchor"></a><code><span class="keyword">val </span>hd_exn : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dt class="spec value" id="val-tl"><a href="#val-tl" class="anchor"></a><code><span class="keyword">val </span>tl : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> option</code></dt><dd><p><code>tl t</code> and <code>tl_eagerly_exn t</code> immediately evaluate the first element of <code>t</code> and return the unevaluated tail.</p></dd></dl><dl><dt class="spec value" id="val-tl_eagerly_exn"><a href="#val-tl_eagerly_exn" class="anchor"></a><code><span class="keyword">val </span>tl_eagerly_exn : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-find_mapi"><a href="#val-find_mapi" class="anchor"></a><code><span class="keyword">val </span>find_mapi : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> f:(int <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> option) <span>&#45;&gt;</span> <span class="type-var">'b</span> option</code></dt><dt class="spec value" id="val-findi"><a href="#val-findi" class="anchor"></a><code><span class="keyword">val </span>findi : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> f:(int <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> (int<span class="keyword"> * </span><span class="type-var">'a</span>) option</code></dt><dt class="spec value" id="val-find_exn"><a href="#val-find_exn" class="anchor"></a><code><span class="keyword">val </span>find_exn : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> f:(<span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p><code>find_exn t ~f</code> returns the first element of <code>t</code> that satisfies <code>f</code>. It raises if there is no such element.</p></dd></dl><dl><dt class="spec value" id="val-for_alli"><a href="#val-for_alli" class="anchor"></a><code><span class="keyword">val </span>for_alli : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> f:(int <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> bool</code></dt><dd><p>Like <code>for_all</code>, but passes the index as an argument.</p></dd></dl><dl><dt class="spec value" id="val-existsi"><a href="#val-existsi" class="anchor"></a><code><span class="keyword">val </span>existsi : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> f:(int <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> bool</code></dt><dd><p>Like <code>exists</code>, but passes the index as an argument.</p></dd></dl><dl><dt class="spec value" id="val-append"><a href="#val-append" class="anchor"></a><code><span class="keyword">val </span>append : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>append t1 t2</code> first produces the elements of <code>t1</code>, then produces the elements of <code>t2</code>.</p></dd></dl><dl><dt class="spec value" id="val-concat"><a href="#val-concat" class="anchor"></a><code><span class="keyword">val </span>concat : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>concat tt</code> produces the elements of each inner sequence sequentially. If any inner sequences are infinite, elements of subsequent inner sequences will not be reached.</p></dd></dl><dl><dt class="spec value" id="val-concat_map"><a href="#val-concat_map" class="anchor"></a><code><span class="keyword">val </span>concat_map : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> f:(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a>) <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>concat_map t ~f</code> is <code>concat (map t ~f)</code>.</p></dd></dl><dl><dt class="spec value" id="val-concat_mapi"><a href="#val-concat_mapi" class="anchor"></a><code><span class="keyword">val </span>concat_mapi : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> f:(int <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a>) <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>concat_mapi t ~f</code> is like concat_map, but passes the index as an argument.</p></dd></dl><dl><dt class="spec value" id="val-interleave"><a href="#val-interleave" class="anchor"></a><code><span class="keyword">val </span>interleave : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>interleave tt</code> produces each element of the inner sequences of <code>tt</code> eventually, even if any or all of the inner sequences are infinite. The elements of each inner sequence are produced in order with respect to that inner sequence. The manner of interleaving among the separate inner sequences is deterministic but unspecified.</p></dd></dl><dl><dt class="spec value" id="val-zip"><a href="#val-zip" class="anchor"></a><code><span class="keyword">val </span>zip : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span><span class="keyword"> * </span><span class="type-var">'b</span>) <a href="index.html#type-t">t</a></code></dt><dd><p>Transforms a pair of sequences into a sequence of pairs. The length of the returned sequence is the length of the shorter input. The remaining elements of the longer input are discarded.</p><p>WARNING: Unlike <code>List.zip</code>, this will not error out if the two input sequences are of different lengths, because <code>zip</code> may have already returned some elements by the time this becomes apparent.</p></dd></dl><dl><dt class="spec value" id="val-zip_full"><a href="#val-zip_full" class="anchor"></a><code><span class="keyword">val </span>zip_full : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> [ `Left of <span class="type-var">'a</span><span class="keyword"> | </span>`Both of <span class="type-var">'a</span><span class="keyword"> * </span><span class="type-var">'b</span><span class="keyword"> | </span>`Right of <span class="type-var">'b</span> ] <a href="index.html#type-t">t</a></code></dt><dd><p><code>zip_full</code> is like <code>zip</code>, but if one sequence ends before the other, then it keeps producing elements from the other sequence until it has ended as well.</p></dd></dl><dl><dt class="spec value" id="val-iteri"><a href="#val-iteri" class="anchor"></a><code><span class="keyword">val </span>iteri : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> f:(int <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> unit) <span>&#45;&gt;</span> unit</code></dt><dd><p><code>iteri</code> is just like <code>iter</code>, but it also passes in the index of each element to <code>f</code>.</p></dd></dl><dl><dt class="spec value" id="val-foldi"><a href="#val-foldi" class="anchor"></a><code><span class="keyword">val </span>foldi : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> f:(int <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>) <span>&#45;&gt;</span> init:<span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'b</span></code></dt><dd><p><code>foldi</code> is just like <code>fold</code>, but it also passes in the index of each element to <code>f</code>.</p></dd></dl><dl><dt class="spec value" id="val-reduce_exn"><a href="#val-reduce_exn" class="anchor"></a><code><span class="keyword">val </span>reduce_exn : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> f:(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p><code>reduce_exn f [a1; ...; an]</code> is <code>f (... (f (f a1 a2) a3) ...) an</code>. It fails on the empty sequence.</p></dd></dl><dl><dt class="spec value" id="val-reduce"><a href="#val-reduce" class="anchor"></a><code><span class="keyword">val </span>reduce : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> f:(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span> option</code></dt><dt class="spec value" id="val-find_consecutive_duplicate"><a href="#val-find_consecutive_duplicate" class="anchor"></a><code><span class="keyword">val </span>find_consecutive_duplicate : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> equal:(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> (<span class="type-var">'a</span><span class="keyword"> * </span><span class="type-var">'a</span>) option</code></dt><dd><p><code>find_consecutive_duplicate t ~equal</code> returns the first pair of consecutive elements <code>(a1, a2)</code> in <code>t</code> such that <code>equal a1 a2</code>. They are returned in the same order as they appear in <code>t</code>.</p></dd></dl><dl><dt class="spec value" id="val-remove_consecutive_duplicates"><a href="#val-remove_consecutive_duplicates" class="anchor"></a><code><span class="keyword">val </span>remove_consecutive_duplicates : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> equal:(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p>The same sequence with consecutive duplicates removed. The relative order of the other elements is unaffected.</p></dd></dl><dl><dt class="spec value" id="val-range"><a href="#val-range" class="anchor"></a><code><span class="keyword">val </span>range : ?&#8288;stride:int <span>&#45;&gt;</span> ?&#8288;start:[ `inclusive<span class="keyword"> | </span>`exclusive ] <span>&#45;&gt;</span> ?&#8288;stop:[ `inclusive<span class="keyword"> | </span>`exclusive ] <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int <a href="index.html#type-t">t</a></code></dt><dd><p><code>range ?stride ?start ?stop start_i stop_i</code> is the sequence of integers from <code>start_i</code> to <code>stop_i</code>, stepping by <code>stride</code>. If <code>stride</code> &lt; 0 then we need <code>start_i</code> &gt; <code>stop_i</code> for the result to be nonempty (or <code>start_i</code> &gt;= <code>stop_i</code> in the case where both bounds are inclusive).</p></dd></dl><dl><dt class="spec value" id="val-init"><a href="#val-init" class="anchor"></a><code><span class="keyword">val </span>init : int <span>&#45;&gt;</span> f:(int <span>&#45;&gt;</span> <span class="type-var">'a</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>init n ~f</code> is <code>[(f 0); (f 1); ...; (f (n-1))]</code>. It is an error if <code>n &lt; 0</code>.</p></dd></dl><dl><dt class="spec value" id="val-filter_map"><a href="#val-filter_map" class="anchor"></a><code><span class="keyword">val </span>filter_map : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> f:(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> option) <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>filter_map t ~f</code> produce mapped elements of <code>t</code> which are not <code>None</code>.</p></dd></dl><dl><dt class="spec value" id="val-filter_mapi"><a href="#val-filter_mapi" class="anchor"></a><code><span class="keyword">val </span>filter_mapi : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> f:(int <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> option) <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>filter_mapi</code> is just like <code>filter_map</code>, but it also passes in the index of each element to <code>f</code>.</p></dd></dl><dl><dt class="spec value" id="val-filter_opt"><a href="#val-filter_opt" class="anchor"></a><code><span class="keyword">val </span>filter_opt : <span class="type-var">'a</span> option <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>filter_opt t</code> produces the elements of <code>t</code> which are not <code>None</code>. <code>filter_opt t</code> = <code>filter_map t ~f:ident</code></p></dd></dl><dl><dt class="spec value" id="val-sub"><a href="#val-sub" class="anchor"></a><code><span class="keyword">val </span>sub : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> pos:int <span>&#45;&gt;</span> len:int <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>sub t ~pos ~len</code> is the <code>len</code>-element subsequence of <code>t</code>, starting at <code>pos</code>. If the sequence is shorter than <code>pos + len</code>, it returns <code> t[pos] ... t[l-1] </code>, where <code>l</code> is the length of the sequence.</p></dd></dl><dl><dt class="spec value" id="val-take"><a href="#val-take" class="anchor"></a><code><span class="keyword">val </span>take : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>take t n</code> produces the first <code>n</code> elements of <code>t</code>.</p></dd></dl><dl><dt class="spec value" id="val-drop"><a href="#val-drop" class="anchor"></a><code><span class="keyword">val </span>drop : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>drop t n</code> produces all elements of <code>t</code> except the first <code>n</code> elements. If there are fewer than <code>n</code> elements in <code>t</code>, there is no error; the resulting sequence simply produces no elements. Usually you will probably want to use <code>drop_eagerly</code> because it can be significantly cheaper.</p></dd></dl><dl><dt class="spec value" id="val-drop_eagerly"><a href="#val-drop_eagerly" class="anchor"></a><code><span class="keyword">val </span>drop_eagerly : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>drop_eagerly t n</code> immediately consumes the first <code>n</code> elements of <code>t</code> and returns the unevaluated tail of <code>t</code>.</p></dd></dl><dl><dt class="spec value" id="val-take_while"><a href="#val-take_while" class="anchor"></a><code><span class="keyword">val </span>take_while : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> f:(<span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>take_while t ~f</code> produces the longest prefix of <code>t</code> for which <code>f</code> applied to each element is <code>true</code>.</p></dd></dl><dl><dt class="spec value" id="val-drop_while"><a href="#val-drop_while" class="anchor"></a><code><span class="keyword">val </span>drop_while : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> f:(<span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>drop_while t ~f</code> produces the suffix of <code>t</code> beginning with the first element of <code>t</code> for which <code>f</code> is <code>false</code>. Usually you will probably want to use <code>drop_while_option</code> because it can be significantly cheaper.</p></dd></dl><dl><dt class="spec value" id="val-drop_while_option"><a href="#val-drop_while_option" class="anchor"></a><code><span class="keyword">val </span>drop_while_option : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> f:(<span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> (<span class="type-var">'a</span><span class="keyword"> * </span><span class="type-var">'a</span> <a href="index.html#type-t">t</a>) option</code></dt><dd><p><code>drop_while_option t ~f</code> immediately consumes the elements from <code>t</code> until the predicate <code>f</code> fails and returns the first element that failed along with the unevaluated tail of <code>t</code>. The first element is returned separately because the alternatives would mean forcing the consumer to evaluate the first element again (if the previous state of the sequence is returned) or take on extra cost for each element (if the element is added to the final state of the sequence using <code>shift_right</code>).</p></dd></dl><dl><dt class="spec value" id="val-split_n"><a href="#val-split_n" class="anchor"></a><code><span class="keyword">val </span>split_n : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <span class="type-var">'a</span> list<span class="keyword"> * </span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>split_n t n</code> immediately consumes the first <code>n</code> elements of <code>t</code> and returns the consumed prefix, as a list, along with the unevaluated tail of <code>t</code>.</p></dd></dl><dl><dt class="spec value" id="val-split_n_eagerly"><a href="#val-split_n_eagerly" class="anchor"></a><code><span class="keyword">val </span>split_n_eagerly : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a><span class="keyword"> * </span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>split_n_eagerly t n</code> behaves as <code>split_n t n</code>, but converts the prefix into a sequence.</p></dd></dl><dl><dt class="spec value" id="val-chunks_exn"><a href="#val-chunks_exn" class="anchor"></a><code><span class="keyword">val </span>chunks_exn : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <span class="type-var">'a</span> list <a href="index.html#type-t">t</a></code></dt><dd><p><code>chunks_exn t n</code> produces lists of elements of <code>t</code>, up to <code>n</code> elements at a time. The last list may contain fewer than <code>n</code> elements. No list contains zero elements. If <code>n</code> is not positive, it raises.</p></dd></dl><dl><dt class="spec value" id="val-shift_right"><a href="#val-shift_right" class="anchor"></a><code><span class="keyword">val </span>shift_right : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>shift_right t a</code> produces <code>a</code> and then produces each element of <code>t</code>.</p></dd></dl><dl><dt class="spec value" id="val-shift_right_with_list"><a href="#val-shift_right_with_list" class="anchor"></a><code><span class="keyword">val </span>shift_right_with_list : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>shift_right_with_list t l</code> produces the elements of <code>l</code>, then produces the elements of <code>t</code>. It is better to call <code>shift_right_with_list</code> with a list of size n than <code>shift_right</code> n times; the former will require O(1) work per element produced and the latter O(n) work per element produced.</p></dd></dl><dl><dt class="spec value" id="val-shift_left"><a href="#val-shift_left" class="anchor"></a><code><span class="keyword">val </span>shift_left : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>shift_left t n</code> is a synonym for <code>drop t n</code>.</p></dd></dl><div class="spec module" id="module-Infix"><a href="#module-Infix" class="anchor"></a><code><span class="keyword">module </span><a href="Infix/index.html">Infix</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><dl><dt class="spec value" id="val-cartesian_product"><a href="#val-cartesian_product" class="anchor"></a><code><span class="keyword">val </span>cartesian_product : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span><span class="keyword"> * </span><span class="type-var">'b</span>) <a href="index.html#type-t">t</a></code></dt><dd><p>Returns a sequence with all possible pairs. The stepper function of the second sequence passed as argument may be applied to the same state multiple times, so be careful using <code>cartesian_product</code> with expensive or side-effecting functions. If the second sequence is infinite, some values in the first sequence may not be reached.</p></dd></dl><dl><dt class="spec value" id="val-interleaved_cartesian_product"><a href="#val-interleaved_cartesian_product" class="anchor"></a><code><span class="keyword">val </span>interleaved_cartesian_product : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span><span class="keyword"> * </span><span class="type-var">'b</span>) <a href="index.html#type-t">t</a></code></dt><dd><p>Returns a sequence that eventually reaches every possible pair of elements of the inputs, even if either or both are infinite. The step function of both inputs may be applied to the same state repeatedly, so be careful using <code>interleaved_cartesian_product</code> with expensive or side-effecting functions.</p></dd></dl><dl><dt class="spec value" id="val-intersperse"><a href="#val-intersperse" class="anchor"></a><code><span class="keyword">val </span>intersperse : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> sep:<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>intersperse xs ~sep</code> produces <code>sep</code> between adjacent elements of <code>xs</code>. e.g. <code>intersperse [1;2;3] ~sep:0 = [1;0;2;0;3]</code></p></dd></dl><dl><dt class="spec value" id="val-cycle_list_exn"><a href="#val-cycle_list_exn" class="anchor"></a><code><span class="keyword">val </span>cycle_list_exn : <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>cycle_list_exn xs</code> repeats the elements of <code>xs</code> forever. If <code>xs</code> is empty, it raises.</p></dd></dl><dl><dt class="spec value" id="val-repeat"><a href="#val-repeat" class="anchor"></a><code><span class="keyword">val </span>repeat : <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>repeat a</code> repeats <code>a</code> forever.</p></dd></dl><dl><dt class="spec value" id="val-singleton"><a href="#val-singleton" class="anchor"></a><code><span class="keyword">val </span>singleton : <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>singleton a</code> produces <code>a</code> exactly once.</p></dd></dl><dl><dt class="spec value" id="val-delayed_fold"><a href="#val-delayed_fold" class="anchor"></a><code><span class="keyword">val </span>delayed_fold : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> init:<span class="type-var">'s</span> <span>&#45;&gt;</span> f:(<span class="type-var">'s</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> k:(<span class="type-var">'s</span> <span>&#45;&gt;</span> <span class="type-var">'r</span>) <span>&#45;&gt;</span> <span class="type-var">'r</span>) <span>&#45;&gt;</span> finish:(<span class="type-var">'s</span> <span>&#45;&gt;</span> <span class="type-var">'r</span>) <span>&#45;&gt;</span> <span class="type-var">'r</span></code></dt><dd><p><code>delayed_fold</code> allows to do an on-demand fold, while maintaining a state. This function is sufficient to implement <code>fold_m</code> in any monad.</p><pre><code class="ml">let fold_m t ~init ~f =
  let open M in
  delayed_fold t ~init
    ~f:(fun s a ~k -&gt; f s a &gt;&gt;= k)
    ~finish:return</code></pre><p>It is possible to exit early by not calling <code>k</code> in <code>f</code>. It is also possible to call <code>k</code> multiple times. This results in the rest of the sequence being folded over multiple times, independently.</p><p>Note that <code>delayed_fold</code>, when targeting JavaScript, can result in stack overflow as JavaScript doesn't generally have tail call optimization.</p></dd></dl><dl><dt class="spec value" id="val-to_list"><a href="#val-to_list" class="anchor"></a><code><span class="keyword">val </span>to_list : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> list</code></dt><dt class="spec value" id="val-to_list_rev"><a href="#val-to_list_rev" class="anchor"></a><code><span class="keyword">val </span>to_list_rev : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> list</code></dt><dd><p><code>to_list_rev t</code> returns a list of the elements of <code>t</code>, in reverse order. It is faster than <code>to_list</code>.</p></dd></dl><dl><dt class="spec value" id="val-of_list"><a href="#val-of_list" class="anchor"></a><code><span class="keyword">val </span>of_list : <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-of_lazy"><a href="#val-of_lazy" class="anchor"></a><code><span class="keyword">val </span>of_lazy : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> Base__.Lazy.t <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>of_lazy t_lazy</code> produces a sequence that forces <code>t_lazy</code> the first time it needs to compute an element.</p></dd></dl><dl><dt class="spec value" id="val-memoize"><a href="#val-memoize" class="anchor"></a><code><span class="keyword">val </span>memoize : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>memoize t</code> produces each element of <code>t</code>, but also memoizes them so that if you consume the same element multiple times it is only computed once. It's a non-eager version of <code>force_eagerly</code>.</p></dd></dl><dl><dt class="spec value" id="val-force_eagerly"><a href="#val-force_eagerly" class="anchor"></a><code><span class="keyword">val </span>force_eagerly : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>force_eagerly t</code> precomputes the sequence. It is behaviorally equivalent to <code>of_list
    (to_list t)</code>, but may at some point have a more efficient implementation. It's an eager version of <code>memoize</code>.</p></dd></dl><dl><dt class="spec value" id="val-bounded_length"><a href="#val-bounded_length" class="anchor"></a><code><span class="keyword">val </span>bounded_length : <span class="type-var">_</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> at_most:int <span>&#45;&gt;</span> [ `Is of int<span class="keyword"> | </span>`Greater ]</code></dt><dd><p><code>bounded_length ~at_most t</code> returns <code>`Is len</code> if <code>len = length t &lt;= at_most</code>, and otherwise returns <code>`Greater</code>. Walks through only as much of the sequence as necessary. Always returns <code>`Greater</code> if <code>at_most &lt; 0</code>.</p></dd></dl><dl><dt class="spec value" id="val-length_is_bounded_by"><a href="#val-length_is_bounded_by" class="anchor"></a><code><span class="keyword">val </span>length_is_bounded_by : ?&#8288;min:int <span>&#45;&gt;</span> ?&#8288;max:int <span>&#45;&gt;</span> <span class="type-var">_</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>length_is_bounded_by ~min ~max t</code> returns true if <code>min &lt;= length t</code> and <code>length t &lt;=
    max</code> When <code>min</code> or <code>max</code> are not provided, the check for that bound is omitted. Walks through only as much of the sequence as necessary.</p></dd></dl><aside><p><code>Generator</code> is a monadic interface to generate sequences in a direct style, similar to Python's generators.</p><p>Here are some examples:</p><pre><code class="ml">open Generator

let rec traverse_list = function
  | [] -&gt; return ()
  | x :: xs -&gt; yield x &gt;&gt;= fun () -&gt; traverse_list xs

let traverse_option = function
  | None -&gt; return ()
  | Some x -&gt; yield x

let traverse_array arr =
  let n = Array.length arr in
  let rec loop i =
    if i &gt;= n then return () else yield arr.(i) &gt;&gt;= fun () -&gt; loop (i + 1)
  in
  loop 0

let rec traverse_bst = function
  | Node.Empty -&gt; return ()
  | Node.Branch (left, value, right) -&gt;
    traverse_bst left  &gt;&gt;= fun () -&gt;
    yield        value &gt;&gt;= fun () -&gt;
    traverse_bst right

let sequence_of_list   x = Generator.run (traverse_list   x)
let sequence_of_option x = Generator.run (traverse_option x)
let sequence_of_array  x = Generator.run (traverse_array  x)
let sequence_of_bst    x = Generator.run (traverse_bst    x)</code></pre></aside><div class="spec module" id="module-Generator"><a href="#module-Generator" class="anchor"></a><code><span class="keyword">module </span><a href="Generator/index.html">Generator</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div></div></body></html>