<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>BatBitSet (batteries.BatBitSet)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../index.html">batteries</a> &#x00BB; BatBitSet</nav><h1>Module <code>BatBitSet</code></h1><p>Efficient bit sets.</p><p>A bitset is an array of boolean values that can be accessed with indexes like an array but provides a better memory usage (divided by Sys.word_size; either 32 or 64) for a very small speed trade-off. It can provide efficient storage of dense sets of nonnegative integers near zero. Sparse sets should use <code>BatSet</code>, sets with large ranges of contiguous ints should use <code>BatISet</code>.</p><dl><dt>author</dt><dd>Nicolas Cannasse</dd></dl><dl><dt>author</dt><dd>David Teller (Boilerplate code)</dd></dl><nav class="toc"><ul><li><a href="#in-place-update">In-place Update</a></li><li><a href="#return-new-bitset">Return new bitset</a></li><li><a href="#boilerplate-code">Boilerplate code</a></li></ul></nav></header><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type </span>t</code></dt></dl><dl><dt class="spec value" id="val-empty"><a href="#val-empty" class="anchor"></a><code><span class="keyword">val </span>empty : unit <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Create an empty bitset of capacity 0, the bitset will automatically expand when needed.</p><p>Example: <code>BitSet.empty ()</code></p></dd></dl><dl><dt class="spec value" id="val-create"><a href="#val-create" class="anchor"></a><code><span class="keyword">val </span>create : int <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Create an empty bitset with at least an initial capacity (in number of bits).</p><p>Example: <code>BitSet.create 0 = BitSet.empty ()</code></p><dl><dt>raises Invalid_argument</dt><dd><p>on negative capacity</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-create_full"><a href="#val-create_full" class="anchor"></a><code><span class="keyword">val </span>create_full : int <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Create a full bitset with at least initial capacity (in number of bits). All the bit under the defined capacity will be set.</p><p>Example: <code>BitSet.count (BitSet.create_full n) = n</code></p><dl><dt>raises Invalid_argument</dt><dd><p>on negative capacity</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-copy"><a href="#val-copy" class="anchor"></a><code><span class="keyword">val </span>copy : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Copy a bitset : further modifications of first one will not affect the copy.</p><p>Example: <code>
    let a = Bitset.create 8 in
    let b = BitSet.copy a in
    BitSet.set a 6;
    BitSet.mem a 6 &amp;&amp; not (BitSet.mem b 6)</code></p></dd></dl><dl><dt class="spec value" id="val-mem"><a href="#val-mem" class="anchor"></a><code><span class="keyword">val </span>mem : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> bool</code></dt><dd><p><code>mem s n</code> returns true if nth-bit in the bitset <code>s</code> is set, or false otherwise.</p><p>Example: <code>let a = BitSet.create_full 256 in not (BitSet.mem a 300)</code></p><dl><dt>raises Invalid_argument</dt><dd><p>on negative index (<code>n &lt; 0</code>)</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-count"><a href="#val-count" class="anchor"></a><code><span class="keyword">val </span>count : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int</code></dt><dd><p><code>count s</code> returns the number of bits set in the bitset <code>s</code>. Also known as Population Count, or <code>cardinal</code> for sets.</p><p>Example: <code>BitSet.count (BitSet.of_list [6;4;2;2;1]) = 4</code></p></dd></dl><dl><dt class="spec value" id="val-next_set_bit"><a href="#val-next_set_bit" class="anchor"></a><code><span class="keyword">val </span>next_set_bit : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int option</code></dt><dd><p><code>next_set_bit s n</code> returns <code>Some m</code> when <code>m</code> is the next set element with index greater than or equal <code>n</code>, or None if no such element exists (i.e. <code>n</code> is greater than the largest element)</p><p>More efficient than scanning with repeated <code>BitSet.mem</code>.</p><dl><dt>raises Invalid_argument</dt><dd><p>on negative index (<code>n &lt; 0</code>)</p></dd></dl></dd></dl><section><header><h6 id="in-place-update"><a href="#in-place-update" class="anchor"></a>In-place Update</h6></header><aside><p>These functions modify an existing bitset.</p></aside><dl><dt class="spec value" id="val-set"><a href="#val-set" class="anchor"></a><code><span class="keyword">val </span>set : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> unit</code></dt><dd><p><code>set s n</code> sets the <code>n</code>th-bit in the bitset <code>s</code> to true.</p><dl><dt>raises Invalid_argument</dt><dd><p>on negative index (<code>n &lt; 0</code>)</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-unset"><a href="#val-unset" class="anchor"></a><code><span class="keyword">val </span>unset : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> unit</code></dt><dd><p><code>unset s n</code> sets the <code>n</code>th-bit in the bitset <code>s</code> to false.</p><dl><dt>raises Invalid_argument</dt><dd><p>on negative index (<code>n &lt; 0</code>)</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-put"><a href="#val-put" class="anchor"></a><code><span class="keyword">val </span>put : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool <span>&#45;&gt;</span> int <span>&#45;&gt;</span> unit</code></dt><dd><p><code>put s v n</code> sets the nth-bit in the bitset <code>s</code> to <code>v</code>.</p><dl><dt>raises Invalid_argument</dt><dd><p>on negative index (<code>n &lt; 0</code>)</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-toggle"><a href="#val-toggle" class="anchor"></a><code><span class="keyword">val </span>toggle : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> unit</code></dt><dd><p><code>toggle s n</code> changes the nth-bit value in the bitset <code>s</code>.</p><dl><dt>raises Invalid_argument</dt><dd><p>on negative index (<code>n &lt; 0</code>)</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-intersect"><a href="#val-intersect" class="anchor"></a><code><span class="keyword">val </span>intersect : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>intersect s t</code> sets <code>s</code> to the intersection of the sets <code>s</code> and <code>t</code>.</p></dd></dl><dl><dt class="spec value" id="val-unite"><a href="#val-unite" class="anchor"></a><code><span class="keyword">val </span>unite : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>unite s t</code> sets <code>s</code> to the union of the sets <code>s</code> and <code>t</code>.</p></dd></dl><dl><dt class="spec value" id="val-differentiate"><a href="#val-differentiate" class="anchor"></a><code><span class="keyword">val </span>differentiate : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>differentiate s t</code> removes the elements of <code>t</code> from <code>s</code>.</p></dd></dl><dl><dt class="spec value" id="val-differentiate_sym"><a href="#val-differentiate_sym" class="anchor"></a><code><span class="keyword">val </span>differentiate_sym : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>differentiate_sym s t</code> sets <code>s</code> to the symmetrical difference of the sets <code>s</code> and <code>t</code>.</p></dd></dl></section><section><header><h6 id="return-new-bitset"><a href="#return-new-bitset" class="anchor"></a>Return new bitset</h6></header><aside><p>These functions return a new bitset that shares nothing with the input bitset. This is not as efficient as the in-place update.</p></aside><dl><dt class="spec value" id="val-add"><a href="#val-add" class="anchor"></a><code><span class="keyword">val </span>add : int <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>add n s</code> returns a copy of <code>s</code> with bit <code>n</code> true.</p><dl><dt>raises Invalid_argument</dt><dd><p>on negative index (<code>n &lt; 0</code>)</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-remove"><a href="#val-remove" class="anchor"></a><code><span class="keyword">val </span>remove : int <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>remove n s</code> returns a copy of <code>s</code> with bit <code>n</code> false.</p><dl><dt>raises Invalid_argument</dt><dd><p>on negative index (<code>n &lt; 0</code>)</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-inter"><a href="#val-inter" class="anchor"></a><code><span class="keyword">val </span>inter : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>inter s t</code> returns the intersection of sets <code>s</code> and <code>t</code>.</p></dd></dl><dl><dt class="spec value" id="val-union"><a href="#val-union" class="anchor"></a><code><span class="keyword">val </span>union : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>union s t</code> return the union of sets <code>s</code> and <code>t</code>.</p></dd></dl><dl><dt class="spec value" id="val-diff"><a href="#val-diff" class="anchor"></a><code><span class="keyword">val </span>diff : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>diff s t</code> returns <code>s</code>-<code>t</code>.</p></dd></dl><dl><dt class="spec value" id="val-sym_diff"><a href="#val-sym_diff" class="anchor"></a><code><span class="keyword">val </span>sym_diff : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>sym_diff s t</code> returns the symmetrical difference of <code>s</code> and <code>t</code>.</p></dd></dl></section><section><header><h6 id="boilerplate-code"><a href="#boilerplate-code" class="anchor"></a>Boilerplate code</h6></header><dl><dt class="spec value" id="val-print"><a href="#val-print" class="anchor"></a><code><span class="keyword">val </span>print : <span class="type-var">'a</span> BatInnerIO.output <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-enum"><a href="#val-enum" class="anchor"></a><code><span class="keyword">val </span>enum : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int BatEnum.t</code></dt><dd><p><code>enum s</code> returns an enumeration of bits which are set in the bitset <code>s</code>.</p></dd></dl><dl><dt class="spec value" id="val-of_enum"><a href="#val-of_enum" class="anchor"></a><code><span class="keyword">val </span>of_enum : ?&#8288;cap:int <span>&#45;&gt;</span> int BatEnum.t <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>of_enum ~cap e</code> builds a bitset of capacity <code>cap</code> an enumeration of ints <code>e</code>.</p><p>Note: Performance of this function may be poor if enumeration is in increasing order and the max.</p></dd></dl><dl><dt class="spec value" id="val-of_list"><a href="#val-of_list" class="anchor"></a><code><span class="keyword">val </span>of_list : ?&#8288;cap:int <span>&#45;&gt;</span> int list <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>As <code>of_enum</code>, but from a list</p></dd></dl><dl><dt class="spec value" id="val-compare"><a href="#val-compare" class="anchor"></a><code><span class="keyword">val </span>compare : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int</code></dt><dd><p><code>compare s1 s2</code> compares two bitsets using a lexicographic ordering. Highest bit indexes are compared first. The capacity of the bitsets is not important for this comparison, only the bits starting with the highest set bit and going down.</p></dd></dl><dl><dt class="spec value" id="val-equal"><a href="#val-equal" class="anchor"></a><code><span class="keyword">val </span>equal : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>equal s1 s2</code> returns true if, and only if, all bits values in s1 are the same as in s2.</p></dd></dl><dl><dt class="spec value" id="val-ord"><a href="#val-ord" class="anchor"></a><code><span class="keyword">val </span>ord : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> BatOrd.order</code></dt><dd><p><code>ord s1 s2</code> returns <code>BatOrd.Lt</code>, <code>BatOrd.Eq</code> or <code>BatOrd.Gt</code> if <code>compare s1 s2</code> is, respectively, <code>&lt; 0</code>, <code>0</code> or <code>&gt; 0</code>.</p></dd></dl><dl><dt class="spec value" id="val-capacity"><a href="#val-capacity" class="anchor"></a><code><span class="keyword">val </span>capacity : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int</code></dt><dd><h6 id="internals"><a href="#internals" class="anchor"></a>Internals</h6><p><code>capacity s</code> returns the number of bits, both set and unset, stored in <code>s</code>. This is guaranteed to be larger than the largest element (set bit index) in <code>s</code>.</p></dd></dl></section></div></body></html>