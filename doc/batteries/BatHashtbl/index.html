<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>BatHashtbl (batteries.BatHashtbl)</title><link rel="stylesheet" href="../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../index.html">batteries</a> &#x00BB; BatHashtbl</nav><h1>Module <code>BatHashtbl</code></h1><p>Extra functions over hashtables.</p><nav class="toc"><ul><li><a href="#base-operations">Base operations</a></li><li><a href="#enumerations">Enumerations</a></li><li><a href="#lists">Lists</a></li><li><a href="#searching">Searching</a></li><li><a href="#traversing">Traversing</a></li><li><a href="#the-polymorphic-hash-primitive">The polymorphic hash primitive</a></li><li><a href="#boilerplate-code">Boilerplate code</a></li><li><a href="#printing">Printing</a></li><li><a href="#override-modules">Override modules</a></li><li><a href="#functorial-interface">Functorial interface</a></li></ul></nav></header><aside><p>Operations over hashtables.</p><p>This module replaces Stdlib's <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Hashtbl.html">Hashtbl</a> module. All functions and types are provided here.</p><dl><dt>author</dt><dd>Xavier Leroy (base module)</dd></dl><dl><dt>author</dt><dd>Damien Doligez (base module)</dd></dl><dl><dt>author</dt><dd>Nicolas Cannasse</dd></dl><dl><dt>author</dt><dd>David Teller</dd></dl></aside><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> ('a, 'b) t</code><code> = (<span class="type-var">'a</span>, <span class="type-var">'b</span>) <a href="../../ocaml/Stdlib/Hashtbl/index.html#type-t">Stdlib.Hashtbl.t</a></code></dt><dd><p>A Hashtable wth keys of type 'a and values 'b</p></dd></dl><section><header><h6 id="base-operations"><a href="#base-operations" class="anchor"></a>Base operations</h6></header><dl><dt class="spec value" id="val-create"><a href="#val-create" class="anchor"></a><code><span class="keyword">val</span> create : int <span>&#45;&gt;</span> (<span class="type-var">'a</span>, <span class="type-var">'b</span>) <a href="index.html#type-t">t</a></code></dt><dd><p><code>Hashtbl.create n</code> creates a new, empty hash table, with initial size <code>n</code>. For best results, <code>n</code> should be on the order of the expected number of elements that will be in the table. The table grows as needed, so <code>n</code> is just an initial guess.</p></dd></dl><dl><dt class="spec value" id="val-length"><a href="#val-length" class="anchor"></a><code><span class="keyword">val</span> length : (<span class="type-var">'a</span>, <span class="type-var">'b</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int</code></dt><dd><p><code>Hashtbl.length tbl</code> returns the number of bindings in <code>tbl</code>. Multiple bindings are counted multiply, so <code>Hashtbl.length</code> gives the number of times <code>Hashtbl.iter</code> calls its first argument.</p></dd></dl><dl><dt class="spec value" id="val-is_empty"><a href="#val-is_empty" class="anchor"></a><code><span class="keyword">val</span> is_empty : (<span class="type-var">'a</span>, <span class="type-var">'b</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>Hashtbl.is_empty tbl</code> returns <code>true</code> if there are no bindings in <code>tbl</code>, false otherwise.</p></dd></dl><dl><dt class="spec value" id="val-add"><a href="#val-add" class="anchor"></a><code><span class="keyword">val</span> add : (<span class="type-var">'a</span>, <span class="type-var">'b</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>Hashtbl.add tbl x y</code> adds a binding of <code>x</code> to <code>y</code> in table <code>tbl</code>. Previous bindings for <code>x</code> are not removed, but simply hidden. That is, after performing <span class="xref-unresolved" title="unresolved reference to &quot;Hashtbl.remove&quot;"><code>Hashtbl</code>.remove</span><code> tbl x</code>, the previous binding for <code>x</code>, if any, is restored. (Same behavior as with association lists.)</p></dd></dl><dl><dt class="spec value" id="val-remove"><a href="#val-remove" class="anchor"></a><code><span class="keyword">val</span> remove : (<span class="type-var">'a</span>, <span class="type-var">'b</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>Hashtbl.remove tbl x</code> removes the current binding of <code>x</code> in <code>tbl</code>, restoring the previous binding if it exists. It does nothing if <code>x</code> is not bound in <code>tbl</code>.</p></dd></dl><dl><dt class="spec value" id="val-remove_all"><a href="#val-remove_all" class="anchor"></a><code><span class="keyword">val</span> remove_all : (<span class="type-var">'a</span>, <span class="type-var">'b</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> unit</code></dt><dd><p>Remove all bindings for the given key</p></dd></dl><dl><dt class="spec value" id="val-replace"><a href="#val-replace" class="anchor"></a><code><span class="keyword">val</span> replace : (<span class="type-var">'a</span>, <span class="type-var">'b</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>Hashtbl.replace tbl x y</code> replaces the current binding of <code>x</code> in <code>tbl</code> by a binding of <code>x</code> to <code>y</code>. If <code>x</code> is unbound in <code>tbl</code>, a binding of <code>x</code> to <code>y</code> is added to <code>tbl</code>. This is functionally equivalent to <span class="xref-unresolved" title="unresolved reference to &quot;Hashtbl.remove&quot;"><code>Hashtbl</code>.remove</span><code> tbl x</code> followed by <span class="xref-unresolved" title="unresolved reference to &quot;Hashtbl.add&quot;"><code>Hashtbl</code>.add</span><code> tbl x y</code>.</p></dd></dl><dl><dt class="spec value" id="val-modify"><a href="#val-modify" class="anchor"></a><code><span class="keyword">val</span> modify : <span class="type-var">'a</span> <span>&#45;&gt;</span> (<span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>) <span>&#45;&gt;</span> (<span class="type-var">'a</span>, <span class="type-var">'b</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>Hashtbl.modify k f tbl</code> replaces the first binding for <code>k</code> in <code>tbl</code> with <code>f</code> applied to that value.</p><dl><dt>raises Not_found</dt><dd><p>if <code>k</code> is unbound in <code>tbl</code>.</p></dd></dl><dl><dt>since</dt><dd>2.1</dd></dl></dd></dl><dl><dt class="spec value" id="val-modify_def"><a href="#val-modify_def" class="anchor"></a><code><span class="keyword">val</span> modify_def : <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> (<span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>) <span>&#45;&gt;</span> (<span class="type-var">'a</span>, <span class="type-var">'b</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>Hashtbl.modify_def v k f tbl</code> does the same as <code>Hashtbl.modify k f tbl</code> but <code>f v</code> is inserted in <code>tbl</code> if <code>k</code> was unbound.</p><dl><dt>since</dt><dd>2.1</dd></dl></dd></dl><dl><dt class="spec value" id="val-modify_opt"><a href="#val-modify_opt" class="anchor"></a><code><span class="keyword">val</span> modify_opt : <span class="type-var">'a</span> <span>&#45;&gt;</span> (<span class="type-var">'b</span> option <span>&#45;&gt;</span> <span class="type-var">'b</span> option) <span>&#45;&gt;</span> (<span class="type-var">'a</span>, <span class="type-var">'b</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>Hashtbl.modify_opt k f tbl</code> allows to remove, modify or add a binding for <code>k</code> in <code>tbl</code>. <code>f</code> will be called with <code>None</code> if <code>k</code> was unbound. first previous binding of <code>k</code> in <code>tbl</code> will be deleted if <code>f</code> returns <code>None</code>. Otherwise, the previous binding is replaced by the value produced by <code>f</code>.</p><dl><dt>since</dt><dd>2.1</dd></dl></dd></dl><dl><dt class="spec value" id="val-copy"><a href="#val-copy" class="anchor"></a><code><span class="keyword">val</span> copy : (<span class="type-var">'a</span>, <span class="type-var">'b</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span>, <span class="type-var">'b</span>) <a href="index.html#type-t">t</a></code></dt><dd><p>Return a copy of the given hashtable.</p></dd></dl><dl><dt class="spec value" id="val-clear"><a href="#val-clear" class="anchor"></a><code><span class="keyword">val</span> clear : (<span class="type-var">'a</span>, <span class="type-var">'b</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Empty a hash table.</p></dd></dl></section><section><header><h6 id="enumerations"><a href="#enumerations" class="anchor"></a>Enumerations</h6></header><dl><dt class="spec value" id="val-keys"><a href="#val-keys" class="anchor"></a><code><span class="keyword">val</span> keys : (<span class="type-var">'a</span>, <span class="type-var">'b</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="../BatEnum/index.html#type-t">BatEnum.t</a></code></dt><dd><p>Return an enumeration of all the keys of a hashtable. If the key is in the Hashtable multiple times, all occurrences will be returned.</p></dd></dl><dl><dt class="spec value" id="val-values"><a href="#val-values" class="anchor"></a><code><span class="keyword">val</span> values : (<span class="type-var">'a</span>, <span class="type-var">'b</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="../BatEnum/index.html#type-t">BatEnum.t</a></code></dt><dd><p>Return an enumeration of all the values of a hashtable.</p></dd></dl><dl><dt class="spec value" id="val-enum"><a href="#val-enum" class="anchor"></a><code><span class="keyword">val</span> enum : (<span class="type-var">'a</span>, <span class="type-var">'b</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span> * <span class="type-var">'b</span>) <a href="../BatEnum/index.html#type-t">BatEnum.t</a></code></dt><dd><p>Return an enumeration of (key,value) pairs of a hashtable.</p></dd></dl><dl><dt class="spec value" id="val-of_enum"><a href="#val-of_enum" class="anchor"></a><code><span class="keyword">val</span> of_enum : (<span class="type-var">'a</span> * <span class="type-var">'b</span>) <a href="../BatEnum/index.html#type-t">BatEnum.t</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span>, <span class="type-var">'b</span>) <a href="index.html#type-t">t</a></code></dt><dd><p>Create a hashtable from a (key,value) enumeration.</p></dd></dl></section><section><header><h6 id="lists"><a href="#lists" class="anchor"></a>Lists</h6></header><dl><dt class="spec value" id="val-of_list"><a href="#val-of_list" class="anchor"></a><code><span class="keyword">val</span> of_list : (<span class="type-var">'a</span> * <span class="type-var">'b</span>) list <span>&#45;&gt;</span> (<span class="type-var">'a</span>, <span class="type-var">'b</span>) <a href="index.html#type-t">t</a></code></dt><dd><p>Create a hashtable from a list of (key,value) pairs.</p><dl><dt>since</dt><dd>2.6.0</dd></dl></dd></dl><dl><dt class="spec value" id="val-to_list"><a href="#val-to_list" class="anchor"></a><code><span class="keyword">val</span> to_list : (<span class="type-var">'a</span>, <span class="type-var">'b</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span> * <span class="type-var">'b</span>) list</code></dt><dd><p>Return the list of (key,value) pairs.</p><dl><dt>since</dt><dd>2.6.0</dd></dl></dd></dl><dl><dt class="spec value" id="val-bindings"><a href="#val-bindings" class="anchor"></a><code><span class="keyword">val</span> bindings : (<span class="type-var">'a</span>, <span class="type-var">'b</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span> * <span class="type-var">'b</span>) list</code></dt><dd><p>Alias for <code>to_list</code>.</p><dl><dt>since</dt><dd>2.6.0</dd></dl></dd></dl></section><section><header><h6 id="searching"><a href="#searching" class="anchor"></a>Searching</h6></header><dl><dt class="spec value" id="val-find"><a href="#val-find" class="anchor"></a><code><span class="keyword">val</span> find : (<span class="type-var">'a</span>, <span class="type-var">'b</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span></code></dt><dd><p><code>Hashtbl.find tbl x</code> returns the current binding of <code>x</code> in <code>tbl</code>, or raises <code>Not_found</code> if no such binding exists.</p></dd></dl><dl><dt class="spec value" id="val-find_all"><a href="#val-find_all" class="anchor"></a><code><span class="keyword">val</span> find_all : (<span class="type-var">'a</span>, <span class="type-var">'b</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> list</code></dt><dd><p><code>Hashtbl.find_all tbl x</code> returns the list of all data associated with <code>x</code> in <code>tbl</code>. The current binding is returned first, then the previous bindings, in reverse order of introduction in the table.</p></dd></dl><dl><dt class="spec value" id="val-find_default"><a href="#val-find_default" class="anchor"></a><code><span class="keyword">val</span> find_default : (<span class="type-var">'a</span>, <span class="type-var">'b</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'b</span></code></dt><dd><p><code>Hashtbl.find_default tbl key default</code> finds a binding for <code>key</code>, or return <code>default</code> if <code>key</code> is unbound in <code>tbl</code>.</p></dd></dl><dl><dt class="spec value" id="val-find_option"><a href="#val-find_option" class="anchor"></a><code><span class="keyword">val</span> find_option : (<span class="type-var">'a</span>, <span class="type-var">'b</span>) <a href="../../ocaml/Stdlib/Hashtbl/index.html#type-t">Stdlib.Hashtbl.t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> option</code></dt><dd><p>Find a binding for the key, or return <code>None</code> if no value is found</p></dd></dl><dl><dt class="spec value" id="val-mem"><a href="#val-mem" class="anchor"></a><code><span class="keyword">val</span> mem : (<span class="type-var">'a</span>, <span class="type-var">'b</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>Hashtbl.mem tbl x</code> checks if <code>x</code> is bound in <code>tbl</code>.</p></dd></dl></section><section><header><h6 id="traversing"><a href="#traversing" class="anchor"></a>Traversing</h6><p>A number of higher-order functions are provided to allow purely functional traversal or transformation of hashtables. These functions are similar to their counterparts in module <a href="../BatEnum/index.html"><code>BatEnum</code></a>.</p><p>Whenever you wish to traverse or transfor a hashtable, you have the choice between using the more general functions of <a href="../BatEnum/index.html"><code>BatEnum</code></a>, with <a href="index.html#val-keys"><code>keys</code></a>, <a href="index.html#val-values"><code>values</code></a>, <a href="index.html#val-enum"><code>enum</code></a> and <a href="index.html#val-of_enum"><code>of_enum</code></a>, or the more optimized functions of this section.</p><p>If you are new to OCaml or unsure about data structure, using the functions of <a href="../BatEnum/index.html"><code>BatEnum</code></a> is a safe bet. Should you wish to improve performance at the cost of generality, you will always be able to rewrite your code to make use of the functions of this section.</p></header><dl><dt class="spec value" id="val-iter"><a href="#val-iter" class="anchor"></a><code><span class="keyword">val</span> iter : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> unit) <span>&#45;&gt;</span> (<span class="type-var">'a</span>, <span class="type-var">'b</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>Hashtbl.iter f tbl</code> applies <code>f</code> to all bindings in table <code>tbl</code>. <code>f</code> receives the key as first argument, and the associated value as second argument. Each binding is presented exactly once to <code>f</code>. The order in which the bindings are passed to <code>f</code> is unspecified. However, if the table contains several bindings for the same key, they are passed to <code>f</code> in reverse order of introduction, that is, the most recent binding is passed first.</p></dd></dl><dl><dt class="spec value" id="val-fold"><a href="#val-fold" class="anchor"></a><code><span class="keyword">val</span> fold : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'c</span> <span>&#45;&gt;</span> <span class="type-var">'c</span>) <span>&#45;&gt;</span> (<span class="type-var">'a</span>, <span class="type-var">'b</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'c</span> <span>&#45;&gt;</span> <span class="type-var">'c</span></code></dt><dd><p><code>Hashtbl.fold f tbl init</code> computes <code>(f kN dN ... (f k1 d1 (f k0 d0 init))...)</code>, where <code>k0,k1..kN</code> are the keys of all bindings in <code>tbl</code>, and <code>d0,d1..dN</code> are the associated values. Each binding is presented exactly once to <code>f</code>. The order in which the bindings are passed to <code>f</code> is unspecified. However, if the table contains several bindings for the same key, they are passed to <code>f</code> in reverse order of introduction, that is, the most recent binding is passed first.</p></dd></dl><dl><dt class="spec value" id="val-map"><a href="#val-map" class="anchor"></a><code><span class="keyword">val</span> map : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'c</span>) <span>&#45;&gt;</span> (<span class="type-var">'a</span>, <span class="type-var">'b</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span>, <span class="type-var">'c</span>) <a href="index.html#type-t">t</a></code></dt><dd><p><code>map f x</code> creates a new hashtable with the same keys as <code>x</code>, but with the function <code>f</code> applied to all the values</p></dd></dl><dl><dt class="spec value" id="val-map_inplace"><a href="#val-map_inplace" class="anchor"></a><code><span class="keyword">val</span> map_inplace : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>) <span>&#45;&gt;</span> (<span class="type-var">'a</span>, <span class="type-var">'b</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>map_inplace f x</code> replace all values currently bound in <code>x</code> by <code>f</code> applied to each value.</p><dl><dt>since</dt><dd>2.1</dd></dl></dd></dl><dl><dt class="spec value" id="val-filter"><a href="#val-filter" class="anchor"></a><code><span class="keyword">val</span> filter : (<span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> (<span class="type-var">'key</span>, <span class="type-var">'a</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<span class="type-var">'key</span>, <span class="type-var">'a</span>) <a href="index.html#type-t">t</a></code></dt><dd><p><code>filter f m</code> returns a new hashtable where only the values <code>a</code> of <code>m</code> such that <code>f a = true</code> remain.</p></dd></dl><dl><dt class="spec value" id="val-filter_inplace"><a href="#val-filter_inplace" class="anchor"></a><code><span class="keyword">val</span> filter_inplace : (<span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> (<span class="type-var">'key</span>, <span class="type-var">'a</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>filter_inplace f m</code> removes from <code>m</code> all bindings that does not satisfy the predicate f.</p><dl><dt>since</dt><dd>2.1</dd></dl></dd></dl><dl><dt class="spec value" id="val-filteri"><a href="#val-filteri" class="anchor"></a><code><span class="keyword">val</span> filteri : (<span class="type-var">'key</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> (<span class="type-var">'key</span>, <span class="type-var">'a</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<span class="type-var">'key</span>, <span class="type-var">'a</span>) <a href="index.html#type-t">t</a></code></dt><dd><p><code>filteri f m</code> returns a hashtbl where only the key, values pairs <code>key</code>, <code>a</code> of <code>m</code> such that <code>f key a = true</code> remain.</p></dd></dl><dl><dt class="spec value" id="val-filteri_inplace"><a href="#val-filteri_inplace" class="anchor"></a><code><span class="keyword">val</span> filteri_inplace : (<span class="type-var">'key</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> (<span class="type-var">'key</span>, <span class="type-var">'a</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>filteri_inplace f m</code> performs as filter_inplace but <code>f</code> receive the value in additiuon to the key.</p><dl><dt>since</dt><dd>2.1</dd></dl></dd></dl><dl><dt class="spec value" id="val-filter_map"><a href="#val-filter_map" class="anchor"></a><code><span class="keyword">val</span> filter_map : (<span class="type-var">'key</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> option) <span>&#45;&gt;</span> (<span class="type-var">'key</span>, <span class="type-var">'a</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<span class="type-var">'key</span>, <span class="type-var">'b</span>) <a href="index.html#type-t">t</a></code></dt><dd><p><code>filter_map f m</code> combines the features of <code>filteri</code> and <code>map</code>. It calls <code>f key0 a0</code>, <code>f key1 a1</code>, <code>f keyn an</code> where <code>a0,a1..an</code> are the elements of <code>m</code> and <code>key0..keyn</code> the corresponding keys. It returns a hashtbl with associations <code>keyi</code>,<code>bi</code> where <code>f keyi ai =
    Some bi</code>. When <code>f</code> returns <code>None</code>, the corresponding element of <code>m</code> is discarded.</p></dd></dl><dl><dt class="spec value" id="val-filter_map_inplace"><a href="#val-filter_map_inplace" class="anchor"></a><code><span class="keyword">val</span> filter_map_inplace : (<span class="type-var">'key</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> option) <span>&#45;&gt;</span> (<span class="type-var">'key</span>, <span class="type-var">'a</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>filter_map_inplace f m</code> performs like filter_map but modify <code>m</code> inplace instead of creating a new Hashtbl.</p></dd></dl></section><section><header><h6 id="the-polymorphic-hash-primitive"><a href="#the-polymorphic-hash-primitive" class="anchor"></a>The polymorphic hash primitive</h6></header><dl><dt class="spec value" id="val-hash"><a href="#val-hash" class="anchor"></a><code><span class="keyword">val</span> hash : <span class="type-var">'a</span> <span>&#45;&gt;</span> int</code></dt><dd><p><code>Hashtbl.hash x</code> associates a positive integer to any value of any type. It is guaranteed that if <code>x = y</code> or <code>Pervasives.compare x y = 0</code>, then <code>hash x = hash y</code>. Moreover, <code>hash</code> always terminates, even on cyclic structures.</p></dd></dl><dl><dt class="spec external" id="val-hash_param"><a href="#val-hash_param" class="anchor"></a><code><span class="keyword">val</span> hash_param : int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> int</code></dt><dd><p><code>Hashtbl.hash_param n m x</code> computes a hash value for <code>x</code>, with the same properties as for <code>hash</code>. The two extra parameters <code>n</code> and <code>m</code> give more precise control over hashing. Hashing performs a depth-first, right-to-left traversal of the structure <code>x</code>, stopping after <code>n</code> meaningful nodes were encountered, or <code>m</code> nodes, meaningful or not, were encountered. Meaningful nodes are: integers; floating-point numbers; strings; characters; booleans; and constant constructors. Larger values of <code>m</code> and <code>n</code> means that more nodes are taken into account to compute the final hash value, and therefore collisions are less likely to happen. However, hashing takes longer. The parameters <code>m</code> and <code>n</code> govern the tradeoff between accuracy and speed.</p></dd></dl></section><section><header><h6 id="boilerplate-code"><a href="#boilerplate-code" class="anchor"></a>Boilerplate code</h6></header></section><section><header><h6 id="printing"><a href="#printing" class="anchor"></a>Printing</h6></header><dl><dt class="spec value" id="val-print"><a href="#val-print" class="anchor"></a><code><span class="keyword">val</span> print : ?&#8288;first:string <span>&#45;&gt;</span> ?&#8288;last:string <span>&#45;&gt;</span> ?&#8288;sep:string <span>&#45;&gt;</span> ?&#8288;kvsep:string <span>&#45;&gt;</span> (<span class="type-var">'a</span> <a href="../BatInnerIO/index.html#type-output">BatInnerIO.output</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> unit) <span>&#45;&gt;</span> (<span class="type-var">'a</span> <a href="../BatInnerIO/index.html#type-output">BatInnerIO.output</a> <span>&#45;&gt;</span> <span class="type-var">'c</span> <span>&#45;&gt;</span> unit) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="../BatInnerIO/index.html#type-output">BatInnerIO.output</a> <span>&#45;&gt;</span> (<span class="type-var">'b</span>, <span class="type-var">'c</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt></dl></section><section><header><h6 id="override-modules"><a href="#override-modules" class="anchor"></a>Override modules</h6></header><aside><p>The following modules replace functions defined in <code>Hashtbl</code> with functions behaving slightly differently but having the same name. This is by design: the functions meant to override the corresponding functions of <code>Hashtbl</code>.</p></aside><dl><dt class="spec module" id="module-Exceptionless"><a href="#module-Exceptionless" class="anchor"></a><code><span class="keyword">module</span> <a href="Exceptionless/index.html">Exceptionless</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Operations on <code>Hashtbl</code> without exceptions.</p></dd></dl><dl><dt class="spec module" id="module-Infix"><a href="#module-Infix" class="anchor"></a><code><span class="keyword">module</span> <a href="Infix/index.html">Infix</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Infix operators over a <a href="index.html"><code>BatHashtbl</code></a></p></dd></dl><dl><dt class="spec module" id="module-Labels"><a href="#module-Labels" class="anchor"></a><code><span class="keyword">module</span> <a href="Labels/index.html">Labels</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Operations on <code>Hashtbl</code> with labels.</p></dd></dl></section><section><header><h6 id="functorial-interface"><a href="#functorial-interface" class="anchor"></a>Functorial interface</h6></header><div class="spec module-type" id="module-type-HashedType"><a href="#module-type-HashedType" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-HashedType/index.html">HashedType</a> = <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><dl><dt class="spec module-type" id="module-type-S"><a href="#module-type-S" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-S/index.html">S</a> = <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>The output signature of the functor <span class="xref-unresolved" title="unresolved reference to &quot;Hashtbl.Make&quot;"><code>Hashtbl</code>.Make</span>.</p></dd></dl><dl><dt class="spec module" id="module-Make"><a href="#module-Make" class="anchor"></a><code><span class="keyword">module</span> <a href="Make/index.html">Make</a> : <span class="keyword">functor</span> (<a href="Make/argument-1-H/index.html">H</a> : <a href="index.html#module-type-HashedType">HashedType</a>) <span>&#45;&gt;</span> <a href="index.html#module-type-S">S</a> <span class="keyword">with</span> <span class="keyword">type</span> <a href="Make/index.html#type-key">key</a> = <a href="Make/argument-1-H/index.html#type-t">H.t</a></code></dt><dd><p>Functor building an implementation of the hashtable structure. The functor <code>Hashtbl.Make</code> returns a structure containing a type <code>key</code> of keys and a type <code>'a t</code> of hash tables associating data of type <code>'a</code> to keys of type <code>key</code>. The operations perform similarly to those of the generic interface, but use the hashing and equality functions specified in the functor argument <code>H</code> instead of generic equality and hashing.</p></dd></dl><dl><dt class="spec module" id="module-Cap"><a href="#module-Cap" class="anchor"></a><code><span class="keyword">module</span> <a href="Cap/index.html">Cap</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Capabilities for hashtables.</p></dd></dl></section></div></body></html>