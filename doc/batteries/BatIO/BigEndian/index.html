<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>BigEndian (batteries.BatIO.BigEndian)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../../index.html">batteries</a> &#x00BB; <a href="../index.html">BatIO</a> &#x00BB; BigEndian</nav><h1>Module <code>BatIO.BigEndian</code></h1><p>Same operations as module <a href="../index.html"><code>BatIO</code></a>, but with big-endian encoding</p></header><aside><p>This module redefines the operations of module <a href="../index.html"><code>BatIO</code></a> which behave differently on big-endian <code>input</code>s/<code>output</code>s.</p><p>Generally, to use this module you will wish to either open both <a href="../index.html"><code>BatIO</code></a> and <a href="index.html"><code>BigEndian</code></a>, so as to import a big-endian version of <a href="../index.html"><code>BatIO</code></a>, as per <code>open System.BatIO, BigEndian in ...</code>, or to redefine locally <a href="../index.html"><code>BatIO</code></a> to use big-endian encodings <code>module BatIO = System.BatIO include BigEndian</code></p></aside><dl><dt class="spec value" id="val-read_ui16"><a href="#val-read_ui16" class="anchor"></a><code><span class="keyword">val </span>read_ui16 : <a href="../index.html#type-input">input</a> <span>&#45;&gt;</span> int</code></dt><dd><p>Read an unsigned 16-bit word.</p></dd></dl><dl><dt class="spec value" id="val-read_i16"><a href="#val-read_i16" class="anchor"></a><code><span class="keyword">val </span>read_i16 : <a href="../index.html#type-input">input</a> <span>&#45;&gt;</span> int</code></dt><dd><p>Read a signed 16-bit word.</p></dd></dl><dl><dt class="spec value" id="val-read_i32"><a href="#val-read_i32" class="anchor"></a><code><span class="keyword">val </span>read_i32 : <a href="../index.html#type-input">input</a> <span>&#45;&gt;</span> int</code></dt><dd><p>Read a signed 32-bit integer. </p><dl><dt>raises Overflow</dt><dd><p>if the read integer cannot be represented as an OCaml 31-bit integer.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-read_real_i32"><a href="#val-read_real_i32" class="anchor"></a><code><span class="keyword">val </span>read_real_i32 : <a href="../index.html#type-input">input</a> <span>&#45;&gt;</span> int32</code></dt><dd><p>Read a signed 32-bit integer as an OCaml int32.</p></dd></dl><dl><dt class="spec value" id="val-read_i64"><a href="#val-read_i64" class="anchor"></a><code><span class="keyword">val </span>read_i64 : <a href="../index.html#type-input">input</a> <span>&#45;&gt;</span> int64</code></dt><dd><p>Read a signed 64-bit integer as an OCaml int64.</p></dd></dl><dl><dt class="spec value" id="val-read_double"><a href="#val-read_double" class="anchor"></a><code><span class="keyword">val </span>read_double : <a href="../index.html#type-input">input</a> <span>&#45;&gt;</span> float</code></dt><dd><p>Read an IEEE double precision floating point value.</p></dd></dl><dl><dt class="spec value" id="val-read_float"><a href="#val-read_float" class="anchor"></a><code><span class="keyword">val </span>read_float : <a href="../index.html#type-input">input</a> <span>&#45;&gt;</span> float</code></dt><dd><p>Read an IEEE single precision floating point value.</p></dd></dl><dl><dt class="spec value" id="val-write_ui16"><a href="#val-write_ui16" class="anchor"></a><code><span class="keyword">val </span>write_ui16 : (int, <span class="type-var">_</span>) <a href="../index.html#type-printer">printer</a></code></dt><dd><p>Write an unsigned 16-bit word.</p></dd></dl><dl><dt class="spec value" id="val-write_i16"><a href="#val-write_i16" class="anchor"></a><code><span class="keyword">val </span>write_i16 : (int, <span class="type-var">_</span>) <a href="../index.html#type-printer">printer</a></code></dt><dd><p>Write a signed 16-bit word.</p></dd></dl><dl><dt class="spec value" id="val-write_i32"><a href="#val-write_i32" class="anchor"></a><code><span class="keyword">val </span>write_i32 : (int, <span class="type-var">_</span>) <a href="../index.html#type-printer">printer</a></code></dt><dd><p>Write a signed 32-bit integer.</p></dd></dl><dl><dt class="spec value" id="val-write_real_i32"><a href="#val-write_real_i32" class="anchor"></a><code><span class="keyword">val </span>write_real_i32 : (int32, <span class="type-var">_</span>) <a href="../index.html#type-printer">printer</a></code></dt><dd><p>Write an OCaml int32.</p></dd></dl><dl><dt class="spec value" id="val-write_i64"><a href="#val-write_i64" class="anchor"></a><code><span class="keyword">val </span>write_i64 : (int64, <span class="type-var">_</span>) <a href="../index.html#type-printer">printer</a></code></dt><dd><p>Write an OCaml int64.</p></dd></dl><dl><dt class="spec value" id="val-write_double"><a href="#val-write_double" class="anchor"></a><code><span class="keyword">val </span>write_double : (float, <span class="type-var">_</span>) <a href="../index.html#type-printer">printer</a></code></dt><dd><p>Write an IEEE double precision floating point value.</p></dd></dl><dl><dt class="spec value" id="val-write_float"><a href="#val-write_float" class="anchor"></a><code><span class="keyword">val </span>write_float : (float, <span class="type-var">_</span>) <a href="../index.html#type-printer">printer</a></code></dt><dd><p>Write an IEEE single precision floating point value.</p></dd></dl><dl><dt class="spec value" id="val-ui16s_of"><a href="#val-ui16s_of" class="anchor"></a><code><span class="keyword">val </span>ui16s_of : <a href="../index.html#type-input">input</a> <span>&#45;&gt;</span> int BatEnum.t</code></dt><dd><p>Read an enumeration of unsigned 16-bit words.</p></dd></dl><dl><dt class="spec value" id="val-i16s_of"><a href="#val-i16s_of" class="anchor"></a><code><span class="keyword">val </span>i16s_of : <a href="../index.html#type-input">input</a> <span>&#45;&gt;</span> int BatEnum.t</code></dt><dd><p>Read an enumartion of signed 16-bit words.</p></dd></dl><dl><dt class="spec value" id="val-i32s_of"><a href="#val-i32s_of" class="anchor"></a><code><span class="keyword">val </span>i32s_of : <a href="../index.html#type-input">input</a> <span>&#45;&gt;</span> int BatEnum.t</code></dt><dd><p>Read an enumeration of signed 32-bit integers.</p><dl><dt>raises Overflow</dt><dd><p>if the read integer cannot be represented as an OCaml 31-bit integer.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-real_i32s_of"><a href="#val-real_i32s_of" class="anchor"></a><code><span class="keyword">val </span>real_i32s_of : <a href="../index.html#type-input">input</a> <span>&#45;&gt;</span> int32 BatEnum.t</code></dt><dd><p>Read an enumeration of signed 32-bit integers as OCaml <code>int32</code>s.</p></dd></dl><dl><dt class="spec value" id="val-i64s_of"><a href="#val-i64s_of" class="anchor"></a><code><span class="keyword">val </span>i64s_of : <a href="../index.html#type-input">input</a> <span>&#45;&gt;</span> int64 BatEnum.t</code></dt><dd><p>Read an enumeration of signed 64-bit integers as OCaml <code>int64</code>s.</p></dd></dl><dl><dt class="spec value" id="val-doubles_of"><a href="#val-doubles_of" class="anchor"></a><code><span class="keyword">val </span>doubles_of : <a href="../index.html#type-input">input</a> <span>&#45;&gt;</span> float BatEnum.t</code></dt><dd><p>Read an enumeration of IEEE double precision floating point values.</p></dd></dl><dl><dt class="spec value" id="val-floats_of"><a href="#val-floats_of" class="anchor"></a><code><span class="keyword">val </span>floats_of : <a href="../index.html#type-input">input</a> <span>&#45;&gt;</span> float BatEnum.t</code></dt><dd><p>Read an enumeration of IEEE single precision floating point values.</p></dd></dl></div></body></html>