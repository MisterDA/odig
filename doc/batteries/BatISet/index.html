<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>BatISet (batteries.BatISet)</title><link rel="stylesheet" href="../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../index.html">batteries</a> &#x00BB; BatISet</nav><h1>Module <code>BatISet</code></h1><p>DIET : Discrete Interval Encoding Trees</p><p>Sets of integers represented as ranges</p><p>This data structure is efficient for large sets of integers where many adjacent integers are all part of the set. This will have higher overhead for sets with lots of point elements, but will be much more efficient for sets containing mostly ranges.</p></header><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> t</code><code> = (int * int) <a href="../BatAvlTree/index.html#type-tree">BatAvlTree.tree</a></code></dt><dd><p>the underlying representation is a balanced tree of ranges</p></dd></dl><dl><dt class="spec type" id="type-elt"><a href="#type-elt" class="anchor"></a><code><span class="keyword">type</span> elt</code><code> = int</code></dt><dd><p>This kind of set only holds ints</p></dd></dl><dl><dt class="spec value" id="val-empty"><a href="#val-empty" class="anchor"></a><code><span class="keyword">val</span> empty : <a href="index.html#type-t">t</a></code></dt><dd><p>The empty set</p></dd></dl><dl><dt class="spec value" id="val-is_empty"><a href="#val-is_empty" class="anchor"></a><code><span class="keyword">val</span> is_empty : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p>Test whether a set is empty, returns <code>true</code> if the set is empty.</p></dd></dl><dl><dt class="spec value" id="val-mem"><a href="#val-mem" class="anchor"></a><code><span class="keyword">val</span> mem : int <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p>test whether a given int is a member of the set</p></dd></dl><dl><dt class="spec value" id="val-add"><a href="#val-add" class="anchor"></a><code><span class="keyword">val</span> add : int <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Add the given int to the set, returning a new set</p></dd></dl><dl><dt class="spec value" id="val-add_range"><a href="#val-add_range" class="anchor"></a><code><span class="keyword">val</span> add_range : int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>add_range lo hi t</code> adds the range of integers <code>lo, hi</code> (including both endpoints) to the given set, returning a new set</p><dl><dt>raises Invalid_argument</dt><dd><p>if <code>lo</code> &gt; <code>hi</code></p></dd></dl></dd></dl><dl><dt class="spec value" id="val-singleton"><a href="#val-singleton" class="anchor"></a><code><span class="keyword">val</span> singleton : int <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Return the singleton set containing only the given element</p></dd></dl><dl><dt class="spec value" id="val-remove"><a href="#val-remove" class="anchor"></a><code><span class="keyword">val</span> remove : int <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Remove an element from the given set, returning a new set</p></dd></dl><dl><dt class="spec value" id="val-remove_range"><a href="#val-remove_range" class="anchor"></a><code><span class="keyword">val</span> remove_range : int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>remove_range lo hi t</code> removes a range of elements from the given set, returning a new set</p><dl><dt>raises Invalid_argument</dt><dd><p>if <code>lo</code> &gt; <code>hi</code></p></dd></dl></dd></dl><dl><dt class="spec value" id="val-union"><a href="#val-union" class="anchor"></a><code><span class="keyword">val</span> union : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Compute the union of two sets. This is the set whose elements are those elements in either input set.</p></dd></dl><dl><dt class="spec value" id="val-inter"><a href="#val-inter" class="anchor"></a><code><span class="keyword">val</span> inter : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Compute the intersection of two sets. This is the set whose elements are those in *both* of the input sets.</p></dd></dl><dl><dt class="spec value" id="val-diff"><a href="#val-diff" class="anchor"></a><code><span class="keyword">val</span> diff : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Compute the difference between two sets. This is the set of elements that are in the first but not in the second. Unlike <code>union</code> and <code>inter</code>, order matters here.</p></dd></dl><dl><dt class="spec value" id="val-compl"><a href="#val-compl" class="anchor"></a><code><span class="keyword">val</span> compl : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Create the complement of the given set - i.e. the set of all values not in the input set.</p></dd></dl><dl><dt class="spec value" id="val-compare"><a href="#val-compare" class="anchor"></a><code><span class="keyword">val</span> compare : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int</code></dt><dd><p>Compare two sets. It is not safe to use the polymorphic (&lt;) and related functions to compare these sets, as the tree representation used can balance in multiple ways.</p></dd></dl><dl><dt class="spec value" id="val-equal"><a href="#val-equal" class="anchor"></a><code><span class="keyword">val</span> equal : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p>Test whether two sets are equal. It is not safe to use the polymorphic (=) on these sets, as the same set can have multiple representations depending on how it was built.</p></dd></dl><dl><dt class="spec value" id="val-ord"><a href="#val-ord" class="anchor"></a><code><span class="keyword">val</span> ord : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../BatOrd/index.html#type-order">BatOrd.order</a></code></dt><dd><p>Same as <code>compare</code> but returns <code>BatOrd.Lt | BatOrd.Eq | BatOrd.Gt</code> instead of an int.</p></dd></dl><dl><dt class="spec value" id="val-subset"><a href="#val-subset" class="anchor"></a><code><span class="keyword">val</span> subset : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>subset t u</code> returns <code>true</code> if <code>t</code> is a subset of <code>u</code></p></dd></dl><dl><dt class="spec value" id="val-from"><a href="#val-from" class="anchor"></a><code><span class="keyword">val</span> from : int <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>from x t</code> returns the portion of <code>t</code> in the range <code>x, max_int</code></p></dd></dl><dl><dt class="spec value" id="val-after"><a href="#val-after" class="anchor"></a><code><span class="keyword">val</span> after : int <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>after x t</code> returns the portion of <code>t</code> in the range <code>x+1, max_int</code></p></dd></dl><dl><dt class="spec value" id="val-until"><a href="#val-until" class="anchor"></a><code><span class="keyword">val</span> until : int <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>until x t</code> returns the portion of <code>t</code> in the range <code>min_int, x</code></p></dd></dl><dl><dt class="spec value" id="val-before"><a href="#val-before" class="anchor"></a><code><span class="keyword">val</span> before : int <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>before x t</code> returns the portion of <code>t</code> in the range <code>min_int, x-1</code></p></dd></dl><dl><dt class="spec value" id="val-iter"><a href="#val-iter" class="anchor"></a><code><span class="keyword">val</span> iter : (int <span>&#45;&gt;</span> unit) <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>iter f t</code> calls <code>f</code> once for each element of <code>t</code></p></dd></dl><dl><dt class="spec value" id="val-iter_range"><a href="#val-iter_range" class="anchor"></a><code><span class="keyword">val</span> iter_range : (int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> unit) <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>iter_range f t</code> calls <code>f</code> once for each contiguous range of <code>t</code>. The contiguous ranges of a set are sequences of adjacent integers all part of the set.</p></dd></dl><dl><dt class="spec value" id="val-fold"><a href="#val-fold" class="anchor"></a><code><span class="keyword">val</span> fold : (int <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span>) <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p><code>fold f t x0</code> returns the final result of merging each element of <code>t</code> into <code>x0</code> using merge function <code>f</code></p></dd></dl><dl><dt class="spec value" id="val-fold_range"><a href="#val-fold_range" class="anchor"></a><code><span class="keyword">val</span> fold_range : (int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span>) <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p>As fold, but operates on contiguous ranges</p></dd></dl><dl><dt class="spec value" id="val-for_all"><a href="#val-for_all" class="anchor"></a><code><span class="keyword">val</span> for_all : (int <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p>Tests whether a predicate applies to all elements of the set</p></dd></dl><dl><dt class="spec value" id="val-exists"><a href="#val-exists" class="anchor"></a><code><span class="keyword">val</span> exists : (int <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p>Test whether some element of a set satisfies a predicate</p></dd></dl><dl><dt class="spec value" id="val-filter"><a href="#val-filter" class="anchor"></a><code><span class="keyword">val</span> filter : (int <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Builds the subset of those elements that satisfy the predicate</p></dd></dl><dl><dt class="spec value" id="val-partition"><a href="#val-partition" class="anchor"></a><code><span class="keyword">val</span> partition : (int <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> * <a href="index.html#type-t">t</a></code></dt><dd><p>partitions the input set into two sets with elements that satisfy the predicate and those that don't</p></dd></dl><dl><dt class="spec value" id="val-cardinal"><a href="#val-cardinal" class="anchor"></a><code><span class="keyword">val</span> cardinal : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int</code></dt><dd><p>Returns the number of elements in the set</p></dd></dl><dl><dt class="spec value" id="val-elements"><a href="#val-elements" class="anchor"></a><code><span class="keyword">val</span> elements : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int list</code></dt><dd><p>Returns a list of all elements in the set</p></dd></dl><dl><dt class="spec value" id="val-ranges"><a href="#val-ranges" class="anchor"></a><code><span class="keyword">val</span> ranges : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (int * int) list</code></dt><dd><p>Returns a list of all contiguous ranges in the set</p></dd></dl><dl><dt class="spec value" id="val-min_elt"><a href="#val-min_elt" class="anchor"></a><code><span class="keyword">val</span> min_elt : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int</code></dt><dd><p>Returns the minimum element in the set</p></dd></dl><dl><dt class="spec value" id="val-max_elt"><a href="#val-max_elt" class="anchor"></a><code><span class="keyword">val</span> max_elt : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int</code></dt><dd><p>Returns the maximum element in the set</p></dd></dl><dl><dt class="spec value" id="val-choose"><a href="#val-choose" class="anchor"></a><code><span class="keyword">val</span> choose : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int</code></dt><dd><p>Returns some element in the set</p></dd></dl><dl><dt class="spec value" id="val-enum"><a href="#val-enum" class="anchor"></a><code><span class="keyword">val</span> enum : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (int * int) <a href="../BatEnum/index.html#type-t">BatEnum.t</a></code></dt><dd><p>Enumerates all contiguous ranges in the set</p></dd></dl><dl><dt class="spec value" id="val-of_enum"><a href="#val-of_enum" class="anchor"></a><code><span class="keyword">val</span> of_enum : (int * int) <a href="../BatEnum/index.html#type-t">BatEnum.t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-of_list"><a href="#val-of_list" class="anchor"></a><code><span class="keyword">val</span> of_list : (int * int) list <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Build a ISet.t out of a list or enum of ranges</p></dd></dl><dl><dt class="spec value" id="val-print"><a href="#val-print" class="anchor"></a><code><span class="keyword">val</span> print : <span class="type-var">_</span> <a href="../BatIO/index.html#type-output">BatIO.output</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt></dl></div></body></html>