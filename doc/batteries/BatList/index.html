<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>BatList (batteries.BatList)</title><link rel="stylesheet" href="../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../index.html">batteries</a> &#x00BB; BatList</nav><h1>Module <code>BatList</code></h1><p>Additional and modified functions for lists.</p><p>The OCaml standard library provides a module for list functions. This BatList module can be used to extend the List module or as a standalone module. It provides new functions and modify the behavior of some other ones (in particular all functions are now <b>tail-recursive</b>).</p><p>The following functions have the same behavior as the <code>List</code> module ones but are tail-recursive: <code>map</code>, <code>append</code>, <code>concat</code>, <code>flatten</code>, <code>fold_right</code>, <code>remove_assoc</code>, <code>remove_assq</code>, <code>split</code>. That means they will not cause a <code>Stack_overflow</code> when used on very long list.</p><p>The implementation might be a little more slow in bytecode, but compiling in native code will not affect performances.</p><p>This module extends Stdlib's <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/List.html">List</a> module, go there for documentation on the rest of the functions and types.</p><nav class="toc"><ul><li><a href="#base-operations">Base operations</a></li><li><a href="#constructors">Constructors</a></li><li><a href="#iterators">Iterators</a></li><li><a href="#iterators-on-two-lists">Iterators on two lists</a></li><li><a href="#list-scanning">List scanning</a></li><li><a href="#unary-predicate,-one-list">Unary predicate, One list</a></li><li><a href="#binary-predicate,-two-lists">Binary predicate, Two lists</a></li><li><a href="#list-searching">List searching</a></li><li><a href="#association-lists">Association lists</a></li><li><a href="#list-transformations">List transformations</a></li><li><a href="#batenum-functions">BatEnum functions</a></li><li><a href="#list-of-pairs">List of pairs</a></li><li><a href="#sorting">Sorting</a></li><li><a href="#utilities">Utilities</a></li><li><a href="#boilerplate-code">Boilerplate code</a></li><li><a href="#printing">Printing</a></li><li><a href="#obsolete-functions">Obsolete functions</a></li><li><a href="#override-modules">Override modules</a></li></ul></nav></header><aside><p>List operations.</p><p>@documents List</p><dl><dt>author</dt><dd>Xavier Leroy (base module)</dd></dl><dl><dt>author</dt><dd>Brian Hurt</dd></dl><dl><dt>author</dt><dd>Nicolas Cannasse</dd></dl><dl><dt>author</dt><dd>Richard W.M. Jones</dd></dl><dl><dt>author</dt><dd>David Teller</dd></dl></aside><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> 'a t</code><code> = <span class="type-var">'a</span> list</code></dt><dd><p>The type of lists</p></dd></dl><div><div class="spec include"><div class="doc"><details open="open"><summary><span class="def"><code><span class="keyword">include</span> <a href="../BatEnum/index.html#module-type-Enumerable">BatEnum.Enumerable</a> <span class="keyword">with</span> <span class="keyword">type</span> 'a <a href="../BatEnum/module-type-Enumerable/index.html#type-enumerable">enumerable</a> = <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></span></summary><dl><dt class="spec type" id="type-enumerable"><a href="#type-enumerable" class="anchor"></a><code><span class="keyword">type</span> 'a enumerable</code><code> = <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p>The data structure, e.g. <code>'a List.t</code></p></dd></dl><dl><dt class="spec value" id="val-enum"><a href="#val-enum" class="anchor"></a><code><span class="keyword">val</span> enum : <span class="type-var">'a</span> <a href="index.html#type-enumerable">enumerable</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="../BatEnum/index.html#type-t">BatEnum.t</a></code></dt><dd><p>Return an enumeration of the elements of the data structure</p></dd></dl><dl><dt class="spec value" id="val-of_enum"><a href="#val-of_enum" class="anchor"></a><code><span class="keyword">val</span> of_enum : <span class="type-var">'a</span> <a href="../BatEnum/index.html#type-t">BatEnum.t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-enumerable">enumerable</a></code></dt><dd><p>Build a data structure from an enumeration</p></dd></dl></details></div></div></div><div><div class="spec include"><div class="doc"><details open="open"><summary><span class="def"><code><span class="keyword">include</span> <a href="../BatInterfaces/index.html#module-type-Mappable">BatInterfaces.Mappable</a> <span class="keyword">with</span> <span class="keyword">type</span> 'a <a href="../BatInterfaces/module-type-Mappable/index.html#type-mappable">mappable</a> = <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></span></summary><dl><dt class="spec type" id="type-mappable"><a href="#type-mappable" class="anchor"></a><code><span class="keyword">type</span> 'a mappable</code><code> = <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p>The data structure, e.g. <code>'a List.t</code></p></dd></dl><dl><dt class="spec value" id="val-map"><a href="#val-map" class="anchor"></a><code><span class="keyword">val</span> map : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-mappable">mappable</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-mappable">mappable</a></code></dt><dd><p><code>map f e</code> applies <code>f</code> to every element of <code>e</code> and returns the corresponding data structure</p></dd></dl></details></div></div></div><section><header><h6 id="base-operations"><a href="#base-operations" class="anchor"></a>Base operations</h6></header><dl><dt class="spec value" id="val-is_empty"><a href="#val-is_empty" class="anchor"></a><code><span class="keyword">val</span> is_empty : <span class="type-var">'a</span> list <span>&#45;&gt;</span> bool</code></dt><dd><p><code>is_empty e</code> returns true if <code>e</code> does not contains any element.</p></dd></dl><dl><dt class="spec value" id="val-cons"><a href="#val-cons" class="anchor"></a><code><span class="keyword">val</span> cons : <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'a</span> list</code></dt><dd><p><code>cons h t</code> returns the list starting with <code>h</code> and continuing as <code>t</code>.</p></dd></dl><dl><dt class="spec value" id="val-hd"><a href="#val-hd" class="anchor"></a><code><span class="keyword">val</span> hd : <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p>Returns the first element of the list, or </p><dl><dt>raises Failure</dt><dd><p>if the list is empty.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-first"><a href="#val-first" class="anchor"></a><code><span class="keyword">val</span> first : <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p>Alias to hd</p></dd></dl><dl><dt class="spec value" id="val-tl"><a href="#val-tl" class="anchor"></a><code><span class="keyword">val</span> tl : <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'a</span> list</code></dt><dd><p>Return the given list without its first element.</p><dl><dt>raises Failure</dt><dd><p>if the list is empty.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-last"><a href="#val-last" class="anchor"></a><code><span class="keyword">val</span> last : <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p>Returns the last element of the list, or </p><dl><dt>raises Invalid_argument</dt><dd><p>if the list is empty. This function takes linear time.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-length"><a href="#val-length" class="anchor"></a><code><span class="keyword">val</span> length : <span class="type-var">'a</span> list <span>&#45;&gt;</span> int</code></dt><dd><p>Return the length (number of elements) of the given list.</p></dd></dl><dl><dt class="spec value" id="val-compare_lengths"><a href="#val-compare_lengths" class="anchor"></a><code><span class="keyword">val</span> compare_lengths : <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'b</span> list <span>&#45;&gt;</span> int</code></dt><dd><p>Compare the lengths of two lists. <code>compare_lengths l1 l2</code> is equivalent to <code>compare (length l1) (length l2)</code>, except that the computation stops after itering on the shortest list.</p><dl><dt>since</dt><dd>2.7.0</dd></dl></dd></dl><dl><dt class="spec value" id="val-compare_length_with"><a href="#val-compare_length_with" class="anchor"></a><code><span class="keyword">val</span> compare_length_with : <span class="type-var">'a</span> list <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int</code></dt><dd><p>Compare the length of a list to an integer. <code>compare_length_with l n</code> is equivalent to <code>compare (length l) n</code>, except that the computation stops after at most <code>n</code> iterations on the list.</p><dl><dt>since</dt><dd>2.7.0</dd></dl></dd></dl><dl><dt class="spec value" id="val-at"><a href="#val-at" class="anchor"></a><code><span class="keyword">val</span> at : <span class="type-var">'a</span> list <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p><code>at l n</code> returns the n-th element of the list <code>l</code> or</p><dl><dt>raises Invalid_argument</dt><dd><p>if the index is outside of <code>l</code> bounds. O(l)</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-at_opt"><a href="#val-at_opt" class="anchor"></a><code><span class="keyword">val</span> at_opt : <span class="type-var">'a</span> list <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <span class="type-var">'a</span> option</code></dt><dd><p><code>at_opt</code> returns the n-th element of the list <code>l</code> or None if the index is beyond the length of <code>l</code>.</p><dl><dt>since</dt><dd>2.7.0</dd></dl><dl><dt>raises Invalid_argument</dt><dd><p>if the index is negative</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-rev"><a href="#val-rev" class="anchor"></a><code><span class="keyword">val</span> rev : <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'a</span> list</code></dt><dd><p>List reversal.</p></dd></dl><dl><dt class="spec value" id="val-shuffle"><a href="#val-shuffle" class="anchor"></a><code><span class="keyword">val</span> shuffle : ?&#8288;state:<a href="../../ocaml/Stdlib__random/State/index.html#type-t">Stdlib.Random.State.t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'a</span> list</code></dt><dd><p><code>shuffle ~state:rs l</code> randomly shuffles the elements of <code>l</code>. The optional random state <code>rs</code> allows to control the random numbers being used during shuffling (for reproducibility).</p><p>Shuffling is implemented using the Fisher-Yates algorithm on an array and works in O(n), where n is the number of elements of <code>l</code>.</p><dl><dt>since</dt><dd>2.6.0</dd></dl></dd></dl><dl><dt class="spec value" id="val-append"><a href="#val-append" class="anchor"></a><code><span class="keyword">val</span> append : <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'a</span> list</code></dt><dd><p><code>append l1 l2</code> is a concatenation of <code>l1</code> and <code>l2</code>. Same function as the infix operator <code>@</code>. Tail-recursive. This function takes O(<code>length l1</code>) time.</p></dd></dl><dl><dt class="spec value" id="val-rev_append"><a href="#val-rev_append" class="anchor"></a><code><span class="keyword">val</span> rev_append : <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'a</span> list</code></dt><dd><p><code>List.rev_append l1 l2</code> reverses <code>l1</code> and concatenates it to <code>l2</code>.</p></dd></dl><dl><dt class="spec value" id="val-concat"><a href="#val-concat" class="anchor"></a><code><span class="keyword">val</span> concat : <span class="type-var">'a</span> list list <span>&#45;&gt;</span> <span class="type-var">'a</span> list</code></dt><dd><p>Concatenate a list of lists. The elements of the argument are all concatenated together (in the same order) to give the result. Tail-recursive.</p></dd></dl><dl><dt class="spec value" id="val-flatten"><a href="#val-flatten" class="anchor"></a><code><span class="keyword">val</span> flatten : <span class="type-var">'a</span> list list <span>&#45;&gt;</span> <span class="type-var">'a</span> list</code></dt><dd><p>Same as <code>concat</code>.</p></dd></dl><dl><dt class="spec value" id="val-singleton"><a href="#val-singleton" class="anchor"></a><code><span class="keyword">val</span> singleton : <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> list</code></dt><dd><p>Create a list consisting of exactly one element.</p><dl><dt>since</dt><dd>2.1</dd></dl></dd></dl></section><section><header><h6 id="constructors"><a href="#constructors" class="anchor"></a>Constructors</h6></header><dl><dt class="spec value" id="val-make"><a href="#val-make" class="anchor"></a><code><span class="keyword">val</span> make : int <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> list</code></dt><dd><p>Similar to <code>String.make</code>, <code>make n x</code> returns a list containing <code>n</code> elements <code>x</code>.</p></dd></dl><dl><dt class="spec value" id="val-range"><a href="#val-range" class="anchor"></a><code><span class="keyword">val</span> range : int <span>&#45;&gt;</span> [&lt; `To | `Downto ] <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int list</code></dt><dd><p><code>range 1 `To 3</code> = <code>[1; 2; 3]</code>. <code>range 3 `Downto 1</code> = <code>[3; 2; 1]</code>.</p><dl><dt>raises Invalid_argument</dt><dd><p>in (<code>range i `To j</code>) if (i &gt; j).</p></dd></dl><dl><dt>raises Invalid_argument</dt><dd><p>in (<code>range i `Downto j</code>) if (i &lt; j).</p></dd></dl><dl><dt>since</dt><dd>2.2.0</dd></dl></dd></dl><dl><dt class="spec value" id="val-frange"><a href="#val-frange" class="anchor"></a><code><span class="keyword">val</span> frange : float <span>&#45;&gt;</span> [&lt; `To | `Downto ] <span>&#45;&gt;</span> float <span>&#45;&gt;</span> int <span>&#45;&gt;</span> float list</code></dt><dd><p><code>frange start `To stop n</code> generates (without accumulating floating point errors) <code>n</code> floats in the range <code>[start..stop]</code>. <code>n</code> must be &gt;= 2. At each step, floats in an increasing (resp. decreasing) range increase (resp. decrease) by approximately (stop - start) / (n - 1).</p><dl><dt>raises Invalid_argument</dt><dd><p>in (<code>frange i _ j n</code>) if (n &lt; 2).</p></dd></dl><dl><dt>raises Invalid_argument</dt><dd><p>in (<code>frange i `To j _</code>) if (i &gt;= j).</p></dd></dl><dl><dt>raises Invalid_argument</dt><dd><p>in (<code>frange i `Downto j _</code>) if (i &lt;= j). Examples: <code>frange 1.0 `To 3.0 3</code> = <code>[1.0; 2.0; 3.0]</code>. <code>frange 3.0 `Downto 1.0 3</code> = <code>[3.0; 2.0; 1.0]</code>.</p></dd></dl><dl><dt>since</dt><dd>2.6.0</dd></dl></dd></dl><dl><dt class="spec value" id="val-init"><a href="#val-init" class="anchor"></a><code><span class="keyword">val</span> init : int <span>&#45;&gt;</span> (int <span>&#45;&gt;</span> <span class="type-var">'a</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span> list</code></dt><dd><p>Similar to <code>Array.init</code>, <code>init n f</code> returns the list containing the results of (f 0),(f 1).... (f (n-1)).</p><dl><dt>raises Invalid_argument</dt><dd><p>if n &lt; 0.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-unfold"><a href="#val-unfold" class="anchor"></a><code><span class="keyword">val</span> unfold : <span class="type-var">'b</span> <span>&#45;&gt;</span> (<span class="type-var">'b</span> <span>&#45;&gt;</span> (<span class="type-var">'a</span> * <span class="type-var">'b</span>) option) <span>&#45;&gt;</span> <span class="type-var">'a</span> list</code></dt><dd><p><code>unfold init f</code> creates a list by repeatedly applying <code>f</code> to the second element of its own result, starting from the initial value <code>init</code>. The first element of each result is accumulated in a list. The list is terminated and returned as soon as <code>f</code> returns <code>None</code>.</p><p>Example: <code>List.unfold 0 (fun x -&gt; if x = 3 then None else Some (string_of_int x, x+1))</code> will return <code>[&quot;0&quot;;&quot;1&quot;;&quot;2&quot;]</code></p><dl><dt>since</dt><dd>2.1</dd></dl></dd></dl><dl><dt class="spec value" id="val-unfold_exc"><a href="#val-unfold_exc" class="anchor"></a><code><span class="keyword">val</span> unfold_exc : (unit <span>&#45;&gt;</span> <span class="type-var">'a</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span> list * exn</code></dt><dd><p>Creates a list containing the results of sequential calls to <code>f()</code>. <code>f()</code> is called repeatedly until it throws an exception. Both the results list, as well as the exception thrown are returned in a <code>(results_list, exn)</code> pair. Warning: if calls to <code>f()</code> never throw an exception, unfold_exc is an infinite loop.</p><dl><dt>since</dt><dd>2.3.0</dd></dl></dd></dl></section><section><header><h6 id="iterators"><a href="#iterators" class="anchor"></a>Iterators</h6></header><dl><dt class="spec value" id="val-iter"><a href="#val-iter" class="anchor"></a><code><span class="keyword">val</span> iter : (<span class="type-var">'a</span> <span>&#45;&gt;</span> unit) <span>&#45;&gt;</span> <span class="type-var">'a</span> list <span>&#45;&gt;</span> unit</code></dt><dd><p><code>List.iter f [a0; a1; ...; an]</code> applies function <code>f</code> in turn to <code>a0; a1; ...; an</code>. It is equivalent to <code>begin f a0; f a1; ...; f an; () end</code>.</p></dd></dl><dl><dt class="spec value" id="val-iteri"><a href="#val-iteri" class="anchor"></a><code><span class="keyword">val</span> iteri : (int <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> unit) <span>&#45;&gt;</span> <span class="type-var">'a</span> list <span>&#45;&gt;</span> unit</code></dt><dd><p><code>iteri f l</code> will call <code>(f 0 a0); (f 1 a1) ... (f n an)</code> where <code>a0..an</code> are the elements of the list <code>l</code>.</p></dd></dl><dl><dt class="spec value" id="val-map"><a href="#val-map" class="anchor"></a><code><span class="keyword">val</span> map : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'b</span> list</code></dt><dd><p><code>map f [a0; a1; ...; an]</code> applies function <code>f</code> to <code>a0, a1, ..., an</code>, and builds the list <code>[f a0; f a1; ...; f an]</code> with the results returned by <code>f</code>. Tail-recursive.</p></dd></dl><dl><dt class="spec value" id="val-rev_map"><a href="#val-rev_map" class="anchor"></a><code><span class="keyword">val</span> rev_map : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'b</span> list</code></dt><dd><p><code>List.rev_map f l</code> gives the same result as <span class="xref-unresolved" title="unresolved reference to &quot;List.rev&quot;"><code>List</code>.rev</span><code> (</code><span class="xref-unresolved" title="unresolved reference to &quot;List.map&quot;"><code>List</code>.map</span><code> f l)</code>.</p></dd></dl><dl><dt class="spec value" id="val-mapi"><a href="#val-mapi" class="anchor"></a><code><span class="keyword">val</span> mapi : (int <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'b</span> list</code></dt><dd><p><code>mapi f l</code> will build the list containing <code>(f 0 a0); (f 1 a1) ... (f n an)</code> where <code>a0..an</code> are the elements of the list <code>l</code>.</p></dd></dl><dl><dt class="spec value" id="val-fold_left"><a href="#val-fold_left" class="anchor"></a><code><span class="keyword">val</span> fold_left : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'a</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> list <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p><code>List.fold_left f a [b0; b1; ...; bn]</code> is <code>f (... (f (f a b0) b1) ...) bn</code>.</p></dd></dl><dl><dt class="spec value" id="val-fold_lefti"><a href="#val-fold_lefti" class="anchor"></a><code><span class="keyword">val</span> fold_lefti : (<span class="type-var">'a</span> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'a</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> list <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p>As <code>fold_left</code>, but with the index of the element, from <code>0</code> to <code>length li - 1</code>, as additional argument.</p><dl><dt>since</dt><dd>2.3.0</dd></dl></dd></dl><dl><dt class="spec value" id="val-fold_right"><a href="#val-fold_right" class="anchor"></a><code><span class="keyword">val</span> fold_right : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'b</span></code></dt><dd><p><code>List.fold_right f [a0; a1; ...; an] b</code> is <code>f a0 (f a1 (... (f an b) ...))</code>. Tail-recursive.</p></dd></dl><dl><dt class="spec value" id="val-fold_righti"><a href="#val-fold_righti" class="anchor"></a><code><span class="keyword">val</span> fold_righti : (int <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span>) <span>&#45;&gt;</span> <span class="type-var">'b</span> list <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p>As <code>fold_right</code>, but with the index of the element, from <code>0</code> to <code>length li - 1</code>, as additional argument.</p><dl><dt>since</dt><dd>2.3.0</dd></dl></dd></dl><dl><dt class="spec value" id="val-reduce"><a href="#val-reduce" class="anchor"></a><code><span class="keyword">val</span> reduce : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p><code>List.reduce f h::t</code> is <code>fold_left f h t</code>.</p><dl><dt>raises Invalid_argument</dt><dd><p>on empty list.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-fold_left_map"><a href="#val-fold_left_map" class="anchor"></a><code><span class="keyword">val</span> fold_left_map : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> * <span class="type-var">'c</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> list <span>&#45;&gt;</span> <span class="type-var">'a</span> * <span class="type-var">'c</span> list</code></dt><dd><p>Combines <code>fold_left</code> and <code>map</code>. Tail-recursive.</p><p>More precisely :</p><pre><code class="ml">fold_left_map f acc [] = (acc, [])

fold_left_map f acc (x :: xs) =
  let (acc', y) = f acc x in
  let (res, ys) = fold_left_map acc' xs in
  (res, y :: ys)</code></pre><dl><dt>since</dt><dd>2.6.0</dd></dl></dd></dl><dl><dt class="spec value" id="val-max"><a href="#val-max" class="anchor"></a><code><span class="keyword">val</span> max : <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p><code>max l</code> returns the largest value in <code>l</code> as judged by <code>Pervasives.compare</code>.</p><dl><dt>raises Invalid_argument</dt><dd><p>on an empty list.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-min"><a href="#val-min" class="anchor"></a><code><span class="keyword">val</span> min : <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p><code>min l</code> returns the smallest value in <code>l</code> as judged by <code>Pervasives.compare</code>.</p><dl><dt>raises Invalid_argument</dt><dd><p>on an empty list.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-sum"><a href="#val-sum" class="anchor"></a><code><span class="keyword">val</span> sum : int list <span>&#45;&gt;</span> int</code></dt><dd><p><code>sum l</code> returns the sum of the integers of <code>l</code>.</p><dl><dt>raises Invalid_argument</dt><dd><p>on the empty list.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-fsum"><a href="#val-fsum" class="anchor"></a><code><span class="keyword">val</span> fsum : float list <span>&#45;&gt;</span> float</code></dt><dd><p><code>fsum l</code> returns the sum of the floats of <code>l</code>.</p><dl><dt>raises Invalid_argument</dt><dd><p>on the empty list.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-favg"><a href="#val-favg" class="anchor"></a><code><span class="keyword">val</span> favg : float list <span>&#45;&gt;</span> float</code></dt><dd><p><code>favg l</code> returns the average of the floats of <code>l</code></p><dl><dt>raises Invalid_argument</dt><dd><p>on the empty list.</p></dd></dl><dl><dt>since</dt><dd>2.6.0</dd></dl></dd></dl><dl><dt class="spec value" id="val-kahan_sum"><a href="#val-kahan_sum" class="anchor"></a><code><span class="keyword">val</span> kahan_sum : float list <span>&#45;&gt;</span> float</code></dt><dd><p><code>kahan_sum l</code> returns a numerically-accurate sum of the floats of <code>l</code>. See <a href="../BatArray/index.html#val-fsum"><code>BatArray.fsum</code></a> for more details.</p><dl><dt>since</dt><dd>2.2.0</dd></dl></dd></dl><dl><dt class="spec value" id="val-min_max"><a href="#val-min_max" class="anchor"></a><code><span class="keyword">val</span> min_max : ?&#8288;cmp:(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> int) <span>&#45;&gt;</span> <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'a</span> * <span class="type-var">'a</span></code></dt><dd><p><code>min_max l</code> returns the pair (smallest, largest) from <code>l</code> as judged by <code>Pervasives.compare</code> (by default). You can provide another comparison function via the optional <code>cmp</code> parameter.</p><dl><dt>raises Invalid_argument</dt><dd><p>on an empty list.</p></dd></dl><dl><dt>since</dt><dd>2.1</dd></dl></dd></dl></section><section><header><h6 id="iterators-on-two-lists"><a href="#iterators-on-two-lists" class="anchor"></a>Iterators on two lists</h6></header><dl><dt class="spec value" id="val-iter2"><a href="#val-iter2" class="anchor"></a><code><span class="keyword">val</span> iter2 : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> unit) <span>&#45;&gt;</span> <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'b</span> list <span>&#45;&gt;</span> unit</code></dt><dd><p><code>List.iter2 f [a0; a1; ...; an] [b0; b1; ...; bn]</code> calls in turn <code>f a0 b0; f a1 b1; ...; f an bn</code>.</p><dl><dt>raises Invalid_argument</dt><dd><p>if two lists have different lengths.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-iter2i"><a href="#val-iter2i" class="anchor"></a><code><span class="keyword">val</span> iter2i : (int <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> unit) <span>&#45;&gt;</span> <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'b</span> list <span>&#45;&gt;</span> unit</code></dt><dd><p><code>List.iter2i f [a0; a1; ...; an] [b0; b1; ...; bn]</code> calls in turn <code>f 0 a0 b0; f 1 a1 b1; ...; f n an bn</code>.</p><dl><dt>raises Invalid_argument</dt><dd><p>if two lists have different lengths.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-map2"><a href="#val-map2" class="anchor"></a><code><span class="keyword">val</span> map2 : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'c</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'b</span> list <span>&#45;&gt;</span> <span class="type-var">'c</span> list</code></dt><dd><p><code>List.map2 f [a0; a1; ...; an] [b0; b1; ...; bn]</code> is <code>[f a0 b0; f a1 b1; ...; f an bn]</code>.</p><dl><dt>raises Invalid_argument</dt><dd><p>if two lists have different lengths. Tail-recursive.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-map2i"><a href="#val-map2i" class="anchor"></a><code><span class="keyword">val</span> map2i : (int <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'c</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'b</span> list <span>&#45;&gt;</span> <span class="type-var">'c</span> list</code></dt><dd><p><code>List.map2i f [a0; a1; ...; an] [b0; b1; ...; bn]</code> is <code>[f 0 a0 b0; f 1 a1 b1; ...; f n an bn]</code>.</p><dl><dt>raises Invalid_argument</dt><dd><p>if two lists have different lengths. Tail-recursive.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-rev_map2"><a href="#val-rev_map2" class="anchor"></a><code><span class="keyword">val</span> rev_map2 : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'c</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'b</span> list <span>&#45;&gt;</span> <span class="type-var">'c</span> list</code></dt><dd><p><code>List.rev_map2 f l1 l2</code> gives the same result as <span class="xref-unresolved" title="unresolved reference to &quot;List.rev&quot;"><code>List</code>.rev</span><code> (</code><span class="xref-unresolved" title="unresolved reference to &quot;List.map2&quot;"><code>List</code>.map2</span><code> f l1 l2)</code>, but is tail-recursive and more efficient.</p></dd></dl><dl><dt class="spec value" id="val-fold_left2"><a href="#val-fold_left2" class="anchor"></a><code><span class="keyword">val</span> fold_left2 : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'c</span> <span>&#45;&gt;</span> <span class="type-var">'a</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> list <span>&#45;&gt;</span> <span class="type-var">'c</span> list <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p><code>List.fold_left2 f a [b0; b1; ...; bn] [c0; c1; ...; cn]</code> is <code>f (... (f (f a b0 c0) b1 c1) ...) bn cn</code>.</p><dl><dt>raises Invalid_argument</dt><dd><p>if two lists have different lengths.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-fold_right2"><a href="#val-fold_right2" class="anchor"></a><code><span class="keyword">val</span> fold_right2 : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'c</span> <span>&#45;&gt;</span> <span class="type-var">'c</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'b</span> list <span>&#45;&gt;</span> <span class="type-var">'c</span> <span>&#45;&gt;</span> <span class="type-var">'c</span></code></dt><dd><p><code>List.fold_right2 f [a0; a1; ...; an] [b0; b1; ...; bn] c</code> is <code>f a0 b0 (f a1 b1 (... (f an bn c) ...))</code>.</p><dl><dt>raises Invalid_argument</dt><dd><p>if two lists have different lengths. Tail-recursive.</p></dd></dl></dd></dl></section><section><header><h6 id="list-scanning"><a href="#list-scanning" class="anchor"></a>List scanning</h6></header><dl><dt class="spec value" id="val-mem"><a href="#val-mem" class="anchor"></a><code><span class="keyword">val</span> mem : <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> list <span>&#45;&gt;</span> bool</code></dt><dd><p><code>mem a l</code> is true if and only if <code>a</code> is equal to an element of <code>l</code>.</p></dd></dl><dl><dt class="spec value" id="val-mem_cmp"><a href="#val-mem_cmp" class="anchor"></a><code><span class="keyword">val</span> mem_cmp : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> int) <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> list <span>&#45;&gt;</span> bool</code></dt><dd><p>Same as <span class="xref-unresolved" title="unresolved reference to &quot;List.mem&quot;"><code>List</code>.mem</span>, but the comparator function is explicitely provided.</p><dl><dt>since</dt><dd>2.2.0</dd></dl></dd></dl><dl><dt class="spec value" id="val-memq"><a href="#val-memq" class="anchor"></a><code><span class="keyword">val</span> memq : <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> list <span>&#45;&gt;</span> bool</code></dt><dd><p>Same as <span class="xref-unresolved" title="unresolved reference to &quot;List.mem&quot;"><code>List</code>.mem</span>, but uses physical equality instead of structural equality to compare list elements.</p></dd></dl></section><section><header><h6 id="unary-predicate,-one-list"><a href="#unary-predicate,-one-list" class="anchor"></a>Unary predicate, One list</h6></header><dl><dt class="spec value" id="val-for_all"><a href="#val-for_all" class="anchor"></a><code><span class="keyword">val</span> for_all : (<span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <span class="type-var">'a</span> list <span>&#45;&gt;</span> bool</code></dt><dd><p><code>for_all p [a0; a1; ...; an]</code> checks if all elements of the list satisfy the predicate <code>p</code>. That is, it returns <code>(p a0) &amp;&amp; (p a1) &amp;&amp; ... &amp;&amp; (p an)</code>.</p></dd></dl><dl><dt class="spec value" id="val-exists"><a href="#val-exists" class="anchor"></a><code><span class="keyword">val</span> exists : (<span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <span class="type-var">'a</span> list <span>&#45;&gt;</span> bool</code></dt><dd><p><code>exists p [a0; a1; ...; an]</code> checks if at least one element of the list satisfies the predicate <code>p</code>. That is, it returns <code>(p a0) || (p a1) || ... || (p an)</code>.</p></dd></dl></section><section><header><h6 id="binary-predicate,-two-lists"><a href="#binary-predicate,-two-lists" class="anchor"></a>Binary predicate, Two lists</h6></header><dl><dt class="spec value" id="val-for_all2"><a href="#val-for_all2" class="anchor"></a><code><span class="keyword">val</span> for_all2 : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'b</span> list <span>&#45;&gt;</span> bool</code></dt><dd><p>Same as <span class="xref-unresolved" title="unresolved reference to &quot;List.for_all&quot;"><code>List</code>.for_all</span>, but for a two-argument predicate.</p><dl><dt>raises Invalid_argument</dt><dd><p>if two lists have different lengths.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-exists2"><a href="#val-exists2" class="anchor"></a><code><span class="keyword">val</span> exists2 : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'b</span> list <span>&#45;&gt;</span> bool</code></dt><dd><p>Same as <span class="xref-unresolved" title="unresolved reference to &quot;List.exists&quot;"><code>List</code>.exists</span>, but for a two-argument predicate.</p><dl><dt>raises Invalid_argument</dt><dd><p>if two lists have different lengths.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-subset"><a href="#val-subset" class="anchor"></a><code><span class="keyword">val</span> subset : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> int) <span>&#45;&gt;</span> <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'b</span> list <span>&#45;&gt;</span> bool</code></dt><dd><p><code>subset cmp l l'</code> check if all elements of the list <code>l</code> is contained in the list <code>l'</code> by applying <code>cmp</code> as comparator.</p><dl><dt>since</dt><dd>2.2.0</dd></dl></dd></dl></section><section><header><h6 id="list-searching"><a href="#list-searching" class="anchor"></a>List searching</h6></header><dl><dt class="spec value" id="val-find"><a href="#val-find" class="anchor"></a><code><span class="keyword">val</span> find : (<span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p><code>find p l</code> returns the first element of the list <code>l</code> that satisfies the predicate <code>p</code>.</p><dl><dt>raises Not_found</dt><dd><p>if there is no value that satisfies <code>p</code> in the list <code>l</code>.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-find_opt"><a href="#val-find_opt" class="anchor"></a><code><span class="keyword">val</span> find_opt : (<span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'a</span> option</code></dt><dd><p><code>find_opt p l</code> returns the first element of the list <code>l</code> that satisfies the predicate <code>p</code>, or <code>None</code> if there is no value that satisfies <code>p</code> in the list <code>l</code>.</p><dl><dt>since</dt><dd>2.7.0</dd></dl></dd></dl><dl><dt class="spec value" id="val-find_exn"><a href="#val-find_exn" class="anchor"></a><code><span class="keyword">val</span> find_exn : (<span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> exn <span>&#45;&gt;</span> <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p><code>find_exn p e l</code> returns the first element of <code>l</code> such as <code>p x</code> returns <code>true</code> or raises <code>e</code> if such an element has not been found.</p></dd></dl><dl><dt class="spec value" id="val-findi"><a href="#val-findi" class="anchor"></a><code><span class="keyword">val</span> findi : (int <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <span class="type-var">'a</span> list <span>&#45;&gt;</span> int * <span class="type-var">'a</span></code></dt><dd><p><code>findi p e l</code> returns the first element <code>ai</code> of <code>l</code> along with its index <code>i</code> such that <code>p i ai</code> is true, or </p><dl><dt>raises Not_found</dt><dd><p>if no such element has been found.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-find_map"><a href="#val-find_map" class="anchor"></a><code><span class="keyword">val</span> find_map : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> option) <span>&#45;&gt;</span> <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'b</span></code></dt><dd><p><code>find_map pred list</code> finds the first element of <code>list</code> for which <code>pred element</code> returns <code>Some r</code>. It returns <code>r</code> immediately once found or </p><dl><dt>raises Not_found</dt><dd><p>if no element matches the predicate. See also <a href="index.html#val-filter_map"><code>filter_map</code></a>.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-rfind"><a href="#val-rfind" class="anchor"></a><code><span class="keyword">val</span> rfind : (<span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p><code>rfind p l</code> returns the last element <code>x</code> of <code>l</code> such as <code>p x</code> returns <code>true</code> or </p><dl><dt>raises Not_found</dt><dd><p>if such element as not been found.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-filter"><a href="#val-filter" class="anchor"></a><code><span class="keyword">val</span> filter : (<span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'a</span> list</code></dt><dd><p><code>filter p l</code> returns all the elements of the list <code>l</code> that satisfy the predicate <code>p</code>. The order of the elements in the input list is preserved.</p></dd></dl><dl><dt class="spec value" id="val-filteri"><a href="#val-filteri" class="anchor"></a><code><span class="keyword">val</span> filteri : (int <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'a</span> list</code></dt><dd><p><code>filteri p [a0; a1; ...; an]</code> returns all the elements <code>ai</code> of index <code>i</code> that satisfy the predicate <code>p i ai</code>. The order of the elements in the input list is preserved.</p><dl><dt>since</dt><dd>2.2.0</dd></dl></dd></dl><dl><dt class="spec value" id="val-filter_map"><a href="#val-filter_map" class="anchor"></a><code><span class="keyword">val</span> filter_map : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> option) <span>&#45;&gt;</span> <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'b</span> list</code></dt><dd><p><code>filter_map f l</code> calls <code>(f a0) (f a1).... (f an)</code> where <code>a0,a1..an</code> are the elements of <code>l</code>. It returns the list of elements <code>bi</code> such as <code>f ai = Some bi</code> (when <code>f</code> returns <code>None</code>, the corresponding element of <code>l</code> is discarded).</p></dd></dl><dl><dt class="spec value" id="val-filteri_map"><a href="#val-filteri_map" class="anchor"></a><code><span class="keyword">val</span> filteri_map : (int <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> option) <span>&#45;&gt;</span> <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'b</span> list</code></dt><dd><p><code>filteri_map f l</code> calls <code>(f 0 a0) (f 1 a1).... (f n an)</code> where <code>a0,a1..an</code> are the elements of <code>l</code>. It returns the list of elements <code>bi</code> such as <code>f ai = Some bi</code> (when <code>f</code> returns <code>None</code>, the corresponding element of <code>l</code> is discarded).</p><dl><dt>since</dt><dd>2.2.0</dd></dl></dd></dl><dl><dt class="spec value" id="val-find_all"><a href="#val-find_all" class="anchor"></a><code><span class="keyword">val</span> find_all : (<span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'a</span> list</code></dt><dd><p><code>find_all</code> is another name for <span class="xref-unresolved" title="unresolved reference to &quot;List.filter&quot;"><code>List</code>.filter</span>.</p></dd></dl><dl><dt class="spec value" id="val-partition"><a href="#val-partition" class="anchor"></a><code><span class="keyword">val</span> partition : (<span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'a</span> list * <span class="type-var">'a</span> list</code></dt><dd><p><code>partition p l</code> returns a pair of lists <code>(l1, l2)</code>, where <code>l1</code> is the list of all the elements of <code>l</code> that satisfy the predicate <code>p</code>, and <code>l2</code> is the list of all the elements of <code>l</code> that do not satisfy <code>p</code>. The order of the elements in the input list is preserved.</p></dd></dl><dl><dt class="spec value" id="val-index_of"><a href="#val-index_of" class="anchor"></a><code><span class="keyword">val</span> index_of : <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> list <span>&#45;&gt;</span> int option</code></dt><dd><p><code>index_of e l</code> returns the index of the first occurrence of <code>e</code> in <code>l</code>, or <code>None</code> if there is no occurrence of <code>e</code> in <code>l</code></p></dd></dl><dl><dt class="spec value" id="val-index_ofq"><a href="#val-index_ofq" class="anchor"></a><code><span class="keyword">val</span> index_ofq : <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> list <span>&#45;&gt;</span> int option</code></dt><dd><p><code>index_ofq e l</code> behaves as <code>index_of e l</code> except it uses physical equality</p></dd></dl><dl><dt class="spec value" id="val-rindex_of"><a href="#val-rindex_of" class="anchor"></a><code><span class="keyword">val</span> rindex_of : <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> list <span>&#45;&gt;</span> int option</code></dt><dd><p><code>rindex_of e l</code> returns the index of the last occurrence of <code>e</code> in <code>l</code>, or <code>None</code> if there is no occurrence of <code>e</code> in <code>l</code></p></dd></dl><dl><dt class="spec value" id="val-rindex_ofq"><a href="#val-rindex_ofq" class="anchor"></a><code><span class="keyword">val</span> rindex_ofq : <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> list <span>&#45;&gt;</span> int option</code></dt><dd><p><code>rindex_ofq e l</code> behaves as <code>rindex_of e l</code> except it uses physical equality</p></dd></dl><dl><dt class="spec value" id="val-unique"><a href="#val-unique" class="anchor"></a><code><span class="keyword">val</span> unique : ?&#8288;eq:(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'a</span> list</code></dt><dd><p><code>unique cmp l</code> returns the list <code>l</code> without any duplicate element. The default comparator ( = ) is used if no comparison function specified.</p><p>Implementation Note: The current implementation removes any elements where the tail of the list contains an equal element, thus it keeps the *last* copy of each equal element.</p><p>This function takes O(n^2) time.</p><dl><dt>see <code>sort_unique</code></dt><dd><p>to save time in cases when reordering the list is acceptable</p></dd></dl><dl><dt>since</dt><dd>2.0</dd></dl></dd></dl><dl><dt class="spec value" id="val-unique_cmp"><a href="#val-unique_cmp" class="anchor"></a><code><span class="keyword">val</span> unique_cmp : ?&#8288;cmp:(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> int) <span>&#45;&gt;</span> <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'a</span> list</code></dt><dd><p>As <code>unique</code>, except comparator parameter returns an int. Default comparator is <code>Pervasives.compare</code>. This function takes O(n log n) time.</p><p>Implementation Note: The current implementation removes subsequent elements that compare as equal to earlier elements in the list, thus it keeps the *first* copy of each equal element.</p><dl><dt>since</dt><dd>1.3.0</dd></dl></dd></dl><dl><dt class="spec value" id="val-unique_hash"><a href="#val-unique_hash" class="anchor"></a><code><span class="keyword">val</span> unique_hash : ?&#8288;hash:(<span class="type-var">'a</span> <span>&#45;&gt;</span> int) <span>&#45;&gt;</span> ?&#8288;eq:(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'a</span> list</code></dt><dd><p>As <code>unique</code>, except uses a hash table to cut down the expected runtime to linear, assuming a good hash function. <code>?hash</code> defaults to <code>Hashtbl.hash</code> and <code>?eq</code> defaults to <code>(=)</code>.</p><p>Implementation Note: The current implementation removes subsequent elements that hash and compare as equal to earlier elements in the list, thus it keeps the *first* copy of each equal element.</p><dl><dt>since</dt><dd>2.0.0</dd></dl></dd></dl></section><section><header><h6 id="association-lists"><a href="#association-lists" class="anchor"></a>Association lists</h6></header><dl><dt class="spec value" id="val-assoc"><a href="#val-assoc" class="anchor"></a><code><span class="keyword">val</span> assoc : <span class="type-var">'a</span> <span>&#45;&gt;</span> (<span class="type-var">'a</span> * <span class="type-var">'b</span>) list <span>&#45;&gt;</span> <span class="type-var">'b</span></code></dt><dd><p><code>assoc a l</code> returns the value associated with key <code>a</code> in the list of pairs <code>l</code>. That is, <code>assoc a [ ...; (a,b); ...] = b</code> if <code>(a,b)</code> is the leftmost binding of <code>a</code> in list <code>l</code>.</p><dl><dt>raises Not_found</dt><dd><p>if there is no value associated with <code>a</code> in the list <code>l</code>.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-assoc_opt"><a href="#val-assoc_opt" class="anchor"></a><code><span class="keyword">val</span> assoc_opt : <span class="type-var">'a</span> <span>&#45;&gt;</span> (<span class="type-var">'a</span> * <span class="type-var">'b</span>) list <span>&#45;&gt;</span> <span class="type-var">'b</span> option</code></dt><dd><p><code>assoc_opt a l</code> returns the value associated with key <code>a</code> in the list of pairs <code>l</code>. That is, <code>assoc_opt a [ ...; (a,b); ...] = b</code> if <code>(a,b)</code> is the leftmost binding of <code>a</code> in list <code>l</code>. Returns <code>None</code> if there is no value associated with <code>a</code> in the list <code>l</code>.</p><dl><dt>since</dt><dd>2.7.0</dd></dl></dd></dl><dl><dt class="spec value" id="val-assoc_inv"><a href="#val-assoc_inv" class="anchor"></a><code><span class="keyword">val</span> assoc_inv : <span class="type-var">'b</span> <span>&#45;&gt;</span> (<span class="type-var">'a</span> * <span class="type-var">'b</span>) list <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p><code>assoc_inv b l</code> returns the key associated with value <code>b</code> in the list of pairs <code>l</code>. That is, <code>assoc b [ ...; (a,b); ...] = a</code> if <code>(a,b)</code> is the leftmost binding of <code>a</code> in list <code>l</code>.</p><dl><dt>raises Not_found</dt><dd><p>if there is no key associated with <code>b</code> in the list <code>l</code>.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-remove_assoc"><a href="#val-remove_assoc" class="anchor"></a><code><span class="keyword">val</span> remove_assoc : <span class="type-var">'a</span> <span>&#45;&gt;</span> (<span class="type-var">'a</span> * <span class="type-var">'b</span>) list <span>&#45;&gt;</span> (<span class="type-var">'a</span> * <span class="type-var">'b</span>) list</code></dt><dd><p><code>remove_assoc a l</code> returns the list of pairs <code>l</code> without the first pair with key <code>a</code>, if any. Tail-recursive.</p></dd></dl><dl><dt class="spec value" id="val-mem_assoc"><a href="#val-mem_assoc" class="anchor"></a><code><span class="keyword">val</span> mem_assoc : <span class="type-var">'a</span> <span>&#45;&gt;</span> (<span class="type-var">'a</span> * <span class="type-var">'b</span>) list <span>&#45;&gt;</span> bool</code></dt><dd><p>Same as <span class="xref-unresolved" title="unresolved reference to &quot;List.assoc&quot;"><code>List</code>.assoc</span>, but simply return true if a binding exists, and false if no bindings exist for the given key.</p></dd></dl><dl><dt class="spec value" id="val-assq"><a href="#val-assq" class="anchor"></a><code><span class="keyword">val</span> assq : <span class="type-var">'a</span> <span>&#45;&gt;</span> (<span class="type-var">'a</span> * <span class="type-var">'b</span>) list <span>&#45;&gt;</span> <span class="type-var">'b</span></code></dt><dd><p>Same as <span class="xref-unresolved" title="unresolved reference to &quot;List.assoc&quot;"><code>List</code>.assoc</span>, but uses physical equality instead of structural equality to compare keys.</p></dd></dl><dl><dt class="spec value" id="val-assq_opt"><a href="#val-assq_opt" class="anchor"></a><code><span class="keyword">val</span> assq_opt : <span class="type-var">'a</span> <span>&#45;&gt;</span> (<span class="type-var">'a</span> * <span class="type-var">'b</span>) list <span>&#45;&gt;</span> <span class="type-var">'b</span> option</code></dt><dd><p>Same as <span class="xref-unresolved" title="unresolved reference to &quot;List.assoc_opt&quot;"><code>List</code>.assoc_opt</span>, but uses physical equality instead of structural equality to compare keys.</p><dl><dt>since</dt><dd>2.7.0</dd></dl></dd></dl><dl><dt class="spec value" id="val-assq_inv"><a href="#val-assq_inv" class="anchor"></a><code><span class="keyword">val</span> assq_inv : <span class="type-var">'b</span> <span>&#45;&gt;</span> (<span class="type-var">'a</span> * <span class="type-var">'b</span>) list <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p>Same as <span class="xref-unresolved" title="unresolved reference to &quot;List.assoc_inv&quot;"><code>List</code>.assoc_inv</span>, but uses physical equality instead of structural equality to compare keys.</p></dd></dl><dl><dt class="spec value" id="val-remove_assq"><a href="#val-remove_assq" class="anchor"></a><code><span class="keyword">val</span> remove_assq : <span class="type-var">'a</span> <span>&#45;&gt;</span> (<span class="type-var">'a</span> * <span class="type-var">'b</span>) list <span>&#45;&gt;</span> (<span class="type-var">'a</span> * <span class="type-var">'b</span>) list</code></dt><dd><p>Same as <span class="xref-unresolved" title="unresolved reference to &quot;List.remove_assoc&quot;"><code>List</code>.remove_assoc</span>, but uses physical equality instead of structural equality to compare keys. Tail-recursive.</p></dd></dl><dl><dt class="spec value" id="val-mem_assq"><a href="#val-mem_assq" class="anchor"></a><code><span class="keyword">val</span> mem_assq : <span class="type-var">'a</span> <span>&#45;&gt;</span> (<span class="type-var">'a</span> * <span class="type-var">'b</span>) list <span>&#45;&gt;</span> bool</code></dt><dd><p>Same as <span class="xref-unresolved" title="unresolved reference to &quot;List.mem_assoc&quot;"><code>List</code>.mem_assoc</span>, but uses physical equality instead of structural equality to compare keys.</p></dd></dl><dl><dt class="spec value" id="val-modify"><a href="#val-modify" class="anchor"></a><code><span class="keyword">val</span> modify : <span class="type-var">'a</span> <span>&#45;&gt;</span> (<span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>) <span>&#45;&gt;</span> (<span class="type-var">'a</span> * <span class="type-var">'b</span>) list <span>&#45;&gt;</span> (<span class="type-var">'a</span> * <span class="type-var">'b</span>) list</code></dt><dd><p><code>modify a f l</code> returns the same list as <code>l</code> but with value associated to key <code>a</code> replaced with <code>f a</code>.</p><dl><dt>raises Not_found</dt><dd><p>if no value is associated with <code>a</code> in <code>l</code></p></dd></dl><dl><dt>since</dt><dd>2.1</dd></dl></dd></dl><dl><dt class="spec value" id="val-modify_def"><a href="#val-modify_def" class="anchor"></a><code><span class="keyword">val</span> modify_def : <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> (<span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>) <span>&#45;&gt;</span> (<span class="type-var">'a</span> * <span class="type-var">'b</span>) list <span>&#45;&gt;</span> (<span class="type-var">'a</span> * <span class="type-var">'b</span>) list</code></dt><dd><p><code>modify_def dfl a f l</code> performs as <code>modify a f l</code> except that it add an association from <code>a</code> to <code>f dfl</code> instead of raising <code>Not_found</code>.</p><dl><dt>since</dt><dd>2.1</dd></dl></dd></dl><dl><dt class="spec value" id="val-modify_opt"><a href="#val-modify_opt" class="anchor"></a><code><span class="keyword">val</span> modify_opt : <span class="type-var">'a</span> <span>&#45;&gt;</span> (<span class="type-var">'b</span> option <span>&#45;&gt;</span> <span class="type-var">'b</span> option) <span>&#45;&gt;</span> (<span class="type-var">'a</span> * <span class="type-var">'b</span>) list <span>&#45;&gt;</span> (<span class="type-var">'a</span> * <span class="type-var">'b</span>) list</code></dt><dd><p><code>modify_opt a f l</code> allows to modify the binding for <code>a</code> in <code>l</code> or absence thereof.</p><dl><dt>since</dt><dd>2.1</dd></dl></dd></dl></section><section><header><h6 id="list-transformations"><a href="#list-transformations" class="anchor"></a>List transformations</h6></header><dl><dt class="spec value" id="val-modify_at"><a href="#val-modify_at" class="anchor"></a><code><span class="keyword">val</span> modify_at : int <span>&#45;&gt;</span> (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'a</span> list</code></dt><dd><p><code>modify_at n f l</code> returns the same list as <code>l</code> but with nth-value <code>a</code> replaced with <code>f a</code>.</p><dl><dt>raises Invalid_argument</dt><dd><p>if the index is outside of <code>l</code> bounds</p></dd></dl><dl><dt>since</dt><dd>2.3.0</dd></dl></dd></dl><dl><dt class="spec value" id="val-modify_opt_at"><a href="#val-modify_opt_at" class="anchor"></a><code><span class="keyword">val</span> modify_opt_at : int <span>&#45;&gt;</span> (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> option) <span>&#45;&gt;</span> <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'a</span> list</code></dt><dd><p><code>modify_opt_at n f l</code> returns the same list as <code>l</code> but with nth-value <code>a</code> removed if <code>f a</code> is <code>None</code>, and replaced by <code>v</code> if it is <code>Some v</code>.</p><dl><dt>raises Invalid_argument</dt><dd><p>if the index is outside of <code>l</code> bounds</p></dd></dl><dl><dt>since</dt><dd>2.3.0</dd></dl></dd></dl><dl><dt class="spec value" id="val-split_at"><a href="#val-split_at" class="anchor"></a><code><span class="keyword">val</span> split_at : int <span>&#45;&gt;</span> <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'a</span> list * <span class="type-var">'a</span> list</code></dt><dd><p><code>split_at n l</code> returns two lists <code>l1</code> and <code>l2</code>, <code>l1</code> containing the first <code>n</code> elements of <code>l</code> and <code>l2</code> the others. </p><dl><dt>raises Invalid_argument</dt><dd><p>if <code>n</code> is outside of <code>l</code> size bounds.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-split_nth"><a href="#val-split_nth" class="anchor"></a><code><span class="keyword">val</span> split_nth : int <span>&#45;&gt;</span> <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'a</span> list * <span class="type-var">'a</span> list</code></dt><dd><p>Obsolete. As <code>split_at</code>.</p></dd></dl><dl><dt class="spec value" id="val-remove"><a href="#val-remove" class="anchor"></a><code><span class="keyword">val</span> remove : <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> list</code></dt><dd><p><code>remove l x</code> returns the list <code>l</code> without the first element <code>x</code> found or returns <code>l</code> if no element is equal to <code>x</code>. Elements are compared using ( = ).</p></dd></dl><dl><dt class="spec value" id="val-remove_if"><a href="#val-remove_if" class="anchor"></a><code><span class="keyword">val</span> remove_if : (<span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'a</span> list</code></dt><dd><p><code>remove_if cmp l</code> is similar to <code>remove</code>, but with <code>cmp</code> used instead of ( = ).</p></dd></dl><dl><dt class="spec value" id="val-remove_at"><a href="#val-remove_at" class="anchor"></a><code><span class="keyword">val</span> remove_at : int <span>&#45;&gt;</span> <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'a</span> list</code></dt><dd><p><code>remove_at i l</code> returns the list <code>l</code> without the element at index <code>i</code>.</p><dl><dt>raises Invalid_argument</dt><dd><p>if <code>i</code> is outside of <code>l</code> size bounds.</p></dd></dl><dl><dt>since</dt><dd>2.3.0</dd></dl></dd></dl><dl><dt class="spec value" id="val-remove_all"><a href="#val-remove_all" class="anchor"></a><code><span class="keyword">val</span> remove_all : <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> list</code></dt><dd><p><code>remove_all l x</code> is similar to <code>remove</code> but removes all elements that are equal to <code>x</code> and not only the first one.</p></dd></dl><dl><dt class="spec value" id="val-take"><a href="#val-take" class="anchor"></a><code><span class="keyword">val</span> take : int <span>&#45;&gt;</span> <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'a</span> list</code></dt><dd><p><code>take n l</code> returns up to the <code>n</code> first elements from list <code>l</code>, if available.</p></dd></dl><dl><dt class="spec value" id="val-ntake"><a href="#val-ntake" class="anchor"></a><code><span class="keyword">val</span> ntake : int <span>&#45;&gt;</span> <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'a</span> list list</code></dt><dd><p><code>ntake n l</code> cuts <code>l</code> into lists of size at most <code>n</code>. <code>n</code> must be &gt; 0.</p><dl><dt>raises Invalid_argument</dt><dd><p>if <code>n</code> &lt;= 0. Each list in the result has size n, except the last one which may have fewer elements in case <code>l</code> was too short. Example: <code>ntake 2 [1; 2; 3; 4; 5] = [[1; 2]; [3; 4]; [5]]</code></p></dd></dl><dl><dt>since</dt><dd>2.2.0</dd></dl></dd></dl><dl><dt class="spec value" id="val-drop"><a href="#val-drop" class="anchor"></a><code><span class="keyword">val</span> drop : int <span>&#45;&gt;</span> <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'a</span> list</code></dt><dd><p><code>drop n l</code> returns <code>l</code> without the first <code>n</code> elements, or the empty list if <code>l</code> have less than <code>n</code> elements.</p></dd></dl><dl><dt class="spec value" id="val-takedrop"><a href="#val-takedrop" class="anchor"></a><code><span class="keyword">val</span> takedrop : int <span>&#45;&gt;</span> <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'a</span> list * <span class="type-var">'a</span> list</code></dt><dd><p><code>takedrop n l</code> is equivalent to <code>(take n l, drop n l)</code> but is done in one pass.</p><dl><dt>since</dt><dd>2.2.0</dd></dl></dd></dl><dl><dt class="spec value" id="val-take_while"><a href="#val-take_while" class="anchor"></a><code><span class="keyword">val</span> take_while : (<span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'a</span> list</code></dt><dd><p><code>take_while p xs</code> returns the (possibly empty) longest prefix of elements of <code>xs</code> that satisfy the predicate <code>p</code>.</p></dd></dl><dl><dt class="spec value" id="val-drop_while"><a href="#val-drop_while" class="anchor"></a><code><span class="keyword">val</span> drop_while : (<span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'a</span> list</code></dt><dd><p><code>drop_while p xs</code> returns the suffix remaining after <code>take_while p xs</code>.</p></dd></dl><dl><dt class="spec value" id="val-span"><a href="#val-span" class="anchor"></a><code><span class="keyword">val</span> span : (<span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'a</span> list * <span class="type-var">'a</span> list</code></dt><dd><p><code>span</code>, applied to a predicate <code>p</code> and a list <code>xs</code>, returns a tuple where first element is longest prefix (possibly empty) of xs of elements that satisfy p and second element is the remainder of the list. This is equivalent to <code>(take_while p xs, drop_while p xs)</code>, but is done in one pass.</p><dl><dt>since</dt><dd>2.1</dd></dl></dd></dl><dl><dt class="spec value" id="val-nsplit"><a href="#val-nsplit" class="anchor"></a><code><span class="keyword">val</span> nsplit : (<span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'a</span> list list</code></dt><dd><p><code>nsplit</code>, applied to a predicate <code>p</code> and a list <code>xs</code>, returns a list of lists. <code>xs</code> is split when <code>p x</code> is true and <code>x</code> is excluded from the result.</p><p>If elements that satisfy <code>p</code> are consecutive, or at the beginning or end of the input list, the output list will contain empty lists marking their position. For example, <code>split (fun n -&gt; n&lt;0) [-1;2;-2;-3;4;-5]</code> is <code>[[];[2];[];[4];[]]</code>. This is consistent with the behavior of <code>String.nsplit</code>, where <code>String.nsplit &quot;;&quot; &quot;1;2;;3;&quot; = [&quot;1&quot;;&quot;2&quot;;&quot;&quot;;&quot;3&quot;;&quot;&quot;]</code>.</p><p>Note that for any <code>xss : 'a list list</code> and <code>sep : 'a</code>, we always have that <code>flatten (interleave [sep] (nsplit ((=) sep) xss))</code> is <code>xss</code>.</p><dl><dt>since</dt><dd>2.1</dd></dl></dd></dl><dl><dt class="spec value" id="val-group_consecutive"><a href="#val-group_consecutive" class="anchor"></a><code><span class="keyword">val</span> group_consecutive : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'a</span> list list</code></dt><dd><p>The <code>group_consecutive</code> function takes a list and returns a list of lists such that the concatenation of the result is equal to the argument. Moreover, each sublist in the result contains only equal elements. For example, <code>group_consecutive (=) [3;3;4;3;3] =  [[3;3];[4];[3;3]]</code>.</p><p><b>Note:</b> In the next major version, this function is intended to replace the current <code>group</code>, which also sorts its input before grouping, and which will therefore be renamed into something more pertinent, such as <code>classify</code>, <code>regroup</code>, or <code>group_sort</code>.</p><dl><dt>since</dt><dd>2.1</dd></dl></dd></dl><dl><dt class="spec value" id="val-interleave"><a href="#val-interleave" class="anchor"></a><code><span class="keyword">val</span> interleave : ?&#8288;first:<span class="type-var">'a</span> <span>&#45;&gt;</span> ?&#8288;last:<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'a</span> list</code></dt><dd><p><code>interleave ~first ~last sep [a0;a1;a2;...;an]</code> returns <code>first; a0; sep; a1; sep; a2; sep; ...; sep; an; last</code>.</p></dd></dl></section><section><header><h6 id="batenum-functions"><a href="#batenum-functions" class="anchor"></a>BatEnum functions</h6><p>Abstraction layer.</p></header><dl><dt class="spec value" id="val-enum"><a href="#val-enum" class="anchor"></a><code><span class="keyword">val</span> enum : <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="../BatEnum/index.html#type-t">BatEnum.t</a></code></dt><dd><p>Returns an enumeration of the elements of a list. This enumeration may be used to visit elements of the list in forward order (i.e. from the first element to the last one).</p></dd></dl><dl><dt class="spec value" id="val-of_enum"><a href="#val-of_enum" class="anchor"></a><code><span class="keyword">val</span> of_enum : <span class="type-var">'a</span> <a href="../BatEnum/index.html#type-t">BatEnum.t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> list</code></dt><dd><p>Build a list from an enumeration. In the result, elements appear in the same order as they did in the source enumeration.</p></dd></dl><dl><dt class="spec value" id="val-backwards"><a href="#val-backwards" class="anchor"></a><code><span class="keyword">val</span> backwards : <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="../BatEnum/index.html#type-t">BatEnum.t</a></code></dt><dd><p>Returns an enumeration of the elements of a list. This enumeration may be used to visit elements of the list in backwards order (i.e. from the last element to the first one).</p></dd></dl><dl><dt class="spec value" id="val-of_backwards"><a href="#val-of_backwards" class="anchor"></a><code><span class="keyword">val</span> of_backwards : <span class="type-var">'a</span> <a href="../BatEnum/index.html#type-t">BatEnum.t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> list</code></dt><dd><p>Build a list from an enumeration. The first element of the enumeration becomes the last element of the list, the second element of the enumeration becomes the second-to-last element of the list...</p></dd></dl></section><section><header><h6 id="list-of-pairs"><a href="#list-of-pairs" class="anchor"></a>List of pairs</h6></header><dl><dt class="spec value" id="val-split"><a href="#val-split" class="anchor"></a><code><span class="keyword">val</span> split : (<span class="type-var">'a</span> * <span class="type-var">'b</span>) list <span>&#45;&gt;</span> <span class="type-var">'a</span> list * <span class="type-var">'b</span> list</code></dt><dd><p>Transform a list of pairs into a pair of lists: <code>split [(a0,b0); (a1,b1); ...; (an,bn)]</code> is <code>([a0; a1; ...; an], [b0;
    b1; ...; bn])</code>. Tail-recursive.</p></dd></dl><dl><dt class="spec value" id="val-combine"><a href="#val-combine" class="anchor"></a><code><span class="keyword">val</span> combine : <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'b</span> list <span>&#45;&gt;</span> (<span class="type-var">'a</span> * <span class="type-var">'b</span>) list</code></dt><dd><p>Transform a pair of lists into a list of pairs: <code>combine [a0; a1; ...; an] [b0; b1; ...; bn]</code> is <code>[(a0,b0); (a1,b1); ...; (an,bn)]</code>.</p><dl><dt>raises Invalid_argument</dt><dd><p>if two lists have different lengths. Tail-recursive.</p></dd></dl></dd></dl></section><section><header><h6 id="sorting"><a href="#sorting" class="anchor"></a>Sorting</h6></header><dl><dt class="spec value" id="val-sort"><a href="#val-sort" class="anchor"></a><code><span class="keyword">val</span> sort : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> int) <span>&#45;&gt;</span> <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'a</span> list</code></dt><dd><p>Sort a list in increasing order according to a comparison function. The comparison function must return 0 if its arguments compare as equal, a positive integer if the first is greater, and a negative integer if the first is smaller (see Array.sort for a complete specification). For example, <span class="xref-unresolved" title="unresolved reference to &quot;Pervasives.compare&quot;"><code>Pervasives</code>.compare</span> is a suitable comparison function. The resulting list is sorted in increasing order. <code>List.sort</code> is guaranteed to run in constant heap space (in addition to the size of the result list) and logarithmic stack space.</p><p>The current implementation uses Merge Sort. It runs in constant heap space and logarithmic stack space.</p></dd></dl><dl><dt class="spec value" id="val-stable_sort"><a href="#val-stable_sort" class="anchor"></a><code><span class="keyword">val</span> stable_sort : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> int) <span>&#45;&gt;</span> <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'a</span> list</code></dt><dd><p>Same as <span class="xref-unresolved" title="unresolved reference to &quot;List.sort&quot;"><code>List</code>.sort</span>, but the sorting algorithm is guaranteed to be stable (i.e. elements that compare equal are kept in their original order) .</p><p>The current implementation uses Merge Sort. It runs in constant heap space and logarithmic stack space.</p></dd></dl><dl><dt class="spec value" id="val-fast_sort"><a href="#val-fast_sort" class="anchor"></a><code><span class="keyword">val</span> fast_sort : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> int) <span>&#45;&gt;</span> <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'a</span> list</code></dt><dd><p>Same as <span class="xref-unresolved" title="unresolved reference to &quot;List.sort&quot;"><code>List</code>.sort</span> or <span class="xref-unresolved" title="unresolved reference to &quot;List.stable_sort&quot;"><code>List</code>.stable_sort</span>, whichever is faster on typical input.</p></dd></dl><dl><dt class="spec value" id="val-merge"><a href="#val-merge" class="anchor"></a><code><span class="keyword">val</span> merge : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> int) <span>&#45;&gt;</span> <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'a</span> list</code></dt><dd><p>Merge two lists: Assuming that <code>l1</code> and <code>l2</code> are sorted according to the comparison function <code>cmp</code>, <code>merge cmp l1 l2</code> will return a sorted list containting all the elements of <code>l1</code> and <code>l2</code>. If several elements compare equal, the elements of <code>l1</code> will be before the elements of <code>l2</code>. Not tail-recursive (sum of the lengths of the arguments).</p></dd></dl><dl><dt class="spec value" id="val-sort_uniq"><a href="#val-sort_uniq" class="anchor"></a><code><span class="keyword">val</span> sort_uniq : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> int) <span>&#45;&gt;</span> <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'a</span> list</code></dt><dd><p><code>sort_uniq cmp l</code> returns the list <code>l</code> sorted and without any duplicate element. <code>cmp</code> is a usual comparison function providing total order.</p><p>This function takes O(n log n) time.</p><dl><dt>since</dt><dd>2.3.0</dd></dl></dd></dl><dl><dt class="spec value" id="val-sort_unique"><a href="#val-sort_unique" class="anchor"></a><code><span class="keyword">val</span> sort_unique : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> int) <span>&#45;&gt;</span> <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'a</span> list</code></dt><dd><p>synonym for <code>sort_uniq</code></p></dd></dl></section><section><header><h6 id="utilities"><a href="#utilities" class="anchor"></a>Utilities</h6></header><dl><dt class="spec value" id="val-group"><a href="#val-group" class="anchor"></a><code><span class="keyword">val</span> group : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> int) <span>&#45;&gt;</span> <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'a</span> list list</code></dt><dd><p><code>group cmp l</code> returns list of groups and each group consists of elements judged equal by comparison function <code>cmp</code>. Groups in the resulting list appear in order given by <code>cmp</code>. All groups are always nonempty. <code>group</code> returns <code>[]</code> only if <code>l</code> is empty.</p><p>For example <code>group cmp [f;c;b;e;d;a]</code> can give <code>[[a;b];[c];[d;e;f]]</code> if following conditions are met: <code>cmp a b = 0</code>, <code>cmp b c = -1</code>, <code>cmp c d = -1</code>, <code>cmp d e = 0</code>, ...</p><p>See the note on <code>group_consecutive</code>.</p></dd></dl><dl><dt class="spec value" id="val-cartesian_product"><a href="#val-cartesian_product" class="anchor"></a><code><span class="keyword">val</span> cartesian_product : <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'b</span> list <span>&#45;&gt;</span> (<span class="type-var">'a</span> * <span class="type-var">'b</span>) list</code></dt><dd><p>Different from <code>List.combine</code>, this returns every pair of elements formed out of the two lists. <code>cartesian_product [a0; a1; ...; an] [b0; b1; ...; bn] =
    [(a0,b0);(a0,b1); ...; (a0,bn); (a1,b0); ..; (a1, bn);
    ...; (an,bn)]</code>. The lists can be of unequal size.</p></dd></dl><dl><dt class="spec value" id="val-n_cartesian_product"><a href="#val-n_cartesian_product" class="anchor"></a><code><span class="keyword">val</span> n_cartesian_product : <span class="type-var">'a</span> list list <span>&#45;&gt;</span> <span class="type-var">'a</span> list list</code></dt><dd><p>Given n lists, return the n-way cartesian product of these lists. Given <code>[a;b];[c];[d;e;f]</code>, returns <code>[a;c;d];[a;c;e];[a;c;f];[b;c;d];[b;c;e];[b;c;f]</code>, all ways of choosing one element from each input list.</p></dd></dl><dl><dt class="spec value" id="val-transpose"><a href="#val-transpose" class="anchor"></a><code><span class="keyword">val</span> transpose : <span class="type-var">'a</span> list list <span>&#45;&gt;</span> <span class="type-var">'a</span> list list</code></dt><dd><p>Transposes a list of lists, turning rows of the input into columns of the output and vice versa.</p><dl><dt>since</dt><dd>2.0.0</dd></dl></dd></dl></section><section><header><h6 id="boilerplate-code"><a href="#boilerplate-code" class="anchor"></a>Boilerplate code</h6></header></section><section><header><h6 id="printing"><a href="#printing" class="anchor"></a>Printing</h6></header><dl><dt class="spec value" id="val-print"><a href="#val-print" class="anchor"></a><code><span class="keyword">val</span> print : ?&#8288;first:string <span>&#45;&gt;</span> ?&#8288;last:string <span>&#45;&gt;</span> ?&#8288;sep:string <span>&#45;&gt;</span> (<span class="type-var">'a</span> <a href="../BatInnerIO/index.html#type-output">BatInnerIO.output</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> unit) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="../BatInnerIO/index.html#type-output">BatInnerIO.output</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> list <span>&#45;&gt;</span> unit</code></dt><dd><p>Print the contents of a list</p></dd></dl><dl><dt class="spec value" id="val-eq"><a href="#val-eq" class="anchor"></a><code><span class="keyword">val</span> eq : <span class="type-var">'a</span> <a href="../BatOrd/index.html#type-eq">BatOrd.eq</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> list <a href="../BatOrd/index.html#type-eq">BatOrd.eq</a></code></dt><dt class="spec value" id="val-ord"><a href="#val-ord" class="anchor"></a><code><span class="keyword">val</span> ord : <span class="type-var">'a</span> <a href="../BatOrd/index.html#type-ord">BatOrd.ord</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> list <a href="../BatOrd/index.html#type-ord">BatOrd.ord</a></code></dt><dt class="spec value" id="val-compare"><a href="#val-compare" class="anchor"></a><code><span class="keyword">val</span> compare : <span class="type-var">'a</span> <a href="../BatOrd/index.html#type-comp">BatOrd.comp</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> list <a href="../BatOrd/index.html#type-comp">BatOrd.comp</a></code></dt></dl><aside><p>Comparison and equality for lists based on element comparison and equality</p></aside><div class="spec module" id="module-Eq"><a href="#module-Eq" class="anchor"></a><code><span class="keyword">module</span> <a href="Eq/index.html">Eq</a> : <span class="keyword">functor</span> (<a href="Eq/argument-1-T/index.html">T</a> : <a href="../BatOrd/index.html#module-type-Eq">BatOrd.Eq</a>) <span>&#45;&gt;</span> <a href="../BatOrd/index.html#module-type-Eq">BatOrd.Eq</a> <span class="keyword">with</span> <span class="keyword">type</span> <a href="Eq/index.html#type-t">t</a> = <a href="Eq/argument-1-T/index.html#type-t">T.t</a> list</code></div><div class="spec module" id="module-Ord"><a href="#module-Ord" class="anchor"></a><code><span class="keyword">module</span> <a href="Ord/index.html">Ord</a> : <span class="keyword">functor</span> (<a href="Ord/argument-1-T/index.html">T</a> : <a href="../BatOrd/index.html#module-type-Ord">BatOrd.Ord</a>) <span>&#45;&gt;</span> <a href="../BatOrd/index.html#module-type-Ord">BatOrd.Ord</a> <span class="keyword">with</span> <span class="keyword">type</span> <a href="Ord/index.html#type-t">t</a> = <a href="Ord/argument-1-T/index.html#type-t">T.t</a> list</code></div><div class="spec module" id="module-Comp"><a href="#module-Comp" class="anchor"></a><code><span class="keyword">module</span> <a href="Comp/index.html">Comp</a> : <span class="keyword">functor</span> (<a href="Comp/argument-1-T/index.html">T</a> : <a href="../BatOrd/index.html#module-type-Comp">BatOrd.Comp</a>) <span>&#45;&gt;</span> <a href="../BatOrd/index.html#module-type-Comp">BatOrd.Comp</a> <span class="keyword">with</span> <span class="keyword">type</span> <a href="Comp/index.html#type-t">t</a> = <a href="Comp/argument-1-T/index.html#type-t">T.t</a> list</code></div></section><section><header><h6 id="obsolete-functions"><a href="#obsolete-functions" class="anchor"></a>Obsolete functions</h6></header><dl><dt class="spec value" id="val-nth"><a href="#val-nth" class="anchor"></a><code><span class="keyword">val</span> nth : <span class="type-var">'a</span> list <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p>Obsolete. As <code>at</code>.</p></dd></dl><dl><dt class="spec value" id="val-nth_opt"><a href="#val-nth_opt" class="anchor"></a><code><span class="keyword">val</span> nth_opt : <span class="type-var">'a</span> list <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <span class="type-var">'a</span> option</code></dt><dd><p>Return the <code>n</code>-th element of the given list. The first element (head of the list) is at position 0. Return <code>None</code> if the list is too short. Raise <code>Invalid_argument &quot;List.nth&quot;</code> if <code>n</code> is negative.</p><dl><dt>since</dt><dd>2.7.0</dd></dl></dd></dl><dl><dt class="spec value" id="val-takewhile"><a href="#val-takewhile" class="anchor"></a><code><span class="keyword">val</span> takewhile : (<span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'a</span> list</code></dt><dd><p>obsolete, as <a href="index.html#val-take_while"><code>take_while</code></a></p></dd></dl><dl><dt class="spec value" id="val-dropwhile"><a href="#val-dropwhile" class="anchor"></a><code><span class="keyword">val</span> dropwhile : (<span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'a</span> list</code></dt><dd><p>obsolete, as <a href="index.html#val-drop_while"><code>drop_while</code></a></p></dd></dl></section><section><header><h6 id="override-modules"><a href="#override-modules" class="anchor"></a>Override modules</h6></header><aside><p>The following modules replace functions defined in <code>List</code> with functions behaving slightly differently but having the same name. This is by design: the functions are meant to override the corresponding functions of <code>List</code>.</p></aside><dl><dt class="spec module" id="module-Exceptionless"><a href="#module-Exceptionless" class="anchor"></a><code><span class="keyword">module</span> <a href="Exceptionless/index.html">Exceptionless</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Exceptionless counterparts for error-raising operations</p></dd></dl><dl><dt class="spec module" id="module-Infix"><a href="#module-Infix" class="anchor"></a><code><span class="keyword">module</span> <a href="Infix/index.html">Infix</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd></dd></dl><dl><dt class="spec module" id="module-Labels"><a href="#module-Labels" class="anchor"></a><code><span class="keyword">module</span> <a href="Labels/index.html">Labels</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Operations on <code>List</code> with labels.</p></dd></dl><dl><dt class="spec value" id="val-(@)"><a href="#val-(@)" class="anchor"></a><code><span class="keyword">val</span> (@) : <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'a</span> list</code></dt><dd><p>Tail recursive <code>List.append</code>.</p></dd></dl></section></div></body></html>