<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Make (batteries.BatMap.Make)</title><link rel="stylesheet" href="../../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../../index.html">batteries</a> &#x00BB; <a href="../index.html">BatMap</a> &#x00BB; Make</nav><h1>Module <code>BatMap.Make</code></h1><p>Functor building an implementation of the map structure given a totally ordered type.</p><nav class="toc"><ul><li><a href="#boilerplate-code">Boilerplate code</a></li><li><a href="#printing">Printing</a></li><li><a href="#override-modules">Override modules</a></li></ul></nav></header><h3 class="heading">Parameters</h3><ul><li><code><a href="argument-1-Ord/index.html">Ord</a> : <a href="../../BatInterfaces/index.html#module-type-OrderedType">BatInterfaces.OrderedType</a></code></li></ul><h3 class="heading">Signature</h3><dl><dt class="spec type" id="type-key"><a href="#type-key" class="anchor"></a><code><span class="keyword">type</span> key</code><code> = <a href="argument-1-Ord/index.html#type-t">Ord.t</a></code></dt><dd><p>The type of the map keys.</p></dd></dl><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> +'a t</code></dt><dd><p>The type of maps from type <code>key</code> to type <code>'a</code>.</p></dd></dl><dl><dt class="spec value" id="val-empty"><a href="#val-empty" class="anchor"></a><code><span class="keyword">val</span> empty : <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p>The empty map.</p></dd></dl><dl><dt class="spec value" id="val-is_empty"><a href="#val-is_empty" class="anchor"></a><code><span class="keyword">val</span> is_empty : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p>Test whether a map is empty or not.</p></dd></dl><dl><dt class="spec value" id="val-cardinal"><a href="#val-cardinal" class="anchor"></a><code><span class="keyword">val</span> cardinal : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int</code></dt><dd><p>Return the number of bindings of a map.</p></dd></dl><dl><dt class="spec value" id="val-add"><a href="#val-add" class="anchor"></a><code><span class="keyword">val</span> add : <a href="index.html#type-key">key</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>add x y m</code> returns a map containing the same bindings as <code>m</code>, plus a binding of <code>x</code> to <code>y</code>. If <code>x</code> was already bound in <code>m</code>, its previous binding disappears.</p></dd></dl><dl><dt class="spec value" id="val-update"><a href="#val-update" class="anchor"></a><code><span class="keyword">val</span> update : <a href="index.html#type-key">key</a> <span>&#45;&gt;</span> <a href="index.html#type-key">key</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>update k1 k2 v2 m</code> replace the previous binding of <code>k1</code> in <code>m</code> by <code>k2</code> associated to <code>v2</code>. This is equivalent to <code>add k2 v2 (remove k1) m</code>, but more efficient in the case where <code>k1</code> and <code>k2</code> have the same key ordering.</p><dl><dt>raises Not_found</dt><dd><p>if <code>k1</code> is not bound in <code>m</code>.</p></dd></dl><dl><dt>since</dt><dd>2.4.0</dd></dl></dd></dl><dl><dt class="spec value" id="val-find"><a href="#val-find" class="anchor"></a><code><span class="keyword">val</span> find : <a href="index.html#type-key">key</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p><code>find x m</code> returns the current binding of <code>x</code> in <code>m</code>, or raises <code>Not_found</code> if no such binding exists.</p></dd></dl><dl><dt class="spec value" id="val-find_default"><a href="#val-find_default" class="anchor"></a><code><span class="keyword">val</span> find_default : <span class="type-var">'a</span> <span>&#45;&gt;</span> <a href="index.html#type-key">key</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p><code>find_default d x m</code> returns the current binding of <code>x</code> in <code>m</code>, or the default value <code>d</code> if no such binding exists.</p></dd></dl><dl><dt class="spec value" id="val-remove"><a href="#val-remove" class="anchor"></a><code><span class="keyword">val</span> remove : <a href="index.html#type-key">key</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>remove x m</code> returns a map containing the same bindings as <code>m</code>, except for <code>x</code> which is unbound in the returned map.</p></dd></dl><dl><dt class="spec value" id="val-modify"><a href="#val-modify" class="anchor"></a><code><span class="keyword">val</span> modify : <a href="index.html#type-key">key</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>modify k f m</code> replaces the previous binding for <code>k</code> with <code>f</code> applied to that value. If <code>k</code> is unbound in <code>m</code> or <code>Not_found</code> is raised during the search, <code>Not_found</code> is raised.</p><dl><dt>since</dt><dd>1.2.0</dd></dl><dl><dt>raises Not_found</dt><dd><p>if <code>k</code> is unbound in <code>m</code> (or <code>f</code> raises <code>Not_found</code>)</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-modify_def"><a href="#val-modify_def" class="anchor"></a><code><span class="keyword">val</span> modify_def : <span class="type-var">'a</span> <span>&#45;&gt;</span> <a href="index.html#type-key">key</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>modify_def v0 k f m</code> replaces the previous binding for <code>k</code> with <code>f</code> applied to that value. If <code>k</code> is unbound in <code>m</code> or <code>Not_found</code> is raised during the search, <code>f v0</code> is inserted (as if the value found were <code>v0</code>).</p><dl><dt>since</dt><dd>1.3.0</dd></dl></dd></dl><dl><dt class="spec value" id="val-modify_opt"><a href="#val-modify_opt" class="anchor"></a><code><span class="keyword">val</span> modify_opt : <a href="index.html#type-key">key</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span> option <span>&#45;&gt;</span> <span class="type-var">'a</span> option) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>modify_opt k f m</code> allows to modify the binding for <code>k</code> in <code>m</code> or absence thereof.</p><dl><dt>since</dt><dd>2.1</dd></dl></dd></dl><dl><dt class="spec value" id="val-extract"><a href="#val-extract" class="anchor"></a><code><span class="keyword">val</span> extract : <a href="index.html#type-key">key</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> * <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>extract k m</code> removes the current binding of <code>k</code> from <code>m</code>, returning the value <code>k</code> was bound to and the updated <code>m</code>.</p><dl><dt>raises Not_found</dt><dd><p>if <code>k</code> is unbound in <code>m</code></p></dd></dl><dl><dt>since</dt><dd>1.4.0</dd></dl></dd></dl><dl><dt class="spec value" id="val-pop"><a href="#val-pop" class="anchor"></a><code><span class="keyword">val</span> pop : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<a href="index.html#type-key">key</a> * <span class="type-var">'a</span>) * <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>pop m</code> returns a binding from <code>m</code> and <code>m</code> without that binding.</p><dl><dt>raises Not_found</dt><dd><p>if <code>m</code> is empty</p></dd></dl><dl><dt>since</dt><dd>1.4.0</dd></dl></dd></dl><dl><dt class="spec value" id="val-mem"><a href="#val-mem" class="anchor"></a><code><span class="keyword">val</span> mem : <a href="index.html#type-key">key</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>mem x m</code> returns <code>true</code> if <code>m</code> contains a binding for <code>x</code>, and <code>false</code> otherwise.</p></dd></dl><dl><dt class="spec value" id="val-iter"><a href="#val-iter" class="anchor"></a><code><span class="keyword">val</span> iter : (<a href="index.html#type-key">key</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> unit) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>iter f m</code> applies <code>f</code> to all bindings in map <code>m</code>. <code>f</code> receives the key as first argument, and the associated value as second argument. The bindings are passed to <code>f</code> in increasing order with respect to the ordering over the type of the keys. Only current bindings are presented to <code>f</code>: bindings hidden by more recent bindings are not passed to <code>f</code>.</p></dd></dl><dl><dt class="spec value" id="val-map"><a href="#val-map" class="anchor"></a><code><span class="keyword">val</span> map : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>map f m</code> returns a map with same domain as <code>m</code>, where the associated value <code>a</code> of all bindings of <code>m</code> has been replaced by the result of the application of <code>f</code> to <code>a</code>. The bindings are passed to <code>f</code> in increasing order with respect to the ordering over the type of the keys.</p></dd></dl><dl><dt class="spec value" id="val-mapi"><a href="#val-mapi" class="anchor"></a><code><span class="keyword">val</span> mapi : (<a href="index.html#type-key">key</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Same as <span class="xref-unresolved" title="unresolved reference to &quot;Map.S.map&quot;"><span class="xref-unresolved" title="unresolved reference to &quot;Map.S&quot;"><code>Map</code>.S</span>.map</span>, but the function receives as arguments both the key and the associated value for each binding of the map.</p></dd></dl><dl><dt class="spec value" id="val-fold"><a href="#val-fold" class="anchor"></a><code><span class="keyword">val</span> fold : (<a href="index.html#type-key">key</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'b</span></code></dt><dd><p><code>fold f m a</code> computes <code>(f kN dN ... (f k1 d1 (f k0 d0 a))...)</code>, where <code>k0,k1..kN</code> are the keys of all bindings in <code>m</code> (in increasing order), and <code>d1 ... dN</code> are the associated data.</p></dd></dl><dl><dt class="spec value" id="val-filterv"><a href="#val-filterv" class="anchor"></a><code><span class="keyword">val</span> filterv : (<span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>filterv f m</code> returns a map where only the values <code>a</code> of <code>m</code> such that <code>f a = true</code> remain. The bindings are passed to <code>f</code> in increasing order with respect to the ordering over the type of the keys.</p></dd></dl><dl><dt class="spec value" id="val-filter"><a href="#val-filter" class="anchor"></a><code><span class="keyword">val</span> filter : (<a href="index.html#type-key">key</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>filter f m</code> returns a map where only the <code>(key, value)</code> pairs of <code>m</code> such that <code>f key value = true</code> remain. The bindings are passed to <code>f</code> in increasing order with respect to the ordering over the type of the keys.</p></dd></dl><dl><dt class="spec value" id="val-filter_map"><a href="#val-filter_map" class="anchor"></a><code><span class="keyword">val</span> filter_map : (<a href="index.html#type-key">key</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> option) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>filter_map f m</code> combines the features of <code>filter</code> and <code>map</code>. It calls calls <code>f key0 a0</code>, <code>f key1 a1</code>, <code>f keyn an</code> where <code>a0,a1..an</code> are the elements of <code>m</code> and <code>key0..keyn</code> the respective corresponding keys. It returns the map of pairs <code>(keyi, bi)</code> such as <code>f keyi ai = Some bi</code> (when <code>f</code> returns <code>None</code>, the corresponding element of <code>m</code> is discarded).</p></dd></dl><dl><dt class="spec value" id="val-compare"><a href="#val-compare" class="anchor"></a><code><span class="keyword">val</span> compare : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> int) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int</code></dt><dd><p>Total ordering between maps. The first argument is a total ordering used to compare data associated with equal keys in the two maps.</p></dd></dl><dl><dt class="spec value" id="val-equal"><a href="#val-equal" class="anchor"></a><code><span class="keyword">val</span> equal : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>equal cmp m1 m2</code> tests whether the maps <code>m1</code> and <code>m2</code> are equal, that is, contain equal keys and associate them with equal data. <code>cmp</code> is the equality predicate used to compare the data associated with the keys.</p></dd></dl><dl><dt class="spec value" id="val-keys"><a href="#val-keys" class="anchor"></a><code><span class="keyword">val</span> keys : <span class="type-var">_</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-key">key</a> <a href="../../BatEnum/index.html#type-t">BatEnum.t</a></code></dt><dd><p>Return an enumeration of all the keys of a map. The returned enumeration is sorted in increasing key order.</p></dd></dl><dl><dt class="spec value" id="val-values"><a href="#val-values" class="anchor"></a><code><span class="keyword">val</span> values : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="../../BatEnum/index.html#type-t">BatEnum.t</a></code></dt><dd><p>Return an enumeration of all the values of a map. The returned enumeration is sorted in increasing key order.</p></dd></dl><dl><dt class="spec value" id="val-min_binding"><a href="#val-min_binding" class="anchor"></a><code><span class="keyword">val</span> min_binding : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-key">key</a> * <span class="type-var">'a</span></code></dt><dd><p>Return the <code>(key, value)</code> pair with the smallest key.</p></dd></dl><dl><dt class="spec value" id="val-pop_min_binding"><a href="#val-pop_min_binding" class="anchor"></a><code><span class="keyword">val</span> pop_min_binding : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<a href="index.html#type-key">key</a> * <span class="type-var">'a</span>) * <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Return the <code>(key, value)</code> pair with the smallest key along with the rest of the map.</p></dd></dl><dl><dt class="spec value" id="val-max_binding"><a href="#val-max_binding" class="anchor"></a><code><span class="keyword">val</span> max_binding : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-key">key</a> * <span class="type-var">'a</span></code></dt><dd><p>Return the <code>(key, value)</code> pair with the largest key.</p></dd></dl><dl><dt class="spec value" id="val-pop_max_binding"><a href="#val-pop_max_binding" class="anchor"></a><code><span class="keyword">val</span> pop_max_binding : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<a href="index.html#type-key">key</a> * <span class="type-var">'a</span>) * <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Return the (<code>key, value</code>) pair with the largest key along with the rest of the map.</p></dd></dl><dl><dt class="spec value" id="val-choose"><a href="#val-choose" class="anchor"></a><code><span class="keyword">val</span> choose : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-key">key</a> * <span class="type-var">'a</span></code></dt><dd><p>Return one binding of the given map. Which binding is chosen is unspecified, but equal bindings will be chosen for equal maps.</p><dl><dt>raises Not_found</dt><dd><p>if the map is empty</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-any"><a href="#val-any" class="anchor"></a><code><span class="keyword">val</span> any : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-key">key</a> * <span class="type-var">'a</span></code></dt><dd><p>Return one binding of the given map. The difference with choose is that there is no guarantee that equals elements will be picked for equal sets. This merely returns the quickest binding to get (O(1)).</p><dl><dt>raises Not_found</dt><dd><p>if the map is empty.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-split"><a href="#val-split" class="anchor"></a><code><span class="keyword">val</span> split : <a href="index.html#type-key">key</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> * <span class="type-var">'a</span> option * <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>split x m</code> returns a triple <code>(l, data, r)</code>, where <code>l</code> is the map with all the bindings of <code>m</code> whose key is strictly less than <code>x</code>; <code>r</code> is the map with all the bindings of <code>m</code> whose key is strictly greater than <code>x</code>; <code>data</code> is <code>None</code> if <code>m</code> contains no binding for <code>x</code>, or <code>Some v</code> if <code>m</code> binds <code>v</code> to <code>x</code>.</p></dd></dl><dl><dt class="spec value" id="val-partition"><a href="#val-partition" class="anchor"></a><code><span class="keyword">val</span> partition : (<a href="index.html#type-key">key</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> * <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>partition p m</code> returns a pair of maps <code>(m1, m2)</code>, where <code>m1</code> contains all the bindings of <code>s</code> that satisfy the predicate <code>p</code>, and <code>m2</code> is the map with all the bindings of <code>s</code> that do not satisfy <code>p</code>.</p><dl><dt>since</dt><dd>1.4.0</dd></dl></dd></dl><dl><dt class="spec value" id="val-singleton"><a href="#val-singleton" class="anchor"></a><code><span class="keyword">val</span> singleton : <a href="index.html#type-key">key</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>singleton x y</code> returns the one-element map that contains a binding <code>y</code> for <code>x</code>.</p></dd></dl><dl><dt class="spec value" id="val-bindings"><a href="#val-bindings" class="anchor"></a><code><span class="keyword">val</span> bindings : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<a href="index.html#type-key">key</a> * <span class="type-var">'a</span>) list</code></dt><dd><p>Return the list of all bindings of the given map. The returned list is sorted in increasing key order.</p><p>Added for compatibility with stdlib 3.12</p></dd></dl><dl><dt class="spec value" id="val-enum"><a href="#val-enum" class="anchor"></a><code><span class="keyword">val</span> enum : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<a href="index.html#type-key">key</a> * <span class="type-var">'a</span>) <a href="../../BatEnum/index.html#type-t">BatEnum.t</a></code></dt><dd><p>Return an enumeration of <code>(key, value)</code> pairs of a map. The returned enumeration is sorted in increasing order with respect to the ordering <code>Ord.compare</code>, where <code>Ord</code> is the argument given to <span class="xref-unresolved" title="unresolved reference to &quot;Map.Make&quot;"><code>Map</code>.Make</span>.</p></dd></dl><dl><dt class="spec value" id="val-backwards"><a href="#val-backwards" class="anchor"></a><code><span class="keyword">val</span> backwards : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<a href="index.html#type-key">key</a> * <span class="type-var">'a</span>) <a href="../../BatEnum/index.html#type-t">BatEnum.t</a></code></dt><dd><p>Return an enumeration of <code>(key, value)</code> pairs of a map. The returned enumeration is sorted in decreasing order with respect to the ordering <code>Ord.compare</code>, where <code>Ord</code> is the argument given to <span class="xref-unresolved" title="unresolved reference to &quot;Map.Make&quot;"><code>Map</code>.Make</span>.</p></dd></dl><dl><dt class="spec value" id="val-of_enum"><a href="#val-of_enum" class="anchor"></a><code><span class="keyword">val</span> of_enum : (<a href="index.html#type-key">key</a> * <span class="type-var">'a</span>) <a href="../../BatEnum/index.html#type-t">BatEnum.t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Create a map from a (key, value) enumeration.</p></dd></dl><dl><dt class="spec value" id="val-for_all"><a href="#val-for_all" class="anchor"></a><code><span class="keyword">val</span> for_all : (<a href="index.html#type-key">key</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>for_all p m</code> checks if all the bindings of the map satisfy the predicate <code>p</code>.</p></dd></dl><dl><dt class="spec value" id="val-exists"><a href="#val-exists" class="anchor"></a><code><span class="keyword">val</span> exists : (<a href="index.html#type-key">key</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>exists p m</code> checks if at least one binding of the map satisfy the predicate <code>p</code>.</p></dd></dl><dl><dt class="spec value" id="val-merge"><a href="#val-merge" class="anchor"></a><code><span class="keyword">val</span> merge : (<a href="index.html#type-key">key</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> option <span>&#45;&gt;</span> <span class="type-var">'b</span> option <span>&#45;&gt;</span> <span class="type-var">'c</span> option) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'c</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>merge f m1 m2</code> computes a map whose keys is a subset of keys of <code>m1</code> and of <code>m2</code>. The presence of each such binding, and the corresponding value, is determined with the function <code>f</code>.</p></dd></dl><section><header><h6 id="boilerplate-code"><a href="#boilerplate-code" class="anchor"></a>Boilerplate code</h6></header></section><section><header><h6 id="printing"><a href="#printing" class="anchor"></a>Printing</h6></header><dl><dt class="spec value" id="val-print"><a href="#val-print" class="anchor"></a><code><span class="keyword">val</span> print : ?&#8288;first:string <span>&#45;&gt;</span> ?&#8288;last:string <span>&#45;&gt;</span> ?&#8288;sep:string <span>&#45;&gt;</span> ?&#8288;kvsep:string <span>&#45;&gt;</span> (<span class="type-var">'a</span> <a href="../../BatInnerIO/index.html#type-output">BatInnerIO.output</a> <span>&#45;&gt;</span> <a href="index.html#type-key">key</a> <span>&#45;&gt;</span> unit) <span>&#45;&gt;</span> (<span class="type-var">'a</span> <a href="../../BatInnerIO/index.html#type-output">BatInnerIO.output</a> <span>&#45;&gt;</span> <span class="type-var">'c</span> <span>&#45;&gt;</span> unit) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="../../BatInnerIO/index.html#type-output">BatInnerIO.output</a> <span>&#45;&gt;</span> <span class="type-var">'c</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt></dl><aside><p>Output signature of the functor <span class="xref-unresolved" title="unresolved reference to &quot;Map.Make&quot;"><code>Map</code>.Make</span>.</p></aside></section><section><header><h6 id="override-modules"><a href="#override-modules" class="anchor"></a>Override modules</h6></header><aside><p>The following modules replace functions defined in <code>Map</code> with functions behaving slightly differently but having the same name. This is by design: the functions meant to override the corresponding functions of <code>Map</code>.</p></aside><dl><dt class="spec module" id="module-Exceptionless"><a href="#module-Exceptionless" class="anchor"></a><code><span class="keyword">module</span> <a href="Exceptionless/index.html">Exceptionless</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Operations on <code>Map</code> without exceptions.</p></dd></dl><dl><dt class="spec module" id="module-Infix"><a href="#module-Infix" class="anchor"></a><code><span class="keyword">module</span> <a href="Infix/index.html">Infix</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Infix operators over a <a href="../index.html"><code>BatMap</code></a></p></dd></dl><dl><dt class="spec module" id="module-Labels"><a href="#module-Labels" class="anchor"></a><code><span class="keyword">module</span> <a href="Labels/index.html">Labels</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Operations on <code>Map</code> with labels.</p></dd></dl></section></div></body></html>