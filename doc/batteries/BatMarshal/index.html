<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>BatMarshal (batteries.BatMarshal)</title><link rel="stylesheet" href="../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../index.html">batteries</a> &#x00BB; BatMarshal</nav><h1>Module <code>BatMarshal</code></h1><p>Marshaling of data structures.</p><p>This module provides functions to encode arbitrary data structures as sequences of bytes, which can then be written on a file or sent over a pipe or network connection. The bytes can then be read back later, possibly in another process, and decoded back into a data structure. The format for the byte sequences is compatible across all machines for a given version of OCaml.</p><p>Warning: marshaling is currently not type-safe. The type of marshaled data is not transmitted along the value of the data, making it impossible to check that the data read back possesses the type expected by the context. In particular, the result type of the <code>Marshal.from_*</code> functions is given as <code>'a</code>, but this is misleading: the returned OCaml value does not possess type <code>'a</code> for all <code>'a</code>; it has one, unique type which cannot be determined at compile-type. The programmer should explicitly give the expected type of the returned value, using the following syntax:</p><ul><li><code>(Marshal.from_channel chan : type)</code>. Anything can happen at run-time if the object in the file does not belong to the given type.</li></ul><p>The representation of marshaled values is not human-readable, and uses bytes that are not printable characters. Therefore, input and output channels used in conjunction with <span class="xref-unresolved" title="unresolved reference to &quot;Marshal.output&quot;"><code>Marshal</code>.output</span> and <span class="xref-unresolved" title="unresolved reference to &quot;Marshal.input&quot;"><code>Marshal</code>.input</span> must be opened in binary mode, using e.g. <a href="../BatPervasives/index.html#val-open_out_bin"><code>BatPervasives.open_out_bin</code></a> or <a href="../BatPervasives/index.html#val-open_in_bin"><code>BatPervasives.open_in_bin</code></a>; channels opened in text mode will cause unmarshaling errors on platforms where text channels behave differently than binary channels, e.g. Windows.</p><dl><dt>author</dt><dd>Xavier Leroy (base module)</dd></dl><dl><dt>author</dt><dd>David Teller</dd></dl><nav class="toc"><ul><li><a href="#deprecated">Deprecated</a></li></ul></nav></header><dl><dt class="spec type" id="type-extern_flags"><a href="#type-extern_flags" class="anchor"></a><code><span class="keyword">type</span> extern_flags</code><code> = <a href="../../ocaml/Stdlib/Marshal/index.html#type-extern_flags">Stdlib.Marshal.extern_flags</a></code><code> = </code><table class="variant"><tr id="type-extern_flags.No_sharing" class="anchored"><td class="def constructor"><a href="#type-extern_flags.No_sharing" class="anchor"></a><code>| </code><code><span class="constructor">No_sharing</span></code></td><td class="doc"><p>Don't preserve sharing</p></td></tr><tr id="type-extern_flags.Closures" class="anchored"><td class="def constructor"><a href="#type-extern_flags.Closures" class="anchor"></a><code>| </code><code><span class="constructor">Closures</span></code></td><td class="doc"><p>Send function closures</p></td></tr><tr id="type-extern_flags.Compat_32" class="anchored"><td class="def constructor"><a href="#type-extern_flags.Compat_32" class="anchor"></a><code>| </code><code><span class="constructor">Compat_32</span></code></td><td class="doc"><p>Ensure 32-bit compatibility</p></td></tr></table></dt><dd><p>The flags to the <code>Marshal.to_*</code> functions below.</p></dd></dl><dl><dt class="spec value" id="val-output"><a href="#val-output" class="anchor"></a><code><span class="keyword">val</span> output : <span class="type-var">_</span> <a href="../BatInnerIO/index.html#type-output">BatInnerIO.output</a> <span>&#45;&gt;</span> ?&#8288;sharing:bool <span>&#45;&gt;</span> ?&#8288;closures:bool <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>output out v</code> writes the representation of <code>v</code> on <code>chan</code>.</p><dl><dt>parameter sharing</dt><dd><p>If <code>true</code> (default value), circularities and sharing inside the value <code>v</code> are detected and preserved in the sequence of bytes produced. In particular, this guarantees that marshaling always terminates. Sharing between values marshaled by successive calls to <code>output</code> is not detected, though. If <code>false</code>, sharing is ignored. This results in faster marshaling if <code>v</code> contains no shared substructures, but may cause slower marshaling and larger byte representations if <code>v</code> actually contains sharing, or even non-termination if <code>v</code> contains cycles.</p></dd></dl><dl><dt>parameter closures</dt><dd><p>If <code>false</code> (default value) marshaling fails when it encounters a functional value inside <code>v</code>: only ``pure'' data structures, containing neither functions nor objects, can safely be transmitted between different programs. If <code>true</code>, functional values will be marshaled as a position in the code of the program. In this case, the output of marshaling can only be read back in processes that run exactly the same program, with exactly the same compiled code. (This is checked at un-marshaling time, using an MD5 digest of the code transmitted along with the code position.)</p></dd></dl></dd></dl><dl><dt class="spec external" id="val-to_bytes"><a href="#val-to_bytes" class="anchor"></a><code><span class="keyword">val</span> to_bytes : <span class="type-var">'a</span> <span>&#45;&gt;</span> <a href="index.html#type-extern_flags">extern_flags</a> list <span>&#45;&gt;</span> <a href="../../ocaml/Stdlib/Bytes/index.html#type-t">Stdlib.Bytes.t</a></code></dt><dd><p><code>Marshal.to_bytes v flags</code> returns a byte sequence containing the representation of <code>v</code>. The <code>flags</code> argument has the same meaning as for <span class="xref-unresolved" title="unresolved reference to &quot;Marshal.output&quot;"><code>Marshal</code>.output</span>.</p><dl><dt>since</dt><dd>2.3.0</dd></dl></dd></dl><dl><dt class="spec external" id="val-to_string"><a href="#val-to_string" class="anchor"></a><code><span class="keyword">val</span> to_string : <span class="type-var">'a</span> <span>&#45;&gt;</span> <a href="index.html#type-extern_flags">extern_flags</a> list <span>&#45;&gt;</span> string</code></dt><dd><p>Same as <code>to_bytes</code> but return the result as a string instead of a byte sequence.</p></dd></dl><dl><dt class="spec value" id="val-to_buffer"><a href="#val-to_buffer" class="anchor"></a><code><span class="keyword">val</span> to_buffer : <a href="../../ocaml/Stdlib/Bytes/index.html#type-t">Stdlib.Bytes.t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <a href="index.html#type-extern_flags">extern_flags</a> list <span>&#45;&gt;</span> int</code></dt><dd><p><code>Marshal.to_buffer buff ofs len v flags</code> marshals the value <code>v</code>, storing its byte representation in the sequence <code>buff</code>, starting at index <code>ofs</code>, and writing at most <code>len</code> bytes. It returns the number of bytes actually written to the sequence. If the byte representation of <code>v</code> does not fit in <code>len</code> characters, the exception <code>Failure</code> is raised.</p></dd></dl><dl><dt class="spec value" id="val-input"><a href="#val-input" class="anchor"></a><code><span class="keyword">val</span> input : <a href="../BatInnerIO/index.html#type-input">BatInnerIO.input</a> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p><code>input inp</code> reads from <code>inp</code> the byte representation of a structured value, as produced by one of the <code>Marshal.to_*</code> functions, and reconstructs and returns the corresponding value.</p></dd></dl><dl><dt class="spec value" id="val-from_bytes"><a href="#val-from_bytes" class="anchor"></a><code><span class="keyword">val</span> from_bytes : <a href="../../ocaml/Stdlib/Bytes/index.html#type-t">Stdlib.Bytes.t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p><code>Marshal.from_bytes buff ofs</code> unmarshals a structured value like <span class="xref-unresolved" title="unresolved reference to &quot;Marshal.from_channel&quot;"><code>Marshal</code>.from_channel</span> does, except that the byte representation is not read from a channel, but taken from the byte sequence <code>buff</code>, starting at position <code>ofs</code>. The byte sequence is not mutated.</p><dl><dt>since</dt><dd>2.3.0</dd></dl></dd></dl><dl><dt class="spec value" id="val-from_string"><a href="#val-from_string" class="anchor"></a><code><span class="keyword">val</span> from_string : string <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p>Same as <code>from_bytes</code> but take a string as argument instead of a byte sequence.</p></dd></dl><dl><dt class="spec value" id="val-header_size"><a href="#val-header_size" class="anchor"></a><code><span class="keyword">val</span> header_size : int</code></dt><dd><p>The bytes representing a marshaled value are composed of a fixed-size header and a variable-sized data part, whose size can be determined from the header. <span class="xref-unresolved" title="unresolved reference to &quot;Marshal.header_size&quot;"><code>Marshal</code>.header_size</span> is the size, in bytes, of the header. <span class="xref-unresolved" title="unresolved reference to &quot;Marshal.data_size&quot;"><code>Marshal</code>.data_size</span><code> buff ofs</code> is the size, in bytes, of the data part, assuming a valid header is stored in <code>buff</code> starting at position <code>ofs</code>. Finally, <span class="xref-unresolved" title="unresolved reference to &quot;Marshal.total_size&quot;"><code>Marshal</code>.total_size</span> <code>buff ofs</code> is the total size, in bytes, of the marshaled value. Both <span class="xref-unresolved" title="unresolved reference to &quot;Marshal.data_size&quot;"><code>Marshal</code>.data_size</span> and <span class="xref-unresolved" title="unresolved reference to &quot;Marshal.total_size&quot;"><code>Marshal</code>.total_size</span> raise <code>Failure</code> if <code>buff</code>, <code>ofs</code> does not contain a valid header.</p><p>To read the byte representation of a marshaled value into a byte sequence, the program needs to read first <span class="xref-unresolved" title="unresolved reference to &quot;Marshal.header_size&quot;"><code>Marshal</code>.header_size</span> bytes into the sequence, then determine the length of the remainder of the representation using <span class="xref-unresolved" title="unresolved reference to &quot;Marshal.data_size&quot;"><code>Marshal</code>.data_size</span>, make sure the sequence is large enough to hold the remaining data, then read it, and finally call <span class="xref-unresolved" title="unresolved reference to &quot;Marshal.from_bytes&quot;"><code>Marshal</code>.from_bytes</span> to unmarshal the value.</p></dd></dl><dl><dt class="spec value" id="val-data_size"><a href="#val-data_size" class="anchor"></a><code><span class="keyword">val</span> data_size : <a href="../../ocaml/Stdlib/Bytes/index.html#type-t">Stdlib.Bytes.t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int</code></dt><dd><p>See <span class="xref-unresolved" title="unresolved reference to &quot;Marshal.header_size&quot;"><code>Marshal</code>.header_size</span>.</p></dd></dl><dl><dt class="spec value" id="val-total_size"><a href="#val-total_size" class="anchor"></a><code><span class="keyword">val</span> total_size : <a href="../../ocaml/Stdlib/Bytes/index.html#type-t">Stdlib.Bytes.t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int</code></dt><dd><p>See <span class="xref-unresolved" title="unresolved reference to &quot;Marshal.header_size&quot;"><code>Marshal</code>.header_size</span>.</p></dd></dl><section><header><h6 id="deprecated"><a href="#deprecated" class="anchor"></a>Deprecated</h6></header><dl><dt class="spec value" id="val-to_channel"><a href="#val-to_channel" class="anchor"></a><code><span class="keyword">val</span> to_channel : <span class="type-var">_</span> <a href="../BatInnerIO/index.html#type-output">BatInnerIO.output</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <a href="index.html#type-extern_flags">extern_flags</a> list <span>&#45;&gt;</span> unit</code></dt><dd><dl><dt>deprecated</dt><dd><p>Use <a href="index.html#val-output"><code>output</code></a> instead</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-from_channel"><a href="#val-from_channel" class="anchor"></a><code><span class="keyword">val</span> from_channel : <a href="../BatInnerIO/index.html#type-input">BatInnerIO.input</a> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><dl><dt>deprecated</dt><dd><p>Use <a href="index.html#val-input"><code>input</code></a> instead</p></dd></dl></dd></dl></section></div></body></html>