<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>BatOrd (batteries.BatOrd)</title><link rel="stylesheet" href="../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../index.html">batteries</a> &#x00BB; BatOrd</nav><h1>Module <code>BatOrd</code></h1></header><dl><dt class="spec type" id="type-order"><a href="#type-order" class="anchor"></a><code><span class="keyword">type</span> order</code><code> = </code><table class="variant"><tr id="type-order.Lt" class="anchored"><td class="def constructor"><a href="#type-order.Lt" class="anchor"></a><code>| </code><code><span class="constructor">Lt</span></code></td></tr><tr id="type-order.Eq" class="anchored"><td class="def constructor"><a href="#type-order.Eq" class="anchor"></a><code>| </code><code><span class="constructor">Eq</span></code></td></tr><tr id="type-order.Gt" class="anchored"><td class="def constructor"><a href="#type-order.Gt" class="anchor"></a><code>| </code><code><span class="constructor">Gt</span></code></td><td class="doc"><p>An algebraic datatype for ordering.</p><p>Traditional OCaml code, under the influence of C comparison functions, has used int-returning comparisons (&lt; 0, 0 or &gt; 0). Using an algebraic datatype instead is actually nicer, both for comparison producers (no arbitrary choice of a positive and negative value) and consumers (nice pattern-matching elimination).</p></td></tr></table></dt><dt class="spec type" id="type-ord"><a href="#type-ord" class="anchor"></a><code><span class="keyword">type</span> 'a ord</code><code> = <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <a href="index.html#type-order">order</a></code></dt><dd><p>The type of ordering functions returning an <code>order</code> variant.</p></dd></dl><dl><dt class="spec type" id="type-comp"><a href="#type-comp" class="anchor"></a><code><span class="keyword">type</span> 'a comp</code><code> = <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> int</code></dt><dd><p>The legacy int-returning comparisons :</p><ul><li>compare a b &lt; 0 means a &lt; b</li><li>compare a b = 0 means a = b</li><li>compare a b &gt; 0 means a &gt; b</li></ul></dd></dl><dl><dt class="spec module-type" id="module-type-Comp"><a href="#module-type-Comp" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-Comp/index.html">Comp</a> = <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>We use <code>compare</code> as member name instead of <code>comp</code>, so that the Comp modules can be used as the legacy OrderedType interface.</p></dd></dl><div class="spec module-type" id="module-type-Ord"><a href="#module-type-Ord" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-Ord/index.html">Ord</a> = <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><dl><dt class="spec value" id="val-ord0"><a href="#val-ord0" class="anchor"></a><code><span class="keyword">val</span> ord0 : int <span>&#45;&gt;</span> <a href="index.html#type-order">order</a></code></dt><dt class="spec value" id="val-ord"><a href="#val-ord" class="anchor"></a><code><span class="keyword">val</span> ord : <span class="type-var">'a</span> <a href="index.html#type-comp">comp</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-ord">ord</a></code></dt><dd><p>Returns a variant ordering from a legacy comparison</p></dd></dl><dl><dt class="spec module" id="module-Ord"><a href="#module-Ord" class="anchor"></a><code><span class="keyword">module</span> <a href="Ord/index.html">Ord</a> : <span class="keyword">functor</span> (<a href="Ord/argument-1-Comp/index.html">Comp</a> : <a href="index.html#module-type-Comp">Comp</a>) <span>&#45;&gt;</span> <a href="index.html#module-type-Ord">Ord</a> <span class="keyword">with</span> <span class="keyword">type</span> <a href="Ord/index.html#type-t">t</a> = <a href="Ord/argument-1-Comp/index.html#type-t">Comp.t</a></code></dt><dd><p>Returns a variant ordering from a legacy comparison</p></dd></dl><dl><dt class="spec value" id="val-comp0"><a href="#val-comp0" class="anchor"></a><code><span class="keyword">val</span> comp0 : <a href="index.html#type-order">order</a> <span>&#45;&gt;</span> int</code></dt><dt class="spec value" id="val-comp"><a href="#val-comp" class="anchor"></a><code><span class="keyword">val</span> comp : <span class="type-var">'a</span> <a href="index.html#type-ord">ord</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-comp">comp</a></code></dt><dd><p>Returns an legacy comparison from a variant ordering</p></dd></dl><dl><dt class="spec module" id="module-Comp"><a href="#module-Comp" class="anchor"></a><code><span class="keyword">module</span> <a href="Comp/index.html">Comp</a> : <span class="keyword">functor</span> (<a href="Comp/argument-1-Ord/index.html">Ord</a> : <a href="index.html#module-type-Ord">Ord</a>) <span>&#45;&gt;</span> <a href="index.html#module-type-Comp">Comp</a> <span class="keyword">with</span> <span class="keyword">type</span> <a href="Comp/index.html#type-t">t</a> = <a href="Comp/argument-1-Ord/index.html#type-t">Ord.t</a></code></dt><dd><p>Returns an legacy comparison from a variant ordering</p></dd></dl><dl><dt class="spec value" id="val-poly_comp"><a href="#val-poly_comp" class="anchor"></a><code><span class="keyword">val</span> poly_comp : <span class="type-var">'a</span> <a href="index.html#type-comp">comp</a></code></dt><dt class="spec value" id="val-poly_ord"><a href="#val-poly_ord" class="anchor"></a><code><span class="keyword">val</span> poly_ord : <span class="type-var">'a</span> <a href="index.html#type-ord">ord</a></code></dt><dt class="spec value" id="val-poly"><a href="#val-poly" class="anchor"></a><code><span class="keyword">val</span> poly : <span class="type-var">'a</span> <a href="index.html#type-ord">ord</a></code></dt><dd><p>Polymorphic comparison functions, based on the <code>Pervasives.compare</code> function from inria's stdlib, have polymorphic types: they claim to be able to compare values of any type. In practice, they work for only some types, may fail on function types and may not terminate on cyclic values.</p><p>They work by runtime magic, inspecting the values in an untyped way. While being an useful hack for base types and simple composite types (say <code>(int * float) list</code>, they do not play well with functions, type abstractions, and structures that would need a finer notion of equality/comparison. For example, if one represent sets as balanced binary tree, one may want set with equal elements but different balancings to be equal, which would not be the case using the polymorphic equality function.</p><p>When possible, you should therefore avoid relying on these polymorphic comparison functions. You should be especially careful if your data structure may later evolve to allow cyclic data structures or functions.</p></dd></dl><dl><dt class="spec value" id="val-rev_ord0"><a href="#val-rev_ord0" class="anchor"></a><code><span class="keyword">val</span> rev_ord0 : <a href="index.html#type-order">order</a> <span>&#45;&gt;</span> <a href="index.html#type-order">order</a></code></dt><dt class="spec value" id="val-rev_comp0"><a href="#val-rev_comp0" class="anchor"></a><code><span class="keyword">val</span> rev_comp0 : int <span>&#45;&gt;</span> int</code></dt><dt class="spec value" id="val-rev_ord"><a href="#val-rev_ord" class="anchor"></a><code><span class="keyword">val</span> rev_ord : <span class="type-var">'a</span> <a href="index.html#type-ord">ord</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-ord">ord</a></code></dt><dt class="spec value" id="val-rev_comp"><a href="#val-rev_comp" class="anchor"></a><code><span class="keyword">val</span> rev_comp : <span class="type-var">'a</span> <a href="index.html#type-comp">comp</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-comp">comp</a></code></dt><dt class="spec value" id="val-rev"><a href="#val-rev" class="anchor"></a><code><span class="keyword">val</span> rev : <span class="type-var">'a</span> <a href="index.html#type-ord">ord</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-ord">ord</a></code></dt><dd><p>Reverse a given ordering. If <code>Int.ord</code> sorts integer by increasing order, <code>rev Int.ord</code> will sort them by decreasing order.</p></dd></dl><div class="spec module" id="module-RevOrd"><a href="#module-RevOrd" class="anchor"></a><code><span class="keyword">module</span> <a href="RevOrd/index.html">RevOrd</a> : <span class="keyword">functor</span> (<a href="RevOrd/argument-1-Ord/index.html">Ord</a> : <a href="index.html#module-type-Ord">Ord</a>) <span>&#45;&gt;</span> <a href="index.html#module-type-Ord">Ord</a> <span class="keyword">with</span> <span class="keyword">type</span> <a href="RevOrd/index.html#type-t">t</a> = <a href="RevOrd/argument-1-Ord/index.html#type-t">Ord.t</a></code></div><div class="spec module" id="module-RevComp"><a href="#module-RevComp" class="anchor"></a><code><span class="keyword">module</span> <a href="RevComp/index.html">RevComp</a> : <span class="keyword">functor</span> (<a href="RevComp/argument-1-Comp/index.html">Comp</a> : <a href="index.html#module-type-Comp">Comp</a>) <span>&#45;&gt;</span> <a href="index.html#module-type-Comp">Comp</a> <span class="keyword">with</span> <span class="keyword">type</span> <a href="RevComp/index.html#type-t">t</a> = <a href="RevComp/argument-1-Comp/index.html#type-t">Comp.t</a></code></div><div class="spec module" id="module-Rev"><a href="#module-Rev" class="anchor"></a><code><span class="keyword">module</span> <a href="Rev/index.html">Rev</a> : <span class="keyword">functor</span> (<a href="Rev/argument-1-Ord/index.html">Ord</a> : <a href="index.html#module-type-Ord">Ord</a>) <span>&#45;&gt;</span> <a href="index.html#module-type-Ord">Ord</a> <span class="keyword">with</span> <span class="keyword">type</span> <a href="Rev/index.html#type-t">t</a> = <a href="Rev/argument-1-Ord/index.html#type-t">Ord.t</a></code></div><dl><dt class="spec type" id="type-eq"><a href="#type-eq" class="anchor"></a><code><span class="keyword">type</span> 'a eq</code><code> = <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> bool</code></dt><dd><p>The type for equality function.</p><p>All ordered types also support equality, as equality can be derived from ordering. However, there are also cases where elements may be compared for equality, but have no natural ordering. It is therefore useful to provide equality as an independent notion.</p></dd></dl><dl><dt class="spec value" id="val-eq_ord0"><a href="#val-eq_ord0" class="anchor"></a><code><span class="keyword">val</span> eq_ord0 : <a href="index.html#type-order">order</a> <span>&#45;&gt;</span> bool</code></dt><dt class="spec value" id="val-eq_comp0"><a href="#val-eq_comp0" class="anchor"></a><code><span class="keyword">val</span> eq_comp0 : int <span>&#45;&gt;</span> bool</code></dt><dt class="spec value" id="val-eq_ord"><a href="#val-eq_ord" class="anchor"></a><code><span class="keyword">val</span> eq_ord : <span class="type-var">'a</span> <a href="index.html#type-ord">ord</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-eq">eq</a></code></dt><dt class="spec value" id="val-eq_comp"><a href="#val-eq_comp" class="anchor"></a><code><span class="keyword">val</span> eq_comp : <span class="type-var">'a</span> <a href="index.html#type-comp">comp</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-eq">eq</a></code></dt><dt class="spec value" id="val-eq"><a href="#val-eq" class="anchor"></a><code><span class="keyword">val</span> eq : <span class="type-var">'a</span> <a href="index.html#type-ord">ord</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-eq">eq</a></code></dt><dd><p>Derives an equality function from an ordering function.</p></dd></dl><div class="spec module-type" id="module-type-Eq"><a href="#module-type-Eq" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-Eq/index.html">Eq</a> = <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><div class="spec module" id="module-EqOrd"><a href="#module-EqOrd" class="anchor"></a><code><span class="keyword">module</span> <a href="EqOrd/index.html">EqOrd</a> : <span class="keyword">functor</span> (<a href="EqOrd/argument-1-Ord/index.html">Ord</a> : <a href="index.html#module-type-Ord">Ord</a>) <span>&#45;&gt;</span> <a href="index.html#module-type-Eq">Eq</a> <span class="keyword">with</span> <span class="keyword">type</span> <a href="EqOrd/index.html#type-t">t</a> = <a href="EqOrd/argument-1-Ord/index.html#type-t">Ord.t</a></code></div><div class="spec module" id="module-EqComp"><a href="#module-EqComp" class="anchor"></a><code><span class="keyword">module</span> <a href="EqComp/index.html">EqComp</a> : <span class="keyword">functor</span> (<a href="EqComp/argument-1-Comp/index.html">Comp</a> : <a href="index.html#module-type-Comp">Comp</a>) <span>&#45;&gt;</span> <a href="index.html#module-type-Eq">Eq</a> <span class="keyword">with</span> <span class="keyword">type</span> <a href="EqComp/index.html#type-t">t</a> = <a href="EqComp/argument-1-Comp/index.html#type-t">Comp.t</a></code></div><div class="spec module" id="module-Eq"><a href="#module-Eq" class="anchor"></a><code><span class="keyword">module</span> <a href="Eq/index.html">Eq</a> : <span class="keyword">functor</span> (<a href="Eq/argument-1-Ord/index.html">Ord</a> : <a href="index.html#module-type-Ord">Ord</a>) <span>&#45;&gt;</span> <a href="index.html#module-type-Eq">Eq</a> <span class="keyword">with</span> <span class="keyword">type</span> <a href="Eq/index.html#type-t">t</a> = <a href="Eq/argument-1-Ord/index.html#type-t">Ord.t</a></code></div><dl><dt class="spec type" id="type-choice"><a href="#type-choice" class="anchor"></a><code><span class="keyword">type</span> 'a choice</code><code> = <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p>choice functions, see <code>min</code> and <code>max</code>.</p></dd></dl><dl><dt class="spec value" id="val-min_ord"><a href="#val-min_ord" class="anchor"></a><code><span class="keyword">val</span> min_ord : <span class="type-var">'a</span> <a href="index.html#type-ord">ord</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-choice">choice</a></code></dt><dt class="spec value" id="val-max_ord"><a href="#val-max_ord" class="anchor"></a><code><span class="keyword">val</span> max_ord : <span class="type-var">'a</span> <a href="index.html#type-ord">ord</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-choice">choice</a></code></dt><dt class="spec value" id="val-min_comp"><a href="#val-min_comp" class="anchor"></a><code><span class="keyword">val</span> min_comp : <span class="type-var">'a</span> <a href="index.html#type-comp">comp</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-choice">choice</a></code></dt><dt class="spec value" id="val-max_comp"><a href="#val-max_comp" class="anchor"></a><code><span class="keyword">val</span> max_comp : <span class="type-var">'a</span> <a href="index.html#type-comp">comp</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-choice">choice</a></code></dt><dt class="spec value" id="val-min"><a href="#val-min" class="anchor"></a><code><span class="keyword">val</span> min : <span class="type-var">'a</span> <a href="index.html#type-ord">ord</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-choice">choice</a></code></dt><dd><p><code>min ord</code> will choose the smallest element, according to <code>ord</code>. For example, <code>min Int.ord 1 2</code> will return <code>1</code>.</p><pre><code class="ml">(* the minimum element of a list *)
let list_min ord = List.reduce (min ord)</code></pre></dd></dl><dl><dt class="spec value" id="val-max"><a href="#val-max" class="anchor"></a><code><span class="keyword">val</span> max : <span class="type-var">'a</span> <a href="index.html#type-ord">ord</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-choice">choice</a></code></dt><dd><p><code>max ord</code> will choose the biggest element according to <code>ord</code>.</p></dd></dl><dl><dt class="spec value" id="val-bin_comp"><a href="#val-bin_comp" class="anchor"></a><code><span class="keyword">val</span> bin_comp : <span class="type-var">'a</span> <a href="index.html#type-comp">comp</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-comp">comp</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> int</code></dt><dt class="spec value" id="val-bin_ord"><a href="#val-bin_ord" class="anchor"></a><code><span class="keyword">val</span> bin_ord : <span class="type-var">'a</span> <a href="index.html#type-ord">ord</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-ord">ord</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <a href="index.html#type-order">order</a></code></dt><dd><p>binary lifting of the comparison function, using lexicographic order: <code>bin_ord ord1 v1 v1' ord2 v2 v2'</code> is <code>ord2 v2 v2'</code> if <code>ord1 v1 v1' = Eq</code>, and <code>ord1 v1 v1'</code> otherwhise.</p></dd></dl><dl><dt class="spec value" id="val-bin_eq"><a href="#val-bin_eq" class="anchor"></a><code><span class="keyword">val</span> bin_eq : <span class="type-var">'a</span> <a href="index.html#type-eq">eq</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-eq">eq</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> bool</code></dt><dd><p>binary lifting of the comparison function, using lexicographic order: <code>bin_ord ord1 v1 v1' ord2 v2 v2'</code> is <code>ord2 v2 v2'</code> if <code>ord1 v1 v1' = Eq</code>, and <code>ord1 v1 v1'</code> otherwhise.</p></dd></dl><dl><dt class="spec value" id="val-map_eq"><a href="#val-map_eq" class="anchor"></a><code><span class="keyword">val</span> map_eq : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>) <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-eq">eq</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-eq">eq</a></code></dt><dt class="spec value" id="val-map_comp"><a href="#val-map_comp" class="anchor"></a><code><span class="keyword">val</span> map_comp : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>) <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-comp">comp</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-comp">comp</a></code></dt><dt class="spec value" id="val-map_ord"><a href="#val-map_ord" class="anchor"></a><code><span class="keyword">val</span> map_ord : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>) <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-ord">ord</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-ord">ord</a></code></dt><dd><p>These functions extend an existing equality/comparison/ordering to a new domain through a mapping function. For example, to order sets by their cardinality, use <code>map_ord Set.cardinal Int.ord</code>. The input of the mapping function is the type you want to compare, so this is the reverse of <code>List.map</code>.</p></dd></dl><div class="spec module" id="module-Incubator"><a href="#module-Incubator" class="anchor"></a><code><span class="keyword">module</span> <a href="Incubator/index.html">Incubator</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div></div></body></html>