<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>PathType (batteries.BatPathGen.PathType)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../../index.html">batteries</a> &#x00BB; <a href="../index.html">BatPathGen</a> &#x00BB; PathType</nav><h1>Module type <code>BatPathGen.PathType</code></h1><p>All implementations of <code>Path</code> functionality have this module type.</p><nav class="toc"><ul><li><a href="#construction">Construction</a></li><li><a href="#validation">Validation</a></li><li><a href="#conversions">Conversions</a></li><li><a href="#convenience-aliases">Convenience aliases</a></li><li><a href="#name-related-functions">Name related functions</a></li><li><a href="#supplementary-functions">Supplementary functions</a></li></ul></nav></header><dl><dt class="spec type" id="type-ustring"><a href="#type-ustring" class="anchor"></a><code><span class="keyword">type </span>ustring</code></dt><dd><p>Type of strings used. In case of <span class="xref-unresolved" title="unresolved reference to &quot;Path.OfRope&quot;"><code>Path</code>.OfRope</span> it is <span class="xref-unresolved" title="unresolved reference to &quot;Rope.t&quot;"><code>Rope</code>.t</span> and in <span class="xref-unresolved" title="unresolved reference to &quot;Path.OfString&quot;"><code>Path</code>.OfString</span> module it is <code>string</code>.</p></dd></dl><dl><dt class="spec type" id="type-uchar"><a href="#type-uchar" class="anchor"></a><code><span class="keyword">type </span>uchar</code></dt><dd><p>Type of characters. It corresponds to <code>ustring</code> type.</p></dd></dl><dl><dt class="spec module" id="module-OperatorLift"><a href="#module-OperatorLift" class="anchor"></a><code><span class="keyword">module </span><a href="OperatorLift/index.html">OperatorLift</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Convenience operator for lifting primitive strings to <code>ustring</code> type.</p></dd></dl><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type </span>t</code><code><span class="keyword"> = </span><a href="index.html#type-ustring">ustring</a> list</code></dt><dd><p>A type for storing paths. It is reversed list of names. In case of absolute path, the last element of the list is empty string (<em>Windows:</em> empty or letter-colon; details below). Empty list represents empty relative path.</p><p>Examples: <code>[&quot;a&quot;;&quot;b&quot;;&quot;c&quot;]</code> is c/b/a (relative path); <code>[&quot;d&quot;;&quot;e&quot;;&quot;&quot;]</code> stays for /e/d (absolute path).</p><p>All examples here and below are given for <code>ustring</code>=<code>string</code> case for clarity. To have the code working with other string types, one should prepend the <code>!!</code> operator (<a href="OperatorLift/index.html#val-(!!)"><code>OperatorLift.(!!)</code></a>) to all string literals.</p><p>There are two infix operators provided to allow to write expressions in natural order. For example, to build a path using <code>PathType.Operators.(/:)</code> one can write:</p><p><code>base_dir/:&quot;bar&quot;</code> instead of <code>&quot;bar&quot;::base_dir</code></p><p>However it may be sometimes inevitable to write components in reverse, for example:</p><p><code>let whose_readme = function &quot;README&quot;::app::&quot;doc&quot;::&quot;share&quot;::_ -&gt; Some app | _ -&gt; None</code></p><p><em>Windows:</em> Windows absolute paths start with &quot;\\&quot; or with drive letter. Use following representation:</p><ul><li><code>Path.root/:&quot;.&quot;/:&quot;pipe&quot; = [&quot;pipe&quot;;&quot;.&quot;;&quot;&quot;]</code> for &quot;\\.\pipe&quot;</li><li><code>[&quot;C:&quot;]/:&quot;foo&quot; = [&quot;foo&quot;;&quot;C:&quot;]</code> for &quot;C:\foo&quot;</li></ul><p>In principle the first type of paths has broader range of allowed characters, but this implementation applies more strict rules to both (<a href="index.html#val-default_validator"><code>default_validator</code></a>).</p></dd></dl><dl><dt class="spec value" id="val-is_relative"><a href="#val-is_relative" class="anchor"></a><code><span class="keyword">val </span>is_relative : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dt class="spec value" id="val-is_absolute"><a href="#val-is_absolute" class="anchor"></a><code><span class="keyword">val </span>is_absolute : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt></dl><section><header><h6 id="construction"><a href="#construction" class="anchor"></a>Construction</h6></header><dl><dt class="spec value" id="val-root"><a href="#val-root" class="anchor"></a><code><span class="keyword">val </span>root : <a href="index.html#type-t">t</a></code></dt><dd><p>Root of the filesystem (<code>[&quot;&quot;]</code>). It is minimal absolute path. Below it is called 'empty'. However it yields &quot;/&quot; or &quot;\\&quot; when converted to a string.</p><p><em>Windows:</em> This path (root and nothing more) is meaningless, but for simplicity it is considered valid here. To create absolute path starting with drive letter, construct the list explicitly (as in <code>[&quot;C:&quot;]/:&quot;foo&quot;</code>). A path consisting of drive letter only is also called 'empty' here.</p></dd></dl><dl><dt class="spec value" id="val-append"><a href="#val-append" class="anchor"></a><code><span class="keyword">val </span>append : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-ustring">ustring</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Alternative name for <code>Operators.(/:)</code></p></dd></dl><dl><dt class="spec value" id="val-concat"><a href="#val-concat" class="anchor"></a><code><span class="keyword">val </span>concat : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Alternative name for <a href="Operators/index.html#val-(//@)"><code>Operators.(//@)</code></a></p></dd></dl><dl><dt class="spec module" id="module-Operators"><a href="#module-Operators" class="anchor"></a><code><span class="keyword">module </span><a href="Operators/index.html">Operators</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Infix operators for path construction. They are in separate module, so one can <code>open Path.Operators</code> to use them.</p></dd></dl><dl><dt class="spec module" id="module-Infix"><a href="#module-Infix" class="anchor"></a><code><span class="keyword">module </span><a href="Infix/index.html">Infix</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>As other Operators modules in batteries are named &quot;Infix&quot; we provide Infix as well. This is a mere copy of Operators.</p></dd></dl><dl><dt class="spec exception" id="exception-Malformed_path"><a href="#exception-Malformed_path" class="anchor"></a><code><span class="keyword">exception </span></code><code><span class="exception">Malformed_path</span></code></dt></dl><dl><dt class="spec value" id="val-normalize_filepath"><a href="#val-normalize_filepath" class="anchor"></a><code><span class="keyword">val </span>normalize_filepath : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Consumes single dots where possible, e.g.:</p><p><code>normalize ([&quot;..&quot;]/:&quot;foo&quot;/:&quot;.&quot;/:&quot;bar&quot;/:&quot;sub1&quot;/:&quot;..&quot;/:&quot;sub2&quot;) = [&quot;..&quot;]/:&quot;foo&quot;/:&quot;bar&quot;/:&quot;sub1&quot;/:&quot;..&quot;/:&quot;sub2&quot;</code></p><p>When a directory structure contains links, it can be not pefectly pure tree. Then meaing of the &quot;..&quot; symbol depends on the real nature of parent of what is denoted by the name that preceded the &quot;..&quot; symbol. This symbol cannot be resolved for a graph traversal case when dealing with abstract paths only.</p><p><em>Windows:</em> If single dot is next to root, it is preserved.</p></dd></dl><dl><dt class="spec value" id="val-normalize_in_graph"><a href="#val-normalize_in_graph" class="anchor"></a><code><span class="keyword">val </span>normalize_in_graph : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Consumes single dots where possible, e.g.:</p><p><code>normalize ([&quot;..&quot;]/:&quot;foo&quot;/:&quot;.&quot;/:&quot;bar&quot;/:&quot;sub1&quot;/:&quot;..&quot;/:&quot;sub2&quot;) = [&quot;..&quot;]/:&quot;foo&quot;/:&quot;bar&quot;/:&quot;sub1&quot;/:&quot;..&quot;/:&quot;sub2&quot;</code></p><p>When a directory structure contains links, it can be not pefectly pure tree. Then meaing of the &quot;..&quot; symbol depends on the real nature of parent of what is denoted by the name that preceded the &quot;..&quot; symbol. This symbol cannot be resolved for a graph traversal case when dealing with abstract paths only.</p><p><em>Windows:</em> If single dot is next to root, it is preserved.</p><p>Another name for <code>normalize_filepath</code>.</p></dd></dl><dl><dt class="spec value" id="val-normalize_in_tree"><a href="#val-normalize_in_tree" class="anchor"></a><code><span class="keyword">val </span>normalize_in_tree : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Consumes single dots and applies double dots where possible, e.g.:</p><p><code>normalize ([&quot;..&quot;]/:&quot;foo&quot;/:&quot;.&quot;/:&quot;bar&quot;/:&quot;sub1&quot;/:&quot;..&quot;/:&quot;sub2&quot;) = [&quot;..&quot;]/:&quot;foo&quot;/:&quot;bar&quot;/:&quot;sub2&quot;</code></p><p>This normalization is useful when dealing with paths that describe locations in a tree and the &quot;..&quot; symbol always points to the only parent of what precedes this symbol.</p><p><em>Windows:</em> If single dot is next to root, it is preserved.</p><dl><dt>raises Malformed_path</dt><dd><p>when absolute path is given that contains double dots that would be applied to the root.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-normalize"><a href="#val-normalize" class="anchor"></a><code><span class="keyword">val </span>normalize : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Deprecated name for <code>normalize_in_tree</code></p></dd></dl><dl><dt class="spec value" id="val-parent"><a href="#val-parent" class="anchor"></a><code><span class="keyword">val </span>parent : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Returns parent path, i.e. immediate ancestor: <code>parent (foo/:bar) = foo</code></p><dl><dt>raises Invalid_argument</dt><dd><p>if empty path (relative <code>[]</code> or absolute <code>[&quot;&quot;]</code>) is given</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-belongs"><a href="#val-belongs" class="anchor"></a><code><span class="keyword">val </span>belongs : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>belongs base sub</code> is <code>true</code> when <code>sub</code> descends from <code>base</code>, i.e. <code>base</code> is a prefix of <code>sub</code>. If <code>base</code>=<code>sub</code> the function returns <code>true</code>. It is otherwise <code>false</code>. Both arguments must be absolute paths or both relative.</p><p>If both arguments have a root portion with drive letter and these letters are different, <code>belongs base sub</code> returns false.</p><dl><dt>raises Invalid_argument</dt><dd><p>if exactly one of given arguments is absolute path</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-relative_to_any"><a href="#val-relative_to_any" class="anchor"></a><code><span class="keyword">val </span>relative_to_any : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>relative_to_any base sub</code> returns relative path <code>rel</code> such that <code>normalize (base/:rel) = normalize sub</code>, i.e. common base is stripped and &quot;..&quot; are added if necessary. Both arguments must be absolute paths or both relative.</p><p>This function normalizes <code>base</code> and <code>sub</code> before calculation of the relative path.</p><p><em>Windows:</em> If <code>base</code> and <code>sub</code> are absolute, they must have the same root element: have the same drive letter or both starting with <a href="index.html#val-root"><code>root</code></a> (i.e. <code>&quot;&quot;</code> is the last element of the list). Exceptionally it is possible to get an absolute path as a result if drive letter is in <code>sub</code> but not as a root element (e .g. <code>base = root/:&quot;bar&quot;</code> and <code>sub = root/:bar//@([&quot;C:&quot;]/:&quot;foo&quot;</code>).</p><dl><dt>see <code>relative_to_parent</code></dt><dd><p>may be sometimes more suitable</p></dd></dl><dl><dt>raises Invalid_argument</dt><dd><p>if exactly one of given arguments is an absolute path</p></dd></dl><dl><dt>raises Malformed_path</dt><dd><p>if normalization fails (see <a href="index.html#val-normalize"><code>PathType.normalize</code></a>)</p></dd></dl></dd></dl><dl><dt class="spec exception" id="exception-Not_parent"><a href="#exception-Not_parent" class="anchor"></a><code><span class="keyword">exception </span></code><code><span class="exception">Not_parent</span></code></dt></dl><dl><dt class="spec value" id="val-relative_to_parent"><a href="#val-relative_to_parent" class="anchor"></a><code><span class="keyword">val </span>relative_to_parent : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>relative_to_parent parent sub</code> returns relative path <code>rel</code> such that <code>(normalize parent)/:rel = normalize sub</code>. It is checked if <code>sub</code> is really a descendant of <code>parent</code>. Both arguments must be absolute paths or both relative.</p><p>This function normalizes <code>base</code> and <code>sub</code> before calculation of the relative path.</p><p><em>Windows:</em> Exceptionally it is possible to get an absolute path as a result if drive letter is in <code>sub</code> but not as a root element (e .g. <code>base = root/:&quot;bar&quot;</code> and <code>sub = root/:bar//@([&quot;C:&quot;]/:&quot;foo&quot;)</code>).</p><dl><dt>raises Not_parent</dt><dd><p>if <code>sub</code> is not descendant of <code>parent</code></p></dd></dl><dl><dt>raises Invalid_argument</dt><dd><p>if exactly one of given arguments is absolute path</p></dd></dl><dl><dt>raises Malformed_path</dt><dd><p>if normalization fails (see <a href="index.html#val-normalize"><code>PathType.normalize</code></a>)</p></dd></dl></dd></dl></section><section><header><h6 id="validation"><a href="#validation" class="anchor"></a>Validation</h6></header><dl><dt class="spec exception" id="exception-Illegal_char"><a href="#exception-Illegal_char" class="anchor"></a><code><span class="keyword">exception </span></code><code><span class="exception">Illegal_char</span></code></dt><dd><p>Raised by <a href="index.html#val-of_string"><code>PathType.of_string</code></a>, <a href="index.html#val-append"><code>PathType.append</code></a> and <code>PathType.Operators.(/:)</code> when used validator finds illegal character.</p></dd></dl><dl><dt class="spec type" id="type-validator"><a href="#type-validator" class="anchor"></a><code><span class="keyword">type </span>validator</code><code><span class="keyword"> = </span><a href="index.html#type-ustring">ustring</a> <span>&#45;&gt;</span> bool</code></dt><dd><p>Validators should check if all characters of given string can be used in a name (path component). Return true if the name is valid. Return false if illegal character is found.</p><p>If a name should be rejected for some other reason, user defined validator may raise an exception.</p></dd></dl><dl><dt class="spec value" id="val-default_validator"><a href="#val-default_validator" class="anchor"></a><code><span class="keyword">val </span>default_validator : <a href="index.html#type-validator">validator</a> Pervasives.ref</code></dt><dd><p>Forward slash and code zero are considered invalid.</p><p><em>Windows:</em> Invalid characters are *?:\/&lt;&gt; and all with code &lt;32. Exception: the function <a href="index.html#val-of_string"><code>PathType.of_string</code></a> doesn't use validator against drive letter with colon.</p></dd></dl></section><section><header><h6 id="conversions"><a href="#conversions" class="anchor"></a>Conversions</h6></header><dl><dt class="spec value" id="val-to_ustring"><a href="#val-to_ustring" class="anchor"></a><code><span class="keyword">val </span>to_ustring : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-ustring">ustring</a></code></dt><dd><p>Convert to the chosen <code>ustring</code> type. Empty relative path is converted to &quot;.&quot; (single dot).</p><p><em>Windows:</em> backslash is used as a separator and double backslash for root. If the path is only a drive letter (empty absolute path) trailing backslash is added (e.g. <code>to_string [&quot;C:&quot;] = &quot;C:\&quot;</code>).</p><dl><dt>see <code>to_string</code></dt><dd><p>is likely to bo more useful &quot;</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-to_string"><a href="#val-to_string" class="anchor"></a><code><span class="keyword">val </span>to_string : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> string</code></dt><dd><p>Convert to type primitive string with UTF-8 content. The string is built in the same way as by <code>to_ustring</code> function.</p></dd></dl><dl><dt class="spec value" id="val-of_string"><a href="#val-of_string" class="anchor"></a><code><span class="keyword">val </span>of_string : <a href="index.html#type-ustring">ustring</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Parse path in a given string. Any number of consecutive separators collapse (&quot;a//b&quot; becomes &quot;a/b&quot;). <code>Path.default_validator</code> is applied to each resulting name.</p><p><em>Windows:</em> both slashes '\' and '/' are accepted as separators. Paths of the 'semi-relative' form &quot;C:foo\bar&quot; are not recognized. For example &quot;C:&quot; string is parsed as <code>[&quot;C:&quot;]</code> which has different meaning (see <a href="index.html#val-to_string"><code>to_string</code></a>).</p><dl><dt>raises Illegal_char</dt><dd><p>when a character not allowed in paths is found.</p></dd></dl></dd></dl></section><section><header><h6 id="convenience-aliases"><a href="#convenience-aliases" class="anchor"></a>Convenience aliases</h6></header><dl><dt class="spec value" id="val-s"><a href="#val-s" class="anchor"></a><code><span class="keyword">val </span>s : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> string</code></dt><dd><p>= <a href="index.html#val-to_string"><code>to_string</code></a></p></dd></dl><dl><dt class="spec value" id="val-p"><a href="#val-p" class="anchor"></a><code><span class="keyword">val </span>p : <a href="index.html#type-ustring">ustring</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>= <a href="index.html#val-of_string"><code>of_string</code></a></p></dd></dl></section><section><header><h6 id="name-related-functions"><a href="#name-related-functions" class="anchor"></a>Name related functions</h6><p>These funtions do not accept empty paths, i.e. <code>[]</code>, <code>[&quot;&quot;]</code> or <code>[&quot;C:&quot;]</code>.</p></header><dl><dt class="spec value" id="val-name"><a href="#val-name" class="anchor"></a><code><span class="keyword">val </span>name : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-ustring">ustring</a></code></dt><dd><p>Returns name of the object the pathname points to, i.e. <code>name (foo/:bar) = bar</code></p><dl><dt>raises Invalid_argument</dt><dd><p>if empty path (relative <code>[]</code> or absolute <code>[&quot;&quot;]</code>) is given</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-map_name"><a href="#val-map_name" class="anchor"></a><code><span class="keyword">val </span>map_name : (<a href="index.html#type-ustring">ustring</a> <span>&#45;&gt;</span> <a href="index.html#type-ustring">ustring</a>) <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>map_name fu path</code> returns <code>path</code> with the name replaced by <code>fu (</code><a href="index.html#val-name"><code>PathType.name</code></a><code> path)</code>.</p><p>Example: <code>map_name (fun nn -&gt; nn ^ &quot;.backup&quot;) ([&quot;foo&quot;]/:&quot;bar&quot;) = [&quot;foo&quot;]/:&quot;bar.backup&quot;</code></p><p><a href="index.html#val-default_validator"><code>PathType.default_validator</code></a> is applied to new name.</p><dl><dt>raises Illegal_char</dt><dd><p>(raised by validator if any bad character is found)</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-ext"><a href="#val-ext" class="anchor"></a><code><span class="keyword">val </span>ext : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-ustring">ustring</a> option</code></dt><dd><p>Returns extension of the name of the object the pathname points to. Examples:</p><p><code>ext [&quot;aa.bb&quot;] = Some &quot;bb&quot;</code></p><p><code>ext [&quot;aa.&quot;] = Some &quot;&quot;</code></p><p><code>ext [&quot;aa&quot;] = None</code></p><p><code>ext [&quot;.hidden&quot;] = Some &quot;hidden&quot;</code> <em>(!)</em></p><p>Extension begins where the rightmost dot in the name is found. If the name ends with a dot, the extension is empty and <code>Some &quot;&quot;</code> is returned. If there is no extension (no dot) the function returns <code>None</code>.</p><p>@example &quot;Count unfinished music downloads (files ending with '.ogg.part').&quot;</p><pre><code class="ml">let count_music_parts download_dir =
  let files = Directory.files download_dir in
  let check file =
    match Path.ext file with
    | Some &quot;part&quot; -&gt; ((Path.ext (Path.name_core file)) = &quot;ogg&quot;)
    | _ -&gt; false
  in
  let music_parts = List.filter check files in
  List.length music_parts</code></pre><dl><dt>raises Invalid_argument</dt><dd><p>if empty path (relative <code>[]</code> or absolute <code>[&quot;&quot;]</code>) is given</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-map_ext"><a href="#val-map_ext" class="anchor"></a><code><span class="keyword">val </span>map_ext : (<a href="index.html#type-ustring">ustring</a> option <span>&#45;&gt;</span> <a href="index.html#type-ustring">ustring</a> option) <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>map_ext fu path</code> returns <code>path</code> but with the name with extension given by <code>fu (</code><a href="index.html#val-ext"><code>PathType.ext</code></a><code> path)</code>. If <code>fu</code> returns <code>Some _</code>, the original extension may be replaced (when <code>Some ext</code> is passed to <code>fu</code>) or new added (when <code>fu</code> gets <code>None</code>). In case <code>fu</code> returns <code>None</code>, the extension is removed (if exists).</p><p>@example &quot;A name for file being encoded in a new format.&quot;</p><pre><code class="ml">let pngname file = map_ext (function Some _ | None -&gt; Some &quot;png&quot;) file
let new_bar = pngname ([&quot;foo&quot;]/:&quot;bar.jpeg&quot;) (* = [&quot;foo&quot;]/:&quot;bar.png&quot; *)</code></pre><p><a href="index.html#val-default_validator"><code>PathType.default_validator</code></a> is applied to the resulting name.</p><p>The replacement string returned by the mapping function <code>fu</code> can contain dots. Consequently, this string doesn't need to be an extension as defined by the <a href="index.html#val-ext"><code>ext</code></a> function. Consider for example:</p><pre><code class="ml">let before = foo/:&quot;bar.mli&quot;
let replacement = &quot;mli.off&quot;
let ext_before = Path.ext before (* = Some &quot;mli&quot; *)
let after = Path.map_ext (fun _ -&gt; Some replacement) before (* = foo/:&quot;bar.mli.off&quot; *)
let ext_after = Path.ext after (* = Some &quot;off&quot; *)</code></pre><p>Note the difference between <code>replacement</code> and <code>ext_after</code>! <code>(map_ext fu)</code> is idempotent only if <code>fu</code> always returns <code>Some _</code>. Otherwise it can remove the extension, possibly exposing part of the name that becomes the new extension.</p><p><em>Windows:</em> If <code>fu</code> returns <code>Some &quot;&quot;</code> (to make a name with trailing period) <code>map_ext</code> returns a path that shouldn't be passed to the operating system (it is invalid).</p><dl><dt>raises Illegal_char</dt><dd><p>(raised by validator if any bad character is found)</p></dd></dl><dl><dt>raises Invalid_argument</dt><dd><p>if empty path (relative <code>[]</code> or absolute <code>[&quot;&quot;]</code>) is given</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-name_core"><a href="#val-name_core" class="anchor"></a><code><span class="keyword">val </span>name_core : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-ustring">ustring</a></code></dt><dd><p>Returns part of the name to the left of rightmost dot. Returns empty string if the name starts with a dot.</p><p>@example &quot;Label for a piece of GUI in which a file is edited.&quot;</p><pre><code class="ml">let tab_label modified file =
  let text = (if modified then &quot;*&quot; else &quot;&quot;) ^ (Path.name_core file) in
  GMisc.label ~text ()</code></pre><dl><dt>raises Invalid_argument</dt><dd><p>if empty path (relative <code>[]</code> or absolute <code>[&quot;&quot;]</code>) is given</p></dd></dl></dd></dl><dl><dt class="spec type" id="type-components"><a href="#type-components" class="anchor"></a><code><span class="keyword">type </span>components</code><code><span class="keyword"> = </span><a href="index.html#type-t">t</a><span class="keyword"> * </span><a href="index.html#type-ustring">ustring</a><span class="keyword"> * </span><a href="index.html#type-ustring">ustring</a> option</code></dt><dd><p>A <code>path</code> can be represented by the following triple: <code>(Path.parent path, Path.name_core path, Path.ext path)</code></p></dd></dl><dl><dt class="spec value" id="val-split"><a href="#val-split" class="anchor"></a><code><span class="keyword">val </span>split : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-components">components</a></code></dt><dd><p>Dissect the path to its components (parent path, core part of name and possibly an extension).</p><p>Resulting <code>name_core</code> string can be empty. For example, <code>Path.split (Path.root/:&quot;home&quot;/:&quot;user&quot;/:&quot;.bashrc&quot;)</code> equals <code>(Path.root/:&quot;home&quot;/:&quot;user&quot;, &quot;&quot;, Some &quot;bashrc&quot;)</code>.</p><dl><dt>raises Invalid_argument</dt><dd><p>if empty path (relative <code>[]</code> or absolute <code>[&quot;&quot;]</code>) is given</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-join"><a href="#val-join" class="anchor"></a><code><span class="keyword">val </span>join : <a href="index.html#type-components">components</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Create a path from given components.</p><dl><dt>raises Illegal_char</dt><dd><p>(raised by validator on any bad character)</p><p>@example &quot;Creating paths for a series of numbered images.&quot;</p><pre><code class="ml">let get_animation_frames working_dir count =
  let frame_file num = Path.join
      (working_dir/:&quot;rendering&quot;
      ,&quot;frame&quot;^(stirng_of_int num)
      ,Some &quot;png&quot;
      )
  in
  BatEnum.map frame_file (1 -- count)</code></pre></dd></dl></dd></dl><dl><dt class="spec value" id="val-map"><a href="#val-map" class="anchor"></a><code><span class="keyword">val </span>map : (<a href="index.html#type-components">components</a> <span>&#45;&gt;</span> <a href="index.html#type-components">components</a>) <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Map a path through a function that operates on separate components.</p><dl><dt>raises Illegal_char</dt><dd><p>(raised by validator on any bad character)</p></dd></dl><dl><dt>raises Invalid_argument</dt><dd><p>if empty path (relative <code>[]</code> or absolute <code>[&quot;&quot;]</code>) is given</p><p>@example &quot;Insert a string just before file extension.&quot;</p><pre><code class="ml">let extract_first_page file =
  let insert (parent, name_core, ext) = (parent, name_core ^ &quot;_page1&quot;, ext) in
  let result_file = Path.map insert file in
  let code = Sys.command
      (String.concat ' '
         [&quot;psselect -p1 &lt;&quot;; P.s file
         ;&quot; &gt;&quot;; P.s result_file
         ]
      )
  in
  if code = 0 then result_file else failwith &quot;psselect&quot;</code></pre></dd></dl></dd></dl></section><section><header><h6 id="supplementary-functions"><a href="#supplementary-functions" class="anchor"></a>Supplementary functions</h6></header><dl><dt class="spec value" id="val-drive_letter"><a href="#val-drive_letter" class="anchor"></a><code><span class="keyword">val </span>drive_letter : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-uchar">uchar</a> option</code></dt><dd><p>Return drive letter of the given absolute path.</p><p><em>Windows:</em> <code>drive_letter abs</code> returns <code>None</code> if <code>abs</code> is simple absolute path (i.e. begins with a separator), otherwise the root element of <code>abs</code> consists of a letter <code>ch</code> with a colon - in this case <code>Some ch</code> is returned.</p><p><em>Other systems:</em> Returns <code>None</code> on all absolute paths.</p><p>@example &quot;(Windows only) Are the locations on the same partition?&quot;</p><pre><code class="ml">let can_move_quickly ~path_from ~path_to =
         (drive_letter path_from) = (drive_letter path_to)</code></pre><dl><dt>raises Invalid_argument</dt><dd><p>if relative path is given</p></dd></dl></dd></dl></section></div></body></html>