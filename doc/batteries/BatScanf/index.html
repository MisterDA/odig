<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>BatScanf (batteries.BatScanf)</title><link rel="stylesheet" href="../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../index.html">batteries</a> &#x00BB; BatScanf</nav><h1>Module <code>BatScanf</code></h1><p>Formatted input functions.</p><dl><dt>author</dt><dd>Pierre Weis (Base module)</dd></dl><dl><dt>author</dt><dd>David Teller</dd></dl><nav class="toc"><ul><li><a href="#introduction">Introduction</a></li><li><a href="#functional-input-with-format-strings">Functional input with format strings</a></li><li><a href="#a-simple-example">A simple example</a></li><li><a href="#formatted-input-as-a-functional-feature">Formatted input as a functional feature</a></li><li><a href="#type-of-formatted-input-functions">Type of formatted input functions</a></li><li><a href="#the-general-formatted-input-function">The general formatted input function</a></li><li><a href="#format-string-description">Format string description</a></li><li><a href="#the-space-character-in-format-strings">The space character in format strings</a></li><li><a href="#conversion-specifications-in-format-strings">Conversion specifications in format strings</a></li><li><a href="#scanning-indications-in-format-strings">Scanning indications in format strings</a></li><li><a href="#exceptions-during-scanning">Exceptions during scanning</a></li><li><a href="#specialized-formatted-input-functions">Specialized formatted input functions</a></li><li><a href="#reading-format-strings-from-input">Reading format strings from input</a></li></ul></nav></header><section><header><h6 id="introduction"><a href="#introduction" class="anchor"></a>Introduction</h6></header></section><section><header><h6 id="functional-input-with-format-strings"><a href="#functional-input-with-format-strings" class="anchor"></a>Functional input with format strings</h6></header><aside><p>The module <code>Scanf</code> provides formatted input functions or <em>scanners</em>.</p><p>The formatted input functions can read from any kind of input, including strings, files, or anything that can return characters. The more general source of characters is named a <em>scanning buffer</em> and has type <a href="Scanning/index.html#type-scanbuf"><code>Scanning.scanbuf</code></a>. The more general formatted input function reads from any scanning buffer and is named <code>bscanf</code>.</p><p>Generally speaking, the formatted input functions have 3 arguments:</p><ul><li>the first argument is a source of characters for the input,</li><li>the second argument is a format string that specifies the values to read,</li><li>the third argument is a <em>receiver function</em> that is applied to the values read.</li></ul><p>Hence, a typical call to the formatted input function <span class="xref-unresolved" title="unresolved reference to &quot;Scanf.bscanf&quot;"><code>Scanf</code>.bscanf</span> is <code>bscanf ib fmt f</code>, where:</p><ul><li><code>ib</code> is a source of characters (typically a <em>scanning buffer</em> with type <a href="Scanning/index.html#type-scanbuf"><code>Scanning.scanbuf</code></a>),</li></ul><ul><li><code>fmt</code> is a format string (the same format strings as those used to print material with module <code>Printf</code> or <code>Format</code>),</li></ul><ul><li><code>f</code> is a function that has as many arguments as the number of values to read in the input.</li></ul></aside></section><section><header><h6 id="a-simple-example"><a href="#a-simple-example" class="anchor"></a>A simple example</h6></header><aside><p>As suggested above, the expression <code>bscanf ib &quot;%d&quot; f</code> reads a decimal integer <code>n</code> from the source of characters <code>ib</code> and returns <code>f n</code>.</p><p>For instance,</p><ul><li>if we use <code>stdib</code> as the source of characters (<a href="Scanning/index.html#val-stdib"><code>Scanning.stdib</code></a> is the predefined input buffer that reads from standard input),</li></ul><ul><li>if we define the receiver <code>f</code> as <code>let f x = x + 1</code>,</li></ul><p>then <code>bscanf stdib &quot;%d&quot; f</code> reads an integer <code>n</code> from the standard input and returns <code>f n</code> (that is <code>n + 1</code>). Thus, if we evaluate <code>bscanf stdib
    &quot;%d&quot; f</code>, and then enter <code>41</code> at the keyboard, we get <code>42</code> as the final result.</p></aside></section><section><header><h6 id="formatted-input-as-a-functional-feature"><a href="#formatted-input-as-a-functional-feature" class="anchor"></a>Formatted input as a functional feature</h6></header><aside><p>The OCaml scanning facility is reminiscent of the corresponding C feature. However, it is also largely different, simpler, and yet more powerful: the formatted input functions are higher-order functionals and the parameter passing mechanism is just the regular function application not the variable assigment based mechanism which is typical for formatted input in imperative languages; the OCaml format strings also feature useful additions to easily define complex tokens; as expected within a functional programming language, the formatted input functions also support polymorphism, in particular arbitrary interaction with polymorphic user-defined scanners. Furthermore, the OCaml formatted input facility is fully type-checked at compile time.</p></aside><dl><dt class="spec module" id="module-Scanning"><a href="#module-Scanning" class="anchor"></a><code><span class="keyword">module</span> <a href="Scanning/index.html">Scanning</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd></dd></dl></section><section><header><h6 id="type-of-formatted-input-functions"><a href="#type-of-formatted-input-functions" class="anchor"></a>Type of formatted input functions</h6></header><dl><dt class="spec type" id="type-scanner"><a href="#type-scanner" class="anchor"></a><code><span class="keyword">type</span> ('a, 'b, 'c, 'd) scanner</code><code> = (<span class="type-var">'a</span>, <a href="Scanning/index.html#type-scanbuf">Scanning.scanbuf</a>, <span class="type-var">'b</span>, <span class="type-var">'c</span>, <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'d</span>, <span class="type-var">'d</span>) <a href="../../ocaml/Stdlib/index.html#type-format6">Stdlib.format6</a> <span>&#45;&gt;</span> <span class="type-var">'c</span></code></dt></dl><dl><dt class="spec exception" id="exception-Scan_failure"><a href="#exception-Scan_failure" class="anchor"></a><code><span class="keyword">exception</span> </code><code><span class="exception">Scan_failure</span> <span class="keyword">of</span> string</code></dt></dl></section><section><header><h6 id="the-general-formatted-input-function"><a href="#the-general-formatted-input-function" class="anchor"></a>The general formatted input function</h6></header><dl><dt class="spec value" id="val-bscanf"><a href="#val-bscanf" class="anchor"></a><code><span class="keyword">val</span> bscanf : <a href="Scanning/index.html#type-scanbuf">Scanning.scanbuf</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span>, <span class="type-var">'b</span>, <span class="type-var">'c</span>, <span class="type-var">'d</span>) <a href="index.html#type-scanner">scanner</a></code></dt></dl></section><section><header><h6 id="format-string-description"><a href="#format-string-description" class="anchor"></a>Format string description</h6></header><aside><p>The format is a character string which contains three types of objects:</p><ul><li>plain characters, which are simply matched with the characters of the input,</li><li>conversion specifications, each of which causes reading and conversion of one argument for the function <code>f</code>,</li><li>scanning indications to specify boundaries of tokens.</li></ul></aside></section><section><header><h6 id="the-space-character-in-format-strings"><a href="#the-space-character-in-format-strings" class="anchor"></a>The space character in format strings</h6></header><aside><p>As mentioned above, a plain character in the format string is just matched with the characters of the input; however, one character is a special exception to this simple rule: the space character (ASCII code 32) does not match a single space character, but any amount of ``whitespace'' in the input. More precisely, a space inside the format string matches <em>any number</em> of tab, space, line feed and carriage return characters.</p><p>Matching <em>any</em> amount of whitespace, a space in the format string also matches no amount of whitespace at all; hence, the call <code>bscanf ib
    &quot;Price = %d $&quot; (fun p -&gt; p)</code> succeds and returns <code>1</code> when reading an input with various whitespace in it, such as <code>Price = 1 $</code>, <code>Price  =  1    $</code>, or even <code>Price=1$</code>.</p></aside></section><section><header><h6 id="conversion-specifications-in-format-strings"><a href="#conversion-specifications-in-format-strings" class="anchor"></a>Conversion specifications in format strings</h6></header><aside><p>Conversion specifications consist in the <code>%</code> character, followed by an optional flag, an optional field width, and followed by one or two conversion characters. The conversion characters and their meanings are:</p><ul><li><code>d</code>: reads an optionally signed decimal integer.</li><li><code>i</code>: reads an optionally signed integer (usual input formats for hexadecimal (<code>0x[d]+</code> and <code>0X[d]+</code>), octal (<code>0o[d]+</code>), and binary <code>0b[d]+</code> notations are understood).</li><li><code>u</code>: reads an unsigned decimal integer.</li><li><code>x</code> or <code>X</code>: reads an unsigned hexadecimal integer.</li><li><code>o</code>: reads an unsigned octal integer.</li><li><code>s</code>: reads a string argument that spreads as much as possible, until the following bounding condition holds: a whitespace has been found, a scanning indication has been encountered, or the end-of-input has been reached. Hence, this conversion always succeeds: it returns an empty string, if the bounding condition holds when the scan begins.</li><li><code>S</code>: reads a delimited string argument (delimiters and special escaped characters follow the lexical conventions of OCaml).</li><li><p><code>c</code>: reads a single character. To test the current input character without reading it, specify a null field width, i.e. use specification <code>%0c</code>. </p><p>@raise Invalid_argument,</p><p>if the field width specification is greater than 1.</p></li><li><code>C</code>: reads a single delimited character (delimiters and special escaped characters follow the lexical conventions of OCaml).</li><li><code>f</code>, <code>e</code>, <code>E</code>, <code>g</code>, <code>G</code>: reads an optionally signed floating-point number in decimal notation, in the style <code>dddd.ddd
      e/E+-dd</code>.</li><li><code>F</code>: reads a floating point number according to the lexical conventions of OCaml (hence the decimal point is mandatory if the exponent part is not mentioned).</li><li><code>B</code>: reads a boolean argument (<code>true</code> or <code>false</code>).</li><li><code>b</code>: reads a boolean argument (for backward compatibility; do not use in new programs).</li><li><code>ld</code>, <code>li</code>, <code>lu</code>, <code>lx</code>, <code>lX</code>, <code>lo</code>: reads an <code>int32</code> argument to the format specified by the second letter (decimal, hexadecimal, etc).</li><li><code>nd</code>, <code>ni</code>, <code>nu</code>, <code>nx</code>, <code>nX</code>, <code>no</code>: reads a <code>nativeint</code> argument to the format specified by the second letter.</li><li><code>Ld</code>, <code>Li</code>, <code>Lu</code>, <code>Lx</code>, <code>LX</code>, <code>Lo</code>: reads an <code>int64</code> argument to the format specified by the second letter.</li><li><code>[ range ]</code>: reads characters that matches one of the characters mentioned in the range of characters <code>range</code> (or not mentioned in it, if the range starts with <code>^</code>). Reads a <code>string</code> that can be empty, if the next input character does not match the range. The set of characters from <code>c1</code> to <code>c2</code> (inclusively) is denoted by <code>c1-c2</code>. Hence, <code>%[0-9]</code> returns a string representing a decimal number or an empty string if no decimal digit is found; similarly, <code>%[\\048-\\057\\065-\\070]</code> returns a string of hexadecimal digits. If a closing bracket appears in a range, it must occur as the first character of the range (or just after the <code>^</code> in case of range negation); hence <code>[]]</code> matches a <code>]</code> character and <code>[^]]</code> matches any character that is not <code>]</code>.</li><li><code>r</code>: user-defined reader. Takes the next <code>ri</code> formatted input function and applies it to the scanning buffer <code>ib</code> to read the next argument. The input function <code>ri</code> must therefore have type <code>Scanning.scanbuf -&gt; 'a</code> and the argument read has type <code>'a</code>.</li><li><code>\{ fmt %\}</code>: reads a format string argument. The format string read must have the same type as the format string specification <code>fmt</code>. For instance, <code>&quot;%\{%i%\}&quot;</code> reads any format string that can read a value of type <code>int</code>; hence <code>Scanf.sscanf &quot;fmt:\\\&quot;number is %u\\\&quot;&quot; &quot;fmt:%\{%i%\}&quot;</code> succeeds and returns the format string <code>&quot;number is %u&quot;</code>.</li><li><code>\( fmt %\)</code>: scanning format substitution. Reads a format string to replace <code>fmt</code>. The format string read must have the same type as the format string specification <code>fmt</code>. For instance, <code>&quot;%\( %i% \)&quot;</code> reads any format string that can read a value of type <code>int</code>; hence <code>Scanf.sscanf &quot;\\\&quot;%4d\\\&quot;1234.00&quot; &quot;%\(%i%\)&quot;</code> is equivalent to <code>Scanf.sscanf &quot;1234.00&quot; &quot;%4d&quot;</code>.</li><li><code>l</code>: returns the number of lines read so far.</li><li><code>n</code>: returns the number of characters read so far.</li><li><code>N</code> or <code>L</code>: returns the number of tokens read so far.</li><li><code>!</code>: matches the end of input condition.</li><li><code>%</code>: matches one <code>%</code> character in the input.</li></ul><p>Following the <code>%</code> character that introduces a conversion, there may be the special flag <code>_</code>: the conversion that follows occurs as usual, but the resulting value is discarded. For instance, if <code>f</code> is the function <code>fun i -&gt; i + 1</code>, then <code>Scanf.sscanf &quot;x = 1&quot; &quot;%_s = %i&quot; f</code> returns <code>2</code>.</p><p>The field width is composed of an optional integer literal indicating the maximal width of the token to read. For instance, <code>%6d</code> reads an integer, having at most 6 decimal digits; <code>%4f</code> reads a float with at most 4 characters; and <code>%8[\\000-\\255]</code> returns the next 8 characters (or all the characters still available, if fewer than 8 characters are available in the input).</p><p>Notes:</p><ul><li>as mentioned above, a <code>%s</code> convertion always succeeds, even if there is nothing to read in the input: it simply returns <code>&quot;&quot;</code>.</li></ul><ul><li>in addition to the relevant digits, <code>'_'</code> characters may appear inside numbers (this is reminiscent to the usual OCaml lexical conventions). If stricter scanning is desired, use the range conversion facility instead of the number conversions.</li></ul><ul><li>the <code>scanf</code> facility is not intended for heavy duty lexical analysis and parsing. If it appears not expressive enough for your needs, several alternative exists: regular expressions (module <code>Str</code>), stream parsers, <code>ocamllex</code>-generated lexers, <code>ocamlyacc</code>-generated parsers.</li></ul></aside></section><section><header><h6 id="scanning-indications-in-format-strings"><a href="#scanning-indications-in-format-strings" class="anchor"></a>Scanning indications in format strings</h6></header><aside><p>Scanning indications appear just after the string conversions <code>%s</code> and <code>%[ range ]</code> to delimit the end of the token. A scanning indication is introduced by a <code>@</code> character, followed by some constant character <code>c</code>. It means that the string token should end just before the next matching <code>c</code> (which is skipped). If no <code>c</code> character is encountered, the string token spreads as much as possible. For instance, <code>&quot;%s@\t&quot;</code> reads a string up to the next tab character or to the end of input. If a scanning indication <code>\@c</code> does not follow a string conversion, it is treated as a plain <code>c</code> character.</p><p>Note:</p><ul><li>the scanning indications introduce slight differences in the syntax of <code>Scanf</code> format strings, compared to those used for the <code>Printf</code> module. However, the scanning indications are similar to those used in the <code>Format</code> module; hence, when producing formatted text to be scanned by <code>!Scanf.bscanf</code>, it is wise to use printing functions from the <code>Format</code> module (or, if you need to use functions from <code>Printf</code>, banish or carefully double check the format strings that contain <code>'\@'</code> characters).</li></ul></aside></section><section><header><h6 id="exceptions-during-scanning"><a href="#exceptions-during-scanning" class="anchor"></a>Exceptions during scanning</h6></header><aside><p>Scanners may raise the following exceptions when the input cannot be read according to the format string:</p><ul><li><p>@raise Scanf.Scan_failure</p><p>if the input does not match the format.</p></li></ul><ul><li><p>@raise Failure</p><p>if a conversion to a number is not possible.</p></li></ul><ul><li><p>@raise End_of_file</p><p>if the end of input is encountered while some more characters are needed to read the current conversion specification.</p></li></ul><ul><li><p>@raise Invalid_argument</p><p>if the format string is invalid.</p></li></ul><p>Note:</p><ul><li>as a consequence, scanning a <code>%s</code> conversion never raises exception <code>End_of_file</code>: if the end of input is reached the conversion succeeds and simply returns the characters read so far, or <code>&quot;&quot;</code> if none were read.</li></ul></aside></section><section><header><h6 id="specialized-formatted-input-functions"><a href="#specialized-formatted-input-functions" class="anchor"></a>Specialized formatted input functions</h6></header><dl><dt class="spec value" id="val-fscanf"><a href="#val-fscanf" class="anchor"></a><code><span class="keyword">val</span> fscanf : <a href="../../ocaml/Stdlib/index.html#type-in_channel">Stdlib.in_channel</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span>, <span class="type-var">'b</span>, <span class="type-var">'c</span>, <span class="type-var">'d</span>) <a href="index.html#type-scanner">scanner</a></code></dt><dt class="spec value" id="val-sscanf"><a href="#val-sscanf" class="anchor"></a><code><span class="keyword">val</span> sscanf : string <span>&#45;&gt;</span> (<span class="type-var">'a</span>, <span class="type-var">'b</span>, <span class="type-var">'c</span>, <span class="type-var">'d</span>) <a href="index.html#type-scanner">scanner</a></code></dt><dt class="spec value" id="val-scanf"><a href="#val-scanf" class="anchor"></a><code><span class="keyword">val</span> scanf : (<span class="type-var">'a</span>, <span class="type-var">'b</span>, <span class="type-var">'c</span>, <span class="type-var">'d</span>) <a href="index.html#type-scanner">scanner</a></code></dt><dt class="spec value" id="val-kscanf"><a href="#val-kscanf" class="anchor"></a><code><span class="keyword">val</span> kscanf : <a href="Scanning/index.html#type-scanbuf">Scanning.scanbuf</a> <span>&#45;&gt;</span> (<a href="Scanning/index.html#type-scanbuf">Scanning.scanbuf</a> <span>&#45;&gt;</span> exn <span>&#45;&gt;</span> <span class="type-var">'d</span>) <span>&#45;&gt;</span> (<span class="type-var">'a</span>, <span class="type-var">'b</span>, <span class="type-var">'c</span>, <span class="type-var">'d</span>) <a href="index.html#type-scanner">scanner</a></code></dt></dl></section><section><header><h6 id="reading-format-strings-from-input"><a href="#reading-format-strings-from-input" class="anchor"></a>Reading format strings from input</h6></header><dl><dt class="spec value" id="val-bscanf_format"><a href="#val-bscanf_format" class="anchor"></a><code><span class="keyword">val</span> bscanf_format : <a href="Scanning/index.html#type-scanbuf">Scanning.scanbuf</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span>, <span class="type-var">'b</span>, <span class="type-var">'c</span>, <span class="type-var">'d</span>, <span class="type-var">'e</span>, <span class="type-var">'f</span>) <a href="../../ocaml/Stdlib/index.html#type-format6">Stdlib.format6</a> <span>&#45;&gt;</span> ((<span class="type-var">'a</span>, <span class="type-var">'b</span>, <span class="type-var">'c</span>, <span class="type-var">'d</span>, <span class="type-var">'e</span>, <span class="type-var">'f</span>) <a href="../../ocaml/Stdlib/index.html#type-format6">Stdlib.format6</a> <span>&#45;&gt;</span> <span class="type-var">'g</span>) <span>&#45;&gt;</span> <span class="type-var">'g</span></code></dt><dt class="spec value" id="val-sscanf_format"><a href="#val-sscanf_format" class="anchor"></a><code><span class="keyword">val</span> sscanf_format : string <span>&#45;&gt;</span> (<span class="type-var">'a</span>, <span class="type-var">'b</span>, <span class="type-var">'c</span>, <span class="type-var">'d</span>, <span class="type-var">'e</span>, <span class="type-var">'f</span>) <a href="../../ocaml/Stdlib/index.html#type-format6">Stdlib.format6</a> <span>&#45;&gt;</span> ((<span class="type-var">'a</span>, <span class="type-var">'b</span>, <span class="type-var">'c</span>, <span class="type-var">'d</span>, <span class="type-var">'e</span>, <span class="type-var">'f</span>) <a href="../../ocaml/Stdlib/index.html#type-format6">Stdlib.format6</a> <span>&#45;&gt;</span> <span class="type-var">'g</span>) <span>&#45;&gt;</span> <span class="type-var">'g</span></code></dt><dt class="spec value" id="val-format_from_string"><a href="#val-format_from_string" class="anchor"></a><code><span class="keyword">val</span> format_from_string : string <span>&#45;&gt;</span> (<span class="type-var">'a</span>, <span class="type-var">'b</span>, <span class="type-var">'c</span>, <span class="type-var">'d</span>, <span class="type-var">'e</span>, <span class="type-var">'f</span>) <a href="../../ocaml/Stdlib/index.html#type-format6">Stdlib.format6</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span>, <span class="type-var">'b</span>, <span class="type-var">'c</span>, <span class="type-var">'d</span>, <span class="type-var">'e</span>, <span class="type-var">'f</span>) <a href="../../ocaml/Stdlib/index.html#type-format6">Stdlib.format6</a></code></dt></dl></section></div></body></html>