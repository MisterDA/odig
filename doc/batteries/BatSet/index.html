<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>BatSet (batteries.BatSet)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../index.html">batteries</a> &#x00BB; BatSet</nav><h1>Module <code>BatSet</code></h1><p>Sets over ordered types.</p><p>This module implements the set data structure, given a total ordering function over the set elements. All operations over sets are purely applicative (no side-effects). The implementation uses balanced binary trees, and is therefore reasonably efficient: insertion and membership take time logarithmic in the size of the set, for instance.</p><p><b>Note</b> OCaml, Batteries Included, provides two implementations of sets: polymorphic sets and functorized sets. Functorized sets (see <a href="module-type-S/index.html"><code>S</code></a> and <a href="Make/index.html"><code>Make</code></a>) are slightly more complex to use but offer stronger type-safety. Polymorphic sets make it easier to shoot yourself in the foot. In case of doubt, you should use functorized sets.</p><p>The functorized set implementation is built upon Stdlib's <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Set.html">Set</a> module, but provides the complete interface.</p><dl><dt>author</dt><dd>Xavier Leroy</dd></dl><dl><dt>author</dt><dd>Nicolas Cannasse</dd></dl><dl><dt>author</dt><dd>Markus Mottl</dd></dl><dl><dt>author</dt><dd>David Rajchenbach-Teller</dd></dl><nav class="toc"><ul><li><a href="#functorized-sets">Functorized Sets</a><ul><li><a href="#common-instantiations">Common instantiations</a></li></ul></li><li><a href="#polymorphic-sets">Polymorphic sets</a><ul><li><a href="#boilerplate-code">Boilerplate code</a></li><li><a href="#printing">Printing</a></li><li><a href="#infix-operators">Infix operators</a></li></ul></li></ul></nav></header><section><header><h5 id="functorized-sets"><a href="#functorized-sets" class="anchor"></a>Functorized Sets</h5></header><dl><dt class="spec module-type" id="module-type-OrderedType"><a href="#module-type-OrderedType" class="anchor"></a><code><span class="keyword">module type </span>OrderedType = BatInterfaces.OrderedType</code></dt><dd><p>Input signature of the functor <span class="xref-unresolved" title="unresolved reference to &quot;Set.Make&quot;"><code>Set</code>.Make</span>.</p></dd></dl><dl><dt class="spec module-type" id="module-type-S"><a href="#module-type-S" class="anchor"></a><code><span class="keyword">module type </span><a href="module-type-S/index.html">S</a> = <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Output signature of the functor <span class="xref-unresolved" title="unresolved reference to &quot;Set.Make&quot;"><code>Set</code>.Make</span>.</p></dd></dl><dl><dt class="spec module" id="module-Make"><a href="#module-Make" class="anchor"></a><code><span class="keyword">module </span><a href="Make/index.html">Make</a> : <span class="keyword">functor</span> (<a href="Make/index.html#argument-1-Ord">Ord</a> : <a href="index.html#module-type-OrderedType">OrderedType</a>) <span>&#45;&gt;</span> <a href="index.html#module-type-S">S</a><span class="keyword"> with </span><span class="keyword">type </span><a href="Make/index.html#type-elt">elt</a><span class="keyword"> = </span><a href="Make/index.html#argument-1-Ord">Ord</a>.t</code></dt><dd><p>Functor building an implementation of the set structure given a totally ordered type.</p></dd></dl><div class="spec module" id="module-Make2"><a href="#module-Make2" class="anchor"></a><code><span class="keyword">module </span><a href="Make2/index.html">Make2</a> : <span class="keyword">functor</span> (<a href="Make2/index.html#argument-1-O1">O1</a> : <a href="index.html#module-type-OrderedType">OrderedType</a>) <span>&#45;&gt;</span> <span class="keyword">functor</span> (<a href="Make2/index.html#argument-2-O2">O2</a> : <a href="index.html#module-type-OrderedType">OrderedType</a>) <span>&#45;&gt;</span> <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><section><header><h6 id="common-instantiations"><a href="#common-instantiations" class="anchor"></a>Common instantiations</h6></header><div class="spec module" id="module-Int"><a href="#module-Int" class="anchor"></a><code><span class="keyword">module </span><a href="Int/index.html">Int</a> : <a href="index.html#module-type-S">S</a><span class="keyword"> with </span><span class="keyword">type </span><a href="module-type-S/index.html#type-elt">elt</a><span class="keyword"> = </span>int</code></div><div class="spec module" id="module-Int32"><a href="#module-Int32" class="anchor"></a><code><span class="keyword">module </span><a href="Int32/index.html">Int32</a> : <a href="index.html#module-type-S">S</a><span class="keyword"> with </span><span class="keyword">type </span><a href="module-type-S/index.html#type-elt">elt</a><span class="keyword"> = </span>int32</code></div><div class="spec module" id="module-Int64"><a href="#module-Int64" class="anchor"></a><code><span class="keyword">module </span><a href="Int64/index.html">Int64</a> : <a href="index.html#module-type-S">S</a><span class="keyword"> with </span><span class="keyword">type </span><a href="module-type-S/index.html#type-elt">elt</a><span class="keyword"> = </span>int64</code></div><div class="spec module" id="module-Nativeint"><a href="#module-Nativeint" class="anchor"></a><code><span class="keyword">module </span><a href="Nativeint/index.html">Nativeint</a> : <a href="index.html#module-type-S">S</a><span class="keyword"> with </span><span class="keyword">type </span><a href="module-type-S/index.html#type-elt">elt</a><span class="keyword"> = </span>nativeint</code></div><div class="spec module" id="module-Float"><a href="#module-Float" class="anchor"></a><code><span class="keyword">module </span><a href="Float/index.html">Float</a> : <a href="index.html#module-type-S">S</a><span class="keyword"> with </span><span class="keyword">type </span><a href="module-type-S/index.html#type-elt">elt</a><span class="keyword"> = </span>float</code></div><div class="spec module" id="module-Char"><a href="#module-Char" class="anchor"></a><code><span class="keyword">module </span><a href="Char/index.html">Char</a> : <a href="index.html#module-type-S">S</a><span class="keyword"> with </span><span class="keyword">type </span><a href="module-type-S/index.html#type-elt">elt</a><span class="keyword"> = </span>char</code></div><div class="spec module" id="module-String"><a href="#module-String" class="anchor"></a><code><span class="keyword">module </span><a href="String/index.html">String</a> : <a href="index.html#module-type-S">S</a><span class="keyword"> with </span><span class="keyword">type </span><a href="module-type-S/index.html#type-elt">elt</a><span class="keyword"> = </span>string</code></div></section></section><section><header><h5 id="polymorphic-sets"><a href="#polymorphic-sets" class="anchor"></a>Polymorphic sets</h5><p>The definitions below describe the polymorphic set interface.</p><p>They are similar in functionality to the functorized <a href="Make/index.html"><code>Make</code></a> module, but the compiler cannot ensure that sets using different element ordering have different types: the responsibility of not mixing non-sensical comparison functions together is to the programmer. If in doubt, you should rather use the <a href="Make/index.html"><code>Make</code></a> functor for additional safety.</p><dl><dt>author</dt><dd>Nicolas Cannasse</dd></dl><dl><dt>author</dt><dd>Markus Mottl</dd></dl><dl><dt>author</dt><dd>David Rajchenbach-Teller</dd></dl></header><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type </span>'a t</code></dt><dd><p>The type of sets.</p></dd></dl><div><div class="spec include"><div class="doc"><details open="open"><summary><span class="def"><code><span class="keyword">include </span>BatEnum.Enumerable<span class="keyword"> with </span><span class="keyword">type </span>'a <a href="index.html">BatSet</a>.enumerable<span class="keyword"> = </span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></span></summary><dl><dt class="spec type" id="type-enumerable"><a href="#type-enumerable" class="anchor"></a><code><span class="keyword">type </span>'a enumerable</code><code><span class="keyword"> = </span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt></dl><dl><dt class="spec value" id="val-enum"><a href="#val-enum" class="anchor"></a><code><span class="keyword">val </span>enum : <span class="type-var">'a</span> <a href="index.html#type-enumerable">enumerable</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> BatEnum.t</code></dt><dt class="spec value" id="val-of_enum"><a href="#val-of_enum" class="anchor"></a><code><span class="keyword">val </span>of_enum : <span class="type-var">'a</span> BatEnum.t <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-enumerable">enumerable</a></code></dt></dl></details></div></div></div><div><div class="spec include"><div class="doc"><details open="open"><summary><span class="def"><code><span class="keyword">include </span>BatInterfaces.Mappable<span class="keyword"> with </span><span class="keyword">type </span>'a <a href="index.html">BatSet</a>.mappable<span class="keyword"> = </span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></span></summary><dl><dt class="spec type" id="type-mappable"><a href="#type-mappable" class="anchor"></a><code><span class="keyword">type </span>'a mappable</code><code><span class="keyword"> = </span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt></dl><dl><dt class="spec value" id="val-map"><a href="#val-map" class="anchor"></a><code><span class="keyword">val </span>map : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-mappable">mappable</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-mappable">mappable</a></code></dt></dl></details></div></div></div><dl><dt class="spec value" id="val-empty"><a href="#val-empty" class="anchor"></a><code><span class="keyword">val </span>empty : <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p>The empty set, using <code>compare</code> as comparison function</p></dd></dl><dl><dt class="spec value" id="val-is_empty"><a href="#val-is_empty" class="anchor"></a><code><span class="keyword">val </span>is_empty : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p>Test whether a set is empty or not.</p></dd></dl><dl><dt class="spec value" id="val-singleton"><a href="#val-singleton" class="anchor"></a><code><span class="keyword">val </span>singleton : <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Creates a new set with the single given element in it.</p></dd></dl><dl><dt class="spec value" id="val-mem"><a href="#val-mem" class="anchor"></a><code><span class="keyword">val </span>mem : <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>mem x s</code> tests whether <code>x</code> belongs to the set <code>s</code>.</p></dd></dl><dl><dt class="spec value" id="val-find"><a href="#val-find" class="anchor"></a><code><span class="keyword">val </span>find : <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p><code>find x s</code> returns the set element that compares equal to <code>x</code>.</p><dl><dt>raises Not_found</dt><dd><p>if no such element exists</p></dd></dl><dl><dt>since</dt><dd>2.1</dd></dl></dd></dl><dl><dt class="spec value" id="val-add"><a href="#val-add" class="anchor"></a><code><span class="keyword">val </span>add : <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>add x s</code> returns a set containing all elements of <code>s</code>, plus <code>x</code>. If <code>x</code> was already in <code>s</code>, <code>s</code> is returned unchanged.</p></dd></dl><dl><dt class="spec value" id="val-remove"><a href="#val-remove" class="anchor"></a><code><span class="keyword">val </span>remove : <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>remove x s</code> returns a set containing all elements of <code>s</code>, except <code>x</code>. If <code>x</code> was not in <code>s</code>, <code>s</code> is returned unchanged.</p></dd></dl><dl><dt class="spec value" id="val-update"><a href="#val-update" class="anchor"></a><code><span class="keyword">val </span>update : <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>update x y s</code> replace <code>x</code> by <code>y</code> in <code>s</code>. <code>update</code> is faster when <code>x</code> compares equal to <code>y</code> according to the comparison function used by your set.</p><dl><dt>raises Not_found</dt><dd><p>if <code>x</code> is not in <code>s</code>.</p></dd></dl><dl><dt>since</dt><dd>2.4</dd></dl></dd></dl><dl><dt class="spec value" id="val-union"><a href="#val-union" class="anchor"></a><code><span class="keyword">val </span>union : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>union s t</code> returns the union of <code>s</code> and <code>t</code> - the set containing all elements in either <code>s</code> and <code>t</code>. The returned set uses <code>t</code>'s comparison function. The current implementation works better for small <code>s</code>.</p></dd></dl><dl><dt class="spec value" id="val-intersect"><a href="#val-intersect" class="anchor"></a><code><span class="keyword">val </span>intersect : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>intersect s t</code> returns a new set of those elements that are in both <code>s</code> and <code>t</code>. The returned set uses <code>s</code>'s comparison function.</p></dd></dl><dl><dt class="spec value" id="val-diff"><a href="#val-diff" class="anchor"></a><code><span class="keyword">val </span>diff : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>diff s t</code> returns the set of all elements in <code>s</code> but not in <code>t</code>. The returned set uses <code>s</code>'s comparison function.</p></dd></dl><dl><dt class="spec value" id="val-sym_diff"><a href="#val-sym_diff" class="anchor"></a><code><span class="keyword">val </span>sym_diff : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>sym_diff s t</code> returns the set of all elements in <code>s</code> or <code>t</code> but not both, also known as the symmetric difference. This is the same as <code>diff (union s t) (inter s t)</code>. The returned set uses <code>s</code>'s comparison function.</p></dd></dl><dl><dt class="spec value" id="val-compare"><a href="#val-compare" class="anchor"></a><code><span class="keyword">val </span>compare : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int</code></dt><dd><p>Total ordering between sets. Can be used as the ordering function for doing sets of sets.</p></dd></dl><dl><dt class="spec value" id="val-equal"><a href="#val-equal" class="anchor"></a><code><span class="keyword">val </span>equal : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>equal s1 s2</code> tests whether the sets <code>s1</code> and <code>s2</code> are equal, that is, contain equal elements.</p></dd></dl><dl><dt class="spec value" id="val-subset"><a href="#val-subset" class="anchor"></a><code><span class="keyword">val </span>subset : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>subset a b</code> returns true if <code>a</code> is a subset of <code>b</code>. O(|a|).</p></dd></dl><dl><dt class="spec value" id="val-disjoint"><a href="#val-disjoint" class="anchor"></a><code><span class="keyword">val </span>disjoint : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>disjoint s1 s2</code> tests whether the sets <code>s1</code> and <code>s2</code> contain no shared elements. (i.e. <code>inter s1 s2</code> is empty.)</p></dd></dl><dl><dt class="spec value" id="val-iter"><a href="#val-iter" class="anchor"></a><code><span class="keyword">val </span>iter : (<span class="type-var">'a</span> <span>&#45;&gt;</span> unit) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>iter f s</code> applies <code>f</code> in turn to all elements of <code>s</code>. The elements of <code>s</code> are presented to <code>f</code> in increasing order with respect to the ordering over the type of the elements.</p></dd></dl><dl><dt class="spec value" id="val-at_rank_exn"><a href="#val-at_rank_exn" class="anchor"></a><code><span class="keyword">val </span>at_rank_exn : int <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p><code>at_rank_exn i s</code> returns element at rank <code>i</code> in <code>s</code>, that is the <code>i</code>-th element in increasing order (the <code>0</code>-th element being the smallest element of <code>s</code>).</p><dl><dt>raises Not_found</dt><dd><p>if <code>s = empty</code>.</p></dd></dl><dl><dt>raises Invalid_argument</dt><dd><p>error_message if <code>i &lt; 0 || i &gt;= cardinal s</code></p></dd></dl><dl><dt>since</dt><dd>2.4</dd></dl></dd></dl><dl><dt class="spec value" id="val-map"><a href="#val-map" class="anchor"></a><code><span class="keyword">val </span>map : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>map f x</code> creates a new set with elements <code>f a0</code>, <code>f a1</code>... <code>f aN</code>, where <code>a0</code>, <code>a1</code>, ..., <code>aN</code> are the elements of <code>x</code>.</p><p>This function places no restriction on <code>f</code>; it can map multiple input values to the same output value, in which case the resulting set will have smaller cardinality than the input. <code>f</code> does not need to be order preserving, although if it is, then <code>Incubator.op_map</code> may be more efficient.</p></dd></dl><dl><dt class="spec value" id="val-filter"><a href="#val-filter" class="anchor"></a><code><span class="keyword">val </span>filter : (<span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>filter p s</code> returns the set of all elements in <code>s</code> that satisfy predicate <code>p</code>.</p></dd></dl><dl><dt class="spec value" id="val-filter_map"><a href="#val-filter_map" class="anchor"></a><code><span class="keyword">val </span>filter_map : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> option) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>filter_map f m</code> combines the features of <code>filter</code> and <code>map</code>. It calls calls <code>f a0</code>, <code>f a1</code>, <code>f aN</code> where <code>a0,a1..an</code> are the elements of <code>m</code> and returns the set of pairs <code>bi</code> such as <code>f ai = Some bi</code> (when <code>f</code> returns <code>None</code>, the corresponding element of <code>m</code> is discarded).</p><p>The resulting map uses the polymorphic <code>compare</code> function to order elements.</p></dd></dl><dl><dt class="spec value" id="val-fold"><a href="#val-fold" class="anchor"></a><code><span class="keyword">val </span>fold : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'b</span></code></dt><dd><p><code>fold f s a</code> computes <code>(f xN ... (f x1 (f x0 a))...)</code>, where <code>x0,x1..xN</code> are the elements of <code>s</code>, in increasing order.</p></dd></dl><dl><dt class="spec value" id="val-exists"><a href="#val-exists" class="anchor"></a><code><span class="keyword">val </span>exists : (<span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>exists p s</code> checks if at least one element of the set satisfies the predicate <code>p</code>.</p></dd></dl><dl><dt class="spec value" id="val-for_all"><a href="#val-for_all" class="anchor"></a><code><span class="keyword">val </span>for_all : (<span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p>Returns whether the given predicate applies to all elements in the set</p></dd></dl><dl><dt class="spec value" id="val-partition"><a href="#val-partition" class="anchor"></a><code><span class="keyword">val </span>partition : (<span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a><span class="keyword"> * </span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p>returns two disjoint subsets, those that satisfy the given predicate and those that don't</p></dd></dl><dl><dt class="spec value" id="val-split"><a href="#val-split" class="anchor"></a><code><span class="keyword">val </span>split : <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a><span class="keyword"> * </span>bool<span class="keyword"> * </span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>split x s</code> returns a triple <code>(l, present, r)</code>, where <code>l</code> is the set of elements of <code>s</code> that are strictly less than <code>x</code>; <code>r</code> is the set of elements of <code>s</code> that are strictly greater than <code>x</code>; <code>present</code> is <code>false</code> if <code>s</code> contains no element equal to <code>x</code>, or <code>true</code> if <code>s</code> contains an element equal to <code>x</code>.</p></dd></dl><dl><dt class="spec value" id="val-split_opt"><a href="#val-split_opt" class="anchor"></a><code><span class="keyword">val </span>split_opt : <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a><span class="keyword"> * </span><span class="type-var">'a</span> option<span class="keyword"> * </span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>split_opt x s</code> returns a triple <code>(l, maybe_v, r)</code>, where <code>l</code> is the set of elements of <code>s</code> that are strictly less than <code>x</code>; <code>r</code> is the set of elements of <code>s</code> that are strictly greater than <code>x</code>; <code>maybe_v</code> is <code>None</code> if <code>s</code> contains no element equal to <code>x</code>, or <code>Some v</code> if <code>s</code> contains an element <code>v</code> that compares equal to <code>x</code>.</p><dl><dt>since</dt><dd>2.2.0</dd></dl></dd></dl><dl><dt class="spec value" id="val-split_lt"><a href="#val-split_lt" class="anchor"></a><code><span class="keyword">val </span>split_lt : <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a><span class="keyword"> * </span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>split_lt x s</code> returns a pair of sets <code>(l, r)</code>, such that <code>l</code> is the subset of <code>s</code> with elements &lt; <code>x</code>; <code>r</code> is the subset of <code>s</code> with elements &gt;= <code>x</code>.</p><dl><dt>since</dt><dd>2.2.0</dd></dl></dd></dl><dl><dt class="spec value" id="val-split_le"><a href="#val-split_le" class="anchor"></a><code><span class="keyword">val </span>split_le : <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a><span class="keyword"> * </span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>split_le x s</code> returns a pair of sets <code>(l, r)</code>, such that <code>l</code> is the subset of <code>s</code> with elements &lt;= <code>x</code>; <code>r</code> is the subset of <code>s</code> with elements &gt; <code>x</code>.</p><dl><dt>since</dt><dd>2.2.0</dd></dl></dd></dl><dl><dt class="spec value" id="val-cardinal"><a href="#val-cardinal" class="anchor"></a><code><span class="keyword">val </span>cardinal : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int</code></dt><dd><p>Return the number of elements of a set.</p></dd></dl><dl><dt class="spec value" id="val-elements"><a href="#val-elements" class="anchor"></a><code><span class="keyword">val </span>elements : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> list</code></dt><dd><p>Return the list of all elements of the given set. The returned list is sorted in increasing order with respect to the ordering of the given set.</p></dd></dl><dl><dt class="spec value" id="val-to_list"><a href="#val-to_list" class="anchor"></a><code><span class="keyword">val </span>to_list : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> list</code></dt><dd><p>Alias for <code>elements</code>.</p><dl><dt>since</dt><dd>2.2.0</dd></dl></dd></dl><dl><dt class="spec value" id="val-to_array"><a href="#val-to_array" class="anchor"></a><code><span class="keyword">val </span>to_array : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> array</code></dt><dd><p>Same as <code>to_list</code> but with an array instead of a list.</p><dl><dt>since</dt><dd>2.4</dd></dl></dd></dl><dl><dt class="spec value" id="val-min_elt"><a href="#val-min_elt" class="anchor"></a><code><span class="keyword">val </span>min_elt : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p>returns the smallest element of the set.</p><dl><dt>raises Not_found</dt><dd><p>if given an empty set.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-pop_min"><a href="#val-pop_min" class="anchor"></a><code><span class="keyword">val </span>pop_min : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span><span class="keyword"> * </span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Returns the smallest element of the given set along with the rest of the set. Semantically equivalent and faster than</p><p><code>let mini = min_elt s in (mini, remove mini s)</code></p><dl><dt>raises Not_found</dt><dd><p>if the set is empty.</p></dd></dl><dl><dt>since</dt><dd>2.4</dd></dl></dd></dl><dl><dt class="spec value" id="val-pop_max"><a href="#val-pop_max" class="anchor"></a><code><span class="keyword">val </span>pop_max : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span><span class="keyword"> * </span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Returns the biggest element of the given set along with the rest of the set. Semantically equivalent and faster than</p><p><code>let maxi = max_elt s in (maxi, remove maxi s)</code></p><dl><dt>raises Not_found</dt><dd><p>if the set is empty.</p></dd></dl><dl><dt>since</dt><dd>2.4</dd></dl></dd></dl><dl><dt class="spec value" id="val-max_elt"><a href="#val-max_elt" class="anchor"></a><code><span class="keyword">val </span>max_elt : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p>returns the largest element of the set.</p><dl><dt>raises Not_found</dt><dd><p>if given an empty set.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-choose"><a href="#val-choose" class="anchor"></a><code><span class="keyword">val </span>choose : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p>returns an arbitrary (but deterministic) element of the given set.</p><dl><dt>raises Not_found</dt><dd><p>if given an empty set.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-any"><a href="#val-any" class="anchor"></a><code><span class="keyword">val </span>any : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p>Return one element of the given set. The difference with choose is that there is no guarantee that equals elements will be picked for equal sets. This merely returns the quickest element to get (O(1)).</p><dl><dt>raises Not_found</dt><dd><p>if the set is empty.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-pop"><a href="#val-pop" class="anchor"></a><code><span class="keyword">val </span>pop : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span><span class="keyword"> * </span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p>returns one element of the set and the set without that element.</p><dl><dt>raises Not_found</dt><dd><p>if given an empty set</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-cartesian_product"><a href="#val-cartesian_product" class="anchor"></a><code><span class="keyword">val </span>cartesian_product : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span><span class="keyword"> * </span><span class="type-var">'b</span>) <a href="index.html#type-t">t</a></code></dt><dd><p>cartesian product of the two sets</p><dl><dt>since</dt><dd>2.2.0</dd></dl></dd></dl><dl><dt class="spec value" id="val-enum"><a href="#val-enum" class="anchor"></a><code><span class="keyword">val </span>enum : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> BatEnum.t</code></dt><dd><p>Return an enumeration of all elements of the given set. The returned enumeration is sorted in increasing order with respect to the ordering of this set.</p></dd></dl><dl><dt class="spec value" id="val-of_enum"><a href="#val-of_enum" class="anchor"></a><code><span class="keyword">val </span>of_enum : <span class="type-var">'a</span> BatEnum.t <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-backwards"><a href="#val-backwards" class="anchor"></a><code><span class="keyword">val </span>backwards : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> BatEnum.t</code></dt><dd><p>Return an enumeration of all elements of the given set. The returned enumeration is sorted in decreasing order with respect to the ordering <code>Pervasives.compare</code>.</p></dd></dl><dl><dt class="spec value" id="val-of_list"><a href="#val-of_list" class="anchor"></a><code><span class="keyword">val </span>of_list : <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p>builds a set from the given list, using the default comparison function</p></dd></dl><dl><dt class="spec value" id="val-of_array"><a href="#val-of_array" class="anchor"></a><code><span class="keyword">val </span>of_array : <span class="type-var">'a</span> array <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p>builds a set from the given array, using the default comparison function</p></dd></dl><section><header><h6 id="boilerplate-code"><a href="#boilerplate-code" class="anchor"></a>Boilerplate code</h6></header></section><section><header><h6 id="printing"><a href="#printing" class="anchor"></a>Printing</h6></header><dl><dt class="spec value" id="val-print"><a href="#val-print" class="anchor"></a><code><span class="keyword">val </span>print : ?&#8288;first:string <span>&#45;&gt;</span> ?&#8288;last:string <span>&#45;&gt;</span> ?&#8288;sep:string <span>&#45;&gt;</span> (<span class="type-var">'a</span> BatInnerIO.output <span>&#45;&gt;</span> <span class="type-var">'c</span> <span>&#45;&gt;</span> unit) <span>&#45;&gt;</span> <span class="type-var">'a</span> BatInnerIO.output <span>&#45;&gt;</span> <span class="type-var">'c</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt></dl></section><section><header><h6 id="infix-operators"><a href="#infix-operators" class="anchor"></a>Infix operators</h6></header><div class="spec module" id="module-Infix"><a href="#module-Infix" class="anchor"></a><code><span class="keyword">module </span><a href="Infix/index.html">Infix</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><dl><dt class="spec module" id="module-Incubator"><a href="#module-Incubator" class="anchor"></a><code><span class="keyword">module </span><a href="Incubator/index.html">Incubator</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd></dd></dl><div class="spec module" id="module-PSet"><a href="#module-PSet" class="anchor"></a><code><span class="keyword">module </span><a href="PSet/index.html">PSet</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div></section></section></div></body></html>