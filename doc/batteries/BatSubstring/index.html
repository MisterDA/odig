<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>BatSubstring (batteries.BatSubstring)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../index.html">batteries</a> &#x00BB; BatSubstring</nav><h1>Module <code>BatSubstring</code></h1></header><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type </span>t</code></dt><dd><p><code>Substring.t</code> is the type of substrings of a basestring, an efficient representation of a piece of a string.</p><p>A substring (s,i,n) is valid if 0 &lt;= i &lt;= i+n &lt;= size s, or equivalently, 0 &lt;= i and 0 &lt;= n and i+n &lt;= size s.</p><p>A valid substring (s, i, n) represents the string s<code>i...i+n-1</code>.</p><p>Invariant in the implementation: Any value of type <code>Substring.t</code> is valid.</p></dd></dl><dl><dt class="spec value" id="val-empty"><a href="#val-empty" class="anchor"></a><code><span class="keyword">val </span>empty : unit <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-to_string"><a href="#val-to_string" class="anchor"></a><code><span class="keyword">val </span>to_string : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> string</code></dt><dd><p><code>string sus</code> is the string s<code>i..i+n-1</code> represented by sus = (s, i, n).</p></dd></dl><dl><dt class="spec value" id="val-of_string"><a href="#val-of_string" class="anchor"></a><code><span class="keyword">val </span>of_string : string <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-make"><a href="#val-make" class="anchor"></a><code><span class="keyword">val </span>make : int <span>&#45;&gt;</span> char <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-create"><a href="#val-create" class="anchor"></a><code><span class="keyword">val </span>create : int <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-equal"><a href="#val-equal" class="anchor"></a><code><span class="keyword">val </span>equal : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p>Substring equality</p><dl><dt>since</dt><dd>2.1</dd></dl></dd></dl><dl><dt class="spec value" id="val-of_input"><a href="#val-of_input" class="anchor"></a><code><span class="keyword">val </span>of_input : BatIO.input <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-substring"><a href="#val-substring" class="anchor"></a><code><span class="keyword">val </span>substring : string <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>substring s o l</code> returns a substring with base-string <code>s</code>, offset <code>o</code> and length <code>l</code>. Arguments are checked for validity</p><p><code>substring s i n</code> creates the substring <code>(s, i, n)</code>, consisting of the substring of s with length n starting at i.</p><dl><dt>raises Inavlid_argument</dt><dd><p>if <code>i&lt;0</code> or <code>n&lt;0</code> or <code>i+n &gt; size s</code>. Equivalent to <code>extract s i (Some n)</code>.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-unsafe_substring"><a href="#val-unsafe_substring" class="anchor"></a><code><span class="keyword">val </span>unsafe_substring : string <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>unsafe_substring</code> behaves like <code>substring</code>, but does not perform any sanity check on the position and length.</p></dd></dl><dl><dt class="spec value" id="val-extract"><a href="#val-extract" class="anchor"></a><code><span class="keyword">val </span>extract : string <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int option <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>extract s i None</code> creates the substring (s, i, size s-i) consisting of the tail of s starting at i.</p><dl><dt>raises Invalid_argument</dt><dd><p>if <code>i&lt;0</code> or <code>i &gt; size s</code>.</p><p><code>extract s i (Some n)</code> creates the substring (s, i, n), consisting of the substring of s with length n starting at i.</p></dd></dl><dl><dt>raises Invalid_argument</dt><dd><p>if <code>i&lt;0</code> or <code>n&lt;0</code> or <code>i+n &gt; size s</code>.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-all"><a href="#val-all" class="anchor"></a><code><span class="keyword">val </span>all : string <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>all s</code> is the substring <code>(s, 0, size s)</code>.</p></dd></dl><dl><dt class="spec value" id="val-base"><a href="#val-base" class="anchor"></a><code><span class="keyword">val </span>base : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> string<span class="keyword"> * </span>int<span class="keyword"> * </span>int</code></dt><dd><p><code>base sus</code> is the concrete triple <code>(s, i, n)</code>, where <code>psus = (s, i,
    n)</code>.</p></dd></dl><dl><dt class="spec value" id="val-is_empty"><a href="#val-is_empty" class="anchor"></a><code><span class="keyword">val </span>is_empty : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>is_empty (s, i, n)</code> true if the substring is empty (that is, <code>n = 0</code>).</p></dd></dl><dl><dt class="spec value" id="val-getc"><a href="#val-getc" class="anchor"></a><code><span class="keyword">val </span>getc : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (char<span class="keyword"> * </span><a href="index.html#type-t">t</a>) option</code></dt><dd><p><code>getc sus</code> returns <code>Some(c, rst)</code> where <code>c</code> is the first character and <code>rst</code> the remainder of <code>sus</code>, if <code>sus</code> is non-empty; otherwise returns <code>None</code>.</p></dd></dl><dl><dt class="spec value" id="val-first"><a href="#val-first" class="anchor"></a><code><span class="keyword">val </span>first : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> char option</code></dt><dd><p><code>first sus</code> returns <code>Some c</code> where <code>c</code> is the first character in <code>sus</code>, if <code>sus</code> is non-empty; otherwise returns <code>None</code>.</p></dd></dl><dl><dt class="spec value" id="val-triml"><a href="#val-triml" class="anchor"></a><code><span class="keyword">val </span>triml : int <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>triml k sus</code> returns sus less its leftmost k characters; or the empty string at the end of sus if it has less than k characters.</p><dl><dt>raises Invalid_argument</dt><dd><p>if <code>k &lt; 0</code>, even in the partial application <code>triml k</code>.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-trimr"><a href="#val-trimr" class="anchor"></a><code><span class="keyword">val </span>trimr : int <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>trimr k sus</code> returns sus less its rightmost k characters; or the empty string at the beginning of sus if it has less than k characters. </p><dl><dt>raises Invalid_argument</dt><dd><p>if <code>k &lt; 0</code>, even in the partial application <code>trimr k</code>.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-get"><a href="#val-get" class="anchor"></a><code><span class="keyword">val </span>get : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> char</code></dt><dd><p><code>get sus k</code> returns the k'th character of the substring; that is, s(i+k) where sus = (s, i, n). </p><dl><dt>raises Invalid_argument</dt><dd><p>if <code>k&lt;0</code> or <code>k&gt;=n</code>.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-size"><a href="#val-size" class="anchor"></a><code><span class="keyword">val </span>size : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int</code></dt><dd><p><code>size (s, i, n)</code> returns the size of the substring, that is, <code>n</code>.</p></dd></dl><dl><dt class="spec value" id="val-length"><a href="#val-length" class="anchor"></a><code><span class="keyword">val </span>length : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int</code></dt><dd><p><code>size (s, i, n)</code> returns the size of the substring, that is, <code>n</code>.</p><p>Equivalent to <a href="index.html#val-size"><code>size</code></a>.</p></dd></dl><dl><dt class="spec value" id="val-slice"><a href="#val-slice" class="anchor"></a><code><span class="keyword">val </span>slice : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int option <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>slice sus i' None</code> returns the substring <code>(s, i+i', n-i')</code>, where <code>sus = (s, i, n)</code>.</p><dl><dt>raises Invalid_argument</dt><dd><p>if <code>i' &lt; 0</code> or <code>i' &gt; n</code>.</p><p><code>slice sus i' (Some n')</code> returns the substring <code>(s, i+i', n')</code>, where <code>sus</code> = <code>(s, i, n)</code>. </p><p>@raise Invalid_argument</p><p>if <code>i' &lt; 0</code> or <code>n' &lt; 0</code> or <code>i'+n' &gt;= n</code>.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-concat"><a href="#val-concat" class="anchor"></a><code><span class="keyword">val </span>concat : <a href="index.html#type-t">t</a> list <span>&#45;&gt;</span> string</code></dt><dd><p><code>slice sus i' None</code> returns the substring <code>(s, i+i', n-i')</code>, where <code>sus = (s, i, n)</code>.</p><dl><dt>raises Invalid_argument</dt><dd><p>if <code>i' &lt; 0</code> or <code>i' &gt; n</code>.</p><p><code>slice sus i' (Some n')</code> returns the substring <code>(s, i+i', n')</code>, where <code>sus</code> = <code>(s, i, n)</code>. </p><p>@raise Invalid_argument</p><p>if <code>i' &lt; 0</code> or <code>n' &lt; 0</code> or <code>i'+n' &gt;= n</code>.</p></dd></dl><p><code>concat suss</code> returns a string consisting of the concatenation of the substrings. Equivalent to <code>String.concat (List.map to_string
    suss)</code>.</p></dd></dl><dl><dt class="spec value" id="val-explode"><a href="#val-explode" class="anchor"></a><code><span class="keyword">val </span>explode : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> char list</code></dt><dd><p><code>concat suss</code> returns a string consisting of the concatenation of the substrings. Equivalent to <code>String.concat (List.map to_string
    suss)</code>.</p><p><code>explode sus</code> returns the list of characters of sus, that is, <code>s(i), s(i+1), ..., s(i+n-1)</code> where <code>sus = (s, i, n)</code>. Equivalent to <code>String.explode (to_string ss)</code>.</p></dd></dl><dl><dt class="spec value" id="val-is_prefix"><a href="#val-is_prefix" class="anchor"></a><code><span class="keyword">val </span>is_prefix : string <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>explode sus</code> returns the list of characters of sus, that is, <code>s(i), s(i+1), ..., s(i+n-1)</code> where <code>sus = (s, i, n)</code>. Equivalent to <code>String.explode (to_string ss)</code>.</p><p><code>is_prefix s1 s2</code> is true if <code>s1</code> is a prefix of <code>s2</code>. That is, if there exists a string <code>t</code> such that string <code>s1 ^ t = to_string s2</code>.</p></dd></dl><dl><dt class="spec value" id="val-compare"><a href="#val-compare" class="anchor"></a><code><span class="keyword">val </span>compare : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int</code></dt><dd><p><code>compare sus1 sus2</code> performs lexicographic comparison, using the standard ordering Char.compare on the characters.p Equivalent to, but more efficient than, <code>String.compare (to_string sus1)
    (to_string sus2)</code>.</p></dd></dl><dl><dt class="spec value" id="val-index"><a href="#val-index" class="anchor"></a><code><span class="keyword">val </span>index : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> char <span>&#45;&gt;</span> int</code></dt><dd><p><code>index sus c</code> returns the index of the first occurrence of <code>c</code> in <code>sus</code> or</p><dl><dt>raises Not_found</dt><dd><p>otherwise.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-index_from"><a href="#val-index_from" class="anchor"></a><code><span class="keyword">val </span>index_from : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> char <span>&#45;&gt;</span> int</code></dt><dd><p><code>index_from sus i c</code> returns the index of the first occurrence of <code>c</code> in <code>sus</code> after the index <code>i</code> or </p><dl><dt>raises Not_found</dt><dd><p>otherwise. If <code>i</code> is beyond the range of <code>sus</code>, </p><p>@raise Invalid_argument.</p><p>It is equivalent to <code>i + index (triml i sus) c</code>.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-rindex"><a href="#val-rindex" class="anchor"></a><code><span class="keyword">val </span>rindex : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> char <span>&#45;&gt;</span> int</code></dt><dd><p><code>rindex sus c</code> returns the index of the last occurrence of <code>c</code> in <code>sus</code> or</p><dl><dt>raises Not_found</dt><dd><p>otherwise.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-rindex_from"><a href="#val-rindex_from" class="anchor"></a><code><span class="keyword">val </span>rindex_from : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> char <span>&#45;&gt;</span> int</code></dt><dd><p><code>index_from sus i c</code> returns the index of the last occurrence of <code>c</code> in <code>sus</code> before the index <code>i</code> or </p><dl><dt>raises Not_found</dt><dd><p>otherwise. If <code>i</code> is beyond the range of <code>sus</code>, </p><p>@raise Invalid_argument.</p><p>It is equivalent to <code>rindex (trimr i sus) c</code>.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-contains"><a href="#val-contains" class="anchor"></a><code><span class="keyword">val </span>contains : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> char <span>&#45;&gt;</span> bool</code></dt><dd><p><code>contains s c</code> tests if character <code>c</code> appears in the substring <code>s</code>.</p><dl><dt>since</dt><dd>2.1</dd></dl></dd></dl><dl><dt class="spec value" id="val-dropl"><a href="#val-dropl" class="anchor"></a><code><span class="keyword">val </span>dropl : (char <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>dropl p sus</code> drops the longest prefix (left substring) of <code>sus</code> all of whose characters satisfy predicate <code>p</code>. If all characters do, it returns the empty substring <code>(s, i+n, 0)</code> where <code>sus = (s, i, n)</code>.</p></dd></dl><dl><dt class="spec value" id="val-dropr"><a href="#val-dropr" class="anchor"></a><code><span class="keyword">val </span>dropr : (char <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>dropr p sus</code> drops the longest suffix (right substring) of sus all of whose characters satisfy predicate <code>p</code>. If all characters do, it returns the empty substring <code>(s, i, 0)</code> where <code>sus = (s, i, n)</code>.</p></dd></dl><dl><dt class="spec value" id="val-takel"><a href="#val-takel" class="anchor"></a><code><span class="keyword">val </span>takel : (char <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>takel p sus</code> returns the longest prefix (left substring) of <code>sus</code> all of whose characters satisfy predicate <code>p</code>. That is, if the left-most character does not satisfy p, returns the empty <code>(s, i, 0)</code> where <code>sus = (s, i, n)</code>.</p></dd></dl><dl><dt class="spec value" id="val-taker"><a href="#val-taker" class="anchor"></a><code><span class="keyword">val </span>taker : (char <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>taker p sus</code> returns the longest suffix (right substring) of <code>sus</code> all of whose characters satisfy predicate <code>p</code>. That is, if the right-most character satisfies <code>p</code>, returns the empty <code>(s, i+n, 0)</code> where <code>sus = (s, i, n)</code>.</p><p>Let <code>p</code> be a predicate and xxxxfyyyyfzzzz a string where all characters in xxxx and zzzz satisfy <code>p</code>, and f a character not satisfying <code>p</code>. Then</p><p>sus = xxxxfyyyyfzzzz sus = xxxxzzzz ------------------------------------------------------ dropl p sus = fyyyyfzzzz dropr p sus = xxxxfyyyyf takel p sus = xxxx xxxxzzzz taker p sus = zzzz xxxxzzzz</p><p>It also holds that <code>concat (takel p sus) (dropl p sus) = string sus</code> <code>concat (dropr p sus) (taker p sus) = string sus</code></p></dd></dl><dl><dt class="spec value" id="val-splitl"><a href="#val-splitl" class="anchor"></a><code><span class="keyword">val </span>splitl : (char <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a><span class="keyword"> * </span><a href="index.html#type-t">t</a></code></dt><dd><p><code>splitl p sus</code> splits <code>sus</code> into a pair <code>(sus1, sus2)</code> of substrings where <code>sus1</code> is the longest prefix (left substring) all of whose characters satisfy <code>p</code>, and <code>sus2</code> is the rest. That is, <code>sus2</code> begins with the leftmost character not satisfying <code>p</code>. Disregarding sideeffects, we have: <code>splitl p sus = (takel p sus,
    dropl p sus)</code>.</p></dd></dl><dl><dt class="spec value" id="val-splitr"><a href="#val-splitr" class="anchor"></a><code><span class="keyword">val </span>splitr : (char <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a><span class="keyword"> * </span><a href="index.html#type-t">t</a></code></dt><dd><p><code>splitr p sus</code> splits <code>sus</code> into a pair <code>(sus1, sus2)</code> of substrings where <code>sus2</code> is the longest suffix (right substring) all of whose characters satisfy <code>p</code>, and <code>sus1</code> is the rest. That is, <code>sus1</code> ends with the rightmost character not satisfying <code>p</code>. Disregarding sideeffects, we have: <code>splitr p sus = (dropr p sus,
    taker p sus)</code></p></dd></dl><dl><dt class="spec value" id="val-split_at"><a href="#val-split_at" class="anchor"></a><code><span class="keyword">val </span>split_at : int <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a><span class="keyword"> * </span><a href="index.html#type-t">t</a></code></dt><dd><p><code>split_at sus k</code> returns the pair <code>(sus1, sus2)</code> of substrings, where <code>sus1</code> contains the first <code>k</code> characters of <code>sus</code>, and <code>sus2</code> contains the rest. </p><dl><dt>raises Invalid_argument</dt><dd><p>if <code>k &lt; 0</code> or <code>k &gt; size sus</code>.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-span"><a href="#val-span" class="anchor"></a><code><span class="keyword">val </span>span : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>span sus1 sus2</code> returns a substring spanning from the start of <code>sus1</code> to the end of <code>sus2</code>, provided this is well-defined: <code>sus1</code> and <code>sus2</code> must have the same underlying string, and the start of <code>sus1</code> must not be to the right of the end of <code>sus2</code>; otherwise</p><dl><dt>raises Invalid_argument.</dt><dd><p>More precisely, if <code>base sus1 = (s,i,n)</code> and <code>base sus2 =
    (s',i',n')</code> and <code>s = s'</code> and <code>i &lt;= i'+n'</code>, then <code>base (span sus1
    sus2) = (s, i, i'+n'-i)</code>. This may be used to compute <code>span</code>, <code>union</code>, and <code>intersection</code>.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-translate"><a href="#val-translate" class="anchor"></a><code><span class="keyword">val </span>translate : (char <span>&#45;&gt;</span> char) <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> string</code></dt><dd><p><code>translate f sus</code> applies <code>f</code> to every character of <code>sus</code>, from left to right, and returns the concatenation of the results. Equivalent to <code>String.of_list (List.map f (explode sus))</code>.</p></dd></dl><dl><dt class="spec value" id="val-tokens"><a href="#val-tokens" class="anchor"></a><code><span class="keyword">val </span>tokens : (char <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> list</code></dt><dd><p><code>tokens p sus</code> returns the list of tokens in <code>sus</code>, from left to right, where a token is a non-empty maximal substring of <code>sus</code> not containing any delimiter, and a delimiter is a character satisfying <code>p</code>.</p></dd></dl><dl><dt class="spec value" id="val-fields"><a href="#val-fields" class="anchor"></a><code><span class="keyword">val </span>fields : (char <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> list</code></dt><dd><p><code>fields p sus</code> returns the list of fields in <code>sus</code>, from left to right, where a field is a (possibly empty) maximal substring of <code>sus</code> not containing any delimiter, and a delimiter is a character satisfying <code>p</code>.</p><p>Two tokens may be separated by more than one delimiter, whereas two fields are separated by exactly one delimiter. If the only delimiter is the character <code>'|'</code>, then &quot;abc||def&quot; contains two tokens: &quot;abc&quot; and &quot;def&quot; &quot;abc||def&quot; contains three fields: &quot;abc&quot; and &quot;&quot; and &quot;def&quot;</p></dd></dl><dl><dt class="spec value" id="val-fold_left"><a href="#val-fold_left" class="anchor"></a><code><span class="keyword">val </span>fold_left : (<span class="type-var">'a</span> <span>&#45;&gt;</span> char <span>&#45;&gt;</span> <span class="type-var">'a</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p><code>fold_left f e sus</code> folds <code>f</code> over <code>sus</code> from left to right. That is, evaluates <code>f s.[i+n-1] (f ... (f s.[i+1] (f s.[i] e)) ...)</code> tail-recursively, where <code>sus = (s, i, n)</code>. Equivalent to <code>List.fold_left f e (explode sus)</code>.</p></dd></dl><dl><dt class="spec value" id="val-fold_lefti"><a href="#val-fold_lefti" class="anchor"></a><code><span class="keyword">val </span>fold_lefti : (<span class="type-var">'a</span> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> char <span>&#45;&gt;</span> <span class="type-var">'a</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p>As <code>fold_left</code>, but with the index of the element as additional argument</p><dl><dt>since</dt><dd>2.3.0</dd></dl></dd></dl><dl><dt class="spec value" id="val-fold_right"><a href="#val-fold_right" class="anchor"></a><code><span class="keyword">val </span>fold_right : (char <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span>) <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p><code>fold_right f e sus</code> folds <code>f</code> over <code>sus</code> from right to left. That is, evaluates <code>f s.[i] (f s.[i+1] (f ... (f s.[i+n-1] e) ...))</code> tail-recursively, where <code>sus = (s, i, n)</code>. Equivalent to <code>List.fold_right f e (explode sus)</code>.</p></dd></dl><dl><dt class="spec value" id="val-fold_righti"><a href="#val-fold_righti" class="anchor"></a><code><span class="keyword">val </span>fold_righti : (int <span>&#45;&gt;</span> char <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span>) <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p>As <code>fold_right</code>, but with the index of the element as additional argument</p><dl><dt>since</dt><dd>2.3.0</dd></dl></dd></dl><dl><dt class="spec value" id="val-iter"><a href="#val-iter" class="anchor"></a><code><span class="keyword">val </span>iter : (char <span>&#45;&gt;</span> unit) <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>iter f sus</code> applies <code>f</code> to all characters of <code>sus</code>, from left to right. Equivalent to <code>List.iter f (explode sus)</code>.</p></dd></dl><dl><dt class="spec value" id="val-iteri"><a href="#val-iteri" class="anchor"></a><code><span class="keyword">val </span>iteri : (int <span>&#45;&gt;</span> char <span>&#45;&gt;</span> unit) <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Same as <a href="index.html#val-iter"><code>iter</code></a>, but the function is applied to the index of the element as first argument (counting from 0), and the character itself as second argument.</p><dl><dt>since</dt><dd>2.1</dd></dl></dd></dl><dl><dt class="spec value" id="val-trim"><a href="#val-trim" class="anchor"></a><code><span class="keyword">val </span>trim : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>removes whitespace from left and right ends of input</p></dd></dl><dl><dt class="spec value" id="val-split_on_char"><a href="#val-split_on_char" class="anchor"></a><code><span class="keyword">val </span>split_on_char : char <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> list</code></dt><dd><p><code>split_on_char c ss</code> returns substrings of input <code>ss</code> as divided by <code>c</code></p></dd></dl><dl><dt class="spec value" id="val-split_on_pipe"><a href="#val-split_on_pipe" class="anchor"></a><code><span class="keyword">val </span>split_on_pipe : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> list</code></dt><dt class="spec value" id="val-split_on_dot"><a href="#val-split_on_dot" class="anchor"></a><code><span class="keyword">val </span>split_on_dot : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> list</code></dt><dt class="spec value" id="val-split_on_comma"><a href="#val-split_on_comma" class="anchor"></a><code><span class="keyword">val </span>split_on_comma : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> list</code></dt><dt class="spec value" id="val-split_on_slash"><a href="#val-split_on_slash" class="anchor"></a><code><span class="keyword">val </span>split_on_slash : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> list</code></dt><dt class="spec value" id="val-enum"><a href="#val-enum" class="anchor"></a><code><span class="keyword">val </span>enum : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> char BatEnum.t</code></dt><dd><p><code>enum ss</code> returns an enumeration of the characters represented by ss. It does no copying so beweare of mutating the original string.</p><dl><dt>since</dt><dd>2.1</dd></dl></dd></dl><dl><dt class="spec value" id="val-print"><a href="#val-print" class="anchor"></a><code><span class="keyword">val </span>print : <span class="type-var">'a</span> BatIO.output <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>print oc ss</code> prints <code>ss</code> to the output channel <code>oc</code></p></dd></dl></div></body></html>