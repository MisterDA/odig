<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>BatVect (batteries.BatVect)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../index.html">batteries</a> &#x00BB; BatVect</nav><h1>Module <code>BatVect</code></h1><p>Extensible vectors with constant-time append/prepend.</p><p>This module implements extensible arrays which work very much like ropes as described in <b>Boehm, H., Atkinson, R., and Plass, M.</b> 1995. <em>Ropes: an alternative to strings.</em> Softw. Pract. Exper. 25, 12 (Dec. 1995), 1315-1330.</p><p>These vectors have some interesting properties:</p><ul><li>lower space overhead than other structures based on balanced trees such as Vec. The overhead can be adjusted, allowing to make get faster at the expense of set and viceversa.</li><li>appending or prepending a small vector to an arbitrarily large one in amortized constant time</li><li>concat, substring, insert, remove operations in amortized logarithmic time</li><li>access to and modification of vectors in logarithmic time</li></ul><h6 id="functional-nature-and-persistence"><a href="#functional-nature-and-persistence" class="anchor"></a>Functional nature and persistence</h6><p>All operations but <code>destructive_set</code> (provided for efficient ephemeral usage) are non-destructive: the original vect is never modified. When a new vect is returned as the result of an operation, it will share as much data as possible with its &quot;parent&quot;. For instance, if a vect of length <code>n</code> undergoes <code>m</code> operations (assume <code>n &gt;&gt; m</code>) like set, append or prepend, the modified vector will only require <code>O(m)</code> space in addition to that taken by the original vect.</p><p>However, Vect is an amortized data structure, and its use in a persistent setting can easily degrade its amortized time bounds. It is thus mainly intended to be used ephemerally. In some cases, it is possible to use Vect persistently with the same amortized bounds by explicitly rebalancing vects to be reused using <code>balance</code>. Special care must be taken to avoid calling <code>balance</code> too frequently; in the limit, calling <code>balance</code> after each modification would defeat the purpose of amortization.</p><p>This module is not thread-safe.</p><dl><dt>author</dt><dd>Mauricio Fernandez</dd></dl><nav class="toc"><ul><li><a href="#creation-and-conversions">Creation and conversions</a></li><li><a href="#properties">Properties</a></li><li><a href="#operations">Operations</a></li><li><a href="#conversion">Conversion</a></li><li><a href="#iteration-and-higher-order-functions">Iteration and higher-order functions</a></li><li><a href="#predicates">Predicates</a></li><li><a href="#convenience-functions">Convenience Functions</a></li><li><a href="#boilerplate-code">Boilerplate code</a></li><li><a href="#override-modules">Override modules</a></li><li><a href="#functorial-interface">Functorial interface</a></li></ul></nav></header><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type </span>'a t</code></dt><dd><p>The type of a polymorphic vect.</p></dd></dl><dl><dt class="spec exception" id="exception-Out_of_bounds"><a href="#exception-Out_of_bounds" class="anchor"></a><code><span class="keyword">exception </span></code><code><span class="exception">Out_of_bounds</span></code></dt><dd><p>Raised when an operation violates the bounds of the vect.</p></dd></dl><dl><dt class="spec value" id="val-max_length"><a href="#val-max_length" class="anchor"></a><code><span class="keyword">val </span>max_length : int</code></dt><dd><p>Maximum length of the vect.</p></dd></dl><section><header><h6 id="creation-and-conversions"><a href="#creation-and-conversions" class="anchor"></a>Creation and conversions</h6></header><dl><dt class="spec value" id="val-empty"><a href="#val-empty" class="anchor"></a><code><span class="keyword">val </span>empty : <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p>The empty vect.</p></dd></dl><dl><dt class="spec value" id="val-singleton"><a href="#val-singleton" class="anchor"></a><code><span class="keyword">val </span>singleton : <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Returns a vect of length 1 holding only the given element.</p></dd></dl><dl><dt class="spec value" id="val-of_array"><a href="#val-of_array" class="anchor"></a><code><span class="keyword">val </span>of_array : <span class="type-var">'a</span> array <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>of_array s</code> returns a vect corresponding to the array <code>s</code>. Operates in <code>O(n)</code> time.</p></dd></dl><dl><dt class="spec value" id="val-to_array"><a href="#val-to_array" class="anchor"></a><code><span class="keyword">val </span>to_array : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> array</code></dt><dd><p><code>to_array r</code> returns an array corresponding to the vect <code>r</code>.</p></dd></dl><dl><dt class="spec value" id="val-to_list"><a href="#val-to_list" class="anchor"></a><code><span class="keyword">val </span>to_list : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> list</code></dt><dd><p>Returns a list with the elements contained in the vect.</p></dd></dl><dl><dt class="spec value" id="val-of_list"><a href="#val-of_list" class="anchor"></a><code><span class="keyword">val </span>of_list : <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-make"><a href="#val-make" class="anchor"></a><code><span class="keyword">val </span>make : int <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>make i c</code> returns a vect of length <code>i</code> whose elements are all equal to <code>c</code>; it is similar to Array.make</p></dd></dl><dl><dt class="spec value" id="val-init"><a href="#val-init" class="anchor"></a><code><span class="keyword">val </span>init : int <span>&#45;&gt;</span> (int <span>&#45;&gt;</span> <span class="type-var">'a</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>init n f</code> returns a fresh vect of length <code>n</code>, with element number <code>i</code> initialized to the result of <code>f i</code>. In other terms, <code>init n f</code> tabulates the results of <code>f</code> applied to the integers <code>0</code> to <code>n-1</code>.</p><dl><dt>raises Invalid_argument</dt><dd><p>if <code>n &lt; 0</code> or <code>n &gt; max_length</code>.</p></dd></dl></dd></dl></section><section><header><h6 id="properties"><a href="#properties" class="anchor"></a>Properties</h6></header><dl><dt class="spec value" id="val-is_empty"><a href="#val-is_empty" class="anchor"></a><code><span class="keyword">val </span>is_empty : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p>Returns whether the vect is empty or not.</p></dd></dl><dl><dt class="spec value" id="val-height"><a href="#val-height" class="anchor"></a><code><span class="keyword">val </span>height : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int</code></dt><dd><p>Returns the height (depth) of the vect.</p></dd></dl><dl><dt class="spec value" id="val-length"><a href="#val-length" class="anchor"></a><code><span class="keyword">val </span>length : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int</code></dt><dd><p>Returns the length of the vect (<code>O(1)</code>).</p></dd></dl></section><section><header><h6 id="operations"><a href="#operations" class="anchor"></a>Operations</h6></header><dl><dt class="spec value" id="val-balance"><a href="#val-balance" class="anchor"></a><code><span class="keyword">val </span>balance : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>balance r</code> returns a balanced copy of the <code>r</code> vect. Note that vects are automatically rebalanced when their height exceeds a given threshold, but <code>balance</code> allows to invoke that operation explicity.</p></dd></dl><dl><dt class="spec value" id="val-concat"><a href="#val-concat" class="anchor"></a><code><span class="keyword">val </span>concat : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>concat r u</code> concatenates the <code>r</code> and <code>u</code> vects. In general, it operates in <code>O(log(min n1 n2))</code> amortized time. Small vects are treated specially and can be appended/prepended in amortized <code>O(1)</code> time.</p></dd></dl><dl><dt class="spec value" id="val-append"><a href="#val-append" class="anchor"></a><code><span class="keyword">val </span>append : <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>append c r</code> returns a new vect with the <code>c</code> element at the end in amortized <code>O(1)</code> time.</p></dd></dl><dl><dt class="spec value" id="val-prepend"><a href="#val-prepend" class="anchor"></a><code><span class="keyword">val </span>prepend : <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>prepend c r</code> returns a new vect with the <code>c</code> character at the beginning in amortized <code>O(1)</code> time.</p></dd></dl><dl><dt class="spec value" id="val-get"><a href="#val-get" class="anchor"></a><code><span class="keyword">val </span>get : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p><code>get v n</code> returns the (n+1)th element from the vect <code>v</code>; i.e. <code>get v 0</code> returns the first element. Operates in worst-case <code>O(log size)</code> time.</p><dl><dt>raises Out_of_bounds</dt><dd><p>if a character out of bounds is requested.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-at"><a href="#val-at" class="anchor"></a><code><span class="keyword">val </span>at : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p>as <code>get</code></p></dd></dl><dl><dt class="spec value" id="val-set"><a href="#val-set" class="anchor"></a><code><span class="keyword">val </span>set : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>set v n c</code> returns a copy of the <code>v</code> vect where the (n+1)th element (see also <code>get</code>) has been set to <code>c</code>. Operates in worst-case <code>O(log size)</code> time.</p></dd></dl><dl><dt class="spec value" id="val-modify"><a href="#val-modify" class="anchor"></a><code><span class="keyword">val </span>modify : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>modify v n f</code> is equivalent to <code>set v n (f (get v n))</code>, but more efficient. Operates in worst-case <code>O(log size)</code> time.</p></dd></dl><dl><dt class="spec value" id="val-destructive_set"><a href="#val-destructive_set" class="anchor"></a><code><span class="keyword">val </span>destructive_set : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>destructive_set v n c</code> sets the element of index <code>n</code> in the <code>v</code> vect to <code>c</code>. <b>This operation is destructive</b>, and will also affect vects sharing the modified leaf with <code>v</code>. Use with caution.</p></dd></dl><dl><dt class="spec value" id="val-sub"><a href="#val-sub" class="anchor"></a><code><span class="keyword">val </span>sub : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>sub m n r</code> returns a sub-vect of <code>r</code> containing all the elements whose indexes range from <code>m</code> to <code>m + n - 1</code> (included).</p><dl><dt>raises Out_of_bounds</dt><dd><p>in the same cases as Array.sub. Operates in worst-case <code>O(log size)</code> time.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-insert"><a href="#val-insert" class="anchor"></a><code><span class="keyword">val </span>insert : int <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>insert n r u</code> returns a copy of the <code>u</code> vect where <code>r</code> has been inserted between the elements with index <code>n - 1</code> and <code>n</code> in the original vect; after insertion, the first element of <code>r</code> (if any) is at index <code>n</code>. The length of the new vect is <code>length u + length r</code>. Operates in amortized <code>O(log(size r) + log(size u))</code> time.</p></dd></dl><dl><dt class="spec value" id="val-remove"><a href="#val-remove" class="anchor"></a><code><span class="keyword">val </span>remove : int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>remove m n r</code> returns the vect resulting from deleting the elements with indexes ranging from <code>m</code> to <code>m + n - 1</code> (included) from the original vect <code>r</code>. The length of the new vect is <code>length r - n</code>. Operates in amortized <code>O(log(size r))</code> time.</p></dd></dl></section><section><header><h6 id="conversion"><a href="#conversion" class="anchor"></a>Conversion</h6></header><dl><dt class="spec value" id="val-enum"><a href="#val-enum" class="anchor"></a><code><span class="keyword">val </span>enum : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> BatEnum.t</code></dt><dd><p>Returns an enumeration of the elements of the vector. Behavior of the enumeration is undefined if the contents of the vector changes afterwards.</p></dd></dl><dl><dt class="spec value" id="val-of_enum"><a href="#val-of_enum" class="anchor"></a><code><span class="keyword">val </span>of_enum : <span class="type-var">'a</span> BatEnum.t <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Build a vector from an enumeration.</p></dd></dl><dl><dt class="spec value" id="val-backwards"><a href="#val-backwards" class="anchor"></a><code><span class="keyword">val </span>backwards : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> BatEnum.t</code></dt><dd><p>Returns an enumeration of the elements of a vector, from last to first. Behavior of the enumeration is undefined if the contents of the vector changes afterwards.</p></dd></dl><dl><dt class="spec value" id="val-of_backwards"><a href="#val-of_backwards" class="anchor"></a><code><span class="keyword">val </span>of_backwards : <span class="type-var">'a</span> BatEnum.t <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Build a vector from an enumeration, from last to first.</p></dd></dl></section><section><header><h6 id="iteration-and-higher-order-functions"><a href="#iteration-and-higher-order-functions" class="anchor"></a>Iteration and higher-order functions</h6></header><dl><dt class="spec value" id="val-iter"><a href="#val-iter" class="anchor"></a><code><span class="keyword">val </span>iter : (<span class="type-var">'a</span> <span>&#45;&gt;</span> unit) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>iter f r</code> applies <code>f</code> to all the elements in the <code>r</code> vect, in order.</p></dd></dl><dl><dt class="spec value" id="val-iteri"><a href="#val-iteri" class="anchor"></a><code><span class="keyword">val </span>iteri : (int <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> unit) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Operates like iter, but also passes the index of the character to the given function.</p></dd></dl><dl><dt class="spec value" id="val-rangeiter"><a href="#val-rangeiter" class="anchor"></a><code><span class="keyword">val </span>rangeiter : (<span class="type-var">'a</span> <span>&#45;&gt;</span> unit) <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>rangeiter f m n r</code> applies <code>f</code> to all the elements whose indices <code>k</code> satisfy <code>m</code> &lt;= <code>k</code> &lt; <code>m + n</code>. It is thus equivalent to <code>iter f (sub m n r)</code>, but does not create an intermediary vect. <code>rangeiter</code> operates in worst-case <code>O(n + log m)</code> time, which improves on the <code>O(n log m)</code> bound from an explicit loop using <code>get</code>.</p><dl><dt>raises Out_of_bounds</dt><dd><p>in the same cases as <code>sub</code>.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-fold_left"><a href="#val-fold_left" class="anchor"></a><code><span class="keyword">val </span>fold_left : (<span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>) <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'b</span></code></dt><dd><p><code>fold_left f a r</code> computes <code> f (... (f (f a r0) r1)...) rN-1 </code> where <code>rn = Vect.get n r </code> and <code>N = length r</code>.</p></dd></dl><dl><dt class="spec value" id="val-fold"><a href="#val-fold" class="anchor"></a><code><span class="keyword">val </span>fold : (<span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>) <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'b</span></code></dt><dd><p>An alias for <a href="index.html#val-fold_left"><code>fold_left</code></a></p></dd></dl><dl><dt class="spec value" id="val-reduce"><a href="#val-reduce" class="anchor"></a><code><span class="keyword">val </span>reduce : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p>as <a href="index.html#val-fold_left"><code>fold_left</code></a>, but no initial value - just applies reducing function to elements from left to right.</p></dd></dl><dl><dt class="spec value" id="val-fold_right"><a href="#val-fold_right" class="anchor"></a><code><span class="keyword">val </span>fold_right : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'b</span></code></dt><dd><p><code>fold_right f r a</code> computes <code> f (r0 ... (f rN-2 (f rN-1 a)) ...)) </code> where <code>rn = Vect.get n r </code> and <code>N = length r</code>.</p></dd></dl><dl><dt class="spec value" id="val-foldi"><a href="#val-foldi" class="anchor"></a><code><span class="keyword">val </span>foldi : (int <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>) <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'b</span></code></dt><dd><p>As <a href="index.html#val-fold"><code>fold</code></a>, but with the position of each value passed to the folding function</p></dd></dl><dl><dt class="spec value" id="val-map"><a href="#val-map" class="anchor"></a><code><span class="keyword">val </span>map : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>map f v</code> returns a vect isomorphic to <code>v</code> where each element of index <code>i</code> equals <code>f (get v i)</code>. Therefore, the height of the returned vect is the same as that of the original one. Operates in <code>O(n)</code> time.</p></dd></dl><dl><dt class="spec value" id="val-mapi"><a href="#val-mapi" class="anchor"></a><code><span class="keyword">val </span>mapi : (int <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Same as <a href="index.html#val-map"><code>map</code></a>, but the function is applied to the index of the element as first argument, and the element itself as second argument.</p></dd></dl></section><section><header><h6 id="predicates"><a href="#predicates" class="anchor"></a>Predicates</h6></header><dl><dt class="spec value" id="val-for_all"><a href="#val-for_all" class="anchor"></a><code><span class="keyword">val </span>for_all : (<span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>for_all p [a0; a1; ...; an]</code> checks if all elements of the vect satisfy the predicate <code>p</code>. That is, it returns <code> (p a0) &amp;&amp; (p a1) &amp;&amp; ... &amp;&amp; (p an)</code>.</p></dd></dl><dl><dt class="spec value" id="val-exists"><a href="#val-exists" class="anchor"></a><code><span class="keyword">val </span>exists : (<span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>exists p [a0; a1; ...; an]</code> checks if at least one element of the vect satisfies the predicate <code>p</code>. That is, it returns <code> (p a0) || (p a1) || ... || (p an)</code>.</p></dd></dl><dl><dt class="spec value" id="val-find"><a href="#val-find" class="anchor"></a><code><span class="keyword">val </span>find : (<span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p><code>find p v</code> returns the first element of vect <code>v</code> that satisfies the predicate <code>p</code>.</p><dl><dt>raises Not_found</dt><dd><p>if there is no value that satisfies <code>p</code> in the vect <code>v</code>.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-find_opt"><a href="#val-find_opt" class="anchor"></a><code><span class="keyword">val </span>find_opt : (<span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> option</code></dt><dd><p><code>find_opt p v</code> returns <code>Some a</code>, where <code>a</code> is the first element of vect <code>v</code> that satisfies the predicate <code>p</code>, or <code>None</code> if no such element exists.</p><dl><dt>since</dt><dd>2.7.0</dd></dl></dd></dl><dl><dt class="spec value" id="val-mem"><a href="#val-mem" class="anchor"></a><code><span class="keyword">val </span>mem : <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>mem a v</code> is true if and only if <code>a</code> is equal to an element of <code>v</code>.</p></dd></dl><dl><dt class="spec value" id="val-memq"><a href="#val-memq" class="anchor"></a><code><span class="keyword">val </span>memq : <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p>Same as <span class="xref-unresolved" title="unresolved reference to &quot;Vect.mem&quot;"><code>Vect</code>.mem</span> but uses physical equality instead of structural equality to compare vect elements.</p></dd></dl><dl><dt class="spec value" id="val-findi"><a href="#val-findi" class="anchor"></a><code><span class="keyword">val </span>findi : (<span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int</code></dt><dd><p><code>findi p v</code> returns the index of the first element of vect <code>v</code> that satisfies the predicate <code>p</code>.</p><dl><dt>raises Not_found</dt><dd><p>if there is no value that satisfies <code>p</code> in the vect <code>v</code>.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-filter"><a href="#val-filter" class="anchor"></a><code><span class="keyword">val </span>filter : (<span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>filter f v</code> returns a vect with the elements <code>a</code> from <code>v</code> such that <code>f a</code> returns <code>true</code>. Operates in <code>O(n)</code> time.</p></dd></dl><dl><dt class="spec value" id="val-filter_map"><a href="#val-filter_map" class="anchor"></a><code><span class="keyword">val </span>filter_map : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> option) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>filter_map f v</code> returns a vect consisting of all elements <code>b</code> such that <code>f a</code> returns <code>Some b</code> , where <code>a</code> is an element of <code>v</code>.</p></dd></dl><dl><dt class="spec value" id="val-find_all"><a href="#val-find_all" class="anchor"></a><code><span class="keyword">val </span>find_all : (<span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>find_all</code> is another name for <span class="xref-unresolved" title="unresolved reference to &quot;Vect.filter&quot;"><code>Vect</code>.filter</span>.</p></dd></dl><dl><dt class="spec value" id="val-partition"><a href="#val-partition" class="anchor"></a><code><span class="keyword">val </span>partition : (<span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a><span class="keyword"> * </span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>partition p v</code> returns a pair of vects <code>(v1, v2)</code>, where <code>v1</code> is the vect of all the elements of <code>v</code> that satisfy the predicate <code>p</code>, and <code>v2</code> is the vect of all the elements of <code>v</code> that do not satisfy <code>p</code>. The order of the elements in the input vect is preserved.</p></dd></dl></section><section><header><h6 id="convenience-functions"><a href="#convenience-functions" class="anchor"></a>Convenience Functions</h6></header><dl><dt class="spec value" id="val-first"><a href="#val-first" class="anchor"></a><code><span class="keyword">val </span>first : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dt class="spec value" id="val-last"><a href="#val-last" class="anchor"></a><code><span class="keyword">val </span>last : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p>These return the first and last values in the vector</p></dd></dl><dl><dt class="spec value" id="val-shift"><a href="#val-shift" class="anchor"></a><code><span class="keyword">val </span>shift : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span><span class="keyword"> * </span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p>These return the first and last values in the vector</p><p>Return the first element of a vector and its last <code>n-1</code> elements.</p></dd></dl><dl><dt class="spec value" id="val-pop"><a href="#val-pop" class="anchor"></a><code><span class="keyword">val </span>pop : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span><span class="keyword"> * </span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Return the first element of a vector and its last <code>n-1</code> elements.</p><p>Return the last element of a vector and its first <code>n-1</code> elements.</p></dd></dl></section><section><header><h6 id="boilerplate-code"><a href="#boilerplate-code" class="anchor"></a>Boilerplate code</h6></header><dl><dt class="spec value" id="val-print"><a href="#val-print" class="anchor"></a><code><span class="keyword">val </span>print : ?&#8288;first:string <span>&#45;&gt;</span> ?&#8288;last:string <span>&#45;&gt;</span> ?&#8288;sep:string <span>&#45;&gt;</span> (<span class="type-var">'a</span> BatInnerIO.output <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> unit) <span>&#45;&gt;</span> <span class="type-var">'a</span> BatInnerIO.output <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-compare"><a href="#val-compare" class="anchor"></a><code><span class="keyword">val </span>compare : <span class="type-var">'a</span> BatOrd.comp <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> BatOrd.comp</code></dt><dt class="spec value" id="val-equal"><a href="#val-equal" class="anchor"></a><code><span class="keyword">val </span>equal : <span class="type-var">'a</span> BatOrd.eq <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> BatOrd.eq</code></dt><dt class="spec value" id="val-ord"><a href="#val-ord" class="anchor"></a><code><span class="keyword">val </span>ord : <span class="type-var">'a</span> BatOrd.ord <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> BatOrd.ord</code></dt><dt class="spec value" id="val-invariants"><a href="#val-invariants" class="anchor"></a><code><span class="keyword">val </span>invariants : <span class="type-var">_</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>/*</p><p>/*</p></dd></dl></section><section><header><h6 id="override-modules"><a href="#override-modules" class="anchor"></a>Override modules</h6></header><dl><dt class="spec module" id="module-Labels"><a href="#module-Labels" class="anchor"></a><code><span class="keyword">module </span><a href="Labels/index.html">Labels</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Operations on <a href="index.html"><code>BatVect</code></a> with labels.</p></dd></dl></section><section><header><h6 id="functorial-interface"><a href="#functorial-interface" class="anchor"></a>Functorial interface</h6></header><div class="spec module-type" id="module-type-RANDOMACCESS"><a href="#module-type-RANDOMACCESS" class="anchor"></a><code><span class="keyword">module type </span><a href="module-type-RANDOMACCESS/index.html">RANDOMACCESS</a> = <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><div class="spec module" id="module-Make"><a href="#module-Make" class="anchor"></a><code><span class="keyword">module </span><a href="Make/index.html">Make</a> : <span class="keyword">functor</span> (<a href="Make/argument-1-R/index.html">R</a> : <a href="index.html#module-type-RANDOMACCESS">RANDOMACCESS</a>) <span>&#45;&gt;</span> <span class="keyword">functor</span> (<a href="Make/argument-2-PARAM/index.html">PARAM</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span>) <span>&#45;&gt;</span> <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div></section></div></body></html>