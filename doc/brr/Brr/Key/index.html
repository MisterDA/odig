<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Key (brr.Brr.Key)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../../index.html">brr</a> &#x00BB; <a href="../index.html">Brr</a> &#x00BB; Key</nav><h1>Module <code>Brr.Key</code></h1><p>User keyboard.</p></header><section><header><h2 id="keys"><a href="#keys" class="anchor"></a>Physical keys</h2><p><b>Note.</b> Physical keys are for using the keyboard as a controller. They must not be used to derive text input: they are unrelated to the user's keyboard layout for text entry.</p></header><dl><dt class="spec type" id="type-code"><a href="#type-code" class="anchor"></a><code><span class="keyword">type </span>code</code><code><span class="keyword"> = </span>int</code></dt><dd><p>The type for physical key codes.</p></dd></dl><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type </span>t</code><span class="keyword"> = </span><code>[ </code><table class="variant"><tr id="type-t.Alt" class="anchored"><td class="def constructor"><a href="#type-t.Alt" class="anchor"></a><code><span class="keyword">| </span></code><code>`Alt<span class="keyword"> of </span>[ `Left<span class="keyword"> | </span>`Right ]</code></td></tr><tr id="type-t.Arrow" class="anchored"><td class="def constructor"><a href="#type-t.Arrow" class="anchor"></a><code><span class="keyword">| </span></code><code>`Arrow<span class="keyword"> of </span>[ `Up<span class="keyword"> | </span>`Down<span class="keyword"> | </span>`Left<span class="keyword"> | </span>`Right ]</code></td></tr><tr id="type-t.Ascii" class="anchored"><td class="def constructor"><a href="#type-t.Ascii" class="anchor"></a><code><span class="keyword">| </span></code><code>`Ascii<span class="keyword"> of </span>Char.t</code></td></tr><tr id="type-t.Backspace" class="anchored"><td class="def constructor"><a href="#type-t.Backspace" class="anchor"></a><code><span class="keyword">| </span></code><code>`Backspace</code></td></tr><tr id="type-t.Ctrl" class="anchored"><td class="def constructor"><a href="#type-t.Ctrl" class="anchor"></a><code><span class="keyword">| </span></code><code>`Ctrl<span class="keyword"> of </span>[ `Left<span class="keyword"> | </span>`Right ]</code></td></tr><tr id="type-t.End" class="anchored"><td class="def constructor"><a href="#type-t.End" class="anchor"></a><code><span class="keyword">| </span></code><code>`End</code></td></tr><tr id="type-t.Enter" class="anchored"><td class="def constructor"><a href="#type-t.Enter" class="anchor"></a><code><span class="keyword">| </span></code><code>`Enter</code></td></tr><tr id="type-t.Escape" class="anchored"><td class="def constructor"><a href="#type-t.Escape" class="anchor"></a><code><span class="keyword">| </span></code><code>`Escape</code></td></tr><tr id="type-t.Func" class="anchored"><td class="def constructor"><a href="#type-t.Func" class="anchor"></a><code><span class="keyword">| </span></code><code>`Func<span class="keyword"> of </span>int</code></td></tr><tr id="type-t.Home" class="anchored"><td class="def constructor"><a href="#type-t.Home" class="anchor"></a><code><span class="keyword">| </span></code><code>`Home</code></td></tr><tr id="type-t.Insert" class="anchored"><td class="def constructor"><a href="#type-t.Insert" class="anchor"></a><code><span class="keyword">| </span></code><code>`Insert</code></td></tr><tr id="type-t.Key" class="anchored"><td class="def constructor"><a href="#type-t.Key" class="anchor"></a><code><span class="keyword">| </span></code><code>`Key<span class="keyword"> of </span><a href="index.html#type-code">code</a></code></td></tr><tr id="type-t.Meta" class="anchored"><td class="def constructor"><a href="#type-t.Meta" class="anchor"></a><code><span class="keyword">| </span></code><code>`Meta<span class="keyword"> of </span>[ `Left<span class="keyword"> | </span>`Right ]</code></td></tr><tr id="type-t.Page" class="anchored"><td class="def constructor"><a href="#type-t.Page" class="anchor"></a><code><span class="keyword">| </span></code><code>`Page<span class="keyword"> of </span>[ `Up<span class="keyword"> | </span>`Down ]</code></td></tr><tr id="type-t.Return" class="anchored"><td class="def constructor"><a href="#type-t.Return" class="anchor"></a><code><span class="keyword">| </span></code><code>`Return</code></td></tr><tr id="type-t.Shift" class="anchored"><td class="def constructor"><a href="#type-t.Shift" class="anchor"></a><code><span class="keyword">| </span></code><code>`Shift<span class="keyword"> of </span>[ `Left<span class="keyword"> | </span>`Right ]</code></td></tr><tr id="type-t.Spacebar" class="anchored"><td class="def constructor"><a href="#type-t.Spacebar" class="anchor"></a><code><span class="keyword">| </span></code><code>`Spacebar</code></td></tr><tr id="type-t.Tab" class="anchored"><td class="def constructor"><a href="#type-t.Tab" class="anchor"></a><code><span class="keyword">| </span></code><code>`Tab</code></td></tr></table><code> ]</code></dt><dd><p>The type for physical keys.</p><p><b>Warning.</b> This type is overdefined for now. For example except for <code>`Meta</code>, <code>`Left</code> and <code>`Right</code> modifiers cannot be distinguished; <code>`Left</code> is always returned. <code>`Enter</code> and <code>`Return</code> cannot be distinguished, <code>`Return</code> is always returned.</p></dd></dl><dl><dt class="spec value" id="val-of_ev"><a href="#val-of_ev" class="anchor"></a><code><span class="keyword">val </span>of_ev : Dom_html.keyboardEvent <a href="../Ev/index.html#type-t">Ev.t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>of_ev e</code> is the physical key of keyboard event <code>e</code>.</p></dd></dl><dl><dt class="spec value" id="val-equal"><a href="#val-equal" class="anchor"></a><code><span class="keyword">val </span>equal : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>equal k0 k1</code> is <code>true</code> iff <code>k0</code> and <code>k1</code> are equal.</p></dd></dl><dl><dt class="spec value" id="val-compare"><a href="#val-compare" class="anchor"></a><code><span class="keyword">val </span>compare : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int</code></dt><dd><p><code>compare</code> is a total order on keys compatible with <a href="index.html#val-equal"><code>equal</code></a>.</p></dd></dl><dl><dt class="spec value" id="val-pp"><a href="#val-pp" class="anchor"></a><code><span class="keyword">val </span>pp : Format.formatter <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>pp</code> formats keys.</p></dd></dl></section><section><header><h2 id="ev"><a href="#ev" class="anchor"></a>Keyboard events</h2></header><dl><dt class="spec type" id="type-events"><a href="#type-events" class="anchor"></a><code><span class="keyword">type </span>events</code></dt><dd><p>The type for gathering keyboard events on a given target.</p></dd></dl><dl><dt class="spec value" id="val-for_target"><a href="#val-for_target" class="anchor"></a><code><span class="keyword">val </span>for_target : ?&#8288;capture:bool <span>&#45;&gt;</span> ?&#8288;propagate:bool <span>&#45;&gt;</span> ?&#8288;default:bool <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="../Ev/index.html#type-target">Ev.target</a> <span>&#45;&gt;</span> <a href="index.html#type-events">events</a></code></dt><dd><p><code>for_target t</code> is keyboard events for target <code>t</code>. The other parameters are those of <a href="../Ev/index.html#val-for_target"><code>Ev.for_target</code></a>.</p></dd></dl><dl><dt class="spec value" id="val-for_el"><a href="#val-for_el" class="anchor"></a><code><span class="keyword">val </span>for_el : ?&#8288;capture:bool <span>&#45;&gt;</span> ?&#8288;propagate:bool <span>&#45;&gt;</span> ?&#8288;default:bool <span>&#45;&gt;</span> <a href="../El/index.html#type-t">El.t</a> <span>&#45;&gt;</span> <a href="index.html#type-events">events</a></code></dt><dd><p><code>for_el e</code> is like <a href="index.html#val-for_target"><code>for_target</code></a> but for an element.</p></dd></dl></section><section><header><h2 id="kev"><a href="#kev" class="anchor"></a>Key events</h2></header><dl><dt class="spec value" id="val-any_down"><a href="#val-any_down" class="anchor"></a><code><span class="keyword">val </span>any_down : <a href="index.html#type-events">events</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> Note.event</code></dt><dd><p><code>any_down evs</code> occurs whenever a key goes down on the target.</p></dd></dl><dl><dt class="spec value" id="val-any_up"><a href="#val-any_up" class="anchor"></a><code><span class="keyword">val </span>any_up : <a href="index.html#type-events">events</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> Note.event</code></dt><dd><p><code>any_down evs</code> occurs whenever a key goes up on the target.</p></dd></dl><dl><dt class="spec value" id="val-any_holds"><a href="#val-any_holds" class="anchor"></a><code><span class="keyword">val </span>any_holds : <a href="index.html#type-events">events</a> <span>&#45;&gt;</span> bool Note.signal</code></dt><dd><p><code>any_holds evs</code> is <code>true</code> whenever any key is down.</p></dd></dl><dl><dt class="spec value" id="val-down"><a href="#val-down" class="anchor"></a><code><span class="keyword">val </span>down : <a href="index.html#type-events">events</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit Note.event</code></dt><dd><p><code>down evs k</code> occurs whenever key <code>k</code> goes down on the target.</p></dd></dl><dl><dt class="spec value" id="val-up"><a href="#val-up" class="anchor"></a><code><span class="keyword">val </span>up : <a href="index.html#type-events">events</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit Note.event</code></dt><dd><p><code>up evs k</code> occurs whenever key <code>k</code> goes up on the target.</p></dd></dl><dl><dt class="spec value" id="val-holds"><a href="#val-holds" class="anchor"></a><code><span class="keyword">val </span>holds : <a href="index.html#type-events">events</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool Note.signal</code></dt><dd><p><code>holds evs k</code> is <code>true</code> whenever <code>k</code> is held down on the target.</p></dd></dl></section><section><header><h2 id="mods"><a href="#mods" class="anchor"></a>Modifiers signals</h2></header><dl><dt class="spec value" id="val-alt"><a href="#val-alt" class="anchor"></a><code><span class="keyword">val </span>alt : <a href="index.html#type-events">events</a> <span>&#45;&gt;</span> bool Note.signal</code></dt><dd><p><code>alt evs</code> is <code>true</code> whenver an alt key is down on the target. Equivalent to:</p><pre><code class="ml">S.Bool.(holds evs (`Alt `Left) || holds evs (`Alt `Right))</code></pre></dd></dl><dl><dt class="spec value" id="val-ctrl"><a href="#val-ctrl" class="anchor"></a><code><span class="keyword">val </span>ctrl : <a href="index.html#type-events">events</a> <span>&#45;&gt;</span> bool Note.signal</code></dt><dd><p><code>ctrl evs</code> is <code>true</code> whenver an ctrl key is down on the target. Equivalent to:</p><pre><code class="ml">S.Bool.(holds evs (`Ctrl `Left) || holds evs (`Ctrl `Right))</code></pre></dd></dl><dl><dt class="spec value" id="val-meta"><a href="#val-meta" class="anchor"></a><code><span class="keyword">val </span>meta : <a href="index.html#type-events">events</a> <span>&#45;&gt;</span> bool Note.signal</code></dt><dd><p><code>meta evs</code> is <code>true</code> whenver an meta key is down on the target. Equivalent to:</p><pre><code class="ml">S.Bool.(holds evs (`Meta `Left) || holds evs (`Meta `Right))</code></pre></dd></dl><dl><dt class="spec value" id="val-shift"><a href="#val-shift" class="anchor"></a><code><span class="keyword">val </span>shift : <a href="index.html#type-events">events</a> <span>&#45;&gt;</span> bool Note.signal</code></dt><dd><p><code>shift evs</code> is <code>true</code> whenver an shift key is down on the target. Equivalent to:</p><pre><code class="ml">S.Bool.(holds evs (`Meta `Left) || holds evs (`Meta `Right))</code></pre></dd></dl></section><section><header><h2 id="semantics"><a href="#semantics" class="anchor"></a>Semantic incoherences</h2><p><a href="index.html#val-holds"><code>holds</code></a> and <a href="index.html#val-any_holds"><code>any_holds</code></a> may be initially set to <code>false</code> even though they should be <code>true</code> if <a href="index.html#val-for_target"><code>for_target</code></a> is invoked when the corresponding keys are depressed.</p></header></section><section><header><h2 id="repeat"><a href="#repeat" class="anchor"></a>Key repeat events</h2><p>Key repeat events are not exposed. There are two main use cases for key repeat. First during text input, but his should be handled by text input events and is out of scope. Second for controlling changes to a variable over time, e.g. scrolling with a keyboard. In the latter case it is better to create a timing signal or event with a known rate while the key is held.</p></header></section></div></body></html>