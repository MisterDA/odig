<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Make (bst.Bst.Bisec_tree.Make)</title><link rel="stylesheet" href="../../../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../../../index.html">bst</a> &#x00BB; <a href="../../index.html">Bst</a> &#x00BB; <a href="../index.html">Bisec_tree</a> &#x00BB; Make</nav><h1>Module <code>Bisec_tree.Make</code></h1></header><h3 class="heading">Parameters</h3><ul><li><code><a href="argument-1-P/index.html">P</a> : <a href="../index.html#module-type-Point">Point</a></code></li></ul><h3 class="heading">Signature</h3><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> t</code></dt><dd><p>A Bisector Tree (BST).</p></dd></dl><dl><dt class="spec value" id="val-create"><a href="#val-create" class="anchor"></a><code><span class="keyword">val</span> create : ?&#8288;progress_callback:(int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> unit) <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <a href="../index.html#type-vp_heuristic">vp_heuristic</a> <span>&#45;&gt;</span> <a href="argument-1-P/index.html#type-t">P.t</a> array <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>create k h points</code> create the BST containing all <code>points</code>, using bucket size <code>k</code> and heuristic <code>h</code>. You can provide an optional <code>progress_callback</code> function to give some feedback to the user when indexing many points. If provided, <code>progress_callback</code> will be called upon progression of the indexing as <code>progress_callback x y</code>. <code>x</code> is the current number of points that have been indexed and <code>y</code> is the total number of points to index. The default <code>progress_callback</code> function does nothing.</p></dd></dl><dl><dt class="spec value" id="val-sample_distances"><a href="#val-sample_distances" class="anchor"></a><code><span class="keyword">val</span> sample_distances : int <span>&#45;&gt;</span> <a href="argument-1-P/index.html#type-t">P.t</a> array <span>&#45;&gt;</span> float array</code></dt><dd><p><code>sample_distances n points</code> get distances found in <code>n</code> pairs of randomly-chosen points. The result is sorted.</p></dd></dl><dl><dt class="spec value" id="val-nearest_neighbor"><a href="#val-nearest_neighbor" class="anchor"></a><code><span class="keyword">val</span> nearest_neighbor : <a href="argument-1-P/index.html#type-t">P.t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="argument-1-P/index.html#type-t">P.t</a> * float</code></dt><dd><p><code>nearest_neighbor q bst</code> return the distance along with the nearest neighbor to query point <code>q</code> in <code>bst</code>. Warning: there may be several points at this distance from <code>q</code> in <code>bst</code>, but a single (arbitrary) one is returned. If you are not happy with this, use a point type that is deduplicated (i.e. a point that holds the info for all points with the same coordinates).</p></dd></dl><dl><dt class="spec value" id="val-neighbors"><a href="#val-neighbors" class="anchor"></a><code><span class="keyword">val</span> neighbors : <a href="argument-1-P/index.html#type-t">P.t</a> <span>&#45;&gt;</span> float <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="argument-1-P/index.html#type-t">P.t</a> list</code></dt><dd><p><code>neighbors q tol bst</code> return all points in <code>bst</code> within <code>tol</code> distance from query point <code>q</code>. I.e. all points returned are within <code>(d &lt;= tol)</code> distance from <code>q</code>.</p></dd></dl><dl><dt class="spec value" id="val-partition"><a href="#val-partition" class="anchor"></a><code><span class="keyword">val</span> partition : <a href="argument-1-P/index.html#type-t">P.t</a> <span>&#45;&gt;</span> float <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="argument-1-P/index.html#type-t">P.t</a> list * <a href="argument-1-P/index.html#type-t">P.t</a> list</code></dt><dd><p><code>partition q tol bst</code> is like <code>neighbors</code>, but a pair <code>(xs, ys)</code> is returned, such that <code>(d &lt;= tol)</code> for any <code>x</code> and <code>(d &gt; tol)</code> for any <code>y</code>.</p></dd></dl><dl><dt class="spec value" id="val-to_list"><a href="#val-to_list" class="anchor"></a><code><span class="keyword">val</span> to_list : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="argument-1-P/index.html#type-t">P.t</a> list</code></dt><dd><p><code>to_list bst</code> return the list of points inside <code>bst</code>, in an unspecified order.</p></dd></dl><dl><dt class="spec value" id="val-length"><a href="#val-length" class="anchor"></a><code><span class="keyword">val</span> length : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int</code></dt><dd><p><code>length bst</code> return the number of elements inside <code>bst</code>. I.e. how many points are indexed by this <code>bst</code>.</p></dd></dl><dl><dt class="spec value" id="val-is_empty"><a href="#val-is_empty" class="anchor"></a><code><span class="keyword">val</span> is_empty : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>is_empty bst</code> test if <code>bst</code> is empty.</p></dd></dl><dl><dt class="spec value" id="val-find"><a href="#val-find" class="anchor"></a><code><span class="keyword">val</span> find : <a href="argument-1-P/index.html#type-t">P.t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="argument-1-P/index.html#type-t">P.t</a></code></dt><dd><p><code>find q bst</code> return the first point with distance to <code>q</code> = 0.0.</p><dl><dt>raises Not_found</dt><dd><p>if no such element exists. Warning: there may be several points at this distance from <code>q</code> in <code>bst</code>, but a single (arbitrary) one is returned.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-mem"><a href="#val-mem" class="anchor"></a><code><span class="keyword">val</span> mem : <a href="argument-1-P/index.html#type-t">P.t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>mem q bst</code> return true if <code>q</code> can be found in <code>bst</code>, false otherwise.</p></dd></dl><dl><dt class="spec value" id="val-root"><a href="#val-root" class="anchor"></a><code><span class="keyword">val</span> root : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="argument-1-P/index.html#type-t">P.t</a></code></dt><dd><p><code>root bst</code> return the first point found in <code>bst</code> (either a bucket's vantage point or a node's left vantage point).</p><dl><dt>raises Not_found</dt><dd><p>if <code>is_empty bst</code>.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-check"><a href="#val-check" class="anchor"></a><code><span class="keyword">val</span> check : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>check bst</code> test the invariant of <code>bst</code>. Should always be true. If invariant doesn't hold, then this library has a bug or your <code>P.dist</code> function is not a proper metric.</p></dd></dl><dl><dt class="spec value" id="val-inspect"><a href="#val-inspect" class="anchor"></a><code><span class="keyword">val</span> inspect : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="argument-1-P/index.html#type-t">P.t</a> list</code></dt><dd><p><code>inspect bst</code> extract the vantage points of <code>bst</code> in an unspecified order.</p></dd></dl><dl><dt class="spec value" id="val-dump"><a href="#val-dump" class="anchor"></a><code><span class="keyword">val</span> dump : int <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<a href="../index.html#type-direction">direction</a> list * <a href="argument-1-P/index.html#type-t">P.t</a> list) list</code></dt><dd><p><code>dump max_depth bst</code> list points and paths to reach them in the <code>bst</code>, going down up to <code>max_depth</code>.</p></dd></dl><dl><dt class="spec value" id="val-get_addr"><a href="#val-get_addr" class="anchor"></a><code><span class="keyword">val</span> get_addr : <a href="argument-1-P/index.html#type-t">P.t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../index.html#type-step">step</a> list</code></dt><dd><p><code>get_addr q bst</code> find the address of <code>q</code> in <code>bst</code>.</p></dd></dl><dl><dt class="spec value" id="val-add"><a href="#val-add" class="anchor"></a><code><span class="keyword">val</span> add : <a href="argument-1-P/index.html#type-t">P.t</a> <span>&#45;&gt;</span> <a href="../index.html#type-step">step</a> list <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>add p addr bst</code> add point <code>p</code> to <code>bst</code> at given address <code>addr</code>. <code>addr</code> _must_ be a valid address in <code>bst</code>. Call <code>get_addr p bst</code> to get a valid address for <code>p</code> in <code>bst</code>.</p></dd></dl><dl><dt class="spec value" id="val-to_string"><a href="#val-to_string" class="anchor"></a><code><span class="keyword">val</span> to_string : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> string</code></dt><dd><p><code>to_string bst</code> create a string representation/summary for <code>bst</code></p></dd></dl></div></body></html>