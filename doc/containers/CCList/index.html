<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>CCList (containers.CCList)</title><link rel="stylesheet" href="../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../index.html">containers</a> &#x00BB; CCList</nav><h1>Module <code>CCList</code></h1><h2 id="complements-to-list"><a href="#complements-to-list" class="anchor"></a>Complements to list</h2><nav class="toc"><ul><li><a href="#indices">Indices</a></li><li><a href="#set-operators">Set Operators</a></li><li><a href="#other-constructors">Other Constructors</a></li><li><a href="#association-lists">Association Lists</a></li><li><a href="#references-on-lists">References on Lists</a></li><li><a href="#conversions">Conversions</a></li><li><a href="#infix-operators">Infix Operators</a></li><li><a href="#io">IO</a></li></ul></nav></header><dl><dt class="spec type" id="type-sequence"><a href="#type-sequence" class="anchor"></a><code><span class="keyword">type</span> 'a sequence</code><code> = (<span class="type-var">'a</span> <span>&#45;&gt;</span> unit) <span>&#45;&gt;</span> unit</code></dt><dt class="spec type" id="type-gen"><a href="#type-gen" class="anchor"></a><code><span class="keyword">type</span> 'a gen</code><code> = unit <span>&#45;&gt;</span> <span class="type-var">'a</span> option</code></dt><dt class="spec type" id="type-klist"><a href="#type-klist" class="anchor"></a><code><span class="keyword">type</span> 'a klist</code><code> = unit <span>&#45;&gt;</span> [ `Nil | `Cons of <span class="type-var">'a</span> * <span class="type-var">'a</span> <a href="index.html#type-klist">klist</a> ]</code></dt><dt class="spec type" id="type-printer"><a href="#type-printer" class="anchor"></a><code><span class="keyword">type</span> 'a printer</code><code> = <a href="../../ocaml/Stdlib/Format/index.html#type-formatter">Stdlib.Format.formatter</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> unit</code></dt><dt class="spec type" id="type-random_gen"><a href="#type-random_gen" class="anchor"></a><code><span class="keyword">type</span> 'a random_gen</code><code> = <a href="../../ocaml/Stdlib__random/State/index.html#type-t">Stdlib.Random.State.t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt></dl><div><div class="spec include"><div class="doc"><details open="open"><summary><span class="def"><code><span class="keyword">include</span> <span class="keyword">module</span> <span class="keyword">type</span> <span class="keyword">of</span> <a href="../../ocaml/Stdlib/index.html#module-List">Stdlib.List</a></code></span></summary><aside><p>List operations.</p><p>Some functions are flagged as not tail-recursive. A tail-recursive function uses constant stack space, while a non-tail-recursive function uses stack space proportional to the length of its list argument, which can be a problem with very long lists. When the function takes several list arguments, an approximate formula giving stack usage (in some unspecified constant unit) is shown in parentheses.</p><p>The above considerations can usually be ignored if your lists are not longer than about 10000 elements.</p></aside><dl><dt class="spec value" id="val-length"><a href="#val-length" class="anchor"></a><code><span class="keyword">val</span> length : <span class="type-var">'a</span> list <span>&#45;&gt;</span> int</code></dt><dd><p>Return the length (number of elements) of the given list.</p></dd></dl><dl><dt class="spec value" id="val-compare_lengths"><a href="#val-compare_lengths" class="anchor"></a><code><span class="keyword">val</span> compare_lengths : <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'b</span> list <span>&#45;&gt;</span> int</code></dt><dd><p>Compare the lengths of two lists. <code>compare_lengths l1 l2</code> is equivalent to <code>compare (length l1) (length l2)</code>, except that the computation stops after itering on the shortest list.</p><dl><dt>since</dt><dd>4.05.0</dd></dl></dd></dl><dl><dt class="spec value" id="val-compare_length_with"><a href="#val-compare_length_with" class="anchor"></a><code><span class="keyword">val</span> compare_length_with : <span class="type-var">'a</span> list <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int</code></dt><dd><p>Compare the length of a list to an integer. <code>compare_length_with l n</code> is equivalent to <code>compare (length l) n</code>, except that the computation stops after at most <code>n</code> iterations on the list.</p><dl><dt>since</dt><dd>4.05.0</dd></dl></dd></dl><dl><dt class="spec value" id="val-cons"><a href="#val-cons" class="anchor"></a><code><span class="keyword">val</span> cons : <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'a</span> list</code></dt><dd><p><code>cons x xs</code> is <code>x :: xs</code></p><dl><dt>since</dt><dd>4.03.0</dd></dl></dd></dl><dl><dt class="spec value" id="val-hd"><a href="#val-hd" class="anchor"></a><code><span class="keyword">val</span> hd : <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p>Return the first element of the given list. Raise <code>Failure &quot;hd&quot;</code> if the list is empty.</p></dd></dl><dl><dt class="spec value" id="val-tl"><a href="#val-tl" class="anchor"></a><code><span class="keyword">val</span> tl : <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'a</span> list</code></dt><dd><p>Return the given list without its first element. Raise <code>Failure &quot;tl&quot;</code> if the list is empty.</p></dd></dl><dl><dt class="spec value" id="val-nth"><a href="#val-nth" class="anchor"></a><code><span class="keyword">val</span> nth : <span class="type-var">'a</span> list <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p>Return the <code>n</code>-th element of the given list. The first element (head of the list) is at position 0. Raise <code>Failure &quot;nth&quot;</code> if the list is too short. Raise <code>Invalid_argument &quot;List.nth&quot;</code> if <code>n</code> is negative.</p></dd></dl><dl><dt class="spec value" id="val-nth_opt"><a href="#val-nth_opt" class="anchor"></a><code><span class="keyword">val</span> nth_opt : <span class="type-var">'a</span> list <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <span class="type-var">'a</span> option</code></dt><dd><p>Return the <code>n</code>-th element of the given list. The first element (head of the list) is at position 0. Return <code>None</code> if the list is too short. Raise <code>Invalid_argument &quot;List.nth&quot;</code> if <code>n</code> is negative.</p><dl><dt>since</dt><dd>4.05</dd></dl></dd></dl><dl><dt class="spec value" id="val-rev"><a href="#val-rev" class="anchor"></a><code><span class="keyword">val</span> rev : <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'a</span> list</code></dt><dd><p>List reversal.</p></dd></dl><dl><dt class="spec value" id="val-init"><a href="#val-init" class="anchor"></a><code><span class="keyword">val</span> init : int <span>&#45;&gt;</span> (int <span>&#45;&gt;</span> <span class="type-var">'a</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span> list</code></dt><dd><p><code>List.init len f</code> is <code>f 0; f 1; ...; f (len-1)</code>, evaluated left to right.</p><dl><dt>raises Invalid_argument</dt><dd><p>if len &lt; 0.</p></dd></dl><dl><dt>since</dt><dd>4.06.0</dd></dl></dd></dl><dl><dt class="spec value" id="val-append"><a href="#val-append" class="anchor"></a><code><span class="keyword">val</span> append : <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'a</span> list</code></dt><dd><p>Concatenate two lists. Same as the infix operator <code>@</code>. Not tail-recursive (length of the first argument).</p></dd></dl><dl><dt class="spec value" id="val-rev_append"><a href="#val-rev_append" class="anchor"></a><code><span class="keyword">val</span> rev_append : <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'a</span> list</code></dt><dd><p><code>List.rev_append l1 l2</code> reverses <code>l1</code> and concatenates it to <code>l2</code>. This is equivalent to <span class="xref-unresolved" title="unresolved reference to &quot;List.rev&quot;"><code>List</code>.rev</span><code> l1 @ l2</code>, but <code>rev_append</code> is tail-recursive and more efficient.</p></dd></dl><dl><dt class="spec value" id="val-concat"><a href="#val-concat" class="anchor"></a><code><span class="keyword">val</span> concat : <span class="type-var">'a</span> list list <span>&#45;&gt;</span> <span class="type-var">'a</span> list</code></dt><dd><p>Concatenate a list of lists. The elements of the argument are all concatenated together (in the same order) to give the result. Not tail-recursive (length of the argument + length of the longest sub-list).</p></dd></dl><dl><dt class="spec value" id="val-flatten"><a href="#val-flatten" class="anchor"></a><code><span class="keyword">val</span> flatten : <span class="type-var">'a</span> list list <span>&#45;&gt;</span> <span class="type-var">'a</span> list</code></dt><dd><p>An alias for <code>concat</code>.</p></dd></dl><section><header><h2 id="iterators"><a href="#iterators" class="anchor"></a>Iterators</h2></header><dl><dt class="spec value" id="val-iter"><a href="#val-iter" class="anchor"></a><code><span class="keyword">val</span> iter : (<span class="type-var">'a</span> <span>&#45;&gt;</span> unit) <span>&#45;&gt;</span> <span class="type-var">'a</span> list <span>&#45;&gt;</span> unit</code></dt><dd><p><code>List.iter f [a1; ...; an]</code> applies function <code>f</code> in turn to <code>a1; ...; an</code>. It is equivalent to <code>begin f a1; f a2; ...; f an; () end</code>.</p></dd></dl><dl><dt class="spec value" id="val-iteri"><a href="#val-iteri" class="anchor"></a><code><span class="keyword">val</span> iteri : (int <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> unit) <span>&#45;&gt;</span> <span class="type-var">'a</span> list <span>&#45;&gt;</span> unit</code></dt><dd><p>Same as <span class="xref-unresolved" title="unresolved reference to &quot;List.iter&quot;"><code>List</code>.iter</span>, but the function is applied to the index of the element as first argument (counting from 0), and the element itself as second argument.</p><dl><dt>since</dt><dd>4.00.0</dd></dl></dd></dl><dl><dt class="spec value" id="val-map"><a href="#val-map" class="anchor"></a><code><span class="keyword">val</span> map : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'b</span> list</code></dt><dd><p><code>List.map f [a1; ...; an]</code> applies function <code>f</code> to <code>a1, ..., an</code>, and builds the list <code>[f a1; ...; f an]</code> with the results returned by <code>f</code>. Not tail-recursive.</p></dd></dl><dl><dt class="spec value" id="val-mapi"><a href="#val-mapi" class="anchor"></a><code><span class="keyword">val</span> mapi : (int <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'b</span> list</code></dt><dd><p>Same as <span class="xref-unresolved" title="unresolved reference to &quot;List.map&quot;"><code>List</code>.map</span>, but the function is applied to the index of the element as first argument (counting from 0), and the element itself as second argument. Not tail-recursive.</p><dl><dt>since</dt><dd>4.00.0</dd></dl></dd></dl><dl><dt class="spec value" id="val-rev_map"><a href="#val-rev_map" class="anchor"></a><code><span class="keyword">val</span> rev_map : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'b</span> list</code></dt><dd><p><code>List.rev_map f l</code> gives the same result as <span class="xref-unresolved" title="unresolved reference to &quot;List.rev&quot;"><code>List</code>.rev</span><code> (</code><span class="xref-unresolved" title="unresolved reference to &quot;List.map&quot;"><code>List</code>.map</span><code> f l)</code>, but is tail-recursive and more efficient.</p></dd></dl><dl><dt class="spec value" id="val-fold_left"><a href="#val-fold_left" class="anchor"></a><code><span class="keyword">val</span> fold_left : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'a</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> list <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p><code>List.fold_left f a [b1; ...; bn]</code> is <code>f (... (f (f a b1) b2) ...) bn</code>.</p></dd></dl><dl><dt class="spec value" id="val-fold_right"><a href="#val-fold_right" class="anchor"></a><code><span class="keyword">val</span> fold_right : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'b</span></code></dt><dd><p><code>List.fold_right f [a1; ...; an] b</code> is <code>f a1 (f a2 (... (f an b) ...))</code>. Not tail-recursive.</p></dd></dl></section><section><header><h2 id="iterators-on-two-lists"><a href="#iterators-on-two-lists" class="anchor"></a>Iterators on two lists</h2></header><dl><dt class="spec value" id="val-iter2"><a href="#val-iter2" class="anchor"></a><code><span class="keyword">val</span> iter2 : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> unit) <span>&#45;&gt;</span> <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'b</span> list <span>&#45;&gt;</span> unit</code></dt><dd><p><code>List.iter2 f [a1; ...; an] [b1; ...; bn]</code> calls in turn <code>f a1 b1; ...; f an bn</code>. Raise <code>Invalid_argument</code> if the two lists are determined to have different lengths.</p></dd></dl><dl><dt class="spec value" id="val-map2"><a href="#val-map2" class="anchor"></a><code><span class="keyword">val</span> map2 : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'c</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'b</span> list <span>&#45;&gt;</span> <span class="type-var">'c</span> list</code></dt><dd><p><code>List.map2 f [a1; ...; an] [b1; ...; bn]</code> is <code>[f a1 b1; ...; f an bn]</code>. Raise <code>Invalid_argument</code> if the two lists are determined to have different lengths. Not tail-recursive.</p></dd></dl><dl><dt class="spec value" id="val-rev_map2"><a href="#val-rev_map2" class="anchor"></a><code><span class="keyword">val</span> rev_map2 : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'c</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'b</span> list <span>&#45;&gt;</span> <span class="type-var">'c</span> list</code></dt><dd><p><code>List.rev_map2 f l1 l2</code> gives the same result as <span class="xref-unresolved" title="unresolved reference to &quot;List.rev&quot;"><code>List</code>.rev</span><code> (</code><span class="xref-unresolved" title="unresolved reference to &quot;List.map2&quot;"><code>List</code>.map2</span><code> f l1 l2)</code>, but is tail-recursive and more efficient.</p></dd></dl><dl><dt class="spec value" id="val-fold_left2"><a href="#val-fold_left2" class="anchor"></a><code><span class="keyword">val</span> fold_left2 : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'c</span> <span>&#45;&gt;</span> <span class="type-var">'a</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> list <span>&#45;&gt;</span> <span class="type-var">'c</span> list <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p><code>List.fold_left2 f a [b1; ...; bn] [c1; ...; cn]</code> is <code>f (... (f (f a b1 c1) b2 c2) ...) bn cn</code>. Raise <code>Invalid_argument</code> if the two lists are determined to have different lengths.</p></dd></dl><dl><dt class="spec value" id="val-fold_right2"><a href="#val-fold_right2" class="anchor"></a><code><span class="keyword">val</span> fold_right2 : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'c</span> <span>&#45;&gt;</span> <span class="type-var">'c</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'b</span> list <span>&#45;&gt;</span> <span class="type-var">'c</span> <span>&#45;&gt;</span> <span class="type-var">'c</span></code></dt><dd><p><code>List.fold_right2 f [a1; ...; an] [b1; ...; bn] c</code> is <code>f a1 b1 (f a2 b2 (... (f an bn c) ...))</code>. Raise <code>Invalid_argument</code> if the two lists are determined to have different lengths. Not tail-recursive.</p></dd></dl></section><section><header><h2 id="list-scanning"><a href="#list-scanning" class="anchor"></a>List scanning</h2></header><dl><dt class="spec value" id="val-for_all"><a href="#val-for_all" class="anchor"></a><code><span class="keyword">val</span> for_all : (<span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <span class="type-var">'a</span> list <span>&#45;&gt;</span> bool</code></dt><dd><p><code>for_all p [a1; ...; an]</code> checks if all elements of the list satisfy the predicate <code>p</code>. That is, it returns <code>(p a1) &amp;&amp; (p a2) &amp;&amp; ... &amp;&amp; (p an)</code>.</p></dd></dl><dl><dt class="spec value" id="val-exists"><a href="#val-exists" class="anchor"></a><code><span class="keyword">val</span> exists : (<span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <span class="type-var">'a</span> list <span>&#45;&gt;</span> bool</code></dt><dd><p><code>exists p [a1; ...; an]</code> checks if at least one element of the list satisfies the predicate <code>p</code>. That is, it returns <code>(p a1) || (p a2) || ... || (p an)</code>.</p></dd></dl><dl><dt class="spec value" id="val-for_all2"><a href="#val-for_all2" class="anchor"></a><code><span class="keyword">val</span> for_all2 : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'b</span> list <span>&#45;&gt;</span> bool</code></dt><dd><p>Same as <span class="xref-unresolved" title="unresolved reference to &quot;List.for_all&quot;"><code>List</code>.for_all</span>, but for a two-argument predicate. Raise <code>Invalid_argument</code> if the two lists are determined to have different lengths.</p></dd></dl><dl><dt class="spec value" id="val-exists2"><a href="#val-exists2" class="anchor"></a><code><span class="keyword">val</span> exists2 : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'b</span> list <span>&#45;&gt;</span> bool</code></dt><dd><p>Same as <span class="xref-unresolved" title="unresolved reference to &quot;List.exists&quot;"><code>List</code>.exists</span>, but for a two-argument predicate. Raise <code>Invalid_argument</code> if the two lists are determined to have different lengths.</p></dd></dl><dl><dt class="spec value" id="val-mem"><a href="#val-mem" class="anchor"></a><code><span class="keyword">val</span> mem : <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> list <span>&#45;&gt;</span> bool</code></dt><dd><p><code>mem a l</code> is true if and only if <code>a</code> is equal to an element of <code>l</code>.</p></dd></dl><dl><dt class="spec value" id="val-memq"><a href="#val-memq" class="anchor"></a><code><span class="keyword">val</span> memq : <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> list <span>&#45;&gt;</span> bool</code></dt><dd><p>Same as <span class="xref-unresolved" title="unresolved reference to &quot;List.mem&quot;"><code>List</code>.mem</span>, but uses physical equality instead of structural equality to compare list elements.</p></dd></dl></section><section><header><h2 id="list-searching"><a href="#list-searching" class="anchor"></a>List searching</h2></header><dl><dt class="spec value" id="val-find"><a href="#val-find" class="anchor"></a><code><span class="keyword">val</span> find : (<span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p><code>find p l</code> returns the first element of the list <code>l</code> that satisfies the predicate <code>p</code>. Raise <code>Not_found</code> if there is no value that satisfies <code>p</code> in the list <code>l</code>.</p></dd></dl><dl><dt class="spec value" id="val-find_opt"><a href="#val-find_opt" class="anchor"></a><code><span class="keyword">val</span> find_opt : (<span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'a</span> option</code></dt><dd><p><code>find_opt p l</code> returns the first element of the list <code>l</code> that satisfies the predicate <code>p</code>, or <code>None</code> if there is no value that satisfies <code>p</code> in the list <code>l</code>.</p><dl><dt>since</dt><dd>4.05</dd></dl></dd></dl><dl><dt class="spec value" id="val-filter"><a href="#val-filter" class="anchor"></a><code><span class="keyword">val</span> filter : (<span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'a</span> list</code></dt><dd><p><code>filter p l</code> returns all the elements of the list <code>l</code> that satisfy the predicate <code>p</code>. The order of the elements in the input list is preserved.</p></dd></dl><dl><dt class="spec value" id="val-find_all"><a href="#val-find_all" class="anchor"></a><code><span class="keyword">val</span> find_all : (<span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'a</span> list</code></dt><dd><p><code>find_all</code> is another name for <span class="xref-unresolved" title="unresolved reference to &quot;List.filter&quot;"><code>List</code>.filter</span>.</p></dd></dl><dl><dt class="spec value" id="val-partition"><a href="#val-partition" class="anchor"></a><code><span class="keyword">val</span> partition : (<span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'a</span> list * <span class="type-var">'a</span> list</code></dt><dd><p><code>partition p l</code> returns a pair of lists <code>(l1, l2)</code>, where <code>l1</code> is the list of all the elements of <code>l</code> that satisfy the predicate <code>p</code>, and <code>l2</code> is the list of all the elements of <code>l</code> that do not satisfy <code>p</code>. The order of the elements in the input list is preserved.</p></dd></dl></section><section><header><h2 id="association-lists"><a href="#association-lists" class="anchor"></a>Association lists</h2></header><dl><dt class="spec value" id="val-assoc"><a href="#val-assoc" class="anchor"></a><code><span class="keyword">val</span> assoc : <span class="type-var">'a</span> <span>&#45;&gt;</span> (<span class="type-var">'a</span> * <span class="type-var">'b</span>) list <span>&#45;&gt;</span> <span class="type-var">'b</span></code></dt><dd><p><code>assoc a l</code> returns the value associated with key <code>a</code> in the list of pairs <code>l</code>. That is, <code>assoc a [ ...; (a,b); ...] = b</code> if <code>(a,b)</code> is the leftmost binding of <code>a</code> in list <code>l</code>. Raise <code>Not_found</code> if there is no value associated with <code>a</code> in the list <code>l</code>.</p></dd></dl><dl><dt class="spec value" id="val-assoc_opt"><a href="#val-assoc_opt" class="anchor"></a><code><span class="keyword">val</span> assoc_opt : <span class="type-var">'a</span> <span>&#45;&gt;</span> (<span class="type-var">'a</span> * <span class="type-var">'b</span>) list <span>&#45;&gt;</span> <span class="type-var">'b</span> option</code></dt><dd><p><code>assoc_opt a l</code> returns the value associated with key <code>a</code> in the list of pairs <code>l</code>. That is, <code>assoc_opt a [ ...; (a,b); ...] = b</code> if <code>(a,b)</code> is the leftmost binding of <code>a</code> in list <code>l</code>. Returns <code>None</code> if there is no value associated with <code>a</code> in the list <code>l</code>.</p><dl><dt>since</dt><dd>4.05</dd></dl></dd></dl><dl><dt class="spec value" id="val-assq"><a href="#val-assq" class="anchor"></a><code><span class="keyword">val</span> assq : <span class="type-var">'a</span> <span>&#45;&gt;</span> (<span class="type-var">'a</span> * <span class="type-var">'b</span>) list <span>&#45;&gt;</span> <span class="type-var">'b</span></code></dt><dd><p>Same as <span class="xref-unresolved" title="unresolved reference to &quot;List.assoc&quot;"><code>List</code>.assoc</span>, but uses physical equality instead of structural equality to compare keys.</p></dd></dl><dl><dt class="spec value" id="val-assq_opt"><a href="#val-assq_opt" class="anchor"></a><code><span class="keyword">val</span> assq_opt : <span class="type-var">'a</span> <span>&#45;&gt;</span> (<span class="type-var">'a</span> * <span class="type-var">'b</span>) list <span>&#45;&gt;</span> <span class="type-var">'b</span> option</code></dt><dd><p>Same as <span class="xref-unresolved" title="unresolved reference to &quot;List.assoc_opt&quot;"><code>List</code>.assoc_opt</span>, but uses physical equality instead of structural equality to compare keys.</p><dl><dt>since</dt><dd>4.05</dd></dl></dd></dl><dl><dt class="spec value" id="val-mem_assoc"><a href="#val-mem_assoc" class="anchor"></a><code><span class="keyword">val</span> mem_assoc : <span class="type-var">'a</span> <span>&#45;&gt;</span> (<span class="type-var">'a</span> * <span class="type-var">'b</span>) list <span>&#45;&gt;</span> bool</code></dt><dd><p>Same as <span class="xref-unresolved" title="unresolved reference to &quot;List.assoc&quot;"><code>List</code>.assoc</span>, but simply return true if a binding exists, and false if no bindings exist for the given key.</p></dd></dl><dl><dt class="spec value" id="val-mem_assq"><a href="#val-mem_assq" class="anchor"></a><code><span class="keyword">val</span> mem_assq : <span class="type-var">'a</span> <span>&#45;&gt;</span> (<span class="type-var">'a</span> * <span class="type-var">'b</span>) list <span>&#45;&gt;</span> bool</code></dt><dd><p>Same as <span class="xref-unresolved" title="unresolved reference to &quot;List.mem_assoc&quot;"><code>List</code>.mem_assoc</span>, but uses physical equality instead of structural equality to compare keys.</p></dd></dl><dl><dt class="spec value" id="val-remove_assoc"><a href="#val-remove_assoc" class="anchor"></a><code><span class="keyword">val</span> remove_assoc : <span class="type-var">'a</span> <span>&#45;&gt;</span> (<span class="type-var">'a</span> * <span class="type-var">'b</span>) list <span>&#45;&gt;</span> (<span class="type-var">'a</span> * <span class="type-var">'b</span>) list</code></dt><dd><p><code>remove_assoc a l</code> returns the list of pairs <code>l</code> without the first pair with key <code>a</code>, if any. Not tail-recursive.</p></dd></dl><dl><dt class="spec value" id="val-remove_assq"><a href="#val-remove_assq" class="anchor"></a><code><span class="keyword">val</span> remove_assq : <span class="type-var">'a</span> <span>&#45;&gt;</span> (<span class="type-var">'a</span> * <span class="type-var">'b</span>) list <span>&#45;&gt;</span> (<span class="type-var">'a</span> * <span class="type-var">'b</span>) list</code></dt><dd><p>Same as <span class="xref-unresolved" title="unresolved reference to &quot;List.remove_assoc&quot;"><code>List</code>.remove_assoc</span>, but uses physical equality instead of structural equality to compare keys. Not tail-recursive.</p></dd></dl></section><section><header><h2 id="lists-of-pairs"><a href="#lists-of-pairs" class="anchor"></a>Lists of pairs</h2></header><dl><dt class="spec value" id="val-split"><a href="#val-split" class="anchor"></a><code><span class="keyword">val</span> split : (<span class="type-var">'a</span> * <span class="type-var">'b</span>) list <span>&#45;&gt;</span> <span class="type-var">'a</span> list * <span class="type-var">'b</span> list</code></dt><dd><p>Transform a list of pairs into a pair of lists: <code>split [(a1,b1); ...; (an,bn)]</code> is <code>([a1; ...; an], [b1; ...; bn])</code>. Not tail-recursive.</p></dd></dl><dl><dt class="spec value" id="val-combine"><a href="#val-combine" class="anchor"></a><code><span class="keyword">val</span> combine : <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'b</span> list <span>&#45;&gt;</span> (<span class="type-var">'a</span> * <span class="type-var">'b</span>) list</code></dt><dd><p>Transform a pair of lists into a list of pairs: <code>combine [a1; ...; an] [b1; ...; bn]</code> is <code>[(a1,b1); ...; (an,bn)]</code>. Raise <code>Invalid_argument</code> if the two lists have different lengths. Not tail-recursive.</p></dd></dl></section><section><header><h2 id="sorting"><a href="#sorting" class="anchor"></a>Sorting</h2></header><dl><dt class="spec value" id="val-sort"><a href="#val-sort" class="anchor"></a><code><span class="keyword">val</span> sort : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> int) <span>&#45;&gt;</span> <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'a</span> list</code></dt><dd><p>Sort a list in increasing order according to a comparison function. The comparison function must return 0 if its arguments compare as equal, a positive integer if the first is greater, and a negative integer if the first is smaller (see Array.sort for a complete specification). For example, <span class="xref-unresolved" title="unresolved reference to &quot;Pervasives.compare&quot;"><code>Pervasives</code>.compare</span> is a suitable comparison function. The resulting list is sorted in increasing order. <code>List.sort</code> is guaranteed to run in constant heap space (in addition to the size of the result list) and logarithmic stack space.</p><p>The current implementation uses Merge Sort. It runs in constant heap space and logarithmic stack space.</p></dd></dl><dl><dt class="spec value" id="val-stable_sort"><a href="#val-stable_sort" class="anchor"></a><code><span class="keyword">val</span> stable_sort : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> int) <span>&#45;&gt;</span> <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'a</span> list</code></dt><dd><p>Same as <span class="xref-unresolved" title="unresolved reference to &quot;List.sort&quot;"><code>List</code>.sort</span>, but the sorting algorithm is guaranteed to be stable (i.e. elements that compare equal are kept in their original order) .</p><p>The current implementation uses Merge Sort. It runs in constant heap space and logarithmic stack space.</p></dd></dl><dl><dt class="spec value" id="val-fast_sort"><a href="#val-fast_sort" class="anchor"></a><code><span class="keyword">val</span> fast_sort : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> int) <span>&#45;&gt;</span> <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'a</span> list</code></dt><dd><p>Same as <span class="xref-unresolved" title="unresolved reference to &quot;List.sort&quot;"><code>List</code>.sort</span> or <span class="xref-unresolved" title="unresolved reference to &quot;List.stable_sort&quot;"><code>List</code>.stable_sort</span>, whichever is faster on typical input.</p></dd></dl><dl><dt class="spec value" id="val-sort_uniq"><a href="#val-sort_uniq" class="anchor"></a><code><span class="keyword">val</span> sort_uniq : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> int) <span>&#45;&gt;</span> <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'a</span> list</code></dt><dd><p>Same as <span class="xref-unresolved" title="unresolved reference to &quot;List.sort&quot;"><code>List</code>.sort</span>, but also remove duplicates.</p><dl><dt>since</dt><dd>4.02.0</dd></dl></dd></dl><dl><dt class="spec value" id="val-merge"><a href="#val-merge" class="anchor"></a><code><span class="keyword">val</span> merge : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> int) <span>&#45;&gt;</span> <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'a</span> list</code></dt><dd><p>Merge two lists: Assuming that <code>l1</code> and <code>l2</code> are sorted according to the comparison function <code>cmp</code>, <code>merge cmp l1 l2</code> will return a sorted list containing all the elements of <code>l1</code> and <code>l2</code>. If several elements compare equal, the elements of <code>l1</code> will be before the elements of <code>l2</code>. Not tail-recursive (sum of the lengths of the arguments).</p></dd></dl><section><header><h6 id="iterators"><a href="#iterators" class="anchor"></a>Iterators</h6></header><dl><dt class="spec value" id="val-to_seq"><a href="#val-to_seq" class="anchor"></a><code><span class="keyword">val</span> to_seq : <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="../../ocaml/Stdlib/Seq/index.html#type-t">Stdlib.Seq.t</a></code></dt><dd><p>Iterate on the list</p><dl><dt>since</dt><dd>4.07</dd></dl></dd></dl><dl><dt class="spec value" id="val-of_seq"><a href="#val-of_seq" class="anchor"></a><code><span class="keyword">val</span> of_seq : <span class="type-var">'a</span> <a href="../../ocaml/Stdlib/Seq/index.html#type-t">Stdlib.Seq.t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> list</code></dt><dd><p>Create a list from the iterator</p><dl><dt>since</dt><dd>4.07</dd></dl></dd></dl></section></section></details></div></div></div><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> 'a t</code><code> = <span class="type-var">'a</span> list</code></dt></dl><dl><dt class="spec value" id="val-empty"><a href="#val-empty" class="anchor"></a><code><span class="keyword">val</span> empty : <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>empty</code> is <code>[]</code>.</p></dd></dl><dl><dt class="spec value" id="val-is_empty"><a href="#val-is_empty" class="anchor"></a><code><span class="keyword">val</span> is_empty : <span class="type-var">_</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>is_empty l</code> returns <code>true</code> iff <code>l = []</code>.</p><dl><dt>since</dt><dd>0.11</dd></dl></dd></dl><dl><dt class="spec value" id="val-map"><a href="#val-map" class="anchor"></a><code><span class="keyword">val</span> map : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Safe version of <span class="xref-unresolved" title="unresolved reference to &quot;List.map&quot;"><code>List</code>.map</span>.</p></dd></dl><dl><dt class="spec value" id="val-(&gt;|=)"><a href="#val-(&gt;|=)" class="anchor"></a><code><span class="keyword">val</span> (&gt;|=) : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>) <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Infix version of <code>map</code> with reversed arguments.</p><dl><dt>since</dt><dd>0.5</dd></dl></dd></dl><dl><dt class="spec value" id="val-cons"><a href="#val-cons" class="anchor"></a><code><span class="keyword">val</span> cons : <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>cons x l</code> is <code>x::l</code>.</p><dl><dt>since</dt><dd>0.12</dd></dl></dd></dl><dl><dt class="spec value" id="val-append"><a href="#val-append" class="anchor"></a><code><span class="keyword">val</span> append : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Safe version of <span class="xref-unresolved" title="unresolved reference to &quot;List.append&quot;"><code>List</code>.append</span>. Concatenate two lists.</p></dd></dl><dl><dt class="spec value" id="val-cons_maybe"><a href="#val-cons_maybe" class="anchor"></a><code><span class="keyword">val</span> cons_maybe : <span class="type-var">'a</span> option <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>cons_maybe (Some x) l</code> is <code>x :: l</code>. <code>cons_maybe None l</code> is <code>l</code>.</p><dl><dt>since</dt><dd>0.13</dd></dl></dd></dl><dl><dt class="spec value" id="val-(@)"><a href="#val-(@)" class="anchor"></a><code><span class="keyword">val</span> (@) : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Like <code>append</code>. Concatenate two lists.</p></dd></dl><dl><dt class="spec value" id="val-filter"><a href="#val-filter" class="anchor"></a><code><span class="keyword">val</span> filter : (<span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Safe version of <span class="xref-unresolved" title="unresolved reference to &quot;List.filter&quot;"><code>List</code>.filter</span>. <code>filter p l</code> returns all the elements of the list <code>l</code> that satisfy the predicate <code>p</code>. The order of the elements in the input list is preserved.</p></dd></dl><dl><dt class="spec value" id="val-fold_right"><a href="#val-fold_right" class="anchor"></a><code><span class="keyword">val</span> fold_right : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'b</span></code></dt><dd><p>Safe version of <code>fold_right</code>. <code>fold_right f [a1; ...; an] b</code> is <code>f a1 (f a2 (... (f an b) ...))</code>.</p></dd></dl><dl><dt class="spec value" id="val-fold_while"><a href="#val-fold_while" class="anchor"></a><code><span class="keyword">val</span> fold_while : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> * [ `Stop | `Continue ]) <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p>Fold until a stop condition via <code>('a, `Stop)</code> is indicated by the accumulator.</p><dl><dt>since</dt><dd>0.8</dd></dl></dd></dl><dl><dt class="spec value" id="val-fold_map"><a href="#val-fold_map" class="anchor"></a><code><span class="keyword">val</span> fold_map : (<span class="type-var">'acc</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'acc</span> * <span class="type-var">'b</span>) <span>&#45;&gt;</span> <span class="type-var">'acc</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'acc</span> * <span class="type-var">'b</span> list</code></dt><dd><p><code>fold_map f init l</code> is a <code>fold_left</code>-like function, but it also maps the list to another list.</p><dl><dt>since</dt><dd>0.14</dd></dl></dd></dl><dl><dt class="spec value" id="val-scan_left"><a href="#val-scan_left" class="anchor"></a><code><span class="keyword">val</span> scan_left : (<span class="type-var">'acc</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'acc</span>) <span>&#45;&gt;</span> <span class="type-var">'acc</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'acc</span> list</code></dt><dd><p><code>scan_left f init l</code> returns the list <code>[init; f init x0; f (f init x0) x1; ...]</code> where <code>x0</code>, <code>x1</code>, etc. are the elements of <code>l</code>.</p><dl><dt>since</dt><dd>1.2, but only</dd></dl><dl><dt>since</dt><dd>2.2 with labels</dd></dl></dd></dl><dl><dt class="spec value" id="val-fold_map2"><a href="#val-fold_map2" class="anchor"></a><code><span class="keyword">val</span> fold_map2 : (<span class="type-var">'acc</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'acc</span> * <span class="type-var">'c</span>) <span>&#45;&gt;</span> <span class="type-var">'acc</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'b</span> list <span>&#45;&gt;</span> <span class="type-var">'acc</span> * <span class="type-var">'c</span> list</code></dt><dd><p><code>fold_map2</code> is to <code>fold_map</code> what <code>List.map2</code> is to <code>List.map</code>.</p><dl><dt>raises Invalid_argument</dt><dd><p>if the lists do not have the same length.</p></dd></dl><dl><dt>since</dt><dd>0.16</dd></dl></dd></dl><dl><dt class="spec value" id="val-fold_filter_map"><a href="#val-fold_filter_map" class="anchor"></a><code><span class="keyword">val</span> fold_filter_map : (<span class="type-var">'acc</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'acc</span> * <span class="type-var">'b</span> option) <span>&#45;&gt;</span> <span class="type-var">'acc</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'acc</span> * <span class="type-var">'b</span> list</code></dt><dd><p><code>fold_filter_map f init l</code> is a <code>fold_left</code>-like function, but also generates a list of output in a way similar to <a href="index.html#val-filter_map"><code>filter_map</code></a>.</p><dl><dt>since</dt><dd>0.17</dd></dl></dd></dl><dl><dt class="spec value" id="val-fold_flat_map"><a href="#val-fold_flat_map" class="anchor"></a><code><span class="keyword">val</span> fold_flat_map : (<span class="type-var">'acc</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'acc</span> * <span class="type-var">'b</span> list) <span>&#45;&gt;</span> <span class="type-var">'acc</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'acc</span> * <span class="type-var">'b</span> list</code></dt><dd><p><code>fold_flat_map f acc l</code> is a <code>fold_left</code>-like function, but it also maps the list to a list of lists that is then <code>flatten</code>'d.</p><dl><dt>since</dt><dd>0.14</dd></dl></dd></dl><dl><dt class="spec value" id="val-count"><a href="#val-count" class="anchor"></a><code><span class="keyword">val</span> count : (<span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <span class="type-var">'a</span> list <span>&#45;&gt;</span> int</code></dt><dd><p><code>count p l</code> counts how many elements of <code>l</code> satisfy predicate <code>p</code>.</p><dl><dt>since</dt><dd>1.5, but only</dd></dl><dl><dt>since</dt><dd>2.2 with labels</dd></dl></dd></dl><dl><dt class="spec value" id="val-count_true_false"><a href="#val-count_true_false" class="anchor"></a><code><span class="keyword">val</span> count_true_false : (<span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <span class="type-var">'a</span> list <span>&#45;&gt;</span> int * int</code></dt><dd><dl><dt>since</dt><dd>2.4</dd></dl></dd></dl><dl><dt class="spec value" id="val-init"><a href="#val-init" class="anchor"></a><code><span class="keyword">val</span> init : int <span>&#45;&gt;</span> (int <span>&#45;&gt;</span> <span class="type-var">'a</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>init len f</code> is <code>f 0; f 1; ...; f (len-1)</code>.</p><dl><dt>raises Invalid_argument</dt><dd><p>if len &lt; 0.</p></dd></dl><dl><dt>since</dt><dd>0.6</dd></dl></dd></dl><dl><dt class="spec value" id="val-combine"><a href="#val-combine" class="anchor"></a><code><span class="keyword">val</span> combine : <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'b</span> list <span>&#45;&gt;</span> (<span class="type-var">'a</span> * <span class="type-var">'b</span>) list</code></dt><dd><p>Like <span class="xref-unresolved" title="unresolved reference to &quot;List.combine&quot;"><code>List</code>.combine</span> but tail-recursive. Transform a pair of lists into a list of pairs: <code>combine [a1; ...; an] [b1; ...; bn]</code> is <code>[(a1,b1); ...; (an,bn)]</code>.</p><dl><dt>raises Invalid_argument</dt><dd><p>if the lists have distinct lengths.</p></dd></dl><dl><dt>since</dt><dd>1.2, but only</dd></dl><dl><dt>since</dt><dd>2.2 with labels</dd></dl></dd></dl><dl><dt class="spec value" id="val-combine_gen"><a href="#val-combine_gen" class="anchor"></a><code><span class="keyword">val</span> combine_gen : <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'b</span> list <span>&#45;&gt;</span> (<span class="type-var">'a</span> * <span class="type-var">'b</span>) <a href="index.html#type-gen">gen</a></code></dt><dd><p>Lazy version of <a href="index.html#val-combine"><code>combine</code></a>. Unlike <a href="index.html#val-combine"><code>combine</code></a>, it does not fail if the lists have different lengths; instead, the output has as many pairs as the smallest input list.</p><dl><dt>since</dt><dd>1.2, but only</dd></dl><dl><dt>since</dt><dd>2.2 with labels</dd></dl></dd></dl><dl><dt class="spec value" id="val-split"><a href="#val-split" class="anchor"></a><code><span class="keyword">val</span> split : (<span class="type-var">'a</span> * <span class="type-var">'b</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> * <span class="type-var">'b</span> <a href="index.html#type-t">t</a></code></dt><dd><p>A tail-recursive version of <span class="xref-unresolved" title="unresolved reference to &quot;List.split&quot;"><code>List</code>.split</span>. Transform a list of pairs into a pair of lists: <code>split [(a1,b1); ...; (an,bn)]</code> is <code>([a1; ...; an], [b1; ...; bn])</code>.</p><dl><dt>since</dt><dd>1.2, but only</dd></dl><dl><dt>since</dt><dd>2.2 with labels</dd></dl></dd></dl><dl><dt class="spec value" id="val-compare"><a href="#val-compare" class="anchor"></a><code><span class="keyword">val</span> compare : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> int) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int</code></dt><dt class="spec value" id="val-compare_lengths"><a href="#val-compare_lengths" class="anchor"></a><code><span class="keyword">val</span> compare_lengths : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int</code></dt><dd><p>Equivalent to <code>compare (length l1) (length l2)</code> but more efficient. Compare the lengths of two lists.</p><dl><dt>since</dt><dd>1.5, but only</dd></dl><dl><dt>since</dt><dd>2.2 with labels</dd></dl></dd></dl><dl><dt class="spec value" id="val-compare_length_with"><a href="#val-compare_length_with" class="anchor"></a><code><span class="keyword">val</span> compare_length_with : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int</code></dt><dd><p>Equivalent to <code>compare (length l) x</code> but more efficient. Compare the length of a list to an integer.</p><dl><dt>since</dt><dd>1.5, but only</dd></dl><dl><dt>since</dt><dd>2.2 with labels</dd></dl></dd></dl><dl><dt class="spec value" id="val-equal"><a href="#val-equal" class="anchor"></a><code><span class="keyword">val</span> equal : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dt class="spec value" id="val-flat_map"><a href="#val-flat_map" class="anchor"></a><code><span class="keyword">val</span> flat_map : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Map and flatten at the same time (safe). Evaluation order is not guaranteed.</p></dd></dl><dl><dt class="spec value" id="val-flatten"><a href="#val-flatten" class="anchor"></a><code><span class="keyword">val</span> flatten : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Safe flatten. Concatenate a list of lists.</p></dd></dl><dl><dt class="spec value" id="val-product"><a href="#val-product" class="anchor"></a><code><span class="keyword">val</span> product : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'c</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'c</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Cartesian product of the two lists, with the given combinator.</p></dd></dl><dl><dt class="spec value" id="val-fold_product"><a href="#val-fold_product" class="anchor"></a><code><span class="keyword">val</span> fold_product : (<span class="type-var">'c</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'c</span>) <span>&#45;&gt;</span> <span class="type-var">'c</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'c</span></code></dt><dd><p>Fold on the cartesian product.</p></dd></dl><dl><dt class="spec value" id="val-cartesian_product"><a href="#val-cartesian_product" class="anchor"></a><code><span class="keyword">val</span> cartesian_product : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <a href="index.html#type-t">t</a></code></dt><dd><p>Produce the cartesian product of this list of lists, by returning all the ways of picking one element per sublist. <b>NOTE</b> the order of the returned list is unspecified. For example:</p><pre><code class="ml"># cartesian_product [[1;2];[3];[4;5;6]] |&gt; sort =
[[1;3;4];[1;3;5];[1;3;6];[2;3;4];[2;3;5];[2;3;6]];;
# cartesian_product [[1;2];[];[4;5;6]] = [];;
# cartesian_product [[1;2];[3];[4];[5];[6]] |&gt; sort =
[[1;3;4;5;6];[2;3;4;5;6]];;</code></pre><p>invariant: <code>cartesian_product l = map_product id l</code>.</p><dl><dt>since</dt><dd>1.2, but only</dd></dl><dl><dt>since</dt><dd>2.2 with labels</dd></dl></dd></dl><dl><dt class="spec value" id="val-map_product_l"><a href="#val-map_product_l" class="anchor"></a><code><span class="keyword">val</span> map_product_l : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> list) <span>&#45;&gt;</span> <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'b</span> list list</code></dt><dd><p><code>map_product_l f l</code> maps each element of <code>l</code> to a list of objects of type <code>'b</code> using <code>f</code>. We obtain <code>[l1;l2;...;ln]</code> where <code>length l=n</code> and <code>li : 'b list</code>. Then, it returns all the ways of picking exactly one element per <code>li</code>.</p><dl><dt>since</dt><dd>1.2, but only</dd></dl><dl><dt>since</dt><dd>2.2 with labels</dd></dl></dd></dl><dl><dt class="spec value" id="val-diagonal"><a href="#val-diagonal" class="anchor"></a><code><span class="keyword">val</span> diagonal : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span> * <span class="type-var">'a</span>) <a href="index.html#type-t">t</a></code></dt><dd><p>All pairs of distinct positions of the list. <code>list_diagonal l</code> will return the list of <code>List.nth i l, List.nth j l</code> if <code>i &lt; j</code>.</p></dd></dl><dl><dt class="spec value" id="val-partition_map"><a href="#val-partition_map" class="anchor"></a><code><span class="keyword">val</span> partition_map : (<span class="type-var">'a</span> <span>&#45;&gt;</span> [&lt; `Left of <span class="type-var">'b</span> | `Right of <span class="type-var">'c</span> | `Drop ]) <span>&#45;&gt;</span> <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'b</span> list * <span class="type-var">'c</span> list</code></dt><dd><p><code>partition_map f l</code> maps <code>f</code> on <code>l</code> and gather results in lists:</p><ul><li>if <code>f x = `Left y</code>, adds <code>y</code> to the first list.</li><li>if <code>f x = `Right z</code>, adds <code>z</code> to the second list.</li><li>if <code>f x = `Drop</code>, ignores <code>x</code>.</li></ul><dl><dt>since</dt><dd>0.11</dd></dl></dd></dl><dl><dt class="spec value" id="val-group_by"><a href="#val-group_by" class="anchor"></a><code><span class="keyword">val</span> group_by : ?&#8288;hash:(<span class="type-var">'a</span> <span>&#45;&gt;</span> int) <span>&#45;&gt;</span> ?&#8288;eq:(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> list <a href="index.html#type-t">t</a></code></dt><dd><p>Group equal elements, regardless of their order of appearance. precondition: for any <code>x</code> and <code>y</code>, if <code>eq x y</code> then <code>hash x=hash y</code> must hold.</p><dl><dt>since</dt><dd>2.3</dd></dl></dd></dl><dl><dt class="spec value" id="val-join"><a href="#val-join" class="anchor"></a><code><span class="keyword">val</span> join : join_row:(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'c</span> option) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'c</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>join ~join_row a b</code> combines every element of <code>a</code> with every element of <code>b</code> using <code>join_row</code>. If <code>join_row</code> returns None, then the two elements do not combine. Assume that <code>b</code> allows for multiple iterations.</p><dl><dt>since</dt><dd>2.3</dd></dl></dd></dl><dl><dt class="spec value" id="val-join_by"><a href="#val-join_by" class="anchor"></a><code><span class="keyword">val</span> join_by : ?&#8288;eq:(<span class="type-var">'key</span> <span>&#45;&gt;</span> <span class="type-var">'key</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> ?&#8288;hash:(<span class="type-var">'key</span> <span>&#45;&gt;</span> int) <span>&#45;&gt;</span> (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'key</span>) <span>&#45;&gt;</span> (<span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'key</span>) <span>&#45;&gt;</span> merge:(<span class="type-var">'key</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'c</span> option) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'c</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>join key1 key2 ~merge</code> is a binary operation that takes two sequences <code>a</code> and <code>b</code>, projects their elements resp. with <code>key1</code> and <code>key2</code>, and combine values <code>(x,y)</code> from <code>(a,b)</code> with the same <code>key</code> using <code>merge</code>. If <code>merge</code> returns <code>None</code>, the combination of values is discarded. precondition: for any <code>x</code> and <code>y</code>, if <code>eq x y</code> then <code>hash x=hash y</code> must hold.</p><dl><dt>since</dt><dd>2.3</dd></dl></dd></dl><dl><dt class="spec value" id="val-join_all_by"><a href="#val-join_all_by" class="anchor"></a><code><span class="keyword">val</span> join_all_by : ?&#8288;eq:(<span class="type-var">'key</span> <span>&#45;&gt;</span> <span class="type-var">'key</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> ?&#8288;hash:(<span class="type-var">'key</span> <span>&#45;&gt;</span> int) <span>&#45;&gt;</span> (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'key</span>) <span>&#45;&gt;</span> (<span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'key</span>) <span>&#45;&gt;</span> merge:(<span class="type-var">'key</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'b</span> list <span>&#45;&gt;</span> <span class="type-var">'c</span> option) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'c</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>join_all_by key1 key2 ~merge</code> is a binary operation that takes two sequences <code>a</code> and <code>b</code>, projects their elements resp. with <code>key1</code> and <code>key2</code>, and, for each key <code>k</code> occurring in at least one of them:</p><ul><li>compute the list <code>l1</code> of elements of <code>a</code> that map to <code>k</code></li><li>compute the list <code>l2</code> of elements of <code>b</code> that map to <code>k</code></li><li>call <code>merge k l1 l2</code>. If <code>merge</code> returns <code>None</code>, the combination of values is discarded, otherwise it returns <code>Some c</code> and <code>c</code> is inserted in the result.</li></ul><dl><dt>since</dt><dd>2.3</dd></dl></dd></dl><dl><dt class="spec value" id="val-group_join_by"><a href="#val-group_join_by" class="anchor"></a><code><span class="keyword">val</span> group_join_by : ?&#8288;eq:(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> ?&#8288;hash:(<span class="type-var">'a</span> <span>&#45;&gt;</span> int) <span>&#45;&gt;</span> (<span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'a</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span> * <span class="type-var">'b</span> list) <a href="index.html#type-t">t</a></code></dt><dd><p><code>group_join_by key2</code> associates to every element <code>x</code> of the first sequence, all the elements <code>y</code> of the second sequence such that <code>eq x (key y)</code>. Elements of the first sequences without corresponding values in the second one are mapped to <code>[]</code> precondition: for any <code>x</code> and <code>y</code>, if <code>eq x y</code> then <code>hash x=hash y</code> must hold.</p><dl><dt>since</dt><dd>2.3</dd></dl></dd></dl><dl><dt class="spec value" id="val-sublists_of_len"><a href="#val-sublists_of_len" class="anchor"></a><code><span class="keyword">val</span> sublists_of_len : ?&#8288;last:(<span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'a</span> list option) <span>&#45;&gt;</span> ?&#8288;offset:int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'a</span> list list</code></dt><dd><p><code>sublists_of_len n l</code> returns sub-lists of <code>l</code> that have length <code>n</code>. By default, these sub-lists are non overlapping: <code>sublists_of_len 2 [1;2;3;4;5;6]</code> returns <code>[1;2]; [3;4]; [5;6]</code>.</p><p>Examples:</p><ul><li><code>sublists_of_len 2 [1;2;3;4;5;6] = [[1;2]; [3;4]; [5;6]]</code>.</li><li><code>sublists_of_len 2 ~offset:3 [1;2;3;4;5;6] = [1;2];[4;5]</code>.</li><li><code>sublists_of_len 3 ~last:CCOpt.return [1;2;3;4] = [1;2;3];[4]</code>.</li><li><code>sublists_of_len 2 [1;2;3;4;5] = [[1;2]; [3;4]]</code>.</li></ul><dl><dt>parameter offset</dt><dd><p>the number of elements skipped between two consecutive sub-lists. By default it is <code>n</code>. If <code>offset &lt; n</code>, the sub-lists will overlap; if <code>offset &gt; n</code>, some elements will not appear at all.</p></dd></dl><dl><dt>parameter last</dt><dd><p>if provided and the last group of elements <code>g</code> is such that <code>length g &lt; n</code>, <code>last g</code> is called. If <code>last g = Some g'</code>, <code>g'</code> is appended; otherwise <code>g</code> is dropped. If <code>last = CCOpt.return</code>, it will simply keep the last group. By default, <code>last = fun _ -&gt; None</code>, i.e. the last group is dropped if shorter than <code>n</code>.</p></dd></dl><dl><dt>raises Invalid_argument</dt><dd><p>if <code>offset &lt;= 0</code> or <code>n &lt;= 0</code>. See <a href="index.html#val-sublists_of_len"><code>CCList.sublists_of_len</code></a> for more details.</p></dd></dl><dl><dt>since</dt><dd>1.0, but only</dd></dl><dl><dt>since</dt><dd>1.5 with labels</dd></dl></dd></dl><dl><dt class="spec value" id="val-intersperse"><a href="#val-intersperse" class="anchor"></a><code><span class="keyword">val</span> intersperse : <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'a</span> list</code></dt><dd><p>Insert the first argument between every element of the list.</p><dl><dt>since</dt><dd>2.1, but only</dd></dl><dl><dt>since</dt><dd>2.2 with labels</dd></dl></dd></dl><dl><dt class="spec value" id="val-interleave"><a href="#val-interleave" class="anchor"></a><code><span class="keyword">val</span> interleave : <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'a</span> list</code></dt><dd><p><code>interleave [x1â€¦xn] [y1â€¦ym]</code> is <code>x1,y1,x2,y2,â€¦</code> and finishes with the suffix of the longest list.</p><dl><dt>since</dt><dd>2.1, but only</dd></dl><dl><dt>since</dt><dd>2.2 with labels</dd></dl></dd></dl><dl><dt class="spec value" id="val-pure"><a href="#val-pure" class="anchor"></a><code><span class="keyword">val</span> pure : <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>pure</code> is <code>return</code>.</p></dd></dl><dl><dt class="spec value" id="val-(&lt;*&gt;)"><a href="#val-(&lt;*&gt;)" class="anchor"></a><code><span class="keyword">val</span> (&lt;*&gt;) : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>funs &lt;*&gt; l</code> is <code>product (fun f x -&gt; f x) funs l</code>.</p></dd></dl><dl><dt class="spec value" id="val-(&lt;$&gt;)"><a href="#val-(&lt;$&gt;)" class="anchor"></a><code><span class="keyword">val</span> (&lt;$&gt;) : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>(&lt;$&gt;)</code> is <code>map</code>.</p></dd></dl><dl><dt class="spec value" id="val-return"><a href="#val-return" class="anchor"></a><code><span class="keyword">val</span> return : <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>return x</code> is <code>x</code>.</p></dd></dl><dl><dt class="spec value" id="val-(&gt;&gt;=)"><a href="#val-(&gt;&gt;=)" class="anchor"></a><code><span class="keyword">val</span> (&gt;&gt;=) : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a>) <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>l &gt;&gt;= f</code> is <code>flat_map f l</code>.</p></dd></dl><dl><dt class="spec value" id="val-take"><a href="#val-take" class="anchor"></a><code><span class="keyword">val</span> take : int <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Take the <code>n</code> first elements, drop the rest.</p></dd></dl><dl><dt class="spec value" id="val-drop"><a href="#val-drop" class="anchor"></a><code><span class="keyword">val</span> drop : int <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Drop the <code>n</code> first elements, keep the rest.</p></dd></dl><dl><dt class="spec value" id="val-hd_tl"><a href="#val-hd_tl" class="anchor"></a><code><span class="keyword">val</span> hd_tl : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> * <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>hd_tl (x :: l)</code> returns <code>hd, l</code>.</p><dl><dt>raises Failure</dt><dd><p>if the list is empty.</p></dd></dl><dl><dt>since</dt><dd>0.16</dd></dl></dd></dl><dl><dt class="spec value" id="val-take_drop"><a href="#val-take_drop" class="anchor"></a><code><span class="keyword">val</span> take_drop : int <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> * <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>take_drop n l</code> returns <code>l1, l2</code> such that <code>l1 @ l2 = l</code> and <code>length l1 = min (length l) n</code>.</p></dd></dl><dl><dt class="spec value" id="val-take_while"><a href="#val-take_while" class="anchor"></a><code><span class="keyword">val</span> take_while : (<span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>take_while f l</code> returns the longest prefix of <code>l</code> for which <code>f</code> is <code>true</code>.</p><dl><dt>since</dt><dd>0.13</dd></dl></dd></dl><dl><dt class="spec value" id="val-drop_while"><a href="#val-drop_while" class="anchor"></a><code><span class="keyword">val</span> drop_while : (<span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>drop_while f l</code> drops the longest prefix of <code>l</code> for which <code>f</code> is <code>true</code>.</p><dl><dt>since</dt><dd>0.13</dd></dl></dd></dl><dl><dt class="spec value" id="val-take_drop_while"><a href="#val-take_drop_while" class="anchor"></a><code><span class="keyword">val</span> take_drop_while : (<span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> * <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>take_drop_while p l</code> = <code>take_while p l, drop_while p l</code>.</p><dl><dt>since</dt><dd>1.2, but only</dd></dl><dl><dt>since</dt><dd>2.2 with labels</dd></dl></dd></dl><dl><dt class="spec value" id="val-last"><a href="#val-last" class="anchor"></a><code><span class="keyword">val</span> last : int <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>last n l</code> takes the last <code>n</code> elements of <code>l</code> (or less if <code>l</code> doesn't have that many elements).</p></dd></dl><dl><dt class="spec value" id="val-head_opt"><a href="#val-head_opt" class="anchor"></a><code><span class="keyword">val</span> head_opt : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> option</code></dt><dd><p>First element.</p><dl><dt>since</dt><dd>0.20</dd></dl></dd></dl><dl><dt class="spec value" id="val-tail_opt"><a href="#val-tail_opt" class="anchor"></a><code><span class="keyword">val</span> tail_opt : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> option</code></dt><dd><p>Return the given list without its first element.</p><dl><dt>since</dt><dd>2.0</dd></dl></dd></dl><dl><dt class="spec value" id="val-last_opt"><a href="#val-last_opt" class="anchor"></a><code><span class="keyword">val</span> last_opt : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> option</code></dt><dd><p>Last element.</p><dl><dt>since</dt><dd>0.20</dd></dl></dd></dl><dl><dt class="spec value" id="val-find_pred"><a href="#val-find_pred" class="anchor"></a><code><span class="keyword">val</span> find_pred : (<span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> option</code></dt><dd><p><code>find_pred p l</code> finds the first element of <code>l</code> that satisfies <code>p</code>, or returns <code>None</code> if no element satisfies <code>p</code>.</p><dl><dt>since</dt><dd>0.11</dd></dl></dd></dl><dl><dt class="spec value" id="val-find_opt"><a href="#val-find_opt" class="anchor"></a><code><span class="keyword">val</span> find_opt : (<span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> option</code></dt><dd><p>Safe version of <a href="index.html#val-find"><code>find</code></a>.</p><dl><dt>since</dt><dd>1.5, but only</dd></dl><dl><dt>since</dt><dd>2.2 with labels</dd></dl></dd></dl><dl><dt class="spec value" id="val-find_pred_exn"><a href="#val-find_pred_exn" class="anchor"></a><code><span class="keyword">val</span> find_pred_exn : (<span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p>Unsafe version of <a href="index.html#val-find_pred"><code>find_pred</code></a>.</p><dl><dt>raises Not_found</dt><dd><p>if no such element is found.</p></dd></dl><dl><dt>since</dt><dd>0.11</dd></dl></dd></dl><dl><dt class="spec value" id="val-find_map"><a href="#val-find_map" class="anchor"></a><code><span class="keyword">val</span> find_map : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> option) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> option</code></dt><dd><p><code>find_map f l</code> traverses <code>l</code>, applying <code>f</code> to each element. If for some element <code>x</code>, <code>f x = Some y</code>, then <code>Some y</code> is returned. Otherwise the call returns <code>None</code>.</p><dl><dt>since</dt><dd>0.11</dd></dl></dd></dl><dl><dt class="spec value" id="val-find_mapi"><a href="#val-find_mapi" class="anchor"></a><code><span class="keyword">val</span> find_mapi : (int <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> option) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> option</code></dt><dd><p>Like <a href="index.html#val-find_map"><code>find_map</code></a>, but also pass the index to the predicate function.</p><dl><dt>since</dt><dd>0.11</dd></dl></dd></dl><dl><dt class="spec value" id="val-find_idx"><a href="#val-find_idx" class="anchor"></a><code><span class="keyword">val</span> find_idx : (<span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (int * <span class="type-var">'a</span>) option</code></dt><dd><p><code>find_idx p x</code> returns <code>Some (i,x)</code> where <code>x</code> is the <code>i</code>-th element of <code>l</code>, and <code>p x</code> holds. Otherwise returns <code>None</code>.</p></dd></dl><dl><dt class="spec value" id="val-remove"><a href="#val-remove" class="anchor"></a><code><span class="keyword">val</span> remove : eq:(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> key:<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>remove ~key l</code> removes every instance of <code>key</code> from <code>l</code>. Tail-recursive.</p><dl><dt>parameter eq</dt><dd><p>equality function.</p></dd></dl><dl><dt>since</dt><dd>0.11</dd></dl></dd></dl><dl><dt class="spec value" id="val-filter_map"><a href="#val-filter_map" class="anchor"></a><code><span class="keyword">val</span> filter_map : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> option) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>filter_map f l</code> is the sublist of <code>l</code> containing only elements for which <code>f</code> returns <code>Some e</code>. Map and remove elements at the same time.</p></dd></dl><dl><dt class="spec value" id="val-keep_some"><a href="#val-keep_some" class="anchor"></a><code><span class="keyword">val</span> keep_some : <span class="type-var">'a</span> option <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>keep_some l</code> retains only elements of the form <code>Some x</code>. Like <code>filter_map CCFun.id</code>.</p><dl><dt>since</dt><dd>1.3, but only</dd></dl><dl><dt>since</dt><dd>2.2 with labels</dd></dl></dd></dl><dl><dt class="spec value" id="val-keep_ok"><a href="#val-keep_ok" class="anchor"></a><code><span class="keyword">val</span> keep_ok : (<span class="type-var">'a</span>,Â <span class="type-var">_</span>) <a href="../../result/Result/index.html#type-result">Result.result</a> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>keep_ok l</code> retains only elements of the form <code>Ok x</code>.</p><dl><dt>since</dt><dd>1.3, but only</dd></dl><dl><dt>since</dt><dd>2.2 with labels</dd></dl></dd></dl><dl><dt class="spec value" id="val-all_some"><a href="#val-all_some" class="anchor"></a><code><span class="keyword">val</span> all_some : <span class="type-var">'a</span> option <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> option</code></dt><dd><p><code>all_some l</code> returns <code>Some l'</code> if all elements of <code>l</code> are of the form <code>Some x</code>, or <code>None</code> otherwise.</p><dl><dt>since</dt><dd>1.3, but only</dd></dl><dl><dt>since</dt><dd>2.2 with labels</dd></dl></dd></dl><dl><dt class="spec value" id="val-all_ok"><a href="#val-all_ok" class="anchor"></a><code><span class="keyword">val</span> all_ok : (<span class="type-var">'a</span>,Â <span class="type-var">'err</span>) <a href="../../result/Result/index.html#type-result">Result.result</a> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span> <a href="index.html#type-t">t</a>,Â <span class="type-var">'err</span>) <a href="../../result/Result/index.html#type-result">Result.result</a></code></dt><dd><p><code>all_ok l</code> returns <code>Ok l'</code> if all elements of <code>l</code> are of the form <code>Ok x</code>, or <code>Error e</code> otherwise (with the first error met).</p><dl><dt>since</dt><dd>1.3, but only</dd></dl><dl><dt>since</dt><dd>2.2 with labels</dd></dl></dd></dl><dl><dt class="spec value" id="val-sorted_merge"><a href="#val-sorted_merge" class="anchor"></a><code><span class="keyword">val</span> sorted_merge : cmp:(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> int) <span>&#45;&gt;</span> <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'a</span> list</code></dt><dd><p>Merge elements from both sorted list.</p></dd></dl><dl><dt class="spec value" id="val-sort_uniq"><a href="#val-sort_uniq" class="anchor"></a><code><span class="keyword">val</span> sort_uniq : cmp:(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> int) <span>&#45;&gt;</span> <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'a</span> list</code></dt><dd><p>Sort the list and remove duplicate elements.</p></dd></dl><dl><dt class="spec value" id="val-sorted_merge_uniq"><a href="#val-sorted_merge_uniq" class="anchor"></a><code><span class="keyword">val</span> sorted_merge_uniq : cmp:(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> int) <span>&#45;&gt;</span> <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'a</span> list</code></dt><dd><p><code>sorted_merge_uniq l1 l2</code> merges the sorted lists <code>l1</code> and <code>l2</code> and removes duplicates.</p><dl><dt>since</dt><dd>0.10</dd></dl></dd></dl><dl><dt class="spec value" id="val-is_sorted"><a href="#val-is_sorted" class="anchor"></a><code><span class="keyword">val</span> is_sorted : cmp:(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> int) <span>&#45;&gt;</span> <span class="type-var">'a</span> list <span>&#45;&gt;</span> bool</code></dt><dd><p><code>is_sorted l</code> returns <code>true</code> iff <code>l</code> is sorted (according to given order).</p><dl><dt>parameter cmp</dt><dd><p>the comparison function (default <code>Pervasives.compare</code>).</p></dd></dl><dl><dt>since</dt><dd>0.17</dd></dl></dd></dl><dl><dt class="spec value" id="val-sorted_insert"><a href="#val-sorted_insert" class="anchor"></a><code><span class="keyword">val</span> sorted_insert : cmp:(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> int) <span>&#45;&gt;</span> ?&#8288;uniq:bool <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'a</span> list</code></dt><dd><p><code>sorted_insert x l</code> inserts <code>x</code> into <code>l</code> such that, if <code>l</code> was sorted, then <code>sorted_insert x l</code> is sorted too.</p><dl><dt>parameter uniq</dt><dd><p>if true and <code>x</code> is already in sorted position in <code>l</code>, then <code>x</code> is not duplicated. Default <code>false</code> (<code>x</code> will be inserted in any case).</p></dd></dl><dl><dt>since</dt><dd>0.17</dd></dl></dd></dl><dl><dt class="spec value" id="val-uniq_succ"><a href="#val-uniq_succ" class="anchor"></a><code><span class="keyword">val</span> uniq_succ : eq:(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'a</span> list</code></dt><dd><p><code>uniq_succ l</code> removes duplicate elements that occur one next to the other. Examples: <code>uniq_succ [1;2;1] = [1;2;1]</code>. <code>uniq_succ [1;1;2] = [1;2]</code>.</p><dl><dt>since</dt><dd>0.10</dd></dl></dd></dl><dl><dt class="spec value" id="val-group_succ"><a href="#val-group_succ" class="anchor"></a><code><span class="keyword">val</span> group_succ : eq:(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'a</span> list list</code></dt><dd><p><code>group_succ ~eq l</code> groups together consecutive elements that are equal according to <code>eq</code>.</p><dl><dt>since</dt><dd>0.11</dd></dl></dd></dl><section><header><h3 id="indices"><a href="#indices" class="anchor"></a>Indices</h3></header><dl><dt class="spec value" id="val-mapi"><a href="#val-mapi" class="anchor"></a><code><span class="keyword">val</span> mapi : (int <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Like <a href="index.html#val-map"><code>map</code></a>, but the function is applied to the index of the element as first argument (counting from 0), and the element itself as second argument.</p></dd></dl><dl><dt class="spec value" id="val-iteri"><a href="#val-iteri" class="anchor"></a><code><span class="keyword">val</span> iteri : (int <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> unit) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Like <a href="index.html#val-iter"><code>iter</code></a>, but the function is applied to the index of the element as first argument (counting from 0), and the element itself as second argument.</p></dd></dl><dl><dt class="spec value" id="val-iteri2"><a href="#val-iteri2" class="anchor"></a><code><span class="keyword">val</span> iteri2 : (int <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> unit) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Iter on two lists.</p><dl><dt>raises Invalid_argument</dt><dd><p>when lists do not have the same length.</p></dd></dl><dl><dt>since</dt><dd>2.0, but only</dd></dl><dl><dt>since</dt><dd>2.2 with labels</dd></dl></dd></dl><dl><dt class="spec value" id="val-foldi"><a href="#val-foldi" class="anchor"></a><code><span class="keyword">val</span> foldi : (<span class="type-var">'b</span> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>) <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'b</span></code></dt><dd><p>Like <code>fold</code> but it also passes in the index of each element to the folded function. Tail-recursive.</p></dd></dl><dl><dt class="spec value" id="val-foldi2"><a href="#val-foldi2" class="anchor"></a><code><span class="keyword">val</span> foldi2 : (<span class="type-var">'c</span> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'c</span>) <span>&#45;&gt;</span> <span class="type-var">'c</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'c</span></code></dt><dd><p>Fold on two lists, with index.</p><dl><dt>raises Invalid_argument</dt><dd><p>when lists do not have the same length.</p></dd></dl><dl><dt>since</dt><dd>2.0, but only</dd></dl><dl><dt>since</dt><dd>2.2 with labels</dd></dl></dd></dl><dl><dt class="spec value" id="val-get_at_idx"><a href="#val-get_at_idx" class="anchor"></a><code><span class="keyword">val</span> get_at_idx : int <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> option</code></dt><dd><p>Get by index in the list. If the index is negative, it will get element starting from the end of the list.</p></dd></dl><dl><dt class="spec value" id="val-nth_opt"><a href="#val-nth_opt" class="anchor"></a><code><span class="keyword">val</span> nth_opt : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <span class="type-var">'a</span> option</code></dt><dd><p>Safe version of <a href="index.html#val-nth"><code>nth</code></a>.</p><dl><dt>raises Invalid_argument</dt><dd><p>if the int is negative.</p></dd></dl><dl><dt>since</dt><dd>1.5, but only</dd></dl><dl><dt>since</dt><dd>2.2 with labels</dd></dl></dd></dl><dl><dt class="spec value" id="val-get_at_idx_exn"><a href="#val-get_at_idx_exn" class="anchor"></a><code><span class="keyword">val</span> get_at_idx_exn : int <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p>Get the i-th element, or</p><dl><dt>raises Not_found</dt><dd><p>if the index is invalid. If the index is negative, it will get element starting from the end of the list.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-set_at_idx"><a href="#val-set_at_idx" class="anchor"></a><code><span class="keyword">val</span> set_at_idx : int <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Set i-th element (removes the old one), or does nothing if index is too high. If the index is negative, it will set element starting from the end of the list.</p></dd></dl><dl><dt class="spec value" id="val-insert_at_idx"><a href="#val-insert_at_idx" class="anchor"></a><code><span class="keyword">val</span> insert_at_idx : int <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Insert at i-th position, between the two existing elements. If the index is too high, append at the end of the list. If the index is negative, it will insert element starting from the end of the list.</p></dd></dl><dl><dt class="spec value" id="val-remove_at_idx"><a href="#val-remove_at_idx" class="anchor"></a><code><span class="keyword">val</span> remove_at_idx : int <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Remove element at given index. Does nothing if the index is too high. If the index is negative, it will remove element starting from the end of the list.</p></dd></dl></section><section><header><h3 id="set-operators"><a href="#set-operators" class="anchor"></a>Set Operators</h3><p>Those operations maintain the invariant that the list does not contain duplicates (if it already satisfies it).</p></header><dl><dt class="spec value" id="val-add_nodup"><a href="#val-add_nodup" class="anchor"></a><code><span class="keyword">val</span> add_nodup : eq:(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>add_nodup x set</code> adds <code>x</code> to <code>set</code> if it was not already present. Linear time.</p><dl><dt>since</dt><dd>0.11</dd></dl></dd></dl><dl><dt class="spec value" id="val-remove_one"><a href="#val-remove_one" class="anchor"></a><code><span class="keyword">val</span> remove_one : eq:(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>remove_one x set</code> removes one occurrence of <code>x</code> from <code>set</code>. Linear time.</p><dl><dt>since</dt><dd>0.11</dd></dl></dd></dl><dl><dt class="spec value" id="val-mem"><a href="#val-mem" class="anchor"></a><code><span class="keyword">val</span> mem : eq:(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p>Membership to the list. Linear time.</p></dd></dl><dl><dt class="spec value" id="val-subset"><a href="#val-subset" class="anchor"></a><code><span class="keyword">val</span> subset : eq:(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p>Test for inclusion.</p></dd></dl><dl><dt class="spec value" id="val-uniq"><a href="#val-uniq" class="anchor"></a><code><span class="keyword">val</span> uniq : eq:(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Remove duplicates w.r.t the equality predicate. Complexity is quadratic in the length of the list, but the order of elements is preserved. If you wish for a faster de-duplication but do not care about the order, use <a href="index.html#val-sort_uniq"><code>sort_uniq</code></a>.</p></dd></dl><dl><dt class="spec value" id="val-union"><a href="#val-union" class="anchor"></a><code><span class="keyword">val</span> union : eq:(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p>List union. Complexity is product of length of inputs.</p></dd></dl><dl><dt class="spec value" id="val-inter"><a href="#val-inter" class="anchor"></a><code><span class="keyword">val</span> inter : eq:(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p>List intersection. Complexity is product of length of inputs.</p></dd></dl></section><section><header><h3 id="other-constructors"><a href="#other-constructors" class="anchor"></a>Other Constructors</h3></header><dl><dt class="spec value" id="val-range_by"><a href="#val-range_by" class="anchor"></a><code><span class="keyword">val</span> range_by : step:int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int <a href="index.html#type-t">t</a></code></dt><dd><p><code>range_by ~step i j</code> iterates on integers from <code>i</code> to <code>j</code> included, where the difference between successive elements is <code>step</code>. Use a negative <code>step</code> for a decreasing list.</p><dl><dt>raises Invalid_argument</dt><dd><p>if <code>step=0</code>.</p></dd></dl><dl><dt>since</dt><dd>0.18</dd></dl></dd></dl><dl><dt class="spec value" id="val-range"><a href="#val-range" class="anchor"></a><code><span class="keyword">val</span> range : int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int <a href="index.html#type-t">t</a></code></dt><dd><p><code>range i j</code> iterates on integers from <code>i</code> to <code>j</code> included. It works both for decreasing and increasing ranges.</p></dd></dl><dl><dt class="spec value" id="val-range'"><a href="#val-range'" class="anchor"></a><code><span class="keyword">val</span> range' : int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int <a href="index.html#type-t">t</a></code></dt><dd><p>Like <a href="index.html#val-range"><code>range</code></a> but the second bound is excluded. For instance <code>range' 0 5 = [0;1;2;3;4]</code>.</p></dd></dl><dl><dt class="spec value" id="val-(--)"><a href="#val-(--)" class="anchor"></a><code><span class="keyword">val</span> (--) : int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int <a href="index.html#type-t">t</a></code></dt><dd><p>Infix alias for <code>range</code>.</p></dd></dl><dl><dt class="spec value" id="val-(--^)"><a href="#val-(--^)" class="anchor"></a><code><span class="keyword">val</span> (--^) : int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int <a href="index.html#type-t">t</a></code></dt><dd><p>Infix alias for <code>range'</code>.</p><dl><dt>since</dt><dd>0.17</dd></dl></dd></dl><dl><dt class="spec value" id="val-replicate"><a href="#val-replicate" class="anchor"></a><code><span class="keyword">val</span> replicate : int <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Replicate the given element <code>n</code> times.</p></dd></dl><dl><dt class="spec value" id="val-repeat"><a href="#val-repeat" class="anchor"></a><code><span class="keyword">val</span> repeat : int <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Concatenate the list with itself <code>n</code> times.</p></dd></dl></section><section><header><h3 id="association-lists"><a href="#association-lists" class="anchor"></a>Association Lists</h3></header><div class="spec module" id="module-Assoc"><a href="#module-Assoc" class="anchor"></a><code><span class="keyword">module</span> <a href="Assoc/index.html">Assoc</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><dl><dt class="spec value" id="val-assoc"><a href="#val-assoc" class="anchor"></a><code><span class="keyword">val</span> assoc : eq:(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> (<span class="type-var">'a</span> * <span class="type-var">'b</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'b</span></code></dt><dd><p>Like <code>Assoc.get_exn</code>.</p><dl><dt>since</dt><dd>2.0</dd></dl></dd></dl><dl><dt class="spec value" id="val-assoc_opt"><a href="#val-assoc_opt" class="anchor"></a><code><span class="keyword">val</span> assoc_opt : eq:(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> (<span class="type-var">'a</span> * <span class="type-var">'b</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> option</code></dt><dd><p>Like <code>Assoc.get</code>.</p><dl><dt>since</dt><dd>1.5, but only</dd></dl><dl><dt>since</dt><dd>2.0 with labels</dd></dl></dd></dl><dl><dt class="spec value" id="val-assq_opt"><a href="#val-assq_opt" class="anchor"></a><code><span class="keyword">val</span> assq_opt : <span class="type-var">'a</span> <span>&#45;&gt;</span> (<span class="type-var">'a</span> * <span class="type-var">'b</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> option</code></dt><dd><p>Safe version of <a href="index.html#val-assq"><code>assq</code></a>.</p><dl><dt>since</dt><dd>1.5, but only</dd></dl><dl><dt>since</dt><dd>2.0 with labels</dd></dl></dd></dl><dl><dt class="spec value" id="val-mem_assoc"><a href="#val-mem_assoc" class="anchor"></a><code><span class="keyword">val</span> mem_assoc : eq:(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> (<span class="type-var">'a</span> * <span class="type-var">_</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p>Like <code>Assoc.mem</code>.</p><dl><dt>since</dt><dd>2.0</dd></dl></dd></dl><dl><dt class="spec value" id="val-remove_assoc"><a href="#val-remove_assoc" class="anchor"></a><code><span class="keyword">val</span> remove_assoc : eq:(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> (<span class="type-var">'a</span> * <span class="type-var">'b</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span> * <span class="type-var">'b</span>) <a href="index.html#type-t">t</a></code></dt><dd><p>Like <code>Assoc.remove</code>.</p><dl><dt>since</dt><dd>2.0</dd></dl></dd></dl></section><section><header><h3 id="references-on-lists"><a href="#references-on-lists" class="anchor"></a>References on Lists</h3><dl><dt>since</dt><dd>0.3.3</dd></dl></header><div class="spec module" id="module-Ref"><a href="#module-Ref" class="anchor"></a><code><span class="keyword">module</span> <a href="Ref/index.html">Ref</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><dl><dt class="spec module-type" id="module-type-MONAD"><a href="#module-type-MONAD" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-MONAD/index.html">MONAD</a> = <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd></dd></dl><div class="spec module" id="module-Traverse"><a href="#module-Traverse" class="anchor"></a><code><span class="keyword">module</span> <a href="Traverse/index.html">Traverse</a> : <span class="keyword">functor</span> (<a href="Traverse/argument-1-M/index.html">M</a> : <a href="index.html#module-type-MONAD">MONAD</a>) <span>&#45;&gt;</span> <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div></section><section><header><h3 id="conversions"><a href="#conversions" class="anchor"></a>Conversions</h3></header><dl><dt class="spec value" id="val-random"><a href="#val-random" class="anchor"></a><code><span class="keyword">val</span> random : <span class="type-var">'a</span> <a href="index.html#type-random_gen">random_gen</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <a href="index.html#type-random_gen">random_gen</a></code></dt><dt class="spec value" id="val-random_non_empty"><a href="#val-random_non_empty" class="anchor"></a><code><span class="keyword">val</span> random_non_empty : <span class="type-var">'a</span> <a href="index.html#type-random_gen">random_gen</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <a href="index.html#type-random_gen">random_gen</a></code></dt><dt class="spec value" id="val-random_len"><a href="#val-random_len" class="anchor"></a><code><span class="keyword">val</span> random_len : int <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-random_gen">random_gen</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <a href="index.html#type-random_gen">random_gen</a></code></dt><dt class="spec value" id="val-random_choose"><a href="#val-random_choose" class="anchor"></a><code><span class="keyword">val</span> random_choose : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-random_gen">random_gen</a></code></dt><dd><p>Randomly choose an element in the list.</p><dl><dt>raises Not_found</dt><dd><p>if the list is empty.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-random_sequence"><a href="#val-random_sequence" class="anchor"></a><code><span class="keyword">val</span> random_sequence : <span class="type-var">'a</span> <a href="index.html#type-random_gen">random_gen</a> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <a href="index.html#type-random_gen">random_gen</a></code></dt><dt class="spec value" id="val-to_seq"><a href="#val-to_seq" class="anchor"></a><code><span class="keyword">val</span> to_seq : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-sequence">sequence</a></code></dt><dd><p>Return a <code>sequence</code> of the elements of the list.</p></dd></dl><dl><dt class="spec value" id="val-of_seq"><a href="#val-of_seq" class="anchor"></a><code><span class="keyword">val</span> of_seq : <span class="type-var">'a</span> <a href="index.html#type-sequence">sequence</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Build a list from a given <code>sequence</code>. In the result, elements appear in the same order as they did in the source <code>sequence</code>.</p></dd></dl><dl><dt class="spec value" id="val-to_gen"><a href="#val-to_gen" class="anchor"></a><code><span class="keyword">val</span> to_gen : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-gen">gen</a></code></dt><dd><p>Return a <code>gen</code> of the elements of the list.</p></dd></dl><dl><dt class="spec value" id="val-of_gen"><a href="#val-of_gen" class="anchor"></a><code><span class="keyword">val</span> of_gen : <span class="type-var">'a</span> <a href="index.html#type-gen">gen</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Build a list from a given <code>gen</code>. In the result, elements appear in the same order as they did in the source <code>gen</code>.</p></dd></dl><dl><dt class="spec value" id="val-to_klist"><a href="#val-to_klist" class="anchor"></a><code><span class="keyword">val</span> to_klist : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-klist">klist</a></code></dt><dd><p>Return a <code>klist</code> of the elements of the list.</p></dd></dl><dl><dt class="spec value" id="val-of_klist"><a href="#val-of_klist" class="anchor"></a><code><span class="keyword">val</span> of_klist : <span class="type-var">'a</span> <a href="index.html#type-klist">klist</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Build a list from a given <code>klist</code>. In the result, elements appear in the same order as they did in the source <code>klist</code>.</p></dd></dl></section><section><header><h3 id="infix-operators"><a href="#infix-operators" class="anchor"></a>Infix Operators</h3><p>It is convenient to <span class="xref-unresolved" title="unresolved reference to &quot;open CCList.Infix&quot;"><code>open CCList</code>.Infix</span> to access the infix operators without cluttering the scope too much.</p><dl><dt>since</dt><dd>0.16</dd></dl></header><div class="spec module" id="module-Infix"><a href="#module-Infix" class="anchor"></a><code><span class="keyword">module</span> <a href="Infix/index.html">Infix</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div></section><section><header><h3 id="io"><a href="#io" class="anchor"></a>IO</h3></header><dl><dt class="spec value" id="val-pp"><a href="#val-pp" class="anchor"></a><code><span class="keyword">val</span> pp : ?&#8288;start:string <span>&#45;&gt;</span> ?&#8288;stop:string <span>&#45;&gt;</span> ?&#8288;sep:string <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-printer">printer</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <a href="index.html#type-printer">printer</a></code></dt><dd><p>Print the contents of a list.</p></dd></dl></section></div></body></html>