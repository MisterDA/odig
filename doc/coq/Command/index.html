<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Command (coq.Command)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../index.html">coq</a> &#x00BB; Command</nav><h1>Module <code>Command</code></h1></header><dl><dt class="spec value" id="val-do_universe"><a href="#val-do_universe" class="anchor"></a><code><span class="keyword">val </span>do_universe : Decl_kinds.polymorphic <span>&#45;&gt;</span> Names.Id.t Loc.located list <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-do_constraint"><a href="#val-do_constraint" class="anchor"></a><code><span class="keyword">val </span>do_constraint : Decl_kinds.polymorphic <span>&#45;&gt;</span> (Misctypes.glob_level<span class="keyword"> * </span>Univ.constraint_type<span class="keyword"> * </span>Misctypes.glob_level) list <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-interp_definition"><a href="#val-interp_definition" class="anchor"></a><code><span class="keyword">val </span>interp_definition : Vernacexpr.lident list option <span>&#45;&gt;</span> Constrexpr.local_binder_expr list <span>&#45;&gt;</span> Decl_kinds.polymorphic <span>&#45;&gt;</span> Redexpr.red_expr option <span>&#45;&gt;</span> Constrexpr.constr_expr <span>&#45;&gt;</span> Constrexpr.constr_expr option <span>&#45;&gt;</span> Safe_typing.private_constants Entries.definition_entry<span class="keyword"> * </span>Evd.evar_map<span class="keyword"> * </span>Universes.universe_binders<span class="keyword"> * </span>Impargs.manual_implicits</code></dt><dt class="spec value" id="val-do_definition"><a href="#val-do_definition" class="anchor"></a><code><span class="keyword">val </span>do_definition : Names.Id.t <span>&#45;&gt;</span> Decl_kinds.definition_kind <span>&#45;&gt;</span> Vernacexpr.lident list option <span>&#45;&gt;</span> Constrexpr.local_binder_expr list <span>&#45;&gt;</span> Redexpr.red_expr option <span>&#45;&gt;</span> Constrexpr.constr_expr <span>&#45;&gt;</span> Constrexpr.constr_expr option <span>&#45;&gt;</span> unit Lemmas.declaration_hook <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-declare_assumption"><a href="#val-declare_assumption" class="anchor"></a><code><span class="keyword">val </span>declare_assumption : Vernacexpr.coercion_flag <span>&#45;&gt;</span> Decl_kinds.assumption_kind <span>&#45;&gt;</span> Term.types Univ.in_universe_context_set <span>&#45;&gt;</span> Universes.universe_binders <span>&#45;&gt;</span> Impargs.manual_implicits <span>&#45;&gt;</span> bool <span>&#45;&gt;</span> Vernacexpr.inline <span>&#45;&gt;</span> Names.variable Loc.located <span>&#45;&gt;</span> Globnames.global_reference<span class="keyword"> * </span>Univ.Instance.t<span class="keyword"> * </span>bool</code></dt><dt class="spec value" id="val-do_assumptions"><a href="#val-do_assumptions" class="anchor"></a><code><span class="keyword">val </span>do_assumptions : (Decl_kinds.locality<span class="keyword"> * </span>Decl_kinds.polymorphic<span class="keyword"> * </span>Decl_kinds.assumption_object_kind) <span>&#45;&gt;</span> Vernacexpr.inline <span>&#45;&gt;</span> (Vernacexpr.plident list<span class="keyword"> * </span>Constrexpr.constr_expr) Vernacexpr.with_coercion list <span>&#45;&gt;</span> bool</code></dt></dl><dl><dt class="spec type" id="type-structured_one_inductive_expr"><a href="#type-structured_one_inductive_expr" class="anchor"></a><code><span class="keyword">type </span>structured_one_inductive_expr</code><code><span class="keyword"> = </span></code><code>{</code><table class="record"><tr id="type-structured_one_inductive_expr.ind_name" class="anchored"><td class="def field"><a href="#type-structured_one_inductive_expr.ind_name" class="anchor"></a><code>ind_name : Names.Id.t;</code></td></tr><tr id="type-structured_one_inductive_expr.ind_univs" class="anchored"><td class="def field"><a href="#type-structured_one_inductive_expr.ind_univs" class="anchor"></a><code>ind_univs : Vernacexpr.lident list option;</code></td></tr><tr id="type-structured_one_inductive_expr.ind_arity" class="anchored"><td class="def field"><a href="#type-structured_one_inductive_expr.ind_arity" class="anchor"></a><code>ind_arity : Constrexpr.constr_expr;</code></td></tr><tr id="type-structured_one_inductive_expr.ind_lc" class="anchored"><td class="def field"><a href="#type-structured_one_inductive_expr.ind_lc" class="anchor"></a><code>ind_lc : (Names.Id.t<span class="keyword"> * </span>Constrexpr.constr_expr) list;</code></td></tr></table><code>}</code></dt><dt class="spec type" id="type-structured_inductive_expr"><a href="#type-structured_inductive_expr" class="anchor"></a><code><span class="keyword">type </span>structured_inductive_expr</code><code><span class="keyword"> = </span>Constrexpr.local_binder_expr list<span class="keyword"> * </span><a href="index.html#type-structured_one_inductive_expr">structured_one_inductive_expr</a> list</code></dt></dl><dl><dt class="spec value" id="val-extract_mutual_inductive_declaration_components"><a href="#val-extract_mutual_inductive_declaration_components" class="anchor"></a><code><span class="keyword">val </span>extract_mutual_inductive_declaration_components : (Vernacexpr.one_inductive_expr<span class="keyword"> * </span>Vernacexpr.decl_notation list) list <span>&#45;&gt;</span> <a href="index.html#type-structured_inductive_expr">structured_inductive_expr</a><span class="keyword"> * </span>Libnames.qualid list<span class="keyword"> * </span>Vernacexpr.decl_notation list</code></dt></dl><dl><dt class="spec type" id="type-one_inductive_impls"><a href="#type-one_inductive_impls" class="anchor"></a><code><span class="keyword">type </span>one_inductive_impls</code><code><span class="keyword"> = </span>Impargs.manual_implicits<span class="keyword"> * </span>Impargs.manual_implicits list</code></dt></dl><dl><dt class="spec value" id="val-interp_mutual_inductive"><a href="#val-interp_mutual_inductive" class="anchor"></a><code><span class="keyword">val </span>interp_mutual_inductive : <a href="index.html#type-structured_inductive_expr">structured_inductive_expr</a> <span>&#45;&gt;</span> Vernacexpr.decl_notation list <span>&#45;&gt;</span> Decl_kinds.cumulative_inductive_flag <span>&#45;&gt;</span> Decl_kinds.polymorphic <span>&#45;&gt;</span> Decl_kinds.private_flag <span>&#45;&gt;</span> Decl_kinds.recursivity_kind <span>&#45;&gt;</span> Entries.mutual_inductive_entry<span class="keyword"> * </span>Universes.universe_binders<span class="keyword"> * </span><a href="index.html#type-one_inductive_impls">one_inductive_impls</a> list</code></dt><dt class="spec value" id="val-declare_mutual_inductive_with_eliminations"><a href="#val-declare_mutual_inductive_with_eliminations" class="anchor"></a><code><span class="keyword">val </span>declare_mutual_inductive_with_eliminations : Entries.mutual_inductive_entry <span>&#45;&gt;</span> Universes.universe_binders <span>&#45;&gt;</span> <a href="index.html#type-one_inductive_impls">one_inductive_impls</a> list <span>&#45;&gt;</span> Names.mutual_inductive</code></dt><dt class="spec value" id="val-do_mutual_inductive"><a href="#val-do_mutual_inductive" class="anchor"></a><code><span class="keyword">val </span>do_mutual_inductive : (Vernacexpr.one_inductive_expr<span class="keyword"> * </span>Vernacexpr.decl_notation list) list <span>&#45;&gt;</span> Decl_kinds.cumulative_inductive_flag <span>&#45;&gt;</span> Decl_kinds.polymorphic <span>&#45;&gt;</span> Decl_kinds.private_flag <span>&#45;&gt;</span> Decl_kinds.recursivity_kind <span>&#45;&gt;</span> unit</code></dt></dl><dl><dt class="spec type" id="type-structured_fixpoint_expr"><a href="#type-structured_fixpoint_expr" class="anchor"></a><code><span class="keyword">type </span>structured_fixpoint_expr</code><code><span class="keyword"> = </span></code><code>{</code><table class="record"><tr id="type-structured_fixpoint_expr.fix_name" class="anchored"><td class="def field"><a href="#type-structured_fixpoint_expr.fix_name" class="anchor"></a><code>fix_name : Names.Id.t;</code></td></tr><tr id="type-structured_fixpoint_expr.fix_univs" class="anchored"><td class="def field"><a href="#type-structured_fixpoint_expr.fix_univs" class="anchor"></a><code>fix_univs : Vernacexpr.lident list option;</code></td></tr><tr id="type-structured_fixpoint_expr.fix_annot" class="anchored"><td class="def field"><a href="#type-structured_fixpoint_expr.fix_annot" class="anchor"></a><code>fix_annot : Names.Id.t Loc.located option;</code></td></tr><tr id="type-structured_fixpoint_expr.fix_binders" class="anchored"><td class="def field"><a href="#type-structured_fixpoint_expr.fix_binders" class="anchor"></a><code>fix_binders : Constrexpr.local_binder_expr list;</code></td></tr><tr id="type-structured_fixpoint_expr.fix_body" class="anchored"><td class="def field"><a href="#type-structured_fixpoint_expr.fix_body" class="anchor"></a><code>fix_body : Constrexpr.constr_expr option;</code></td></tr><tr id="type-structured_fixpoint_expr.fix_type" class="anchored"><td class="def field"><a href="#type-structured_fixpoint_expr.fix_type" class="anchor"></a><code>fix_type : Constrexpr.constr_expr;</code></td></tr></table><code>}</code></dt></dl><dl><dt class="spec value" id="val-extract_fixpoint_components"><a href="#val-extract_fixpoint_components" class="anchor"></a><code><span class="keyword">val </span>extract_fixpoint_components : bool <span>&#45;&gt;</span> (Vernacexpr.fixpoint_expr<span class="keyword"> * </span>Vernacexpr.decl_notation list) list <span>&#45;&gt;</span> <a href="index.html#type-structured_fixpoint_expr">structured_fixpoint_expr</a> list<span class="keyword"> * </span>Vernacexpr.decl_notation list</code></dt><dt class="spec value" id="val-extract_cofixpoint_components"><a href="#val-extract_cofixpoint_components" class="anchor"></a><code><span class="keyword">val </span>extract_cofixpoint_components : (Vernacexpr.cofixpoint_expr<span class="keyword"> * </span>Vernacexpr.decl_notation list) list <span>&#45;&gt;</span> <a href="index.html#type-structured_fixpoint_expr">structured_fixpoint_expr</a> list<span class="keyword"> * </span>Vernacexpr.decl_notation list</code></dt></dl><dl><dt class="spec type" id="type-recursive_preentry"><a href="#type-recursive_preentry" class="anchor"></a><code><span class="keyword">type </span>recursive_preentry</code><code><span class="keyword"> = </span>Names.Id.t list<span class="keyword"> * </span>Term.constr option list<span class="keyword"> * </span>Term.types list</code></dt></dl><dl><dt class="spec value" id="val-interp_fixpoint"><a href="#val-interp_fixpoint" class="anchor"></a><code><span class="keyword">val </span>interp_fixpoint : <a href="index.html#type-structured_fixpoint_expr">structured_fixpoint_expr</a> list <span>&#45;&gt;</span> Vernacexpr.decl_notation list <span>&#45;&gt;</span> <a href="index.html#type-recursive_preentry">recursive_preentry</a><span class="keyword"> * </span>Vernacexpr.lident list option<span class="keyword"> * </span>Evd.evar_universe_context<span class="keyword"> * </span>(EConstr.rel_context<span class="keyword"> * </span>Impargs.manual_implicits<span class="keyword"> * </span>int option) list</code></dt><dt class="spec value" id="val-interp_cofixpoint"><a href="#val-interp_cofixpoint" class="anchor"></a><code><span class="keyword">val </span>interp_cofixpoint : <a href="index.html#type-structured_fixpoint_expr">structured_fixpoint_expr</a> list <span>&#45;&gt;</span> Vernacexpr.decl_notation list <span>&#45;&gt;</span> <a href="index.html#type-recursive_preentry">recursive_preentry</a><span class="keyword"> * </span>Vernacexpr.lident list option<span class="keyword"> * </span>Evd.evar_universe_context<span class="keyword"> * </span>(EConstr.rel_context<span class="keyword"> * </span>Impargs.manual_implicits<span class="keyword"> * </span>int option) list</code></dt><dt class="spec value" id="val-declare_fixpoint"><a href="#val-declare_fixpoint" class="anchor"></a><code><span class="keyword">val </span>declare_fixpoint : Decl_kinds.locality <span>&#45;&gt;</span> Decl_kinds.polymorphic <span>&#45;&gt;</span> (<a href="index.html#type-recursive_preentry">recursive_preentry</a><span class="keyword"> * </span>Vernacexpr.lident list option<span class="keyword"> * </span>Evd.evar_universe_context<span class="keyword"> * </span>(Context.Rel.t<span class="keyword"> * </span>Impargs.manual_implicits<span class="keyword"> * </span>int option) list) <span>&#45;&gt;</span> Proof_global.lemma_possible_guards <span>&#45;&gt;</span> Vernacexpr.decl_notation list <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-declare_cofixpoint"><a href="#val-declare_cofixpoint" class="anchor"></a><code><span class="keyword">val </span>declare_cofixpoint : Decl_kinds.locality <span>&#45;&gt;</span> Decl_kinds.polymorphic <span>&#45;&gt;</span> (<a href="index.html#type-recursive_preentry">recursive_preentry</a><span class="keyword"> * </span>Vernacexpr.lident list option<span class="keyword"> * </span>Evd.evar_universe_context<span class="keyword"> * </span>(Context.Rel.t<span class="keyword"> * </span>Impargs.manual_implicits<span class="keyword"> * </span>int option) list) <span>&#45;&gt;</span> Vernacexpr.decl_notation list <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-do_fixpoint"><a href="#val-do_fixpoint" class="anchor"></a><code><span class="keyword">val </span>do_fixpoint : Decl_kinds.locality <span>&#45;&gt;</span> Decl_kinds.polymorphic <span>&#45;&gt;</span> (Vernacexpr.fixpoint_expr<span class="keyword"> * </span>Vernacexpr.decl_notation list) list <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-do_cofixpoint"><a href="#val-do_cofixpoint" class="anchor"></a><code><span class="keyword">val </span>do_cofixpoint : Decl_kinds.locality <span>&#45;&gt;</span> Decl_kinds.polymorphic <span>&#45;&gt;</span> (Vernacexpr.cofixpoint_expr<span class="keyword"> * </span>Vernacexpr.decl_notation list) list <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-check_mutuality"><a href="#val-check_mutuality" class="anchor"></a><code><span class="keyword">val </span>check_mutuality : Environ.env <span>&#45;&gt;</span> Evd.evar_map <span>&#45;&gt;</span> bool <span>&#45;&gt;</span> (Names.Id.t<span class="keyword"> * </span>Term.types) list <span>&#45;&gt;</span> unit</code></dt></dl></div></body></html>