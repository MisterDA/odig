<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Entries (coq.Entries)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../index.html">coq</a> &#x00BB; Entries</nav><h1>Module <code>Entries</code></h1></header><dl><dt class="spec type" id="type-local_entry"><a href="#type-local_entry" class="anchor"></a><code><span class="keyword">type </span>local_entry</code><code><span class="keyword"> = </span></code><table class="variant"><tr id="type-local_entry.LocalDefEntry" class="anchored"><td class="def constructor"><a href="#type-local_entry.LocalDefEntry" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">LocalDefEntry</span><span class="keyword"> of </span>Term.constr</code></td></tr><tr id="type-local_entry.LocalAssumEntry" class="anchored"><td class="def constructor"><a href="#type-local_entry.LocalAssumEntry" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">LocalAssumEntry</span><span class="keyword"> of </span>Term.constr</code></td></tr></table></dt><dt class="spec type" id="type-inductive_universes"><a href="#type-inductive_universes" class="anchor"></a><code><span class="keyword">type </span>inductive_universes</code><code><span class="keyword"> = </span></code><table class="variant"><tr id="type-inductive_universes.Monomorphic_ind_entry" class="anchored"><td class="def constructor"><a href="#type-inductive_universes.Monomorphic_ind_entry" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Monomorphic_ind_entry</span><span class="keyword"> of </span>Univ.universe_context</code></td></tr><tr id="type-inductive_universes.Polymorphic_ind_entry" class="anchored"><td class="def constructor"><a href="#type-inductive_universes.Polymorphic_ind_entry" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Polymorphic_ind_entry</span><span class="keyword"> of </span>Univ.universe_context</code></td></tr><tr id="type-inductive_universes.Cumulative_ind_entry" class="anchored"><td class="def constructor"><a href="#type-inductive_universes.Cumulative_ind_entry" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Cumulative_ind_entry</span><span class="keyword"> of </span>Univ.cumulativity_info</code></td></tr></table></dt><dt class="spec type" id="type-one_inductive_entry"><a href="#type-one_inductive_entry" class="anchor"></a><code><span class="keyword">type </span>one_inductive_entry</code><code><span class="keyword"> = </span></code><code>{</code><table class="record"><tr id="type-one_inductive_entry.mind_entry_typename" class="anchored"><td class="def field"><a href="#type-one_inductive_entry.mind_entry_typename" class="anchor"></a><code>mind_entry_typename : Names.Id.t;</code></td></tr><tr id="type-one_inductive_entry.mind_entry_arity" class="anchored"><td class="def field"><a href="#type-one_inductive_entry.mind_entry_arity" class="anchor"></a><code>mind_entry_arity : Term.constr;</code></td></tr><tr id="type-one_inductive_entry.mind_entry_template" class="anchored"><td class="def field"><a href="#type-one_inductive_entry.mind_entry_template" class="anchor"></a><code>mind_entry_template : bool;</code></td></tr><tr id="type-one_inductive_entry.mind_entry_consnames" class="anchored"><td class="def field"><a href="#type-one_inductive_entry.mind_entry_consnames" class="anchor"></a><code>mind_entry_consnames : Names.Id.t list;</code></td></tr><tr id="type-one_inductive_entry.mind_entry_lc" class="anchored"><td class="def field"><a href="#type-one_inductive_entry.mind_entry_lc" class="anchor"></a><code>mind_entry_lc : Term.constr list;</code></td></tr></table><code>}</code></dt><dt class="spec type" id="type-mutual_inductive_entry"><a href="#type-mutual_inductive_entry" class="anchor"></a><code><span class="keyword">type </span>mutual_inductive_entry</code><code><span class="keyword"> = </span></code><code>{</code><table class="record"><tr id="type-mutual_inductive_entry.mind_entry_record" class="anchored"><td class="def field"><a href="#type-mutual_inductive_entry.mind_entry_record" class="anchor"></a><code>mind_entry_record : Names.Id.t option option;</code></td></tr><tr id="type-mutual_inductive_entry.mind_entry_finite" class="anchored"><td class="def field"><a href="#type-mutual_inductive_entry.mind_entry_finite" class="anchor"></a><code>mind_entry_finite : Decl_kinds.recursivity_kind;</code></td></tr><tr id="type-mutual_inductive_entry.mind_entry_params" class="anchored"><td class="def field"><a href="#type-mutual_inductive_entry.mind_entry_params" class="anchor"></a><code>mind_entry_params : (Names.Id.t<span class="keyword"> * </span><a href="index.html#type-local_entry">local_entry</a>) list;</code></td></tr><tr id="type-mutual_inductive_entry.mind_entry_inds" class="anchored"><td class="def field"><a href="#type-mutual_inductive_entry.mind_entry_inds" class="anchor"></a><code>mind_entry_inds : <a href="index.html#type-one_inductive_entry">one_inductive_entry</a> list;</code></td></tr><tr id="type-mutual_inductive_entry.mind_entry_universes" class="anchored"><td class="def field"><a href="#type-mutual_inductive_entry.mind_entry_universes" class="anchor"></a><code>mind_entry_universes : <a href="index.html#type-inductive_universes">inductive_universes</a>;</code></td></tr><tr id="type-mutual_inductive_entry.mind_entry_private" class="anchored"><td class="def field"><a href="#type-mutual_inductive_entry.mind_entry_private" class="anchor"></a><code>mind_entry_private : bool option;</code></td></tr></table><code>}</code></dt><dt class="spec type" id="type-proof_output"><a href="#type-proof_output" class="anchor"></a><code><span class="keyword">type </span>'a proof_output</code><code><span class="keyword"> = </span>Term.constr Univ.in_universe_context_set<span class="keyword"> * </span><span class="type-var">'a</span></code></dt><dt class="spec type" id="type-const_entry_body"><a href="#type-const_entry_body" class="anchor"></a><code><span class="keyword">type </span>'a const_entry_body</code><code><span class="keyword"> = </span><span class="type-var">'a</span> <a href="index.html#type-proof_output">proof_output</a> Future.computation</code></dt><dt class="spec type" id="type-definition_entry"><a href="#type-definition_entry" class="anchor"></a><code><span class="keyword">type </span>'a definition_entry</code><code><span class="keyword"> = </span></code><code>{</code><table class="record"><tr id="type-definition_entry.const_entry_body" class="anchored"><td class="def field"><a href="#type-definition_entry.const_entry_body" class="anchor"></a><code>const_entry_body : <span class="type-var">'a</span> <a href="index.html#type-const_entry_body">const_entry_body</a>;</code></td></tr><tr id="type-definition_entry.const_entry_secctx" class="anchored"><td class="def field"><a href="#type-definition_entry.const_entry_secctx" class="anchor"></a><code>const_entry_secctx : Context.Named.t option;</code></td></tr><tr id="type-definition_entry.const_entry_feedback" class="anchored"><td class="def field"><a href="#type-definition_entry.const_entry_feedback" class="anchor"></a><code>const_entry_feedback : Stateid.t option;</code></td></tr><tr id="type-definition_entry.const_entry_type" class="anchored"><td class="def field"><a href="#type-definition_entry.const_entry_type" class="anchor"></a><code>const_entry_type : Term.types option;</code></td></tr><tr id="type-definition_entry.const_entry_polymorphic" class="anchored"><td class="def field"><a href="#type-definition_entry.const_entry_polymorphic" class="anchor"></a><code>const_entry_polymorphic : bool;</code></td></tr><tr id="type-definition_entry.const_entry_universes" class="anchored"><td class="def field"><a href="#type-definition_entry.const_entry_universes" class="anchor"></a><code>const_entry_universes : Univ.universe_context;</code></td></tr><tr id="type-definition_entry.const_entry_opaque" class="anchored"><td class="def field"><a href="#type-definition_entry.const_entry_opaque" class="anchor"></a><code>const_entry_opaque : bool;</code></td></tr><tr id="type-definition_entry.const_entry_inline_code" class="anchored"><td class="def field"><a href="#type-definition_entry.const_entry_inline_code" class="anchor"></a><code>const_entry_inline_code : bool;</code></td></tr></table><code>}</code></dt><dt class="spec type" id="type-inline"><a href="#type-inline" class="anchor"></a><code><span class="keyword">type </span>inline</code><code><span class="keyword"> = </span>int option</code></dt><dt class="spec type" id="type-parameter_entry"><a href="#type-parameter_entry" class="anchor"></a><code><span class="keyword">type </span>parameter_entry</code><code><span class="keyword"> = </span>Context.Named.t option<span class="keyword"> * </span>bool<span class="keyword"> * </span>Term.types Univ.in_universe_context<span class="keyword"> * </span><a href="index.html#type-inline">inline</a></code></dt><dt class="spec type" id="type-projection_entry"><a href="#type-projection_entry" class="anchor"></a><code><span class="keyword">type </span>projection_entry</code><code><span class="keyword"> = </span></code><code>{</code><table class="record"><tr id="type-projection_entry.proj_entry_ind" class="anchored"><td class="def field"><a href="#type-projection_entry.proj_entry_ind" class="anchor"></a><code>proj_entry_ind : Names.mutual_inductive;</code></td></tr><tr id="type-projection_entry.proj_entry_arg" class="anchored"><td class="def field"><a href="#type-projection_entry.proj_entry_arg" class="anchor"></a><code>proj_entry_arg : int;</code></td></tr></table><code>}</code></dt><dt class="spec type" id="type-constant_entry"><a href="#type-constant_entry" class="anchor"></a><code><span class="keyword">type </span>'a constant_entry</code><code><span class="keyword"> = </span></code><table class="variant"><tr id="type-constant_entry.DefinitionEntry" class="anchored"><td class="def constructor"><a href="#type-constant_entry.DefinitionEntry" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">DefinitionEntry</span><span class="keyword"> of </span><span class="type-var">'a</span> <a href="index.html#type-definition_entry">definition_entry</a></code></td></tr><tr id="type-constant_entry.ParameterEntry" class="anchored"><td class="def constructor"><a href="#type-constant_entry.ParameterEntry" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">ParameterEntry</span><span class="keyword"> of </span><a href="index.html#type-parameter_entry">parameter_entry</a></code></td></tr><tr id="type-constant_entry.ProjectionEntry" class="anchored"><td class="def constructor"><a href="#type-constant_entry.ProjectionEntry" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">ProjectionEntry</span><span class="keyword"> of </span><a href="index.html#type-projection_entry">projection_entry</a></code></td></tr></table></dt><dt class="spec type" id="type-module_struct_entry"><a href="#type-module_struct_entry" class="anchor"></a><code><span class="keyword">type </span>module_struct_entry</code><code><span class="keyword"> = </span>Declarations.module_alg_expr</code></dt><dt class="spec type" id="type-module_params_entry"><a href="#type-module_params_entry" class="anchor"></a><code><span class="keyword">type </span>module_params_entry</code><code><span class="keyword"> = </span>(Names.MBId.t<span class="keyword"> * </span><a href="index.html#type-module_struct_entry">module_struct_entry</a>) list</code></dt><dt class="spec type" id="type-module_type_entry"><a href="#type-module_type_entry" class="anchor"></a><code><span class="keyword">type </span>module_type_entry</code><code><span class="keyword"> = </span><a href="index.html#type-module_params_entry">module_params_entry</a><span class="keyword"> * </span><a href="index.html#type-module_struct_entry">module_struct_entry</a></code></dt><dt class="spec type" id="type-module_entry"><a href="#type-module_entry" class="anchor"></a><code><span class="keyword">type </span>module_entry</code><code><span class="keyword"> = </span></code><table class="variant"><tr id="type-module_entry.MType" class="anchored"><td class="def constructor"><a href="#type-module_entry.MType" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">MType</span><span class="keyword"> of </span><a href="index.html#type-module_params_entry">module_params_entry</a><span class="keyword"> * </span><a href="index.html#type-module_struct_entry">module_struct_entry</a></code></td></tr><tr id="type-module_entry.MExpr" class="anchored"><td class="def constructor"><a href="#type-module_entry.MExpr" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">MExpr</span><span class="keyword"> of </span><a href="index.html#type-module_params_entry">module_params_entry</a><span class="keyword"> * </span><a href="index.html#type-module_struct_entry">module_struct_entry</a><span class="keyword"> * </span><a href="index.html#type-module_struct_entry">module_struct_entry</a> option</code></td></tr></table></dt><dt class="spec type" id="type-seff_env"><a href="#type-seff_env" class="anchor"></a><code><span class="keyword">type </span>seff_env</code><span class="keyword"> = </span><code>[ </code><table class="variant"><tr id="type-seff_env.Nothing" class="anchored"><td class="def constructor"><a href="#type-seff_env.Nothing" class="anchor"></a><code><span class="keyword">| </span></code><code>`Nothing</code></td></tr><tr id="type-seff_env.Opaque" class="anchored"><td class="def constructor"><a href="#type-seff_env.Opaque" class="anchor"></a><code><span class="keyword">| </span></code><code>`Opaque<span class="keyword"> of </span>Constr.t<span class="keyword"> * </span>Univ.universe_context_set</code></td></tr></table><code> ]</code></dt><dt class="spec type" id="type-side_eff"><a href="#type-side_eff" class="anchor"></a><code><span class="keyword">type </span>side_eff</code><code><span class="keyword"> = </span></code><table class="variant"><tr id="type-side_eff.SEsubproof" class="anchored"><td class="def constructor"><a href="#type-side_eff.SEsubproof" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">SEsubproof</span><span class="keyword"> of </span>Names.constant<span class="keyword"> * </span>Declarations.constant_body<span class="keyword"> * </span><a href="index.html#type-seff_env">seff_env</a></code></td></tr><tr id="type-side_eff.SEscheme" class="anchored"><td class="def constructor"><a href="#type-side_eff.SEscheme" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">SEscheme</span><span class="keyword"> of </span>(Names.inductive<span class="keyword"> * </span>Names.constant<span class="keyword"> * </span>Declarations.constant_body<span class="keyword"> * </span><a href="index.html#type-seff_env">seff_env</a>) list<span class="keyword"> * </span>string</code></td></tr></table></dt><dt class="spec type" id="type-side_effect"><a href="#type-side_effect" class="anchor"></a><code><span class="keyword">type </span>side_effect</code><code><span class="keyword"> = </span></code><code>{</code><table class="record"><tr id="type-side_effect.from_env" class="anchored"><td class="def field"><a href="#type-side_effect.from_env" class="anchor"></a><code>from_env : Declarations.structure_body CEphemeron.key;</code></td></tr><tr id="type-side_effect.eff" class="anchored"><td class="def field"><a href="#type-side_effect.eff" class="anchor"></a><code>eff : <a href="index.html#type-side_eff">side_eff</a>;</code></td></tr></table><code>}</code></dt></dl></div></body></html>