<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Indfun_common (coq.Indfun_common)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../index.html">coq</a> &#x00BB; Indfun_common</nav><h1>Module <code>Indfun_common</code></h1></header><dl><dt class="spec value" id="val-mk_rel_id"><a href="#val-mk_rel_id" class="anchor"></a><code><span class="keyword">val </span>mk_rel_id : Names.Id.t <span>&#45;&gt;</span> Names.Id.t</code></dt><dt class="spec value" id="val-mk_correct_id"><a href="#val-mk_correct_id" class="anchor"></a><code><span class="keyword">val </span>mk_correct_id : Names.Id.t <span>&#45;&gt;</span> Names.Id.t</code></dt><dt class="spec value" id="val-mk_complete_id"><a href="#val-mk_complete_id" class="anchor"></a><code><span class="keyword">val </span>mk_complete_id : Names.Id.t <span>&#45;&gt;</span> Names.Id.t</code></dt><dt class="spec value" id="val-mk_equation_id"><a href="#val-mk_equation_id" class="anchor"></a><code><span class="keyword">val </span>mk_equation_id : Names.Id.t <span>&#45;&gt;</span> Names.Id.t</code></dt><dt class="spec value" id="val-msgnl"><a href="#val-msgnl" class="anchor"></a><code><span class="keyword">val </span>msgnl : Pp.std_ppcmds <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-fresh_id"><a href="#val-fresh_id" class="anchor"></a><code><span class="keyword">val </span>fresh_id : Names.Id.t list <span>&#45;&gt;</span> string <span>&#45;&gt;</span> Names.Id.t</code></dt><dt class="spec value" id="val-fresh_name"><a href="#val-fresh_name" class="anchor"></a><code><span class="keyword">val </span>fresh_name : Names.Id.t list <span>&#45;&gt;</span> string <span>&#45;&gt;</span> Names.Name.t</code></dt><dt class="spec value" id="val-get_name"><a href="#val-get_name" class="anchor"></a><code><span class="keyword">val </span>get_name : Names.Id.t list <span>&#45;&gt;</span> ?&#8288;default:string <span>&#45;&gt;</span> Names.Name.t <span>&#45;&gt;</span> Names.Name.t</code></dt><dt class="spec value" id="val-array_get_start"><a href="#val-array_get_start" class="anchor"></a><code><span class="keyword">val </span>array_get_start : <span class="type-var">'a</span> array <span>&#45;&gt;</span> <span class="type-var">'a</span> array</code></dt><dt class="spec value" id="val-id_of_name"><a href="#val-id_of_name" class="anchor"></a><code><span class="keyword">val </span>id_of_name : Names.Name.t <span>&#45;&gt;</span> Names.Id.t</code></dt><dt class="spec value" id="val-locate_ind"><a href="#val-locate_ind" class="anchor"></a><code><span class="keyword">val </span>locate_ind : Libnames.reference <span>&#45;&gt;</span> Names.inductive</code></dt><dt class="spec value" id="val-locate_constant"><a href="#val-locate_constant" class="anchor"></a><code><span class="keyword">val </span>locate_constant : Libnames.reference <span>&#45;&gt;</span> Names.Constant.t</code></dt><dt class="spec value" id="val-locate_with_msg"><a href="#val-locate_with_msg" class="anchor"></a><code><span class="keyword">val </span>locate_with_msg : Pp.std_ppcmds <span>&#45;&gt;</span> (Libnames.reference <span>&#45;&gt;</span> <span class="type-var">'a</span>) <span>&#45;&gt;</span> Libnames.reference <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dt class="spec value" id="val-filter_map"><a href="#val-filter_map" class="anchor"></a><code><span class="keyword">val </span>filter_map : (<span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'b</span> list</code></dt><dt class="spec value" id="val-list_union_eq"><a href="#val-list_union_eq" class="anchor"></a><code><span class="keyword">val </span>list_union_eq : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'a</span> list</code></dt><dt class="spec value" id="val-list_add_set_eq"><a href="#val-list_add_set_eq" class="anchor"></a><code><span class="keyword">val </span>list_add_set_eq : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'a</span> list</code></dt><dt class="spec value" id="val-chop_rlambda_n"><a href="#val-chop_rlambda_n" class="anchor"></a><code><span class="keyword">val </span>chop_rlambda_n : int <span>&#45;&gt;</span> Glob_term.glob_constr <span>&#45;&gt;</span> (Names.Name.t<span class="keyword"> * </span>Glob_term.glob_constr<span class="keyword"> * </span>Glob_term.glob_constr option) list<span class="keyword"> * </span>Glob_term.glob_constr</code></dt><dt class="spec value" id="val-chop_rprod_n"><a href="#val-chop_rprod_n" class="anchor"></a><code><span class="keyword">val </span>chop_rprod_n : int <span>&#45;&gt;</span> Glob_term.glob_constr <span>&#45;&gt;</span> (Names.Name.t<span class="keyword"> * </span>Glob_term.glob_constr) list<span class="keyword"> * </span>Glob_term.glob_constr</code></dt><dt class="spec value" id="val-def_of_const"><a href="#val-def_of_const" class="anchor"></a><code><span class="keyword">val </span>def_of_const : Term.constr <span>&#45;&gt;</span> Term.constr</code></dt><dt class="spec value" id="val-eq"><a href="#val-eq" class="anchor"></a><code><span class="keyword">val </span>eq : EConstr.constr Lazy.t</code></dt><dt class="spec value" id="val-refl_equal"><a href="#val-refl_equal" class="anchor"></a><code><span class="keyword">val </span>refl_equal : EConstr.constr Lazy.t</code></dt><dt class="spec value" id="val-const_of_id"><a href="#val-const_of_id" class="anchor"></a><code><span class="keyword">val </span>const_of_id : Names.Id.t <span>&#45;&gt;</span> Globnames.global_reference</code></dt><dt class="spec value" id="val-jmeq"><a href="#val-jmeq" class="anchor"></a><code><span class="keyword">val </span>jmeq : unit <span>&#45;&gt;</span> EConstr.constr</code></dt><dt class="spec value" id="val-jmeq_refl"><a href="#val-jmeq_refl" class="anchor"></a><code><span class="keyword">val </span>jmeq_refl : unit <span>&#45;&gt;</span> EConstr.constr</code></dt><dt class="spec value" id="val-save"><a href="#val-save" class="anchor"></a><code><span class="keyword">val </span>save : bool <span>&#45;&gt;</span> Names.Id.t <span>&#45;&gt;</span> Safe_typing.private_constants Entries.definition_entry <span>&#45;&gt;</span> Decl_kinds.goal_kind <span>&#45;&gt;</span> unit Lemmas.declaration_hook CEphemeron.key <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-get_proof_clean"><a href="#val-get_proof_clean" class="anchor"></a><code><span class="keyword">val </span>get_proof_clean : bool <span>&#45;&gt;</span> Names.Id.t<span class="keyword"> * </span>(Safe_typing.private_constants Entries.definition_entry<span class="keyword"> * </span>Decl_kinds.goal_kind)</code></dt><dt class="spec value" id="val-with_full_print"><a href="#val-with_full_print" class="anchor"></a><code><span class="keyword">val </span>with_full_print : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span></code></dt></dl><dl><dt class="spec type" id="type-function_info"><a href="#type-function_info" class="anchor"></a><code><span class="keyword">type </span>function_info</code><code><span class="keyword"> = </span></code><code>{</code><table class="record"><tr id="type-function_info.function_constant" class="anchored"><td class="def field"><a href="#type-function_info.function_constant" class="anchor"></a><code>function_constant : Names.Constant.t;</code></td></tr><tr id="type-function_info.graph_ind" class="anchored"><td class="def field"><a href="#type-function_info.graph_ind" class="anchor"></a><code>graph_ind : Names.inductive;</code></td></tr><tr id="type-function_info.equation_lemma" class="anchored"><td class="def field"><a href="#type-function_info.equation_lemma" class="anchor"></a><code>equation_lemma : Names.Constant.t option;</code></td></tr><tr id="type-function_info.correctness_lemma" class="anchored"><td class="def field"><a href="#type-function_info.correctness_lemma" class="anchor"></a><code>correctness_lemma : Names.Constant.t option;</code></td></tr><tr id="type-function_info.completeness_lemma" class="anchored"><td class="def field"><a href="#type-function_info.completeness_lemma" class="anchor"></a><code>completeness_lemma : Names.Constant.t option;</code></td></tr><tr id="type-function_info.rect_lemma" class="anchored"><td class="def field"><a href="#type-function_info.rect_lemma" class="anchor"></a><code>rect_lemma : Names.Constant.t option;</code></td></tr><tr id="type-function_info.rec_lemma" class="anchored"><td class="def field"><a href="#type-function_info.rec_lemma" class="anchor"></a><code>rec_lemma : Names.Constant.t option;</code></td></tr><tr id="type-function_info.prop_lemma" class="anchored"><td class="def field"><a href="#type-function_info.prop_lemma" class="anchor"></a><code>prop_lemma : Names.Constant.t option;</code></td></tr><tr id="type-function_info.is_general" class="anchored"><td class="def field"><a href="#type-function_info.is_general" class="anchor"></a><code>is_general : bool;</code></td></tr></table><code>}</code></dt></dl><dl><dt class="spec value" id="val-find_Function_infos"><a href="#val-find_Function_infos" class="anchor"></a><code><span class="keyword">val </span>find_Function_infos : Names.Constant.t <span>&#45;&gt;</span> <a href="index.html#type-function_info">function_info</a></code></dt><dt class="spec value" id="val-find_Function_of_graph"><a href="#val-find_Function_of_graph" class="anchor"></a><code><span class="keyword">val </span>find_Function_of_graph : Names.inductive <span>&#45;&gt;</span> <a href="index.html#type-function_info">function_info</a></code></dt><dt class="spec value" id="val-add_Function"><a href="#val-add_Function" class="anchor"></a><code><span class="keyword">val </span>add_Function : bool <span>&#45;&gt;</span> Names.Constant.t <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-update_Function"><a href="#val-update_Function" class="anchor"></a><code><span class="keyword">val </span>update_Function : <a href="index.html#type-function_info">function_info</a> <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-pr_info"><a href="#val-pr_info" class="anchor"></a><code><span class="keyword">val </span>pr_info : <a href="index.html#type-function_info">function_info</a> <span>&#45;&gt;</span> Pp.std_ppcmds</code></dt><dt class="spec value" id="val-pr_table"><a href="#val-pr_table" class="anchor"></a><code><span class="keyword">val </span>pr_table : unit <span>&#45;&gt;</span> Pp.std_ppcmds</code></dt><dt class="spec value" id="val-do_observe"><a href="#val-do_observe" class="anchor"></a><code><span class="keyword">val </span>do_observe : unit <span>&#45;&gt;</span> bool</code></dt><dt class="spec value" id="val-do_rewrite_dependent"><a href="#val-do_rewrite_dependent" class="anchor"></a><code><span class="keyword">val </span>do_rewrite_dependent : unit <span>&#45;&gt;</span> bool</code></dt></dl><dl><dt class="spec exception" id="exception-Building_graph"><a href="#exception-Building_graph" class="anchor"></a><code><span class="keyword">exception </span></code><code><span class="exception">Building_graph</span><span class="keyword"> of </span>exn</code></dt><dt class="spec exception" id="exception-Defining_principle"><a href="#exception-Defining_principle" class="anchor"></a><code><span class="keyword">exception </span></code><code><span class="exception">Defining_principle</span><span class="keyword"> of </span>exn</code></dt><dt class="spec exception" id="exception-ToShow"><a href="#exception-ToShow" class="anchor"></a><code><span class="keyword">exception </span></code><code><span class="exception">ToShow</span><span class="keyword"> of </span>exn</code></dt></dl><dl><dt class="spec value" id="val-is_strict_tcc"><a href="#val-is_strict_tcc" class="anchor"></a><code><span class="keyword">val </span>is_strict_tcc : unit <span>&#45;&gt;</span> bool</code></dt><dt class="spec value" id="val-h_intros"><a href="#val-h_intros" class="anchor"></a><code><span class="keyword">val </span>h_intros : Names.Id.t list <span>&#45;&gt;</span> Tacmach.tactic</code></dt><dt class="spec value" id="val-h_id"><a href="#val-h_id" class="anchor"></a><code><span class="keyword">val </span>h_id : Names.Id.t</code></dt><dt class="spec value" id="val-hrec_id"><a href="#val-hrec_id" class="anchor"></a><code><span class="keyword">val </span>hrec_id : Names.Id.t</code></dt><dt class="spec value" id="val-acc_inv_id"><a href="#val-acc_inv_id" class="anchor"></a><code><span class="keyword">val </span>acc_inv_id : EConstr.constr Util.delayed</code></dt><dt class="spec value" id="val-ltof_ref"><a href="#val-ltof_ref" class="anchor"></a><code><span class="keyword">val </span>ltof_ref : Globnames.global_reference Util.delayed</code></dt><dt class="spec value" id="val-well_founded_ltof"><a href="#val-well_founded_ltof" class="anchor"></a><code><span class="keyword">val </span>well_founded_ltof : EConstr.constr Util.delayed</code></dt><dt class="spec value" id="val-acc_rel"><a href="#val-acc_rel" class="anchor"></a><code><span class="keyword">val </span>acc_rel : EConstr.constr Util.delayed</code></dt><dt class="spec value" id="val-well_founded"><a href="#val-well_founded" class="anchor"></a><code><span class="keyword">val </span>well_founded : EConstr.constr Util.delayed</code></dt><dt class="spec value" id="val-evaluable_of_global_reference"><a href="#val-evaluable_of_global_reference" class="anchor"></a><code><span class="keyword">val </span>evaluable_of_global_reference : Globnames.global_reference <span>&#45;&gt;</span> Names.evaluable_global_reference</code></dt><dt class="spec value" id="val-list_rewrite"><a href="#val-list_rewrite" class="anchor"></a><code><span class="keyword">val </span>list_rewrite : bool <span>&#45;&gt;</span> (EConstr.constr<span class="keyword"> * </span>bool) list <span>&#45;&gt;</span> Tacmach.tactic</code></dt><dt class="spec value" id="val-decompose_lam_n"><a href="#val-decompose_lam_n" class="anchor"></a><code><span class="keyword">val </span>decompose_lam_n : Evd.evar_map <span>&#45;&gt;</span> int <span>&#45;&gt;</span> EConstr.t <span>&#45;&gt;</span> (Names.Name.t<span class="keyword"> * </span>EConstr.t) list<span class="keyword"> * </span>EConstr.t</code></dt><dt class="spec value" id="val-compose_lam"><a href="#val-compose_lam" class="anchor"></a><code><span class="keyword">val </span>compose_lam : (Names.Name.t<span class="keyword"> * </span>EConstr.t) list <span>&#45;&gt;</span> EConstr.t <span>&#45;&gt;</span> EConstr.t</code></dt><dt class="spec value" id="val-compose_prod"><a href="#val-compose_prod" class="anchor"></a><code><span class="keyword">val </span>compose_prod : (Names.Name.t<span class="keyword"> * </span>EConstr.t) list <span>&#45;&gt;</span> EConstr.t <span>&#45;&gt;</span> EConstr.t</code></dt></dl><dl><dt class="spec type" id="type-tcc_lemma_value"><a href="#type-tcc_lemma_value" class="anchor"></a><code><span class="keyword">type </span>tcc_lemma_value</code><code><span class="keyword"> = </span></code><table class="variant"><tr id="type-tcc_lemma_value.Undefined" class="anchored"><td class="def constructor"><a href="#type-tcc_lemma_value.Undefined" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Undefined</span></code></td></tr><tr id="type-tcc_lemma_value.Value" class="anchored"><td class="def constructor"><a href="#type-tcc_lemma_value.Value" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Value</span><span class="keyword"> of </span>Term.constr</code></td></tr><tr id="type-tcc_lemma_value.Not_needed" class="anchored"><td class="def constructor"><a href="#type-tcc_lemma_value.Not_needed" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Not_needed</span></code></td></tr></table></dt></dl></div></body></html>