<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Schedule_v5 (core.Core__.Schedule_v5)</title><link rel="stylesheet" href="../../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../../index.html">core</a> &#x00BB; <a href="../index.html">Core__</a> &#x00BB; Schedule_v5</nav><h1>Module <code>Core__.Schedule_v5</code></h1><nav class="toc"><ul><li><a href="#overview">Overview</a></li><li><a href="#zones-and-tags">Zones and Tags</a></li><li><a href="#daylight-savings-time">Daylight Savings Time</a></li><li><a href="#interface">Interface</a></li></ul></nav></header><aside><p>Latest version of <code>Schedule</code>, which defines a type for schedules like &quot;every 5 min after the hour&quot; or &quot;every weekday at 3pm.&quot; More expressive than V4, for example by adding the <code>Zoned_between</code> variant, which behaves like <code>Between</code> but allows expressing the start and end times in different zones.</p></aside><section><header><h3 id="overview"><a href="#overview" class="anchor"></a>Overview</h3><p>A <code>Schedule.t</code> describes a (potentially repeating) schedule by selecting a subset of all seconds using the set operations in <code>t</code>. For example:</p><ul><li><p>every 5 min after the hour : </p><pre>Mins [ 5 ]</pre></li></ul><ul><li><p>9am to 10am every day :</p><pre>Between (Time.Ofday.create ~hr:9 (), Time.Ofday.create ~hr:10 ())</pre></li></ul><ul><li><p>Every weekday at 3pm:</p><pre>And
        [ Weekdays [ Mon; Tue; Wed; Thu; Fri ]
        ; At [ Time.Ofday.create ~hr:15 () ] ]</pre></li></ul><ul><li><p>On the 15th of every month at midnight:</p><pre>And
        [ Days [ 15 ]
        ; At [ Time.Ofday.start_of_day ] ]</pre></li></ul><ul><li><p>9:30 am on weekends, and 5 am on weekdays</p><pre>Or
        [ And
            [ Weekdays [ Sat; Sun ]
            ; At [ Time.Ofday.create ~hr:9 ~min:30 () ] ]
        ; And
            [ Weekdays [ Mon; Tue; Wed; Thu; Fri ]
            ; At [ Time.Ofday.create ~hr:5 () ] ]
        ]</pre></li></ul></header></section><section><header><h3 id="zones-and-tags"><a href="#zones-and-tags" class="anchor"></a>Zones and Tags</h3><p>On top of this selection language there are two labeling branches of the variant that are important.</p><p><code>In_zone (zone, t)</code> expresses that all of t should be evaluated relative to the time zone given.</p><p><code>Tag (tag, t)</code> tags anything matching t with <code>tag</code>.</p><p>Combining these we can express something complex like the on-call groups across three offices:</p><pre><code class="ml">let weekdays         = Weekdays Day_of_week.weekdays in
let working_hours    = Between Time.Ofday.((create ~hr:8 (), create ~hr:18 ())) in
let working_schedule = And [ weekdays; working_hours ] in
let offices =
  let (!!) = Time.Zone.find_exn in
  Location.Abbrev.([
    tot, !!&quot;America/New_York&quot;
  ; hkg, !!&quot;Asia/Hong_Kong&quot;
  ; ldn, !!&quot;Europe/London&quot; ])
in
List.map offices ~f:(fun (office, zone) -&gt;
  In_zone (zone, Tag (office, working_schedule)))</code></pre><p>after which we can use the <code>tags</code> function to extract the groups on call at any moment.</p></header></section><section><header><h3 id="daylight-savings-time"><a href="#daylight-savings-time" class="anchor"></a>Daylight Savings Time</h3><p>Schedules are expressed in terms of wall clock time, and as such have interesting behavior around daylight savings time boundaries. There are two circumstances that might affect a schedule. The first is a repeated time, which occurs when time jumps back (e.g., 2:30 may happen twice in one day). The second is a skipped time, which occurs when time jumps forward by an hour.</p><p>In both cases <code>Schedule</code> does the naive thing: if the time happens twice and is included in the schedule, it is included twice; if it never happens, <code>Schedule</code> makes no special attempt to artificially include it.</p></header></section><section><header><h3 id="interface"><a href="#interface" class="anchor"></a>Interface</h3></header><dl><dt class="spec type" id="type-zoned"><a href="#type-zoned" class="anchor"></a><code><span class="keyword">type</span> zoned</code><code> = </code><table class="variant"><tr id="type-zoned.Zoned" class="anchored"><td class="def constructor"><a href="#type-zoned.Zoned" class="anchor"></a><code>| </code><code><span class="constructor">Zoned</span></code></td></tr></table></dt><dd><p>These phantom types are concrete and exposed to help the compiler understand that zoned and unzoned cannot be the same type (which it could not know if they were abstract), which helps it infer the injectivity of the type <code>t</code> below.</p></dd></dl><div><div class="spec include"><div class="doc"><details open="open"><summary><span class="def"><code><span class="keyword">include</span> <span class="keyword">sig</span> ... <span class="keyword">end</span></code></span></summary><dl><dt class="spec value" id="val-compare_zoned"><a href="#val-compare_zoned" class="anchor"></a><code><span class="keyword">val</span> compare_zoned : <a href="index.html#type-zoned">zoned</a> <span>&#45;&gt;</span> <a href="index.html#type-zoned">zoned</a> <span>&#45;&gt;</span> int</code></dt></dl></details></div></div></div><dl><dt class="spec type" id="type-unzoned"><a href="#type-unzoned" class="anchor"></a><code><span class="keyword">type</span> unzoned</code><code> = </code><table class="variant"><tr id="type-unzoned.Unzoned" class="anchored"><td class="def constructor"><a href="#type-unzoned.Unzoned" class="anchor"></a><code>| </code><code><span class="constructor">Unzoned</span></code></td></tr></table></dt></dl><div><div class="spec include"><div class="doc"><details open="open"><summary><span class="def"><code><span class="keyword">include</span> <span class="keyword">sig</span> ... <span class="keyword">end</span></code></span></summary><dl><dt class="spec value" id="val-compare_unzoned"><a href="#val-compare_unzoned" class="anchor"></a><code><span class="keyword">val</span> compare_unzoned : <a href="index.html#type-unzoned">unzoned</a> <span>&#45;&gt;</span> <a href="index.html#type-unzoned">unzoned</a> <span>&#45;&gt;</span> int</code></dt></dl></details></div></div></div><aside><ul><li><code>In_zone</code>: see the discussion under Zones and Tags above</li><li><code>Tag</code>: see the discussion under Zones and Tags above</li><li><code>And</code>, <code>Or</code>, <code>Not</code>: correspond to the set operations intersection, union, and complement.</li><li><code>If_then_else (A, B, C)</code>: corresponds to (A &amp;&amp; B) || (NOT A &amp;&amp; C), useful for dealing with schedules that change during certain times of the year (holidays, etc.)</li><li><code>At</code>: the exact times given on every day</li><li><p><code>Shift</code>: shifts an entire schedule forward or backwards by a known span. For example:</p><ul><li><code>Shift ((sec 3.), Secs[10]) = Secs [13]</code></li><li><code>Shift ((sec (-3.)), Secs[10]) = Secs [7]</code></li></ul></li><li><p><code>Between</code>: the contiguous range between the start and end times given. The schedule can span the midnight boundary. If the start and end ofdays are the same then:</p><pre>| Exclusive, Exclusive  -&gt; Not At
      | Inclusive, Inclusive -&gt; At
      | Exclusive, Inclusive
      | Inclusive, Exclusive -&gt; Always</pre></li><li><code>Zoned_between</code>: As Between, but allows expressing the start and end times in different zones</li><li><code>Secs</code>: the given seconds of a minute, repeated every minute</li><li><code>Mins</code>: the given minutes of an hour, repeated every hour</li><li><code>Hours</code>: the given hours of a day, repeated every day</li><li><code>Weekdays</code>: the given weekdays, repeated every week</li><li><code>Days</code>: the given calendar dates, repeated every month (if the day occurs in that month)</li><li><code>Weeks</code>: the given weeks (numbered by ISO 8601), repeated every year</li><li><code>Months</code>: the given months, repeated every year</li><li><code>On</code>: the exact dates given</li><li><code>Before</code>: all seconds before the given boundary (inclusive or exclusive)</li><li><code>After</code>: all seconds after the given boundary (inclusive or exclusive)</li><li><code>Always</code>: the set of all seconds</li><li><code>Never</code>: the empty set</li></ul><p><code>'a</code> indicates whether the schedule currently has an established zone.</p><p><code>'b</code> is the type of the tag used in this schedule. In many cases it can be unspecified. See <code>tags</code> for more.</p><p>Items that take <code>int list</code>s silently ignore <code>int</code>s outside of the viable range. E.g. <code>Days [32]</code> will never occur.</p></aside><div class="spec module" id="module-Inclusive_exclusive"><a href="#module-Inclusive_exclusive" class="anchor"></a><code><span class="keyword">module</span> <a href="Inclusive_exclusive/index.html">Inclusive_exclusive</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> ('a, 'b) t</code><code> = </code><table class="variant"><tr id="type-t.In_zone" class="anchored"><td class="def constructor"><a href="#type-t.In_zone" class="anchor"></a><code>| </code><code><span class="constructor">In_zone</span> : <a href="../../Core__Core_time_float/Zone/index.html#type-t">Core__.Import_time.Time.Zone.t</a> * (<a href="index.html#type-unzoned">unzoned</a>, <span class="type-var">'b</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<a href="index.html#type-zoned">zoned</a>, <span class="type-var">'b</span>) <a href="index.html#type-t">t</a></code></td></tr><tr id="type-t.Tag" class="anchored"><td class="def constructor"><a href="#type-t.Tag" class="anchor"></a><code>| </code><code><span class="constructor">Tag</span> : <span class="type-var">'b</span> * (<span class="type-var">'a</span>, <span class="type-var">'b</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span>, <span class="type-var">'b</span>) <a href="index.html#type-t">t</a></code></td></tr><tr id="type-t.And" class="anchored"><td class="def constructor"><a href="#type-t.And" class="anchor"></a><code>| </code><code><span class="constructor">And</span> : (<span class="type-var">'a</span>, <span class="type-var">'b</span>) <a href="index.html#type-t">t</a> list <span>&#45;&gt;</span> (<span class="type-var">'a</span>, <span class="type-var">'b</span>) <a href="index.html#type-t">t</a></code></td></tr><tr id="type-t.Or" class="anchored"><td class="def constructor"><a href="#type-t.Or" class="anchor"></a><code>| </code><code><span class="constructor">Or</span> : (<span class="type-var">'a</span>, <span class="type-var">'b</span>) <a href="index.html#type-t">t</a> list <span>&#45;&gt;</span> (<span class="type-var">'a</span>, <span class="type-var">'b</span>) <a href="index.html#type-t">t</a></code></td></tr><tr id="type-t.Not" class="anchored"><td class="def constructor"><a href="#type-t.Not" class="anchor"></a><code>| </code><code><span class="constructor">Not</span> : (<span class="type-var">'a</span>, <span class="type-var">'b</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span>, <span class="type-var">'b</span>) <a href="index.html#type-t">t</a></code></td></tr><tr id="type-t.If_then_else" class="anchored"><td class="def constructor"><a href="#type-t.If_then_else" class="anchor"></a><code>| </code><code><span class="constructor">If_then_else</span> : ((<span class="type-var">'a</span>, <span class="type-var">'b</span>) <a href="index.html#type-t">t</a> * (<span class="type-var">'a</span>, <span class="type-var">'b</span>) <a href="index.html#type-t">t</a> * (<span class="type-var">'a</span>, <span class="type-var">'b</span>) <a href="index.html#type-t">t</a>) <span>&#45;&gt;</span> (<span class="type-var">'a</span>, <span class="type-var">'b</span>) <a href="index.html#type-t">t</a></code></td></tr><tr id="type-t.Shift" class="anchored"><td class="def constructor"><a href="#type-t.Shift" class="anchor"></a><code>| </code><code><span class="constructor">Shift</span> : <a href="../../../core_kernel/Core_kernel__Time_intf/module-type-S/Time/Span/index.html#type-t">Core__.Import_time.Time.Span.t</a> * (<span class="type-var">'a</span>, <span class="type-var">'b</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span>, <span class="type-var">'b</span>) <a href="index.html#type-t">t</a></code></td></tr><tr id="type-t.Between" class="anchored"><td class="def constructor"><a href="#type-t.Between" class="anchor"></a><code>| </code><code><span class="constructor">Between</span> : (<a href="Inclusive_exclusive/index.html#type-t">Inclusive_exclusive.t</a> * <a href="../../Core__Core_time_float/Ofday/index.html#type-t">Core__.Import_time.Time.Ofday.t</a>) * (<a href="Inclusive_exclusive/index.html#type-t">Inclusive_exclusive.t</a> * <a href="../../Core__Core_time_float/Ofday/index.html#type-t">Core__.Import_time.Time.Ofday.t</a>) <span>&#45;&gt;</span> (<a href="index.html#type-unzoned">unzoned</a>, <span class="type-var">'b</span>) <a href="index.html#type-t">t</a></code></td></tr><tr id="type-t.Zoned_between" class="anchored"><td class="def constructor"><a href="#type-t.Zoned_between" class="anchor"></a><code>| </code><code><span class="constructor">Zoned_between</span> : (<a href="Inclusive_exclusive/index.html#type-t">Inclusive_exclusive.t</a> * <a href="../../Core__Core_time_float/Zone/index.html#type-t">Core__.Import_time.Time.Zone.t</a> * <a href="../../Core__Core_time_float/Ofday/index.html#type-t">Core__.Import_time.Time.Ofday.t</a>) * (<a href="Inclusive_exclusive/index.html#type-t">Inclusive_exclusive.t</a> * <a href="../../Core__Core_time_float/Zone/index.html#type-t">Core__.Import_time.Time.Zone.t</a> * <a href="../../Core__Core_time_float/Ofday/index.html#type-t">Core__.Import_time.Time.Ofday.t</a>) <span>&#45;&gt;</span> (<a href="index.html#type-zoned">zoned</a>, <span class="type-var">'b</span>) <a href="index.html#type-t">t</a></code></td></tr><tr id="type-t.At" class="anchored"><td class="def constructor"><a href="#type-t.At" class="anchor"></a><code>| </code><code><span class="constructor">At</span> : <a href="../../Core__Core_time_float/Ofday/index.html#type-t">Core__.Import_time.Time.Ofday.t</a> list <span>&#45;&gt;</span> (<a href="index.html#type-unzoned">unzoned</a>, <span class="type-var">'b</span>) <a href="index.html#type-t">t</a></code></td></tr><tr id="type-t.Secs" class="anchored"><td class="def constructor"><a href="#type-t.Secs" class="anchor"></a><code>| </code><code><span class="constructor">Secs</span> : int list <span>&#45;&gt;</span> (<a href="index.html#type-unzoned">unzoned</a>, <span class="type-var">'b</span>) <a href="index.html#type-t">t</a></code></td></tr><tr id="type-t.Mins" class="anchored"><td class="def constructor"><a href="#type-t.Mins" class="anchor"></a><code>| </code><code><span class="constructor">Mins</span> : int list <span>&#45;&gt;</span> (<a href="index.html#type-unzoned">unzoned</a>, <span class="type-var">'b</span>) <a href="index.html#type-t">t</a></code></td></tr><tr id="type-t.Hours" class="anchored"><td class="def constructor"><a href="#type-t.Hours" class="anchor"></a><code>| </code><code><span class="constructor">Hours</span> : int list <span>&#45;&gt;</span> (<a href="index.html#type-unzoned">unzoned</a>, <span class="type-var">'b</span>) <a href="index.html#type-t">t</a></code></td></tr><tr id="type-t.Weekdays" class="anchored"><td class="def constructor"><a href="#type-t.Weekdays" class="anchor"></a><code>| </code><code><span class="constructor">Weekdays</span> : <a href="../../../core_kernel/Core_kernel/Day_of_week/index.html#type-t">Core__.Import.Day_of_week.t</a> list <span>&#45;&gt;</span> (<a href="index.html#type-unzoned">unzoned</a>, <span class="type-var">'b</span>) <a href="index.html#type-t">t</a></code></td></tr><tr id="type-t.Days" class="anchored"><td class="def constructor"><a href="#type-t.Days" class="anchor"></a><code>| </code><code><span class="constructor">Days</span> : int list <span>&#45;&gt;</span> (<a href="index.html#type-unzoned">unzoned</a>, <span class="type-var">'b</span>) <a href="index.html#type-t">t</a></code></td></tr><tr id="type-t.Weeks" class="anchored"><td class="def constructor"><a href="#type-t.Weeks" class="anchor"></a><code>| </code><code><span class="constructor">Weeks</span> : int list <span>&#45;&gt;</span> (<a href="index.html#type-unzoned">unzoned</a>, <span class="type-var">'b</span>) <a href="index.html#type-t">t</a></code></td></tr><tr id="type-t.Months" class="anchored"><td class="def constructor"><a href="#type-t.Months" class="anchor"></a><code>| </code><code><span class="constructor">Months</span> : <a href="../../../core_kernel/Core_kernel/Month/index.html#type-t">Core__.Import.Month.t</a> list <span>&#45;&gt;</span> (<a href="index.html#type-unzoned">unzoned</a>, <span class="type-var">'b</span>) <a href="index.html#type-t">t</a></code></td></tr><tr id="type-t.On" class="anchored"><td class="def constructor"><a href="#type-t.On" class="anchor"></a><code>| </code><code><span class="constructor">On</span> : <a href="../../../core_kernel/Core_kernel/Date/index.html#type-t">Core__.Import.Date.t</a> list <span>&#45;&gt;</span> (<a href="index.html#type-unzoned">unzoned</a>, <span class="type-var">'b</span>) <a href="index.html#type-t">t</a></code></td></tr><tr id="type-t.Before" class="anchored"><td class="def constructor"><a href="#type-t.Before" class="anchor"></a><code>| </code><code><span class="constructor">Before</span> : (<a href="Inclusive_exclusive/index.html#type-t">Inclusive_exclusive.t</a> * (<a href="../../../core_kernel/Core_kernel/Date/index.html#type-t">Core__.Import.Date.t</a> * <a href="../../Core__Core_time_float/Ofday/index.html#type-t">Core__.Import_time.Time.Ofday.t</a>)) <span>&#45;&gt;</span> (<a href="index.html#type-unzoned">unzoned</a>, <span class="type-var">'b</span>) <a href="index.html#type-t">t</a></code></td></tr><tr id="type-t.After" class="anchored"><td class="def constructor"><a href="#type-t.After" class="anchor"></a><code>| </code><code><span class="constructor">After</span> : (<a href="Inclusive_exclusive/index.html#type-t">Inclusive_exclusive.t</a> * (<a href="../../../core_kernel/Core_kernel/Date/index.html#type-t">Core__.Import.Date.t</a> * <a href="../../Core__Core_time_float/Ofday/index.html#type-t">Core__.Import_time.Time.Ofday.t</a>)) <span>&#45;&gt;</span> (<a href="index.html#type-unzoned">unzoned</a>, <span class="type-var">'b</span>) <a href="index.html#type-t">t</a></code></td></tr><tr id="type-t.Always" class="anchored"><td class="def constructor"><a href="#type-t.Always" class="anchor"></a><code>| </code><code><span class="constructor">Always</span> : (<span class="type-var">'a</span>, <span class="type-var">'b</span>) <a href="index.html#type-t">t</a></code></td></tr><tr id="type-t.Never" class="anchored"><td class="def constructor"><a href="#type-t.Never" class="anchor"></a><code>| </code><code><span class="constructor">Never</span> : (<span class="type-var">'a</span>, <span class="type-var">'b</span>) <a href="index.html#type-t">t</a></code></td></tr></table></dt></dl><div><div class="spec include"><div class="doc"><details open="open"><summary><span class="def"><code><span class="keyword">include</span> <span class="keyword">sig</span> ... <span class="keyword">end</span></code></span></summary><dl><dt class="spec value" id="val-compare"><a href="#val-compare" class="anchor"></a><code><span class="keyword">val</span> compare : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> int) <span>&#45;&gt;</span> (<span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> int) <span>&#45;&gt;</span> (<span class="type-var">'a</span>, <span class="type-var">'b</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span>, <span class="type-var">'b</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int</code></dt></dl></details></div></div></div><dl><dt class="spec type" id="type-zoned_t"><a href="#type-zoned_t" class="anchor"></a><code><span class="keyword">type</span> 'b zoned_t</code><code> = (<a href="index.html#type-zoned">zoned</a>, <span class="type-var">'b</span>) <a href="index.html#type-t">t</a></code></dt></dl><div><div class="spec include"><div class="doc"><details open="open"><summary><span class="def"><code><span class="keyword">include</span> <span class="keyword">sig</span> ... <span class="keyword">end</span></code></span></summary><dl><dt class="spec value" id="val-sexp_of_zoned_t"><a href="#val-sexp_of_zoned_t" class="anchor"></a><code><span class="keyword">val</span> sexp_of_zoned_t : (<span class="type-var">'b</span> <span>&#45;&gt;</span> <a href="../../../sexplib0/Sexplib0/Sexp/index.html#type-t">Ppx_sexp_conv_lib.Sexp.t</a>) <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-zoned_t">zoned_t</a> <span>&#45;&gt;</span> <a href="../../../sexplib0/Sexplib0/Sexp/index.html#type-t">Ppx_sexp_conv_lib.Sexp.t</a></code></dt></dl></details></div></div></div><dl><dt class="spec value" id="val-to_string_zoned"><a href="#val-to_string_zoned" class="anchor"></a><code><span class="keyword">val</span> to_string_zoned : (<a href="index.html#type-zoned">zoned</a>, <span class="type-var">'b</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> string_of_tag:(<span class="type-var">'b</span> <span>&#45;&gt;</span> string) <span>&#45;&gt;</span> string</code></dt><dd><p>Returns a string suitable for debugging purposes.</p></dd></dl><div class="spec module" id="module-Stable"><a href="#module-Stable" class="anchor"></a><code><span class="keyword">module</span> <a href="Stable/index.html">Stable</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><dl><dt class="spec value" id="val-includes"><a href="#val-includes" class="anchor"></a><code><span class="keyword">val</span> includes : (<a href="index.html#type-zoned">zoned</a>, <span class="type-var">'b</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../Core_time_float/index.html#type-t">Core__.Import_time.Time.t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>includes t time</code> is true if the second represented by <code>time</code> falls within the schedule <code>t</code>.</p></dd></dl><dl><dt class="spec value" id="val-tags"><a href="#val-tags" class="anchor"></a><code><span class="keyword">val</span> tags : (<a href="index.html#type-zoned">zoned</a>, <span class="type-var">'tag</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../Core_time_float/index.html#type-t">Core__.Import_time.Time.t</a> <span>&#45;&gt;</span> [ `Not_included | `Included of <span class="type-var">'tag</span> list ]</code></dt><dd><p><code>tags t time = `Not_included</code> iff <code>not (includes t time)</code>. Otherwise, <code>tags t time
    = `Included lst</code>, where <code>lst</code> includes all tags of a schedule such that <code>includes t'
    time</code> is true where <code>t'</code> is a tagged branch of the schedule. E.g., for some <code>t</code> equal to <code>Tag some_tag t'</code>, <code>tags t time</code> will return <code>some_tag</code> if and only if <code>includes t'
    time</code> returns true.</p><p>For a more interesting use case, consider the per-office on-call schedule example given in the beginning of this module. Note that a schdeule may have no tags, and therefore, <code>lst</code> can be empty.</p></dd></dl><dl><dt class="spec value" id="val-all_tags"><a href="#val-all_tags" class="anchor"></a><code><span class="keyword">val</span> all_tags : (<a href="index.html#type-zoned">zoned</a>, <span class="type-var">'tag</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> tag_comparator:(<span class="type-var">'tag</span>, <span class="type-var">'cmp</span>) <a href="../../../core_kernel/Core_kernel/Comparator/index.html#type-t">Core__.Import.Comparator.t</a> <span>&#45;&gt;</span> (<span class="type-var">'tag</span>, <span class="type-var">'cmp</span>) <a href="../../../core_kernel/Core_kernel/Set/index.html#type-t">Core__.Import.Set.t</a></code></dt><dt class="spec value" id="val-fold_tags"><a href="#val-fold_tags" class="anchor"></a><code><span class="keyword">val</span> fold_tags : (<a href="index.html#type-zoned">zoned</a>, <span class="type-var">'tag</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> init:<span class="type-var">'m</span> <span>&#45;&gt;</span> f:(<span class="type-var">'m</span> <span>&#45;&gt;</span> <span class="type-var">'tag</span> <span>&#45;&gt;</span> <span class="type-var">'m</span>) <span>&#45;&gt;</span> <a href="../Core_time_float/index.html#type-t">Core__.Import_time.Time.t</a> <span>&#45;&gt;</span> <span class="type-var">'m</span> option</code></dt><dd><p><code>fold_tags t ~init ~f time</code> is nearly behaviorally equivalent to (but more efficient than) <code>List.fold ~init ~f (tags t time)</code>, with the exception that it returns <code>None</code> if <code>includes t time</code> is false. It is important that <code>f</code> be pure, as its results may be discarded.</p></dd></dl><dl><dt class="spec value" id="val-map_tags"><a href="#val-map_tags" class="anchor"></a><code><span class="keyword">val</span> map_tags : (<span class="type-var">'a</span>, <span class="type-var">'b</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> f:(<span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'c</span>) <span>&#45;&gt;</span> (<span class="type-var">'a</span>, <span class="type-var">'c</span>) <a href="index.html#type-t">t</a></code></dt></dl><aside><p>Returns a sequence of schedule changes over time that will never end.</p><p>If your schedules ends, you will continue to receive <code>`No_change_until_at_least</code> with increasing times forever.</p><p>The return type indicates whether <code>includes t start_time</code> is true and delivers a sequence of subsequent changes over time.</p><p>The times returned by the sequence are strictly increasing and never less than <code>start_time</code>. That is, <code>`No_change_until_at_least x</code> can never be followed by <code>`Enter x</code>, only by (at least) <code>`Enter (x + 1s)</code>.</p><p>if <code>emit</code> is set to <code>Transitions_and_tag_changes</code> then all changes in tags will be present in the resulting sequence. Otherwise only the tags in effect when a schedule is entered are available.</p><p>The <code>`In_range | `Out_of_range</code> flag in <code>`No_change_until_at_least</code> indicates whether the covered range is entirely within, or outside of the time covered by the schedule and is only there to help with bookkeeping for the caller. <code>`In_range | `Out_of_range</code> will never disagree with what could be inferred from the <code>`Enter</code> and <code>`Leave</code> events.</p><p>The sequence takes care to do only a small amount of work between each element, so that pulling the next element of the sequence is always cheap. This is the primary motivation behind including <code>`No_change_until_at_least</code>.</p><p>The <code>Time.t</code> returned by <code>`No_change_until_at_least</code> is guaranteed to be a reasonable amount of time in the future (at least 1 hour).</p></aside><div class="spec module" id="module-Event"><a href="#module-Event" class="anchor"></a><code><span class="keyword">module</span> <a href="Event/index.html">Event</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><dl><dt class="spec type" id="type-emit"><a href="#type-emit" class="anchor"></a><code><span class="keyword">type</span> ('tag, 'a) emit</code><code> = </code><table class="variant"><tr id="type-emit.Transitions" class="anchored"><td class="def constructor"><a href="#type-emit.Transitions" class="anchor"></a><code>| </code><code><span class="constructor">Transitions</span> : (<span class="type-var">'tag</span>, [ <a href="Event/index.html#type-no_change">Event.no_change</a> | <span class="type-var">'tag</span> <a href="Event/index.html#type-transition">Event.transition</a> ]) <a href="index.html#type-emit">emit</a></code></td></tr><tr id="type-emit.Transitions_and_tag_changes" class="anchored"><td class="def constructor"><a href="#type-emit.Transitions_and_tag_changes" class="anchor"></a><code>| </code><code><span class="constructor">Transitions_and_tag_changes</span> : (<span class="type-var">'tag</span> <span>&#45;&gt;</span> <span class="type-var">'tag</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> (<span class="type-var">'tag</span>, [ <a href="Event/index.html#type-no_change">Event.no_change</a> | <span class="type-var">'tag</span> <a href="Event/index.html#type-transition">Event.transition</a> | <span class="type-var">'tag</span> <a href="Event/index.html#type-tag_change">Event.tag_change</a> ]) <a href="index.html#type-emit">emit</a></code></td></tr></table></dt><dd><p>In <code>Transitions_and_tag_changes</code>, equality for the tag type must be given.</p></dd></dl><dl><dt class="spec value" id="val-to_endless_sequence"><a href="#val-to_endless_sequence" class="anchor"></a><code><span class="keyword">val</span> to_endless_sequence : (<a href="index.html#type-zoned">zoned</a>, <span class="type-var">'tag</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> start_time:<a href="../Core_time_float/index.html#type-t">Core__.Import_time.Time.t</a> <span>&#45;&gt;</span> emit:(<span class="type-var">'tag</span>, <span class="type-var">'a</span>) <a href="index.html#type-emit">emit</a> <span>&#45;&gt;</span> [ `Started_in_range of <span class="type-var">'tag</span> list * <span class="type-var">'a</span> <a href="../../../core_kernel/Core_kernel/Sequence/index.html#type-t">Core__.Import.Sequence.t</a> | `Started_out_of_range of <span class="type-var">'a</span> <a href="../../../core_kernel/Core_kernel/Sequence/index.html#type-t">Core__.Import.Sequence.t</a> ]</code></dt><dt class="spec value" id="val-next_enter_between"><a href="#val-next_enter_between" class="anchor"></a><code><span class="keyword">val</span> next_enter_between : (<a href="index.html#type-zoned">zoned</a>, <span class="type-var">'tag</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../Core_time_float/index.html#type-t">Core__.Import_time.Time.t</a> <span>&#45;&gt;</span> <a href="../Core_time_float/index.html#type-t">Core__.Import_time.Time.t</a> <span>&#45;&gt;</span> <a href="../Core_time_float/index.html#type-t">Core__.Import_time.Time.t</a> option</code></dt><dd><p><code>next_enter_between t start end</code> The given <code>start</code> <code>end</code> range is inclusive on both ends. This function is useful for one-off events during the run of a program. If you want to track changes to a schedule over time it is better to call <code>to_endless_sequence</code>.</p></dd></dl><dl><dt class="spec value" id="val-next_leave_between"><a href="#val-next_leave_between" class="anchor"></a><code><span class="keyword">val</span> next_leave_between : (<a href="index.html#type-zoned">zoned</a>, <span class="type-var">'tag</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../Core_time_float/index.html#type-t">Core__.Import_time.Time.t</a> <span>&#45;&gt;</span> <a href="../Core_time_float/index.html#type-t">Core__.Import_time.Time.t</a> <span>&#45;&gt;</span> <a href="../Core_time_float/index.html#type-t">Core__.Import_time.Time.t</a> option</code></dt><dd><p>Like <code>next_enter_between</code> but for leave events.</p></dd></dl></section></div></body></html>