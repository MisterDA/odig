<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Core__Bigstring (core.Core__Bigstring)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../index.html">core</a> &#x00BB; Core__Bigstring</nav><h1>Module <code>Core__Bigstring</code></h1><p>String type based on <code>Bigarray</code>, for use in I/O and C-bindings</p><nav class="toc"><ul><li><a href="#input-functions">Input functions</a></li><li><a href="#output-functions">Output functions</a></li><li><a href="#unsafe-functions">Unsafe functions</a></li></ul></nav></header><div><div class="spec include"><div class="doc"><details open="open"><summary><span class="def"><code><span class="keyword">include </span><span class="keyword">module type of </span><span class="keyword">sig</span> ... <span class="keyword">end</span></code></span></summary><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type </span>t</code><code><span class="keyword"> = </span>(Core_kernel__.Import.char, Bigarray.int8_unsigned_elt, Bigarray.c_layout) Bigarray.Array1.t</code></dt></dl><dl><dt class="spec value" id="val-t_of_sexp"><a href="#val-t_of_sexp" class="anchor"></a><code><span class="keyword">val </span>t_of_sexp : Sexplib.Sexp.t <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-sexp_of_t"><a href="#val-sexp_of_t" class="anchor"></a><code><span class="keyword">val </span>sexp_of_t : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> Sexplib.Sexp.t</code></dt><dt class="spec value" id="val-compare"><a href="#val-compare" class="anchor"></a><code><span class="keyword">val </span>compare : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> Core_kernel__.Import.int</code></dt><dt class="spec value" id="val-bin_t"><a href="#val-bin_t" class="anchor"></a><code><span class="keyword">val </span>bin_t : <a href="index.html#type-t">t</a> Bin_prot.Type_class.t</code></dt><dt class="spec value" id="val-bin_read_t"><a href="#val-bin_read_t" class="anchor"></a><code><span class="keyword">val </span>bin_read_t : <a href="index.html#type-t">t</a> Bin_prot.Read.reader</code></dt><dt class="spec value" id="val-__bin_read_t__"><a href="#val-__bin_read_t__" class="anchor"></a><code><span class="keyword">val </span>__bin_read_t__ : (Core_kernel__.Import.int <span>&#45;&gt;</span> <a href="index.html#type-t">t</a>) Bin_prot.Read.reader</code></dt><dt class="spec value" id="val-bin_reader_t"><a href="#val-bin_reader_t" class="anchor"></a><code><span class="keyword">val </span>bin_reader_t : <a href="index.html#type-t">t</a> Bin_prot.Type_class.reader</code></dt><dt class="spec value" id="val-bin_size_t"><a href="#val-bin_size_t" class="anchor"></a><code><span class="keyword">val </span>bin_size_t : <a href="index.html#type-t">t</a> Bin_prot.Size.sizer</code></dt><dt class="spec value" id="val-bin_write_t"><a href="#val-bin_write_t" class="anchor"></a><code><span class="keyword">val </span>bin_write_t : <a href="index.html#type-t">t</a> Bin_prot.Write.writer</code></dt><dt class="spec value" id="val-bin_writer_t"><a href="#val-bin_writer_t" class="anchor"></a><code><span class="keyword">val </span>bin_writer_t : <a href="index.html#type-t">t</a> Bin_prot.Type_class.writer</code></dt><dt class="spec value" id="val-bin_shape_t"><a href="#val-bin_shape_t" class="anchor"></a><code><span class="keyword">val </span>bin_shape_t : Bin_prot.Shape.t</code></dt></dl><dl><dt class="spec type" id="type-t_frozen"><a href="#type-t_frozen" class="anchor"></a><code><span class="keyword">type </span>t_frozen</code><code><span class="keyword"> = </span><a href="index.html#type-t">t</a></code></dt></dl><dl><dt class="spec value" id="val-t_frozen_of_sexp"><a href="#val-t_frozen_of_sexp" class="anchor"></a><code><span class="keyword">val </span>t_frozen_of_sexp : Sexplib.Sexp.t <span>&#45;&gt;</span> <a href="index.html#type-t_frozen">t_frozen</a></code></dt><dt class="spec value" id="val-sexp_of_t_frozen"><a href="#val-sexp_of_t_frozen" class="anchor"></a><code><span class="keyword">val </span>sexp_of_t_frozen : <a href="index.html#type-t_frozen">t_frozen</a> <span>&#45;&gt;</span> Sexplib.Sexp.t</code></dt><dt class="spec value" id="val-hash_fold_t_frozen"><a href="#val-hash_fold_t_frozen" class="anchor"></a><code><span class="keyword">val </span>hash_fold_t_frozen : Ppx_hash_lib.Std.Hash.state <span>&#45;&gt;</span> <a href="index.html#type-t_frozen">t_frozen</a> <span>&#45;&gt;</span> Ppx_hash_lib.Std.Hash.state</code></dt><dt class="spec value" id="val-hash_t_frozen"><a href="#val-hash_t_frozen" class="anchor"></a><code><span class="keyword">val </span>hash_t_frozen : <a href="index.html#type-t_frozen">t_frozen</a> <span>&#45;&gt;</span> Ppx_hash_lib.Std.Hash.hash_value</code></dt><dt class="spec value" id="val-compare_t_frozen"><a href="#val-compare_t_frozen" class="anchor"></a><code><span class="keyword">val </span>compare_t_frozen : <a href="index.html#type-t_frozen">t_frozen</a> <span>&#45;&gt;</span> <a href="index.html#type-t_frozen">t_frozen</a> <span>&#45;&gt;</span> Core_kernel__.Import.int</code></dt><dt class="spec value" id="val-bin_t_frozen"><a href="#val-bin_t_frozen" class="anchor"></a><code><span class="keyword">val </span>bin_t_frozen : <a href="index.html#type-t_frozen">t_frozen</a> Bin_prot.Type_class.t</code></dt><dt class="spec value" id="val-bin_read_t_frozen"><a href="#val-bin_read_t_frozen" class="anchor"></a><code><span class="keyword">val </span>bin_read_t_frozen : <a href="index.html#type-t_frozen">t_frozen</a> Bin_prot.Read.reader</code></dt><dt class="spec value" id="val-__bin_read_t_frozen__"><a href="#val-__bin_read_t_frozen__" class="anchor"></a><code><span class="keyword">val </span>__bin_read_t_frozen__ : (Core_kernel__.Import.int <span>&#45;&gt;</span> <a href="index.html#type-t_frozen">t_frozen</a>) Bin_prot.Read.reader</code></dt><dt class="spec value" id="val-bin_reader_t_frozen"><a href="#val-bin_reader_t_frozen" class="anchor"></a><code><span class="keyword">val </span>bin_reader_t_frozen : <a href="index.html#type-t_frozen">t_frozen</a> Bin_prot.Type_class.reader</code></dt><dt class="spec value" id="val-bin_size_t_frozen"><a href="#val-bin_size_t_frozen" class="anchor"></a><code><span class="keyword">val </span>bin_size_t_frozen : <a href="index.html#type-t_frozen">t_frozen</a> Bin_prot.Size.sizer</code></dt><dt class="spec value" id="val-bin_write_t_frozen"><a href="#val-bin_write_t_frozen" class="anchor"></a><code><span class="keyword">val </span>bin_write_t_frozen : <a href="index.html#type-t_frozen">t_frozen</a> Bin_prot.Write.writer</code></dt><dt class="spec value" id="val-bin_writer_t_frozen"><a href="#val-bin_writer_t_frozen" class="anchor"></a><code><span class="keyword">val </span>bin_writer_t_frozen : <a href="index.html#type-t_frozen">t_frozen</a> Bin_prot.Type_class.writer</code></dt><dt class="spec value" id="val-bin_shape_t_frozen"><a href="#val-bin_shape_t_frozen" class="anchor"></a><code><span class="keyword">val </span>bin_shape_t_frozen : Bin_prot.Shape.t</code></dt><dt class="spec value" id="val-equal"><a href="#val-equal" class="anchor"></a><code><span class="keyword">val </span>equal : <a href="index.html#type-t">t</a> Core_kernel__.Import.Equal.equal</code></dt></dl><div class="spec module" id="module-Hexdump"><a href="#module-Hexdump" class="anchor"></a><code><span class="keyword">module </span>Hexdump = Core_kernel__Bigstring.Hexdump</code></div><dl><dt class="spec value" id="val-create"><a href="#val-create" class="anchor"></a><code><span class="keyword">val </span>create : ?&#8288;max_mem_waiting_gc:Core_kernel__.Byte_units.t <span>&#45;&gt;</span> Core_kernel__.Import.int <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-init"><a href="#val-init" class="anchor"></a><code><span class="keyword">val </span>init : Core_kernel__.Import.int <span>&#45;&gt;</span> f:(Core_kernel__.Import.int <span>&#45;&gt;</span> Core_kernel__.Import.char) <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-of_string"><a href="#val-of_string" class="anchor"></a><code><span class="keyword">val </span>of_string : ?&#8288;pos:Core_kernel__.Import.int <span>&#45;&gt;</span> ?&#8288;len:Core_kernel__.Import.int <span>&#45;&gt;</span> Core_kernel__.Import.string <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-to_string"><a href="#val-to_string" class="anchor"></a><code><span class="keyword">val </span>to_string : ?&#8288;pos:Core_kernel__.Import.int <span>&#45;&gt;</span> ?&#8288;len:Core_kernel__.Import.int <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> Core_kernel__.Import.string</code></dt><dt class="spec value" id="val-concat"><a href="#val-concat" class="anchor"></a><code><span class="keyword">val </span>concat : ?&#8288;sep:<a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> Core_kernel__.Import.list <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-check_args"><a href="#val-check_args" class="anchor"></a><code><span class="keyword">val </span>check_args : loc:Core_kernel__.Import.string <span>&#45;&gt;</span> pos:Core_kernel__.Import.int <span>&#45;&gt;</span> len:Core_kernel__.Import.int <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> Core_kernel__.Import.unit</code></dt><dt class="spec value" id="val-get_opt_len"><a href="#val-get_opt_len" class="anchor"></a><code><span class="keyword">val </span>get_opt_len : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> pos:Core_kernel__.Import.int <span>&#45;&gt;</span> Core_kernel__.Import.int Core_kernel__.Import.option <span>&#45;&gt;</span> Core_kernel__.Import.int</code></dt><dt class="spec value" id="val-length"><a href="#val-length" class="anchor"></a><code><span class="keyword">val </span>length : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> Core_kernel__.Import.int</code></dt><dt class="spec value" id="val-sub_shared"><a href="#val-sub_shared" class="anchor"></a><code><span class="keyword">val </span>sub_shared : ?&#8288;pos:Core_kernel__.Import.int <span>&#45;&gt;</span> ?&#8288;len:Core_kernel__.Import.int <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt></dl><dl><dt class="spec external" id="val-get"><a href="#val-get" class="anchor"></a><code><span class="keyword">val </span>get : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> Core_kernel__.Import.int <span>&#45;&gt;</span> Core_kernel__.Import.char</code></dt><dt class="spec external" id="val-set"><a href="#val-set" class="anchor"></a><code><span class="keyword">val </span>set : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> Core_kernel__.Import.int <span>&#45;&gt;</span> Core_kernel__.Import.char <span>&#45;&gt;</span> Core_kernel__.Import.unit</code></dt><dt class="spec external" id="val-is_mmapped"><a href="#val-is_mmapped" class="anchor"></a><code><span class="keyword">val </span>is_mmapped : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> Core_kernel__.Import.bool</code></dt></dl><dl><dt class="spec value" id="val-blit"><a href="#val-blit" class="anchor"></a><code><span class="keyword">val </span>blit : (<a href="index.html#type-t">t</a>, <a href="index.html#type-t">t</a>) Base.Blit_intf.blit</code></dt><dt class="spec value" id="val-blito"><a href="#val-blito" class="anchor"></a><code><span class="keyword">val </span>blito : (<a href="index.html#type-t">t</a>, <a href="index.html#type-t">t</a>) Base.Blit_intf.blito</code></dt><dt class="spec value" id="val-unsafe_blit"><a href="#val-unsafe_blit" class="anchor"></a><code><span class="keyword">val </span>unsafe_blit : (<a href="index.html#type-t">t</a>, <a href="index.html#type-t">t</a>) Base.Blit_intf.blit</code></dt><dt class="spec value" id="val-sub"><a href="#val-sub" class="anchor"></a><code><span class="keyword">val </span>sub : (<a href="index.html#type-t">t</a>, <a href="index.html#type-t">t</a>) Base.Blit_intf.sub</code></dt><dt class="spec value" id="val-subo"><a href="#val-subo" class="anchor"></a><code><span class="keyword">val </span>subo : (<a href="index.html#type-t">t</a>, <a href="index.html#type-t">t</a>) Base.Blit_intf.subo</code></dt></dl><div class="spec module" id="module-To_string"><a href="#module-To_string" class="anchor"></a><code><span class="keyword">module </span>To_string = Core_kernel__Bigstring.To_string</code></div><div class="spec module" id="module-From_string"><a href="#module-From_string" class="anchor"></a><code><span class="keyword">module </span>From_string = Core_kernel__Bigstring.From_string</code></div><dl><dt class="spec value" id="val-write_bin_prot"><a href="#val-write_bin_prot" class="anchor"></a><code><span class="keyword">val </span>write_bin_prot : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> ?&#8288;pos:Core_kernel__.Import.int <span>&#45;&gt;</span> <span class="type-var">'a</span> Bin_prot.Type_class.writer <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> Core_kernel__.Import.int</code></dt><dt class="spec value" id="val-read_bin_prot"><a href="#val-read_bin_prot" class="anchor"></a><code><span class="keyword">val </span>read_bin_prot : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> ?&#8288;pos:Core_kernel__.Import.int <span>&#45;&gt;</span> ?&#8288;len:Core_kernel__.Import.int <span>&#45;&gt;</span> <span class="type-var">'a</span> Bin_prot.Type_class.reader <span>&#45;&gt;</span> (<span class="type-var">'a</span><span class="keyword"> * </span>Core_kernel__.Import.int) Core_kernel__.Or_error.t</code></dt><dt class="spec value" id="val-read_bin_prot_verbose_errors"><a href="#val-read_bin_prot_verbose_errors" class="anchor"></a><code><span class="keyword">val </span>read_bin_prot_verbose_errors : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> ?&#8288;pos:Core_kernel__.Import.int <span>&#45;&gt;</span> ?&#8288;len:Core_kernel__.Import.int <span>&#45;&gt;</span> <span class="type-var">'a</span> Bin_prot.Type_class.reader <span>&#45;&gt;</span> [ `Invalid_data of Core_kernel__.Error.t<span class="keyword"> | </span>`Not_enough_data<span class="keyword"> | </span>`Ok of <span class="type-var">'a</span><span class="keyword"> * </span>Core_kernel__.Import.int ]</code></dt><dt class="spec value" id="val-map_file"><a href="#val-map_file" class="anchor"></a><code><span class="keyword">val </span>map_file : shared:Core_kernel__.Import.bool <span>&#45;&gt;</span> Unix.file_descr <span>&#45;&gt;</span> Core_kernel__.Import.int <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-find"><a href="#val-find" class="anchor"></a><code><span class="keyword">val </span>find : ?&#8288;pos:Core_kernel__.Import.int <span>&#45;&gt;</span> ?&#8288;len:Core_kernel__.Import.int <span>&#45;&gt;</span> Core_kernel__.Import.char <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> Core_kernel__.Import.int Core_kernel__.Import.option</code></dt></dl><dl><dt class="spec external" id="val-unsafe_find"><a href="#val-unsafe_find" class="anchor"></a><code><span class="keyword">val </span>unsafe_find : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> Core_kernel__.Import.char <span>&#45;&gt;</span> pos:Core_kernel__.Import.int <span>&#45;&gt;</span> len:Core_kernel__.Import.int <span>&#45;&gt;</span> Core_kernel__.Import.int</code></dt><dt class="spec external" id="val-unsafe_destroy"><a href="#val-unsafe_destroy" class="anchor"></a><code><span class="keyword">val </span>unsafe_destroy : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> Core_kernel__.Import.unit</code></dt></dl><dl><dt class="spec value" id="val-unsafe_get_int8"><a href="#val-unsafe_get_int8" class="anchor"></a><code><span class="keyword">val </span>unsafe_get_int8 : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> pos:Core_kernel__.Import.int <span>&#45;&gt;</span> Core_kernel__.Import.int</code></dt><dt class="spec value" id="val-unsafe_set_int8"><a href="#val-unsafe_set_int8" class="anchor"></a><code><span class="keyword">val </span>unsafe_set_int8 : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> pos:Core_kernel__.Import.int <span>&#45;&gt;</span> Core_kernel__.Import.int <span>&#45;&gt;</span> Core_kernel__.Import.unit</code></dt><dt class="spec value" id="val-unsafe_get_uint8"><a href="#val-unsafe_get_uint8" class="anchor"></a><code><span class="keyword">val </span>unsafe_get_uint8 : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> pos:Core_kernel__.Import.int <span>&#45;&gt;</span> Core_kernel__.Import.int</code></dt><dt class="spec value" id="val-unsafe_set_uint8"><a href="#val-unsafe_set_uint8" class="anchor"></a><code><span class="keyword">val </span>unsafe_set_uint8 : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> pos:Core_kernel__.Import.int <span>&#45;&gt;</span> Core_kernel__.Import.int <span>&#45;&gt;</span> Core_kernel__.Import.unit</code></dt><dt class="spec value" id="val-unsafe_get_int16_le"><a href="#val-unsafe_get_int16_le" class="anchor"></a><code><span class="keyword">val </span>unsafe_get_int16_le : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> pos:Core_kernel__.Import.int <span>&#45;&gt;</span> Core_kernel__.Import.int</code></dt><dt class="spec value" id="val-unsafe_get_int16_be"><a href="#val-unsafe_get_int16_be" class="anchor"></a><code><span class="keyword">val </span>unsafe_get_int16_be : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> pos:Core_kernel__.Import.int <span>&#45;&gt;</span> Core_kernel__.Import.int</code></dt><dt class="spec value" id="val-unsafe_set_int16_le"><a href="#val-unsafe_set_int16_le" class="anchor"></a><code><span class="keyword">val </span>unsafe_set_int16_le : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> pos:Core_kernel__.Import.int <span>&#45;&gt;</span> Core_kernel__.Import.int <span>&#45;&gt;</span> Core_kernel__.Import.unit</code></dt><dt class="spec value" id="val-unsafe_set_int16_be"><a href="#val-unsafe_set_int16_be" class="anchor"></a><code><span class="keyword">val </span>unsafe_set_int16_be : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> pos:Core_kernel__.Import.int <span>&#45;&gt;</span> Core_kernel__.Import.int <span>&#45;&gt;</span> Core_kernel__.Import.unit</code></dt><dt class="spec value" id="val-unsafe_get_uint16_le"><a href="#val-unsafe_get_uint16_le" class="anchor"></a><code><span class="keyword">val </span>unsafe_get_uint16_le : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> pos:Core_kernel__.Import.int <span>&#45;&gt;</span> Core_kernel__.Import.int</code></dt><dt class="spec value" id="val-unsafe_get_uint16_be"><a href="#val-unsafe_get_uint16_be" class="anchor"></a><code><span class="keyword">val </span>unsafe_get_uint16_be : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> pos:Core_kernel__.Import.int <span>&#45;&gt;</span> Core_kernel__.Import.int</code></dt><dt class="spec value" id="val-unsafe_set_uint16_le"><a href="#val-unsafe_set_uint16_le" class="anchor"></a><code><span class="keyword">val </span>unsafe_set_uint16_le : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> pos:Core_kernel__.Import.int <span>&#45;&gt;</span> Core_kernel__.Import.int <span>&#45;&gt;</span> Core_kernel__.Import.unit</code></dt><dt class="spec value" id="val-unsafe_set_uint16_be"><a href="#val-unsafe_set_uint16_be" class="anchor"></a><code><span class="keyword">val </span>unsafe_set_uint16_be : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> pos:Core_kernel__.Import.int <span>&#45;&gt;</span> Core_kernel__.Import.int <span>&#45;&gt;</span> Core_kernel__.Import.unit</code></dt><dt class="spec value" id="val-unsafe_get_int32_le"><a href="#val-unsafe_get_int32_le" class="anchor"></a><code><span class="keyword">val </span>unsafe_get_int32_le : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> pos:Core_kernel__.Import.int <span>&#45;&gt;</span> Core_kernel__.Import.int</code></dt><dt class="spec value" id="val-unsafe_get_int32_be"><a href="#val-unsafe_get_int32_be" class="anchor"></a><code><span class="keyword">val </span>unsafe_get_int32_be : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> pos:Core_kernel__.Import.int <span>&#45;&gt;</span> Core_kernel__.Import.int</code></dt><dt class="spec value" id="val-unsafe_set_int32_le"><a href="#val-unsafe_set_int32_le" class="anchor"></a><code><span class="keyword">val </span>unsafe_set_int32_le : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> pos:Core_kernel__.Import.int <span>&#45;&gt;</span> Core_kernel__.Import.int <span>&#45;&gt;</span> Core_kernel__.Import.unit</code></dt><dt class="spec value" id="val-unsafe_set_int32_be"><a href="#val-unsafe_set_int32_be" class="anchor"></a><code><span class="keyword">val </span>unsafe_set_int32_be : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> pos:Core_kernel__.Import.int <span>&#45;&gt;</span> Core_kernel__.Import.int <span>&#45;&gt;</span> Core_kernel__.Import.unit</code></dt><dt class="spec value" id="val-unsafe_get_uint32_le"><a href="#val-unsafe_get_uint32_le" class="anchor"></a><code><span class="keyword">val </span>unsafe_get_uint32_le : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> pos:Core_kernel__.Import.int <span>&#45;&gt;</span> Core_kernel__.Import.int</code></dt><dt class="spec value" id="val-unsafe_get_uint32_be"><a href="#val-unsafe_get_uint32_be" class="anchor"></a><code><span class="keyword">val </span>unsafe_get_uint32_be : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> pos:Core_kernel__.Import.int <span>&#45;&gt;</span> Core_kernel__.Import.int</code></dt><dt class="spec value" id="val-unsafe_set_uint32_le"><a href="#val-unsafe_set_uint32_le" class="anchor"></a><code><span class="keyword">val </span>unsafe_set_uint32_le : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> pos:Core_kernel__.Import.int <span>&#45;&gt;</span> Core_kernel__.Import.int <span>&#45;&gt;</span> Core_kernel__.Import.unit</code></dt><dt class="spec value" id="val-unsafe_set_uint32_be"><a href="#val-unsafe_set_uint32_be" class="anchor"></a><code><span class="keyword">val </span>unsafe_set_uint32_be : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> pos:Core_kernel__.Import.int <span>&#45;&gt;</span> Core_kernel__.Import.int <span>&#45;&gt;</span> Core_kernel__.Import.unit</code></dt><dt class="spec value" id="val-unsafe_get_int64_le_exn"><a href="#val-unsafe_get_int64_le_exn" class="anchor"></a><code><span class="keyword">val </span>unsafe_get_int64_le_exn : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> pos:Core_kernel__.Import.int <span>&#45;&gt;</span> Core_kernel__.Import.int</code></dt><dt class="spec value" id="val-unsafe_get_int64_be_exn"><a href="#val-unsafe_get_int64_be_exn" class="anchor"></a><code><span class="keyword">val </span>unsafe_get_int64_be_exn : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> pos:Core_kernel__.Import.int <span>&#45;&gt;</span> Core_kernel__.Import.int</code></dt><dt class="spec value" id="val-unsafe_get_int64_le_trunc"><a href="#val-unsafe_get_int64_le_trunc" class="anchor"></a><code><span class="keyword">val </span>unsafe_get_int64_le_trunc : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> pos:Core_kernel__.Import.int <span>&#45;&gt;</span> Core_kernel__.Import.int</code></dt><dt class="spec value" id="val-unsafe_get_int64_be_trunc"><a href="#val-unsafe_get_int64_be_trunc" class="anchor"></a><code><span class="keyword">val </span>unsafe_get_int64_be_trunc : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> pos:Core_kernel__.Import.int <span>&#45;&gt;</span> Core_kernel__.Import.int</code></dt><dt class="spec value" id="val-unsafe_set_int64_le"><a href="#val-unsafe_set_int64_le" class="anchor"></a><code><span class="keyword">val </span>unsafe_set_int64_le : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> pos:Core_kernel__.Import.int <span>&#45;&gt;</span> Core_kernel__.Import.int <span>&#45;&gt;</span> Core_kernel__.Import.unit</code></dt><dt class="spec value" id="val-unsafe_set_int64_be"><a href="#val-unsafe_set_int64_be" class="anchor"></a><code><span class="keyword">val </span>unsafe_set_int64_be : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> pos:Core_kernel__.Import.int <span>&#45;&gt;</span> Core_kernel__.Import.int <span>&#45;&gt;</span> Core_kernel__.Import.unit</code></dt><dt class="spec value" id="val-unsafe_get_uint64_be_exn"><a href="#val-unsafe_get_uint64_be_exn" class="anchor"></a><code><span class="keyword">val </span>unsafe_get_uint64_be_exn : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> pos:Core_kernel__.Import.int <span>&#45;&gt;</span> Core_kernel__.Import.int</code></dt><dt class="spec value" id="val-unsafe_get_uint64_le_exn"><a href="#val-unsafe_get_uint64_le_exn" class="anchor"></a><code><span class="keyword">val </span>unsafe_get_uint64_le_exn : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> pos:Core_kernel__.Import.int <span>&#45;&gt;</span> Core_kernel__.Import.int</code></dt><dt class="spec value" id="val-unsafe_set_uint64_le"><a href="#val-unsafe_set_uint64_le" class="anchor"></a><code><span class="keyword">val </span>unsafe_set_uint64_le : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> pos:Core_kernel__.Import.int <span>&#45;&gt;</span> Core_kernel__.Import.int <span>&#45;&gt;</span> Core_kernel__.Import.unit</code></dt><dt class="spec value" id="val-unsafe_set_uint64_be"><a href="#val-unsafe_set_uint64_be" class="anchor"></a><code><span class="keyword">val </span>unsafe_set_uint64_be : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> pos:Core_kernel__.Import.int <span>&#45;&gt;</span> Core_kernel__.Import.int <span>&#45;&gt;</span> Core_kernel__.Import.unit</code></dt><dt class="spec value" id="val-unsafe_get_int32_t_le"><a href="#val-unsafe_get_int32_t_le" class="anchor"></a><code><span class="keyword">val </span>unsafe_get_int32_t_le : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> pos:Core_kernel__.Import.int <span>&#45;&gt;</span> Int32.t</code></dt><dt class="spec value" id="val-unsafe_get_int32_t_be"><a href="#val-unsafe_get_int32_t_be" class="anchor"></a><code><span class="keyword">val </span>unsafe_get_int32_t_be : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> pos:Core_kernel__.Import.int <span>&#45;&gt;</span> Int32.t</code></dt><dt class="spec value" id="val-unsafe_set_int32_t_le"><a href="#val-unsafe_set_int32_t_le" class="anchor"></a><code><span class="keyword">val </span>unsafe_set_int32_t_le : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> pos:Core_kernel__.Import.int <span>&#45;&gt;</span> Int32.t <span>&#45;&gt;</span> Core_kernel__.Import.unit</code></dt><dt class="spec value" id="val-unsafe_set_int32_t_be"><a href="#val-unsafe_set_int32_t_be" class="anchor"></a><code><span class="keyword">val </span>unsafe_set_int32_t_be : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> pos:Core_kernel__.Import.int <span>&#45;&gt;</span> Int32.t <span>&#45;&gt;</span> Core_kernel__.Import.unit</code></dt><dt class="spec value" id="val-unsafe_get_int64_t_le"><a href="#val-unsafe_get_int64_t_le" class="anchor"></a><code><span class="keyword">val </span>unsafe_get_int64_t_le : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> pos:Core_kernel__.Import.int <span>&#45;&gt;</span> Int64.t</code></dt><dt class="spec value" id="val-unsafe_get_int64_t_be"><a href="#val-unsafe_get_int64_t_be" class="anchor"></a><code><span class="keyword">val </span>unsafe_get_int64_t_be : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> pos:Core_kernel__.Import.int <span>&#45;&gt;</span> Int64.t</code></dt><dt class="spec value" id="val-unsafe_set_int64_t_le"><a href="#val-unsafe_set_int64_t_le" class="anchor"></a><code><span class="keyword">val </span>unsafe_set_int64_t_le : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> pos:Core_kernel__.Import.int <span>&#45;&gt;</span> Int64.t <span>&#45;&gt;</span> Core_kernel__.Import.unit</code></dt><dt class="spec value" id="val-unsafe_set_int64_t_be"><a href="#val-unsafe_set_int64_t_be" class="anchor"></a><code><span class="keyword">val </span>unsafe_set_int64_t_be : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> pos:Core_kernel__.Import.int <span>&#45;&gt;</span> Int64.t <span>&#45;&gt;</span> Core_kernel__.Import.unit</code></dt><dt class="spec value" id="val-get_tail_padded_fixed_string"><a href="#val-get_tail_padded_fixed_string" class="anchor"></a><code><span class="keyword">val </span>get_tail_padded_fixed_string : padding:Core_kernel__.Import.char <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> pos:Core_kernel__.Import.int <span>&#45;&gt;</span> len:Core_kernel__.Import.int <span>&#45;&gt;</span> Core_kernel__.Import.unit <span>&#45;&gt;</span> Core_kernel__.Import.string</code></dt><dt class="spec value" id="val-set_tail_padded_fixed_string"><a href="#val-set_tail_padded_fixed_string" class="anchor"></a><code><span class="keyword">val </span>set_tail_padded_fixed_string : padding:Core_kernel__.Import.char <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> pos:Core_kernel__.Import.int <span>&#45;&gt;</span> len:Core_kernel__.Import.int <span>&#45;&gt;</span> Core_kernel__.Import.string <span>&#45;&gt;</span> Core_kernel__.Import.unit</code></dt><dt class="spec value" id="val-get_head_padded_fixed_string"><a href="#val-get_head_padded_fixed_string" class="anchor"></a><code><span class="keyword">val </span>get_head_padded_fixed_string : padding:Core_kernel__.Import.char <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> pos:Core_kernel__.Import.int <span>&#45;&gt;</span> len:Core_kernel__.Import.int <span>&#45;&gt;</span> Core_kernel__.Import.unit <span>&#45;&gt;</span> Core_kernel__.Import.string</code></dt><dt class="spec value" id="val-set_head_padded_fixed_string"><a href="#val-set_head_padded_fixed_string" class="anchor"></a><code><span class="keyword">val </span>set_head_padded_fixed_string : padding:Core_kernel__.Import.char <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> pos:Core_kernel__.Import.int <span>&#45;&gt;</span> len:Core_kernel__.Import.int <span>&#45;&gt;</span> Core_kernel__.Import.string <span>&#45;&gt;</span> Core_kernel__.Import.unit</code></dt></dl></details></div></div></div><dl><dt class="spec exception" id="exception-IOError"><a href="#exception-IOError" class="anchor"></a><code><span class="keyword">exception </span></code><code><span class="exception">IOError</span><span class="keyword"> of </span>int<span class="keyword"> * </span>exn</code></dt><dd><p>Type of I/O errors</p><p>In <code>IOError (n, exn)</code>, <code>n</code> is the number of bytes successfully read/written before the error and <code>exn</code> is the occured exception (e.g. Unix_error, End_of_file)</p></dd></dl><section><header><h6 id="input-functions"><a href="#input-functions" class="anchor"></a>Input functions</h6></header><dl><dt class="spec value" id="val-read"><a href="#val-read" class="anchor"></a><code><span class="keyword">val </span>read : ?&#8288;min_len:int <span>&#45;&gt;</span> Unix.file_descr <span>&#45;&gt;</span> ?&#8288;pos:int <span>&#45;&gt;</span> ?&#8288;len:int <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int</code></dt><dd><p><code>read ?min_len fd ?pos ?len bstr</code> reads at least <code>min_len</code> (must be greater than or equal zero) and at most <code>len</code> (must be greater than or equal to <code>min_len</code>) bytes from file descriptor <code>fd</code>, and writes them to bigstring <code>bstr</code> starting at position <code>pos</code>. </p><dl><dt>returns</dt><dd><p>the number of bytes actually read.</p><p><code>read</code> returns zero only if <code>len = 0</code>. If <code>len &gt; 0</code> and there's nothing left to read, <code>read</code> raises to indicate EOF even if <code>min_len = 0</code>.</p><p>NOTE: even if <code>len</code> is zero, there may still be errors when reading from the descriptor!</p></dd></dl><dl><dt>raises Invalid_argument</dt><dd><p>if the designated ranges are out of bounds.</p></dd></dl><dl><dt>raises IOError</dt><dd><p>in the case of input errors, or on EOF if the minimum length could not be read.</p></dd></dl><dl><dt>parameter pos</dt><dd><p>default = 0</p></dd></dl><dl><dt>parameter min_len</dt><dd><p>default = 0</p></dd></dl><dl><dt>parameter len</dt><dd><p>default = <code>length bstr - pos</code></p></dd></dl></dd></dl><dl><dt class="spec value" id="val-really_read"><a href="#val-really_read" class="anchor"></a><code><span class="keyword">val </span>really_read : Unix.file_descr <span>&#45;&gt;</span> ?&#8288;pos:int <span>&#45;&gt;</span> ?&#8288;len:int <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>really_read fd ?pos ?len bstr</code> reads <code>len</code> bytes from file descriptor <code>fd</code>, and writes them to bigstring <code>bstr</code> starting at position <code>pos</code>.</p><dl><dt>raises Invalid_argument</dt><dd><p>if the designated range is out of bounds.</p></dd></dl><dl><dt>raises IOError</dt><dd><p>in the case of input errors, or on EOF.</p></dd></dl><dl><dt>parameter pos</dt><dd><p>default = 0</p></dd></dl><dl><dt>parameter len</dt><dd><p>default = <code>length bstr - pos</code></p></dd></dl></dd></dl><dl><dt class="spec value" id="val-really_recv"><a href="#val-really_recv" class="anchor"></a><code><span class="keyword">val </span>really_recv : Unix.file_descr <span>&#45;&gt;</span> ?&#8288;pos:int <span>&#45;&gt;</span> ?&#8288;len:int <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>really_recv sock ?pos ?len bstr</code> receives <code>len</code> bytes from socket <code>sock</code>, and writes them to bigstring <code>bstr</code> starting at position <code>pos</code>. If <code>len</code> is zero, the function returns immediately without performing the underlying system call.</p><dl><dt>raises Invalid_argument</dt><dd><p>if the designated range is out of bounds.</p></dd></dl><dl><dt>raises IOError</dt><dd><p>in the case of input errors, or on EOF.</p></dd></dl><dl><dt>parameter pos</dt><dd><p>default = 0</p></dd></dl><dl><dt>parameter len</dt><dd><p>default = <code>length bstr - pos</code></p></dd></dl></dd></dl><dl><dt class="spec value" id="val-recvfrom_assume_fd_is_nonblocking"><a href="#val-recvfrom_assume_fd_is_nonblocking" class="anchor"></a><code><span class="keyword">val </span>recvfrom_assume_fd_is_nonblocking : Unix.file_descr <span>&#45;&gt;</span> ?&#8288;pos:int <span>&#45;&gt;</span> ?&#8288;len:int <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int<span class="keyword"> * </span>Unix.sockaddr</code></dt><dd><p><code>recvfrom_assume_fd_is_nonblocking sock ?pos ?len bstr</code> reads up to <code>len</code> bytes into bigstring <code>bstr</code> starting at position <code>pos</code> from socket <code>sock</code> without yielding to other OCaml-threads.</p><dl><dt>returns</dt><dd><p>the number of bytes actually read and the socket address of the client.</p></dd></dl><dl><dt>raises Unix_error</dt><dd><p>in the case of input errors.</p></dd></dl><dl><dt>raises Invalid_argument</dt><dd><p>if the designated range is out of bounds.</p></dd></dl><dl><dt>parameter pos</dt><dd><p>default = 0</p></dd></dl><dl><dt>parameter len</dt><dd><p>default = <code>length bstr - pos</code></p></dd></dl></dd></dl><dl><dt class="spec value" id="val-read_assume_fd_is_nonblocking"><a href="#val-read_assume_fd_is_nonblocking" class="anchor"></a><code><span class="keyword">val </span>read_assume_fd_is_nonblocking : Unix.file_descr <span>&#45;&gt;</span> ?&#8288;pos:int <span>&#45;&gt;</span> ?&#8288;len:int <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> Core__.Syscall_result.Int.t</code></dt><dd><p><code>read_assume_fd_is_nonblocking fd ?pos ?len bstr</code> reads up to <code>len</code> bytes into bigstring <code>bstr</code> starting at position <code>pos</code> from file descriptor <code>fd</code> without yielding to other OCaml-threads.</p><dl><dt>returns</dt><dd><p>the number of bytes actually read.</p></dd></dl><dl><dt>raises Invalid_argument</dt><dd><p>if the designated range is out of bounds.</p></dd></dl><dl><dt>parameter pos</dt><dd><p>default = 0</p></dd></dl><dl><dt>parameter len</dt><dd><p>default = <code>length bstr - pos</code></p></dd></dl></dd></dl><dl><dt class="spec value" id="val-pread_assume_fd_is_nonblocking"><a href="#val-pread_assume_fd_is_nonblocking" class="anchor"></a><code><span class="keyword">val </span>pread_assume_fd_is_nonblocking : Unix.file_descr <span>&#45;&gt;</span> offset:int <span>&#45;&gt;</span> ?&#8288;pos:int <span>&#45;&gt;</span> ?&#8288;len:int <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int</code></dt><dd><p><code>pread_assume_fd_is_nonblocking fd ~offset ?pos ?len bstr</code> reads up to <code>len</code> bytes from file descriptor <code>fd</code> at offset <code>offset</code>, and writes them to bigstring <code>bstr</code> starting at position <code>pos</code>. The fd must be capable of seeking, and the current file offset used for a regular <code>read()</code> is unchanged. Please see 'man pread' for more information. </p><dl><dt>returns</dt><dd><p>the number of bytes actually read.</p></dd></dl><dl><dt>raises Invalid_argument</dt><dd><p>if the designated range is out of bounds.</p></dd></dl><dl><dt>raises Unix_error</dt><dd><p>in the case of input errors.</p></dd></dl><dl><dt>parameter pos</dt><dd><p>default = 0</p></dd></dl><dl><dt>parameter len</dt><dd><p>default = <code>length bstr - pos</code></p></dd></dl></dd></dl><dl><dt class="spec value" id="val-input"><a href="#val-input" class="anchor"></a><code><span class="keyword">val </span>input : ?&#8288;min_len:int <span>&#45;&gt;</span> Core__.Import.In_channel.t <span>&#45;&gt;</span> ?&#8288;pos:int <span>&#45;&gt;</span> ?&#8288;len:int <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int</code></dt><dd><p><code>input ?min_len ic ?pos ?len bstr</code> tries to read <code>len</code> bytes (guarantees to read at least <code>min_len</code> bytes (must be greater than or equal to zero and smaller or equal to <code>len</code>), if possible, before returning) from input channel <code>ic</code>, and writes them to bigstring <code>bstr</code> starting at position <code>pos</code>. </p><dl><dt>returns</dt><dd><p>the number of bytes actually read.</p><p>NOTE: even if <code>len</code> is zero, there may still be errors when reading from the descriptor, which will be done if the internal buffer is empty!</p><p>NOTE: if at least <code>len</code> characters are available in the input channel buffer and if <code>len</code> is not zero, data will only be fetched from the channel buffer. Otherwise data will be read until at least <code>min_len</code> characters are available.</p></dd></dl><dl><dt>raises Invalid_argument</dt><dd><p>if the designated range is out of bounds.</p></dd></dl><dl><dt>raises IOError</dt><dd><p>in the case of input errors, or on premature EOF.</p></dd></dl><dl><dt>parameter pos</dt><dd><p>default = 0</p></dd></dl><dl><dt>parameter min_len</dt><dd><p>default = 0</p></dd></dl><dl><dt>parameter len</dt><dd><p>default = <code>length bstr - pos</code></p></dd></dl></dd></dl><dl><dt class="spec value" id="val-really_input"><a href="#val-really_input" class="anchor"></a><code><span class="keyword">val </span>really_input : Core__.Import.In_channel.t <span>&#45;&gt;</span> ?&#8288;pos:int <span>&#45;&gt;</span> ?&#8288;len:int <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>really_input ic ?pos ?len bstr</code> reads exactly <code>len</code> bytes from input channel <code>ic</code>, and writes them to bigstring <code>bstr</code> starting at position <code>pos</code>.</p><dl><dt>raises Invalid_argument</dt><dd><p>if the designated range is out of bounds.</p></dd></dl><dl><dt>raises IOError</dt><dd><p>in the case of input errors, or on premature EOF.</p></dd></dl><dl><dt>parameter pos</dt><dd><p>default = 0</p></dd></dl><dl><dt>parameter len</dt><dd><p>default = <code>length bstr - pos</code></p></dd></dl></dd></dl></section><section><header><h6 id="output-functions"><a href="#output-functions" class="anchor"></a>Output functions</h6></header><dl><dt class="spec value" id="val-really_write"><a href="#val-really_write" class="anchor"></a><code><span class="keyword">val </span>really_write : Unix.file_descr <span>&#45;&gt;</span> ?&#8288;pos:int <span>&#45;&gt;</span> ?&#8288;len:int <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>really_write fd ?pos ?len bstr</code> writes <code>len</code> bytes in bigstring <code>bstr</code> starting at position <code>pos</code> to file descriptor <code>fd</code>.</p><dl><dt>raises Invalid_argument</dt><dd><p>if the designated range is out of bounds.</p></dd></dl><dl><dt>raises IOError</dt><dd><p>in the case of output errors.</p></dd></dl><dl><dt>parameter pos</dt><dd><p>default = 0</p></dd></dl><dl><dt>parameter len</dt><dd><p>default = <code>length bstr - pos</code></p></dd></dl></dd></dl><dl><dt class="spec value" id="val-really_send_no_sigpipe"><a href="#val-really_send_no_sigpipe" class="anchor"></a><code><span class="keyword">val </span>really_send_no_sigpipe : (Unix.file_descr <span>&#45;&gt;</span> ?&#8288;pos:int <span>&#45;&gt;</span> ?&#8288;len:int <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit) Core__.Import.Or_error.t</code></dt><dd><p><code>really_send_no_sigpipe sock ?pos ?len bstr</code> sends <code>len</code> bytes in bigstring <code>bstr</code> starting at position <code>pos</code> to socket <code>sock</code> without blocking and ignoring <code>SIGPIPE</code>.</p><dl><dt>raises Invalid_argument</dt><dd><p>if the designated range is out of bounds.</p></dd></dl><dl><dt>raises IOError</dt><dd><p>in the case of output errors.</p></dd></dl><dl><dt>parameter pos</dt><dd><p>default = 0</p></dd></dl><dl><dt>parameter len</dt><dd><p>default = <code>length bstr - pos</code></p><p><code>really_send_no_sigpipe</code> is not implemented on some platforms, in which case it is an <code>Error</code> value that indicates that it is unimplemented.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-send_nonblocking_no_sigpipe"><a href="#val-send_nonblocking_no_sigpipe" class="anchor"></a><code><span class="keyword">val </span>send_nonblocking_no_sigpipe : (Unix.file_descr <span>&#45;&gt;</span> ?&#8288;pos:int <span>&#45;&gt;</span> ?&#8288;len:int <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> Core__.Syscall_result.Int.t) Core__.Import.Or_error.t</code></dt><dd><p><code>send_nonblocking_no_sigpipe sock ?pos ?len bstr</code> tries to send <code>len</code> bytes in bigstring <code>bstr</code> starting at position <code>pos</code> to socket <code>sock</code>. </p><dl><dt>returns</dt><dd><p><code>bytes_written</code>.</p></dd></dl><dl><dt>raises Invalid_argument</dt><dd><p>if the designated range is out of bounds.</p></dd></dl><dl><dt>parameter pos</dt><dd><p>default = 0</p></dd></dl><dl><dt>parameter len</dt><dd><p>default = <code>length bstr - pos</code></p></dd></dl></dd></dl><dl><dt class="spec value" id="val-sendto_nonblocking_no_sigpipe"><a href="#val-sendto_nonblocking_no_sigpipe" class="anchor"></a><code><span class="keyword">val </span>sendto_nonblocking_no_sigpipe : (Unix.file_descr <span>&#45;&gt;</span> ?&#8288;pos:int <span>&#45;&gt;</span> ?&#8288;len:int <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> Unix.sockaddr <span>&#45;&gt;</span> Core__.Syscall_result.Int.t) Core__.Import.Or_error.t</code></dt><dd><p><code>sendto_nonblocking_no_sigpipe sock ?pos ?len bstr sockaddr</code> tries to send <code>len</code> bytes in bigstring <code>bstr</code> starting at position <code>pos</code> to socket <code>sock</code> using address <code>addr</code>.</p><dl><dt>returns</dt><dd><p><code>bytes_written</code>.</p></dd></dl><dl><dt>raises Invalid_argument</dt><dd><p>if the designated range is out of bounds.</p></dd></dl><dl><dt>parameter pos</dt><dd><p>default = 0</p></dd></dl><dl><dt>parameter len</dt><dd><p>default = <code>length bstr - pos</code></p></dd></dl></dd></dl><dl><dt class="spec value" id="val-write"><a href="#val-write" class="anchor"></a><code><span class="keyword">val </span>write : Unix.file_descr <span>&#45;&gt;</span> ?&#8288;pos:int <span>&#45;&gt;</span> ?&#8288;len:int <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int</code></dt><dd><p><code>write fd ?pos ?len bstr</code> writes <code>len</code> bytes in bigstring <code>bstr</code> starting at position <code>pos</code> to file descriptor <code>fd</code>. </p><dl><dt>returns</dt><dd><p>the number of bytes actually written.</p></dd></dl><dl><dt>raises Unix_error</dt><dd><p>in the case of output errors.</p></dd></dl><dl><dt>raises Invalid_argument</dt><dd><p>if the designated range is out of bounds.</p></dd></dl><dl><dt>parameter pos</dt><dd><p>default = 0</p></dd></dl><dl><dt>parameter len</dt><dd><p>default = <code>length bstr - pos</code></p></dd></dl></dd></dl><dl><dt class="spec value" id="val-pwrite_assume_fd_is_nonblocking"><a href="#val-pwrite_assume_fd_is_nonblocking" class="anchor"></a><code><span class="keyword">val </span>pwrite_assume_fd_is_nonblocking : Unix.file_descr <span>&#45;&gt;</span> offset:int <span>&#45;&gt;</span> ?&#8288;pos:int <span>&#45;&gt;</span> ?&#8288;len:int <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int</code></dt><dd><p><code>pwrite_assume_fd_is_nonblocking fd ~offset ?pos ?len bstr</code> writes up to <code>len</code> bytes of bigstring <code>bstr</code> starting at position <code>pos</code> to file descriptor <code>fd</code> at position <code>offset</code>. The fd must be capable of seeking, and the current file offset used for non-positional <code>read()</code>/<code>write()</code> calls is unchanged. </p><dl><dt>returns</dt><dd><p>the number of bytes written.</p></dd></dl><dl><dt>raises Invalid_argument</dt><dd><p>if the designated range is out of bounds.</p></dd></dl><dl><dt>raises Unix_error</dt><dd><p>in the case of input errors.</p></dd></dl><dl><dt>parameter pos</dt><dd><p>default = 0</p></dd></dl><dl><dt>parameter len</dt><dd><p>default = <code>length bstr - pos</code></p></dd></dl></dd></dl><dl><dt class="spec value" id="val-write_assume_fd_is_nonblocking"><a href="#val-write_assume_fd_is_nonblocking" class="anchor"></a><code><span class="keyword">val </span>write_assume_fd_is_nonblocking : Unix.file_descr <span>&#45;&gt;</span> ?&#8288;pos:int <span>&#45;&gt;</span> ?&#8288;len:int <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int</code></dt><dd><p><code>write_assume_fd_is_nonblocking fd ?pos ?len bstr</code> writes <code>len</code> bytes in bigstring <code>bstr</code> starting at position <code>pos</code> to file descriptor <code>fd</code> without yielding to other OCaml-threads. </p><dl><dt>returns</dt><dd><p>the number of bytes actually written.</p></dd></dl><dl><dt>raises Unix_error</dt><dd><p>in the case of output errors.</p></dd></dl><dl><dt>raises Invalid_argument</dt><dd><p>if the designated range is out of bounds.</p></dd></dl><dl><dt>parameter pos</dt><dd><p>default = 0</p></dd></dl><dl><dt>parameter len</dt><dd><p>default = <code>length bstr - pos</code></p></dd></dl></dd></dl><dl><dt class="spec value" id="val-writev"><a href="#val-writev" class="anchor"></a><code><span class="keyword">val </span>writev : Unix.file_descr <span>&#45;&gt;</span> ?&#8288;count:int <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> Core__.Core_unix.IOVec.t array <span>&#45;&gt;</span> int</code></dt><dd><p><code>writev fd ?count iovecs</code> writes <code>count</code> <code>iovecs</code> of bigstrings to file descriptor <code>fd</code>. </p><dl><dt>returns</dt><dd><p>the number of bytes written.</p></dd></dl><dl><dt>raises Unix_error</dt><dd><p>in the case of output errors.</p></dd></dl><dl><dt>raises Invalid_argument</dt><dd><p>if count is out of range.</p></dd></dl><dl><dt>parameter count</dt><dd><p>default = <code>Array.length iovecs</code></p></dd></dl></dd></dl><dl><dt class="spec value" id="val-writev_assume_fd_is_nonblocking"><a href="#val-writev_assume_fd_is_nonblocking" class="anchor"></a><code><span class="keyword">val </span>writev_assume_fd_is_nonblocking : Unix.file_descr <span>&#45;&gt;</span> ?&#8288;count:int <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> Core__.Core_unix.IOVec.t array <span>&#45;&gt;</span> int</code></dt><dd><p><code>writev_assume_fd_is_nonblocking fd ?count iovecs</code> writes <code>count</code> <code>iovecs</code> of bigstrings to file descriptor <code>fd</code> without yielding to other OCaml-threads. </p><dl><dt>returns</dt><dd><p>the number of bytes actually written.</p></dd></dl><dl><dt>raises Unix_error</dt><dd><p>in the case of output errors.</p></dd></dl><dl><dt>raises Invalid_argument</dt><dd><p>if the designated range is out of bounds.</p></dd></dl><dl><dt>parameter count</dt><dd><p>default = <code>Array.length iovecs</code></p></dd></dl></dd></dl><dl><dt class="spec value" id="val-recvmmsg_assume_fd_is_nonblocking"><a href="#val-recvmmsg_assume_fd_is_nonblocking" class="anchor"></a><code><span class="keyword">val </span>recvmmsg_assume_fd_is_nonblocking : (Unix.file_descr <span>&#45;&gt;</span> ?&#8288;count:int <span>&#45;&gt;</span> ?&#8288;srcs:Unix.sockaddr array <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> Core__.Core_unix.IOVec.t array <span>&#45;&gt;</span> lens:int array <span>&#45;&gt;</span> int) Core__.Import.Or_error.t</code></dt><dd><p><code>recvmmsg_assume_fd_is_nonblocking fd iovecs ~count ~lens</code> receives up to <code>count</code> messages into <code>iovecs</code> from file descriptor <code>fd</code> without yielding to other OCaml threads. If <code>~count</code> is supplied, it must be that <code>0 &lt;= count &lt;= Array.length
    iovecs</code>. If <code>~srcs</code> is supplied, save the source addresses for corresponding received messages there. If supplied, <code>Array.length srcs</code> must be <code>&gt;= count</code>. Save the lengths of the received messages in <code>lens</code>. It is required that <code>Array.length lens &gt;=
    count</code>.</p><p>If an IOVec isn't long enough for its corresponding message, excess bytes may be discarded, depending on the type of socket the message is received from. While the <code>recvmmsg</code> system call itself does return details of such truncation, etc., those details are not (yet) passed through this interface.</p><dl><dt>see recvmmsg(2)</dt><dd><p>re. the underlying system call.</p></dd></dl><dl><dt>returns</dt><dd><p>the number of messages actually read, or a negative number to indicate EWOULDBLOCK or EAGAIN. This is a compromise to mitigate the exception overhead for what ends up being a very common result with our use of <code>recvmmsg</code>.</p></dd></dl><dl><dt>raises Unix_error</dt><dd><p>in the case of output errors.</p></dd></dl><dl><dt>raises Invalid_argument</dt><dd><p>if the designated range is out of bounds.</p></dd></dl><dl><dt>parameter count</dt><dd><p>default = <code>Array.length iovecs</code></p></dd></dl></dd></dl><dl><dt class="spec value" id="val-sendmsg_nonblocking_no_sigpipe"><a href="#val-sendmsg_nonblocking_no_sigpipe" class="anchor"></a><code><span class="keyword">val </span>sendmsg_nonblocking_no_sigpipe : (Unix.file_descr <span>&#45;&gt;</span> ?&#8288;count:int <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> Core__.Core_unix.IOVec.t array <span>&#45;&gt;</span> int option) Core__.Import.Or_error.t</code></dt><dd><p><code>sendmsg_nonblocking_no_sigpipe sock ?count iovecs</code> sends <code>count</code> <code>iovecs</code> of bigstrings to socket <code>sock</code>. </p><dl><dt>returns</dt><dd><p><code>Some
    bytes_written</code>, or <code>None</code> if the operation would have blocked. This system call will not cause signal <code>SIGPIPE</code> if an attempt is made to write to a socket that was closed by the other side.</p></dd></dl><dl><dt>raises Unix_error</dt><dd><p>in the case of output errors.</p></dd></dl><dl><dt>raises Invalid_argument</dt><dd><p>if <code>count</code> is out of range.</p></dd></dl><dl><dt>parameter count</dt><dd><p>default = <code>Array.length iovecs</code></p></dd></dl></dd></dl><dl><dt class="spec value" id="val-output"><a href="#val-output" class="anchor"></a><code><span class="keyword">val </span>output : ?&#8288;min_len:int <span>&#45;&gt;</span> Core__.Import.Out_channel.t <span>&#45;&gt;</span> ?&#8288;pos:int <span>&#45;&gt;</span> ?&#8288;len:int <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int</code></dt><dd><p><code>output ?min_len oc ?pos ?len bstr</code> tries to output <code>len</code> bytes (guarantees to write at least <code>min_len</code> bytes (must be equal to or greater than zero), if possible, before returning) from bigstring <code>bstr</code> starting at position <code>pos</code> to output channel <code>oc</code>.</p><dl><dt>returns</dt><dd><p>the number of bytes actually written.</p><p>NOTE: you may need to flush <code>oc</code> to make sure that the data is actually sent.</p><p>NOTE: if <code>len</code> characters fit into the channel buffer completely, they will be buffered. Otherwise writes will be attempted until at least <code>min_len</code> characters have been sent.</p></dd></dl><dl><dt>raises Invalid_argument</dt><dd><p>if the designated range is out of bounds.</p></dd></dl><dl><dt>raises IOError</dt><dd><p>in the case of output errors. The <code>IOError</code>-argument counting the number of successful bytes includes those that have been transferred to the channel buffer before the error.</p></dd></dl><dl><dt>parameter pos</dt><dd><p>default = 0</p></dd></dl><dl><dt>parameter min_len</dt><dd><p>default = 0</p></dd></dl><dl><dt>parameter len</dt><dd><p>default = <code>length bstr - pos</code></p></dd></dl></dd></dl><dl><dt class="spec value" id="val-really_output"><a href="#val-really_output" class="anchor"></a><code><span class="keyword">val </span>really_output : Core__.Import.Out_channel.t <span>&#45;&gt;</span> ?&#8288;pos:int <span>&#45;&gt;</span> ?&#8288;len:int <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>really_output oc ?pos ?len bstr</code> outputs exactly <code>len</code> bytes from bigstring <code>bstr</code> starting at position <code>pos</code> to output channel <code>oc</code>.</p><dl><dt>raises Invalid_argument</dt><dd><p>if the designated range is out of bounds.</p></dd></dl><dl><dt>raises IOError</dt><dd><p>in the case of output errors. The <code>IOError</code>-argument counting the number of successful bytes includes those that have been transferred to the channel buffer before the error.</p></dd></dl><dl><dt>parameter pos</dt><dd><p>default = 0</p></dd></dl><dl><dt>parameter len</dt><dd><p>default = <code>length bstr - pos</code></p></dd></dl></dd></dl></section><section><header><h6 id="unsafe-functions"><a href="#unsafe-functions" class="anchor"></a>Unsafe functions</h6></header><dl><dt class="spec external" id="val-unsafe_read_assume_fd_is_nonblocking"><a href="#val-unsafe_read_assume_fd_is_nonblocking" class="anchor"></a><code><span class="keyword">val </span>unsafe_read_assume_fd_is_nonblocking : Unix.file_descr <span>&#45;&gt;</span> pos:int <span>&#45;&gt;</span> len:int <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> Core__.Syscall_result.Int.t</code></dt><dd><p><code>unsafe_read_assume_fd_is_nonblocking fd ~pos ~len bstr</code> similar to <span class="xref-unresolved" title="unresolved reference to &quot;Bigstring.read_assume_fd_is_nonblocking&quot;"><code>Bigstring</code>.read_assume_fd_is_nonblocking</span>, but does not perform any bounds checks. Will crash on bounds errors!</p></dd></dl><dl><dt class="spec external" id="val-unsafe_write"><a href="#val-unsafe_write" class="anchor"></a><code><span class="keyword">val </span>unsafe_write : Unix.file_descr <span>&#45;&gt;</span> pos:int <span>&#45;&gt;</span> len:int <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int</code></dt><dd><p><code>unsafe_write fd ~pos ~len bstr</code> similar to <span class="xref-unresolved" title="unresolved reference to &quot;Bigstring.write&quot;"><code>Bigstring</code>.write</span>, but does not perform any bounds checks. Will crash on bounds errors!</p></dd></dl><dl><dt class="spec external" id="val-unsafe_write_assume_fd_is_nonblocking"><a href="#val-unsafe_write_assume_fd_is_nonblocking" class="anchor"></a><code><span class="keyword">val </span>unsafe_write_assume_fd_is_nonblocking : Unix.file_descr <span>&#45;&gt;</span> pos:int <span>&#45;&gt;</span> len:int <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int</code></dt><dd><p><code>unsafe_write_assume_fd_is_nonblocking fd ~pos ~len bstr</code> similar to <span class="xref-unresolved" title="unresolved reference to &quot;Bigstring.write_assume_fd_is_nonblocking&quot;"><code>Bigstring</code>.write_assume_fd_is_nonblocking</span>, but does not perform any bounds checks. Will crash on bounds errors!</p></dd></dl><dl><dt class="spec external" id="val-unsafe_read"><a href="#val-unsafe_read" class="anchor"></a><code><span class="keyword">val </span>unsafe_read : min_len:int <span>&#45;&gt;</span> Unix.file_descr <span>&#45;&gt;</span> pos:int <span>&#45;&gt;</span> len:int <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int</code></dt><dd><p><code>unsafe_read ~min_len fd ~pos ~len bstr</code> similar to <span class="xref-unresolved" title="unresolved reference to &quot;Bigstring.read&quot;"><code>Bigstring</code>.read</span>, but does not perform any bounds checks. Will crash on bounds errors!</p></dd></dl><dl><dt class="spec external" id="val-unsafe_really_recv"><a href="#val-unsafe_really_recv" class="anchor"></a><code><span class="keyword">val </span>unsafe_really_recv : Unix.file_descr <span>&#45;&gt;</span> pos:int <span>&#45;&gt;</span> len:int <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>unsafe_really_recv sock ~pos ~len bstr</code> similar to <span class="xref-unresolved" title="unresolved reference to &quot;Bigstring.really_recv&quot;"><code>Bigstring</code>.really_recv</span>, but does not perform any bounds checks. Will crash on bounds errors!</p></dd></dl><dl><dt class="spec external" id="val-unsafe_really_write"><a href="#val-unsafe_really_write" class="anchor"></a><code><span class="keyword">val </span>unsafe_really_write : Unix.file_descr <span>&#45;&gt;</span> pos:int <span>&#45;&gt;</span> len:int <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>unsafe_really_write fd ~pos ~len bstr</code> similar to <span class="xref-unresolved" title="unresolved reference to &quot;Bigstring.write&quot;"><code>Bigstring</code>.write</span>, but does not perform any bounds checks. Will crash on bounds errors!</p></dd></dl><dl><dt class="spec value" id="val-unsafe_really_send_no_sigpipe"><a href="#val-unsafe_really_send_no_sigpipe" class="anchor"></a><code><span class="keyword">val </span>unsafe_really_send_no_sigpipe : (Unix.file_descr <span>&#45;&gt;</span> pos:int <span>&#45;&gt;</span> len:int <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit) Core__.Import.Or_error.t</code></dt><dd><p><code>unsafe_really_send_no_sigpipe sock ~pos ~len bstr</code> similar to <span class="xref-unresolved" title="unresolved reference to &quot;Bigstring.send&quot;"><code>Bigstring</code>.send</span>, but does not perform any bounds checks. Will crash on bounds errors!</p></dd></dl><dl><dt class="spec value" id="val-unsafe_send_nonblocking_no_sigpipe"><a href="#val-unsafe_send_nonblocking_no_sigpipe" class="anchor"></a><code><span class="keyword">val </span>unsafe_send_nonblocking_no_sigpipe : (Unix.file_descr <span>&#45;&gt;</span> pos:int <span>&#45;&gt;</span> len:int <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> Core__.Syscall_result.Int.t) Core__.Import.Or_error.t</code></dt><dd><p><code>unsafe_send_nonblocking_no_sigpipe sock ~pos ~len bstr</code> similar to <span class="xref-unresolved" title="unresolved reference to &quot;Bigstring.send_nonblocking_no_sigpipe&quot;"><code>Bigstring</code>.send_nonblocking_no_sigpipe</span>, but does not perform any bounds checks. Will crash on bounds errors!</p></dd></dl><dl><dt class="spec external" id="val-unsafe_writev"><a href="#val-unsafe_writev" class="anchor"></a><code><span class="keyword">val </span>unsafe_writev : Unix.file_descr <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> Core__.Core_unix.IOVec.t array <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int</code></dt><dd><p><code>unsafe_writev fd iovecs count</code> similar to <span class="xref-unresolved" title="unresolved reference to &quot;Bigstring.writev&quot;"><code>Bigstring</code>.writev</span>, but does not perform any bounds checks. Will crash on bounds errors!</p></dd></dl><dl><dt class="spec value" id="val-unsafe_sendmsg_nonblocking_no_sigpipe"><a href="#val-unsafe_sendmsg_nonblocking_no_sigpipe" class="anchor"></a><code><span class="keyword">val </span>unsafe_sendmsg_nonblocking_no_sigpipe : (Unix.file_descr <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> Core__.Core_unix.IOVec.t array <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int option) Core__.Import.Or_error.t</code></dt><dd><p><code>unsafe_sendmsg_nonblocking_no_sigpipe fd iovecs count</code> similar to <span class="xref-unresolved" title="unresolved reference to &quot;Bigstring.sendmsg_nonblocking_no_sigpipe&quot;"><code>Bigstring</code>.sendmsg_nonblocking_no_sigpipe</span>, but does not perform any bounds checks. Will crash on bounds errors!</p></dd></dl><dl><dt class="spec external" id="val-unsafe_input"><a href="#val-unsafe_input" class="anchor"></a><code><span class="keyword">val </span>unsafe_input : min_len:int <span>&#45;&gt;</span> Core__.Import.In_channel.t <span>&#45;&gt;</span> pos:int <span>&#45;&gt;</span> len:int <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int</code></dt><dd><p><code>unsafe_input ~min_len ic ~pos ~len bstr</code> similar to <span class="xref-unresolved" title="unresolved reference to &quot;Bigstring.input&quot;"><code>Bigstring</code>.input</span>, but does not perform any bounds checks. Will crash on bounds errors!</p></dd></dl><dl><dt class="spec external" id="val-unsafe_output"><a href="#val-unsafe_output" class="anchor"></a><code><span class="keyword">val </span>unsafe_output : min_len:int <span>&#45;&gt;</span> Core__.Import.Out_channel.t <span>&#45;&gt;</span> pos:int <span>&#45;&gt;</span> len:int <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int</code></dt><dd><p><code>unsafe_output ~min_len oc ~pos ~len bstr</code> similar to <span class="xref-unresolved" title="unresolved reference to &quot;Bigstring.output&quot;"><code>Bigstring</code>.output</span>, but does not perform any bounds checks. Will crash on bounds errors!</p></dd></dl></section></div></body></html>