<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>S_invertible (core.Core__Piecewise_linear_intf.S_invertible)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../../index.html">core</a> &#x00BB; <a href="../index.html">Core__Piecewise_linear_intf</a> &#x00BB; S_invertible</nav><h1>Module type <code>Core__Piecewise_linear_intf.S_invertible</code></h1></header><div><div class="spec include"><div class="doc"><p><code>create</code> enforces that the x (key) values are strictly increasing. It also enforces that the y (value) values are either strictly increasing or strictly decreasing. These two properties give us invertibility.</p><p>It also enforces certain finiteness conditions: the x and y values must be finite (non-nan, and non-infinite), and differences of consecutive x values and consecutive y values must be finite.</p><p>(Conceivably, one might have a case where one wants to loosen the conditions on x and y values to non-strict monotonicity, so that one does not have true invertibility, but only a sort of formal invertibility. If that use case arises, a separate functor like <code>Make_formally_invertible</code> could be added, so that <code>Make_invertible</code> maintains its stricter semantics.)</p><details open="open"><summary><span class="def"><code><span class="keyword">include </span><a href="../index.html#module-type-S">S</a></code></span></summary><dl><dt class="spec type" id="type-t_"><a href="#type-t_" class="anchor"></a><code><span class="keyword">type </span>('k, 'v) t_</code></dt><dt class="spec type" id="type-key"><a href="#type-key" class="anchor"></a><code><span class="keyword">type </span>key</code></dt><dt class="spec type" id="type-value"><a href="#type-value" class="anchor"></a><code><span class="keyword">type </span>value</code></dt><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type </span>t</code><code><span class="keyword"> = </span>(<a href="index.html#type-key">key</a>, <a href="index.html#type-value">value</a>) <a href="index.html#type-t_">t_</a></code></dt></dl><div><div class="spec include"><div class="doc"><details open="open"><summary><span class="def"><code><span class="keyword">include </span><span class="keyword">sig</span> ... <span class="keyword">end</span></code></span></summary><dl><dt class="spec value" id="val-compare"><a href="#val-compare" class="anchor"></a><code><span class="keyword">val </span>compare : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int</code></dt><dt class="spec value" id="val-t_of_sexp"><a href="#val-t_of_sexp" class="anchor"></a><code><span class="keyword">val </span>t_of_sexp : Sexplib.Sexp.t <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-sexp_of_t"><a href="#val-sexp_of_t" class="anchor"></a><code><span class="keyword">val </span>sexp_of_t : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> Sexplib.Sexp.t</code></dt><dt class="spec value" id="val-bin_t"><a href="#val-bin_t" class="anchor"></a><code><span class="keyword">val </span>bin_t : <a href="index.html#type-t">t</a> Core__.Import.Bin_prot.Type_class.t</code></dt><dt class="spec value" id="val-bin_read_t"><a href="#val-bin_read_t" class="anchor"></a><code><span class="keyword">val </span>bin_read_t : <a href="index.html#type-t">t</a> Core__.Import.Bin_prot.Read.reader</code></dt><dt class="spec value" id="val-__bin_read_t__"><a href="#val-__bin_read_t__" class="anchor"></a><code><span class="keyword">val </span>__bin_read_t__ : (int <span>&#45;&gt;</span> <a href="index.html#type-t">t</a>) Core__.Import.Bin_prot.Read.reader</code></dt><dt class="spec value" id="val-bin_reader_t"><a href="#val-bin_reader_t" class="anchor"></a><code><span class="keyword">val </span>bin_reader_t : <a href="index.html#type-t">t</a> Core__.Import.Bin_prot.Type_class.reader</code></dt><dt class="spec value" id="val-bin_size_t"><a href="#val-bin_size_t" class="anchor"></a><code><span class="keyword">val </span>bin_size_t : <a href="index.html#type-t">t</a> Core__.Import.Bin_prot.Size.sizer</code></dt><dt class="spec value" id="val-bin_write_t"><a href="#val-bin_write_t" class="anchor"></a><code><span class="keyword">val </span>bin_write_t : <a href="index.html#type-t">t</a> Core__.Import.Bin_prot.Write.writer</code></dt><dt class="spec value" id="val-bin_writer_t"><a href="#val-bin_writer_t" class="anchor"></a><code><span class="keyword">val </span>bin_writer_t : <a href="index.html#type-t">t</a> Core__.Import.Bin_prot.Type_class.writer</code></dt><dt class="spec value" id="val-bin_shape_t"><a href="#val-bin_shape_t" class="anchor"></a><code><span class="keyword">val </span>bin_shape_t : Core__.Import.Bin_prot.Shape.t</code></dt></dl></details></div></div></div><dl><dt class="spec value" id="val-create"><a href="#val-create" class="anchor"></a><code><span class="keyword">val </span>create : (<a href="index.html#type-key">key</a><span class="keyword"> * </span><a href="index.html#type-value">value</a>) list <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> Core__.Import.Or_error.t</code></dt><dd><p><code>create</code> enforces that x (key) values are non-decreasing.</p><p>It also enforces certain finiteness conditions: the x and y values must be finite (non-nan, and non-infinite), and differences of consecutive x values and consecutive y values must be finite.</p></dd></dl><dl><dt class="spec value" id="val-get"><a href="#val-get" class="anchor"></a><code><span class="keyword">val </span>get : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-key">key</a> <span>&#45;&gt;</span> <a href="index.html#type-value">value</a></code></dt><dd><p><code>get t x</code> evaluates the piecewise linear function <code>t</code> at <code>x</code>.</p><p>It is possible to get discontinuous functions by using repeated x-values in the knots. In that case, the function is evaluated in such a way that it is right-continuous. For example, if <code>t</code> has knots <code>[(0.,0.5); (1.,1.5); (1.,10.); (2.,11.)]</code>, then <code>get t 1.</code> returns <code>10.</code>, <code>get t 0.999</code> returns <code>1.499</code>, and <code>get t 1.001</code> returns <code>10.001</code>.</p></dd></dl><dl><dt class="spec value" id="val-first_knot"><a href="#val-first_knot" class="anchor"></a><code><span class="keyword">val </span>first_knot : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<a href="index.html#type-key">key</a><span class="keyword"> * </span><a href="index.html#type-value">value</a>) option</code></dt><dd><p>O(1)</p></dd></dl><dl><dt class="spec value" id="val-last_knot"><a href="#val-last_knot" class="anchor"></a><code><span class="keyword">val </span>last_knot : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<a href="index.html#type-key">key</a><span class="keyword"> * </span><a href="index.html#type-value">value</a>) option</code></dt><dt class="spec value" id="val-to_knots"><a href="#val-to_knots" class="anchor"></a><code><span class="keyword">val </span>to_knots : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<a href="index.html#type-key">key</a><span class="keyword"> * </span><a href="index.html#type-value">value</a>) list</code></dt><dd><p>O(n)</p></dd></dl><dl><dt class="spec value" id="val-to_knots'"><a href="#val-to_knots'" class="anchor"></a><code><span class="keyword">val </span>to_knots' : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-key">key</a> array<span class="keyword"> * </span><a href="index.html#type-value">value</a> array</code></dt><dd><p>O(n)</p></dd></dl><dl><dt class="spec value" id="val-precache"><a href="#val-precache" class="anchor"></a><code><span class="keyword">val </span>precache : ?&#8288;density:float <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>precache t</code> computes and stores a lookup table in <code>t</code> that speeds up subsequent calls to <code>get t</code>. Any call to <code>get</code> needs to find the knots that define the interval in which the key lies. This is done by bisection. Ordinarily the bisection starts on the whole domain of the piecewise linear function. Precaching builds a lookup table based on an equispaced division of the domain. This allows <code>get</code> to quickly determine a (potentially very) small initial interval on which to start the bisection.</p><p>This works best for knots that are reasonably evenly distributed.</p><p><code>density</code> is the ratio of the size of the lookup table to the size of the knot array.</p><p>Calling <code>precache</code> multiple times is safe. If the existing lookup density is the same or higher density than the requested density, the lookup table will not be recomputed.</p></dd></dl><dl><dt class="spec value" id="val-create_from_linear_combination"><a href="#val-create_from_linear_combination" class="anchor"></a><code><span class="keyword">val </span>create_from_linear_combination : (<a href="index.html#type-t">t</a><span class="keyword"> * </span>float) list <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> Core__.Import.Or_error.t</code></dt><dd><p>Returns the <code>t</code> such that <code>get t key</code> = sum (<code>get t_i key</code>) * <code>weight_i</code>. This will fail if given an empty list as an argument, if any weights are not finite, or if any of the input <code>t</code>s has a discontinuity.</p><p>The domain of each <code>t</code> does not have to be the same. The domain of the <code>t</code> that is returned will be the connected union of the domains.</p><p>There are cases in <code>S_invertible</code> in which all <code>t</code>s could be valid and invertible, but the linear combination is not invertible. I.e. if one <code>t</code> is downward sloping, the other <code>t</code> is upward sloping, and the linear combination is sometimes upward and sometimes downward sloping.</p></dd></dl></details></div></div></div><dl><dt class="spec value" id="val-get_inverse"><a href="#val-get_inverse" class="anchor"></a><code><span class="keyword">val </span>get_inverse : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-value">value</a> <span>&#45;&gt;</span> <a href="index.html#type-key">key</a></code></dt><dd><p><code>get_inverse t value</code> is the inverse operation of <code>get t key</code>.</p></dd></dl></div></body></html>