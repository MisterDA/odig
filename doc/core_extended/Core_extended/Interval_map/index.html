<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Interval_map (core_extended.Core_extended.Interval_map)</title><link rel="stylesheet" href="../../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../../index.html">core_extended</a> &#x00BB; <a href="../index.html">Core_extended</a> &#x00BB; Interval_map</nav><h1>Module <code>Core_extended.Interval_map</code></h1></header><div><div class="spec include"><div class="doc"><p>See <code>Interval_map_inf</code>.</p><details open="open"><summary><span class="def"><code><span class="keyword">include</span> <a href="../Interval_map_intf/index.html#module-type-M">Interval_map_intf.M</a></code></span></summary><div><div class="spec include"><div class="doc"><details open="open"><summary><span class="def"><code><span class="keyword">include</span> <a href="../Interval_map_intf/index.html#module-type-Operations">Interval_map_intf.Operations</a></code></span></summary><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> ('k, +'v, 'cmp) t</code></dt></dl><aside><p>Note on complexities: As the mappings are for ranges, where complexities are given they are given in terms of variables (n, m) which are the number of change points that have been inserted into the sequence.</p></aside><dl><dt class="spec value" id="val-compare"><a href="#val-compare" class="anchor"></a><code><span class="keyword">val</span> compare : (<span class="type-var">'v</span> <span>&#45;&gt;</span> <span class="type-var">'v</span> <span>&#45;&gt;</span> int) <span>&#45;&gt;</span> (<span class="type-var">'k</span>, <span class="type-var">'v</span>, <span class="type-var">'cmp</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<span class="type-var">'k</span>, <span class="type-var">'v</span>, <span class="type-var">'cmp</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int</code></dt><dd><p>Comparison works lexicographically pointwise across the whole sequence (from -infty to +infty).</p><p>This means that <code>x = y ⇔ (∀k. find x k = find y k)</code>.</p><p>Complexity is O(n + m).</p><p>Note that this is a normalising comparison (a change point which changes the value to the same value is treated as if it does not exist), which means that it is not entirely extensional. In particular, two equal sequences may be distinguished by converting to sexps or using <code>construct_preimage</code>, both of which do not perform normalisation. In example:</p><pre><code class="ml">let module Int_interval_map = Interval_map.Make(Int) in
let compare = Int_interval_map.compare Int.compare in
let sexp_of_t = Int_interval_map.sexp_of_t Int.sexp_of_t in
let list_preimage t =
  Sequence.to_list (Int_interval_map.construct_preimage t)
in

let x = Int_interval_map.always 42 in
let y = Int_interval_map.change x ~at:0 42 in

assert (compare x y = 0);
assert (sexp_of_t x &lt;&gt; sexp_of_t y);
assert (list_preimage x &lt;&gt; list_preimage y);</code></pre></dd></dl><dl><dt class="spec value" id="val-create"><a href="#val-create" class="anchor"></a><code><span class="keyword">val</span> create : left_of_leftmost:<span class="type-var">'v</span> <span>&#45;&gt;</span> value_right_of:(<span class="type-var">'k</span>, <span class="type-var">'v</span>, <span class="type-var">'cmp</span>) <a href="../../../core_kernel/Core_kernel/Map/index.html#type-t">Core_kernel.Map.t</a> <span>&#45;&gt;</span> (<span class="type-var">'k</span>, <span class="type-var">'v</span>, <span class="type-var">'cmp</span>) <a href="index.html#type-t">t</a></code></dt><dd><p>Create a sequence with a specified far-leftmost value, and sequence of change points.</p><p>Complexity is O(1), as the primary cost is in construction of the map which is passed into this function.</p><p>e.g. suppose that <code>let x = create ~left_of_leftmost:&quot;A&quot;
                 ~value_right_of:Int.Map.of_alist_exn [
                   0, &quot;B&quot;; 2, &quot;C&quot;; 4, &quot;D&quot;; ]</code></p><p>Then <code>x</code> will be an interval map such that: <code>∀      k &lt; 0. find x k = &quot;A&quot;</code> <code>∀ 0 &lt;= k &lt; 2. find x k = &quot;B&quot;</code> <code>∀ 2 &lt;= k &lt; 4. find x k = &quot;C&quot;</code> <code>∀ 4 &lt;= k    . find x k = &quot;D&quot;</code></p></dd></dl><dl><dt class="spec value" id="val-always"><a href="#val-always" class="anchor"></a><code><span class="keyword">val</span> always : <span class="type-var">'v</span> <span>&#45;&gt;</span> comparator:(<span class="type-var">'k</span>, <span class="type-var">'cmp</span>) <a href="../../../core_kernel/Core_kernel/Comparator/index.html#type-t">Core_kernel.Comparator.t</a> <span>&#45;&gt;</span> (<span class="type-var">'k</span>, <span class="type-var">'v</span>, <span class="type-var">'cmp</span>) <a href="index.html#type-t">t</a></code></dt><dd><p>Create a sequence which has a single constant value across the whole sequence of keys.</p><p><code>find (always ~comparator x) k = x</code></p><p>O(1).</p></dd></dl><dl><dt class="spec value" id="val-find"><a href="#val-find" class="anchor"></a><code><span class="keyword">val</span> find : (<span class="type-var">'k</span>, <span class="type-var">'v</span>, <span class="type-var">'cmp</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'k</span> <span>&#45;&gt;</span> <span class="type-var">'v</span></code></dt><dd><p>Find the value associated with some point along the sequence of keys.</p><p>O(log n).</p></dd></dl><dl><dt class="spec value" id="val-change"><a href="#val-change" class="anchor"></a><code><span class="keyword">val</span> change : (<span class="type-var">'k</span>, <span class="type-var">'v</span>, <span class="type-var">'cmp</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> at:<span class="type-var">'k</span> <span>&#45;&gt;</span> <span class="type-var">'v</span> <span>&#45;&gt;</span> (<span class="type-var">'k</span>, <span class="type-var">'v</span>, <span class="type-var">'cmp</span>) <a href="index.html#type-t">t</a></code></dt><dd><p>Insert a change point into the sequence of changes.</p><p>The precise effect on the values along the sequence depends on what other change points are present, notionally inserting a change point means the value prior to this point is unchanged, then at this point the value becomes the supplied value, and then continues to be that value until the next change point which had already been inserted.</p><p>If you want to control values directly within bounded intervals, <code>set_within</code> may be simpler to use.</p><p>O(log n).</p></dd></dl><dl><dt class="spec value" id="val-map"><a href="#val-map" class="anchor"></a><code><span class="keyword">val</span> map : (<span class="type-var">'k</span>, <span class="type-var">'a</span>, <span class="type-var">'cmp</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> f:(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>) <span>&#45;&gt;</span> (<span class="type-var">'k</span>, <span class="type-var">'b</span>, <span class="type-var">'cmp</span>) <a href="index.html#type-t">t</a></code></dt><dd><p>Apply a function to all values within the sequence.</p><p><code>find (map x ~f) k = f (find x k)</code></p><p>O(n).</p></dd></dl><dl><dt class="spec value" id="val-map2"><a href="#val-map2" class="anchor"></a><code><span class="keyword">val</span> map2 : (<span class="type-var">'k</span>, <span class="type-var">'a</span>, <span class="type-var">'cmp</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<span class="type-var">'k</span>, <span class="type-var">'b</span>, <span class="type-var">'cmp</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> f:(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'c</span>) <span>&#45;&gt;</span> (<span class="type-var">'k</span>, <span class="type-var">'c</span>, <span class="type-var">'cmp</span>) <a href="index.html#type-t">t</a></code></dt><dd><p>Apply a function to values from two sequences.</p><p><code>find (map2 x y ~f) = f (find x k) (find y k)</code></p><p>O(n + m).</p></dd></dl><dl><dt class="spec value" id="val-join"><a href="#val-join" class="anchor"></a><code><span class="keyword">val</span> join : (<span class="type-var">'k</span>, (<span class="type-var">'k</span>, <span class="type-var">'v</span>, <span class="type-var">'cmp</span>) <a href="index.html#type-t">t</a>, <span class="type-var">'cmp</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<span class="type-var">'k</span>, <span class="type-var">'v</span>, <span class="type-var">'cmp</span>) <a href="index.html#type-t">t</a></code></dt><dd><p>Flatten a sequence of sequences.</p><p><code>find (flatten x) k = find (find x k) k</code></p><p>O(sum(k)) where k is the size/number of changes of each inner sequence, of which there will be n.</p></dd></dl><dl><dt class="spec value" id="val-remove_changes_within"><a href="#val-remove_changes_within" class="anchor"></a><code><span class="keyword">val</span> remove_changes_within : (<span class="type-var">'k</span>, <span class="type-var">'v</span>, <span class="type-var">'cmp</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'k</span> <a href="../Interval_map_intf/Interval/index.html#type-t">Interval_map_intf.Interval.t</a> <span>&#45;&gt;</span> (<span class="type-var">'k</span>, <span class="type-var">'v</span>, <span class="type-var">'cmp</span>) <a href="index.html#type-t">t</a></code></dt><dd><p><code>remove_changes_within t interval</code> removes any change points within the specified interval.</p><p>By removing these points of change, the value within the interval will become whatever the value already was outside the left-boundary of the interval.</p><p>Some intervals are open on the left (e.g. <code> `Always </code> or <code> `Until k </code>), and in these cases the value in the interval will become <code>t.left_of_leftmost</code>.</p><p>Complexity is O(log(n) + n'), where n' is the number of change points within the specified interval (not the whole sequence).</p></dd></dl><dl><dt class="spec value" id="val-set_within"><a href="#val-set_within" class="anchor"></a><code><span class="keyword">val</span> set_within : (<span class="type-var">'k</span>, <span class="type-var">'v</span>, <span class="type-var">'cmp</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'k</span> <a href="../Interval_map_intf/Interval/index.html#type-t">Interval_map_intf.Interval.t</a> <span>&#45;&gt;</span> <span class="type-var">'v</span> <span>&#45;&gt;</span> (<span class="type-var">'k</span>, <span class="type-var">'v</span>, <span class="type-var">'cmp</span>) <a href="index.html#type-t">t</a></code></dt><dd><p><code>set_within t interval v</code> modifies the sequence so that all values within the specified interval are <code>v</code>, and values outside the interval are not modified.</p><p><code>find (set_within t interval x) k =
        (if Interval.contains interval k then x else find t k)</code></p><p>Complexity is O(log(n) + n'), where n' is the number of change points within the specified interval (not the whole sequence).</p></dd></dl><dl><dt class="spec value" id="val-map_within"><a href="#val-map_within" class="anchor"></a><code><span class="keyword">val</span> map_within : (<span class="type-var">'k</span>, <span class="type-var">'v</span>, <span class="type-var">'cmp</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'k</span> <a href="../Interval_map_intf/Interval/index.html#type-t">Interval_map_intf.Interval.t</a> <span>&#45;&gt;</span> f:(<span class="type-var">'v</span> <span>&#45;&gt;</span> <span class="type-var">'v</span>) <span>&#45;&gt;</span> (<span class="type-var">'k</span>, <span class="type-var">'v</span>, <span class="type-var">'cmp</span>) <a href="index.html#type-t">t</a></code></dt><dd><p><code>map_within t interval ~f</code> modifies the sequence similarly to set_within, except that it applies a function to the range rather than a constant value (i.e. <code>map_within t interval ~f:(Fn.const x) = set_within t interval x</code>).</p><p>Complexity is O(log(n) + n'), where n' is the number of change points within the specified interval (not the whole sequence).</p></dd></dl><dl><dt class="spec value" id="val-construct_preimage"><a href="#val-construct_preimage" class="anchor"></a><code><span class="keyword">val</span> construct_preimage : (<span class="type-var">'k</span>, <span class="type-var">'v</span>, <span class="type-var">'cmp</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<span class="type-var">'v</span> * <span class="type-var">'k</span> <a href="../Interval_map_intf/Interval/index.html#type-t">Interval_map_intf.Interval.t</a>) <a href="../../../core_kernel/Core_kernel/Sequence/index.html#type-t">Core_kernel.Sequence.t</a></code></dt><dd><p>Construct a preimage of the sequence. This is a series of pairs of a value and an interval of keys within which the sequence has that value.</p><p>O(n).</p><p>Importantly note that: 1) A particular value may be output many times with different intervals. 2) Each interval output will be unique and not overlap with any other. 3) As noted above, this is one of the areas where extensionality breaks down.</p><p>In example of the last point:</p><pre><code class="ml">let x = Int_interval_map.always 42 in
let y = Int_interval_map.change x ~at:0 42 in
let list_preimage t =
  Sequence.to_list (Int_interval_map.construct_preimage t)
in
assert (list_preimage x = [(42, `Always)]);
assert (list_preimage y = [(42, `Until 0); (42, `From 0)];</code></pre></dd></dl></details></div></div></div><div class="spec module-type" id="module-type-S"><a href="#module-type-S" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-S/index.html">S</a> : <a href="../Interval_map_intf/index.html#module-type-S">Interval_map_intf.S</a> <span class="keyword">with</span> <span class="keyword">type</span> ('k, 'v, 'cmp) <a href="module-type-S/index.html#type-interval_map">interval_map</a> := (<span class="type-var">'k</span>, <span class="type-var">'v</span>, <span class="type-var">'cmp</span>) <a href="index.html#type-t">t</a></code></div><div class="spec module-type" id="module-type-S_with_boundary"><a href="#module-type-S_with_boundary" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-S_with_boundary/index.html">S_with_boundary</a> : <a href="../Interval_map_intf/index.html#module-type-S_with_boundary">Interval_map_intf.S_with_boundary</a> <span class="keyword">with</span> <span class="keyword">type</span> ('k, 'v, 'cmp) <a href="module-type-S_with_boundary/index.html#type-interval_map">interval_map</a> := (<span class="type-var">'k</span>, <span class="type-var">'v</span>, <span class="type-var">'cmp</span>) <a href="index.html#type-t">t</a></code></div><div class="spec module" id="module-Make"><a href="#module-Make" class="anchor"></a><code><span class="keyword">module</span> <a href="Make/index.html">Make</a> : <span class="keyword">functor</span> (<a href="Make/argument-1-T/index.html">T</a> : <a href="../Interval_map_intf/index.html#module-type-Type_with_map_module">Interval_map_intf.Type_with_map_module</a>) <span>&#45;&gt;</span> <a href="index.html#module-type-S">S</a> <span class="keyword">with</span> <span class="keyword">type</span> <a href="Make/Key/index.html#type-t">Key.t</a> = <a href="Make/argument-1-T/Map/Key/index.html#type-t">T.Map.Key.t</a> <span class="keyword">and</span> <span class="keyword">type</span> <a href="Make/Key/index.html#type-comparator_witness">Key.comparator_witness</a> = <a href="Make/argument-1-T/Map/Key/index.html#type-comparator_witness">T.Map.Key.comparator_witness</a></code></div><div class="spec module" id="module-Make_with_boundary"><a href="#module-Make_with_boundary" class="anchor"></a><code><span class="keyword">module</span> <a href="Make_with_boundary/index.html">Make_with_boundary</a> : <span class="keyword">functor</span> (<a href="Make_with_boundary/argument-1-Key/index.html">Key</a> : <a href="../Interval_map_intf/index.html#module-type-Key">Interval_map_intf.Key</a>) <span>&#45;&gt;</span> <a href="index.html#module-type-S_with_boundary">S_with_boundary</a> <span class="keyword">with</span> <span class="keyword">type</span> <a href="Make_with_boundary/index.html#type-key">key</a> := <a href="Make_with_boundary/argument-1-Key/index.html#type-t">Key.t</a></code></div></details></div></div></div></div></body></html>