<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Linebuf (core_extended.Core_extended.Linebuf)</title><link rel="stylesheet" href="../../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../../index.html">core_extended</a> &#x00BB; <a href="../index.html">Core_extended</a> &#x00BB; Linebuf</nav><h1>Module <code>Core_extended.Linebuf</code></h1></header><aside><p>Line-by-line reading of a file. A line buffer allows one to read one line of a file at a time, blocking until a line is available. Line buffers are distinct from Pervasives.read_line in that they &quot;notice&quot; new data arriving in the file more quickly.</p></aside><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> t</code></dt><dd><p>The type of a line buffer.</p></dd></dl><dl><dt class="spec type" id="type-error_type"><a href="#type-error_type" class="anchor"></a><code><span class="keyword">type</span> error_type</code><code> = </code><table class="variant"><tr id="type-error_type.Null_retry" class="anchored"><td class="def constructor"><a href="#type-error_type.Null_retry" class="anchor"></a><code>| </code><code><span class="constructor">Null_retry</span></code></td></tr><tr id="type-error_type.Too_many_nulls" class="anchored"><td class="def constructor"><a href="#type-error_type.Too_many_nulls" class="anchor"></a><code>| </code><code><span class="constructor">Too_many_nulls</span></code></td></tr><tr id="type-error_type.Exception" class="anchored"><td class="def constructor"><a href="#type-error_type.Exception" class="anchor"></a><code>| </code><code><span class="constructor">Exception</span> <span class="keyword">of</span> string * exn</code></td></tr></table></dt><dt class="spec type" id="type-lnum"><a href="#type-lnum" class="anchor"></a><code><span class="keyword">type</span> lnum</code><code> = </code><table class="variant"><tr id="type-lnum.Known" class="anchored"><td class="def constructor"><a href="#type-lnum.Known" class="anchor"></a><code>| </code><code><span class="constructor">Known</span> <span class="keyword">of</span> int</code></td></tr><tr id="type-lnum.Unknown" class="anchored"><td class="def constructor"><a href="#type-lnum.Unknown" class="anchor"></a><code>| </code><code><span class="constructor">Unknown</span></code></td></tr></table></dt><dt class="spec type" id="type-result"><a href="#type-result" class="anchor"></a><code><span class="keyword">type</span> result</code><code> = </code><table class="variant"><tr id="type-result.Success" class="anchored"><td class="def constructor"><a href="#type-result.Success" class="anchor"></a><code>| </code><code><span class="constructor">Success</span> <span class="keyword">of</span> <a href="index.html#type-lnum">lnum</a> * string</code></td></tr><tr id="type-result.Nothing_available" class="anchored"><td class="def constructor"><a href="#type-result.Nothing_available" class="anchor"></a><code>| </code><code><span class="constructor">Nothing_available</span></code></td></tr><tr id="type-result.Error" class="anchored"><td class="def constructor"><a href="#type-result.Error" class="anchor"></a><code>| </code><code><span class="constructor">Error</span> <span class="keyword">of</span> <a href="index.html#type-error_type">error_type</a></code></td></tr><tr id="type-result.Fatal_error" class="anchored"><td class="def constructor"><a href="#type-result.Fatal_error" class="anchor"></a><code>| </code><code><span class="constructor">Fatal_error</span> <span class="keyword">of</span> string * exn</code></td></tr></table></dt></dl><dl><dt class="spec exception" id="exception-File_truncated_or_deleted"><a href="#exception-File_truncated_or_deleted" class="anchor"></a><code><span class="keyword">exception</span> </code><code><span class="exception">File_truncated_or_deleted</span></code></dt></dl><dl><dt class="spec value" id="val-create"><a href="#val-create" class="anchor"></a><code><span class="keyword">val</span> create : ?&#8288;pos:<a href="../../../ocaml/Stdlib/Int64/index.html#type-t">Stdlib.Int64.t</a> <span>&#45;&gt;</span> ?&#8288;close_on_eof:bool <span>&#45;&gt;</span> ?&#8288;null_hack:[ `Off | `Retry_then_fail | `Retry ] <span>&#45;&gt;</span> ?&#8288;eprint_nulls:bool <span>&#45;&gt;</span> ?&#8288;follow_deletes:bool <span>&#45;&gt;</span> ?&#8288;signal_on_truncate_or_delete:bool <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Open a line buffer from the passed filename. If <code>close_on_eof</code> is set, when <code>eof</code> is read, the file will be closed and reopened if necessary. if <code>follow_deletes</code> is set, then when <code>eof</code> is read linebuf will stat the file, and if it has been deleted and recreated it will open the new file. If <code>eprint_nulls</code> is set, then when nulls are found, a warning message will be printed to stderr. <code>null_hack</code> specifies the behaviour of the linebuf upon reception of null characters in the file (as seen when tailing files over CIFS). Null hack options: `Off: don't check for nulls, just keep going. `Retry: close and reopen file when nulls are read from the file. If max_null_retries is reached, then pass the line with nulls. `Retry_then_fail: the same as retry, except that an exception is raised once max_null_retries is reached.</p></dd></dl><dl><dt class="spec value" id="val-close"><a href="#val-close" class="anchor"></a><code><span class="keyword">val</span> close : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Closes the line buffer (and the underlying file).</p></dd></dl><dl><dt class="spec value" id="val-is_closed"><a href="#val-is_closed" class="anchor"></a><code><span class="keyword">val</span> is_closed : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p>Returns whether or not the line buffer is closed</p></dd></dl><dl><dt class="spec value" id="val-try_read"><a href="#val-try_read" class="anchor"></a><code><span class="keyword">val</span> try_read : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> string option</code></dt><dd><p>Tries to read a line from the file. If no more lines are available, returns <code>None</code>.</p></dd></dl><dl><dt class="spec value" id="val-try_read_lnum"><a href="#val-try_read_lnum" class="anchor"></a><code><span class="keyword">val</span> try_read_lnum : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<a href="index.html#type-lnum">lnum</a> * string) option</code></dt><dd><p><code>try_read_lnum</code> is like <code>try_read</code> except also provides the line number of the read line.</p></dd></dl><dl><dt class="spec value" id="val-try_read_lnum_verbose"><a href="#val-try_read_lnum_verbose" class="anchor"></a><code><span class="keyword">val</span> try_read_lnum_verbose : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-result">result</a></code></dt><dd><p>Like try_read, except that it returns more verbose errors</p></dd></dl><dl><dt class="spec value" id="val-read"><a href="#val-read" class="anchor"></a><code><span class="keyword">val</span> read : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> string</code></dt><dd><p>Calls try_read every 0.01 seconds and returns when a line is available.</p></dd></dl><dl><dt class="spec value" id="val-tail"><a href="#val-tail" class="anchor"></a><code><span class="keyword">val</span> tail : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Seeks to the end of the file and blocks until another line is available -- this new line is not returned. Successive return values of <code>try_read_lnum</code> and <code>try_read_lnum</code> will return <code>Unknown</code> as the current line number until <code>reset</code> is called</p></dd></dl><dl><dt class="spec value" id="val-unsafe_tail"><a href="#val-unsafe_tail" class="anchor"></a><code><span class="keyword">val</span> unsafe_tail : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Same as <code>tail</code> except it may return before a new line is available on the file i.e. it (usually) doesn't block. Note that this does interact with files in a fairly naive way, so there's no guarantee that it absolutely doesn't block.</p><p>Note that when this functions is called, the next line that's read may be a partial line. After that first line, only full lines will be read.</p></dd></dl><dl><dt class="spec value" id="val-name"><a href="#val-name" class="anchor"></a><code><span class="keyword">val</span> name : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> string</code></dt><dt class="spec value" id="val-reset"><a href="#val-reset" class="anchor"></a><code><span class="keyword">val</span> reset : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>reopens the file and seeks to the beginning. Also recovers the ability to get line numbers if <code>tail</code> has been called</p></dd></dl></div></body></html>