<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Core_extended__Extended_list (core_extended.Core_extended__Extended_list)</title><link rel="stylesheet" href="../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../index.html">core_extended</a> &#x00BB; Core_extended__Extended_list</nav><h1>Module <code>Core_extended__Extended_list</code></h1><p>Extensions to <code>Core.List</code>.</p></header><dl><dt class="spec value" id="val-of_option"><a href="#val-of_option" class="anchor"></a><code><span class="keyword">val</span> of_option : <span class="type-var">'a</span> option <span>&#45;&gt;</span> <span class="type-var">'a</span> list</code></dt><dd><p><code>of_option o</code> returns a list that is empty if <code>o</code> is None, otherwise it is a singleton list. Useful to get filter_map-like behavior in the context of something like a concat_map.</p></dd></dl><dl><dt class="spec value" id="val-set_inter"><a href="#val-set_inter" class="anchor"></a><code><span class="keyword">val</span> set_inter : <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'a</span> list</code></dt><dd><p><code>set_inter l1 l2</code> returns a list without duplicates of all elements of l1 that are in l2</p></dd></dl><dl><dt class="spec value" id="val-set_diff"><a href="#val-set_diff" class="anchor"></a><code><span class="keyword">val</span> set_diff : <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'a</span> list</code></dt><dd><p><code>set_diff l1 l2</code> returns a list of all elements of l1 that are not in l2</p></dd></dl><dl><dt class="spec value" id="val-classify"><a href="#val-classify" class="anchor"></a><code><span class="keyword">val</span> classify : ?&#8288;equal:(<span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> f:(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span> list <span>&#45;&gt;</span> (<span class="type-var">'b</span> * <span class="type-var">'a</span> list) list</code></dt><dd><p><code>classify l ~equal ~f</code> elements <code>x</code> and <code>y</code> of list <code>l</code> are assigned to the same class iff <code>equal (f x) (f y)</code> returns true. The default for <code>equal</code> is ( = )</p></dd></dl><dl><dt class="spec value" id="val-enumerate_from"><a href="#val-enumerate_from" class="anchor"></a><code><span class="keyword">val</span> enumerate_from : int <span>&#45;&gt;</span> <span class="type-var">'a</span> list <span>&#45;&gt;</span> (<span class="type-var">'a</span> * int) list</code></dt><dd><p><code>enumerate_from n xs</code> returns a list of pairs constructed by pairing an incrementing counter, starting at <code>n</code>, with the elements of <code>xs</code>. e.g. enumerate_from 1 <code>a,b,c</code> = <code>a,1; b,2; c,3</code></p></dd></dl><dl><dt class="spec value" id="val-map_accum"><a href="#val-map_accum" class="anchor"></a><code><span class="keyword">val</span> map_accum : <span class="type-var">'a</span> list <span>&#45;&gt;</span> f:(<span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> * <span class="type-var">'c</span>) <span>&#45;&gt;</span> init:<span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> * <span class="type-var">'c</span> list</code></dt><dd><p>A combination of <code>map</code> and <code>fold</code>. Applies a function to each element of the input list, building up an accumulator, returning both the final state of the accumulator and a new list.</p></dd></dl><dl><dt class="spec value" id="val-max"><a href="#val-max" class="anchor"></a><code><span class="keyword">val</span> max : ?&#8288;cmp:(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> int) <span>&#45;&gt;</span> <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'a</span> option</code></dt><dt class="spec value" id="val-min"><a href="#val-min" class="anchor"></a><code><span class="keyword">val</span> min : ?&#8288;cmp:(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> int) <span>&#45;&gt;</span> <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'a</span> option</code></dt><dt class="spec value" id="val-max_exn"><a href="#val-max_exn" class="anchor"></a><code><span class="keyword">val</span> max_exn : ?&#8288;cmp:(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> int) <span>&#45;&gt;</span> <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dt class="spec value" id="val-min_exn"><a href="#val-min_exn" class="anchor"></a><code><span class="keyword">val</span> min_exn : ?&#8288;cmp:(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> int) <span>&#45;&gt;</span> <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dt class="spec value" id="val-lcs"><a href="#val-lcs" class="anchor"></a><code><span class="keyword">val</span> lcs : <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'a</span> list</code></dt><dd><p>Find the longest common subsequence between two list.</p></dd></dl><aside><p>Numbers the elements in a list by occurence:</p><p><code>[a;b;c;a;d] -&gt; [(a,0);(b,0);(c,0);(a,1);(d,0)]</code></p></aside><dl><dt class="spec value" id="val-number"><a href="#val-number" class="anchor"></a><code><span class="keyword">val</span> number : <span class="type-var">'a</span> list <span>&#45;&gt;</span> (<span class="type-var">'a</span> * int) list</code></dt><dt class="spec value" id="val-multimerge"><a href="#val-multimerge" class="anchor"></a><code><span class="keyword">val</span> multimerge : <span class="type-var">'a</span> list list <span>&#45;&gt;</span> <span class="type-var">'a</span> list</code></dt><dd><p>Merges several list trying to keep the order in which the elements appear. The elements of the individual are not deduped.</p><p>multimerge <code>[[a;b;d;a] [b;c;d]] -&gt; [a;b;c;d;a]</code></p></dd></dl><dl><dt class="spec value" id="val-multimerge_unique"><a href="#val-multimerge_unique" class="anchor"></a><code><span class="keyword">val</span> multimerge_unique : <span class="type-var">'a</span> list list <span>&#45;&gt;</span> <span class="type-var">'a</span> list</code></dt><dt class="spec value" id="val-square"><a href="#val-square" class="anchor"></a><code><span class="keyword">val</span> square : ?&#8288;null:<span class="type-var">'v</span> <span>&#45;&gt;</span> (<span class="type-var">'k</span> * <span class="type-var">'v</span>) list list <span>&#45;&gt;</span> <span class="type-var">'k</span> list * <span class="type-var">'v</span> list list</code></dt><dd><p>Takes a list of <code>`key*`value lists</code> and returns a header * table_body body that is obtained by splitting the lists and re-ordering the terms (so that they all have the same header).</p><p>If <code>null_value</code> is not specified and the rows have different keys the function will raise an exception. <code>
   square ~null
   [[(1,a_1);(2,b_1);(4,c_1)];
    [(3,a_2)];
    [(0,a_3);(1,b_3);(2,c_3);(3,d_3);(4,e_3)]]
   =
   ([0   ;1   ;2   ;3   ;4],
   [[null;a_1 ;b_1 ;null;c_1 ]
    [null;null;null;a_2 ;null]
    [a_3 ;b_3 ;c_3 ;d_3 ;e_3 ]])
   </code></p></dd></dl><dl><dt class="spec value" id="val-square_unique"><a href="#val-square_unique" class="anchor"></a><code><span class="keyword">val</span> square_unique : ?&#8288;null:<span class="type-var">'v</span> <span>&#45;&gt;</span> ?&#8288;equal:(<span class="type-var">'k</span> <span>&#45;&gt;</span> <span class="type-var">'k</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> (<span class="type-var">'k</span> * <span class="type-var">'v</span>) list list <span>&#45;&gt;</span> <span class="type-var">'k</span> list * <span class="type-var">'v</span> list list</code></dt><dt class="spec value" id="val-equal"><a href="#val-equal" class="anchor"></a><code><span class="keyword">val</span> equal : equal:(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'b</span> list <span>&#45;&gt;</span> bool</code></dt><dt class="spec value" id="val-compare"><a href="#val-compare" class="anchor"></a><code><span class="keyword">val</span> compare : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> int) <span>&#45;&gt;</span> <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'b</span> list <span>&#45;&gt;</span> int</code></dt></dl></div></body></html>