<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Core_extended__Extended_string (core_extended.Core_extended__Extended_string)</title><link rel="stylesheet" href="../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../index.html">core_extended</a> &#x00BB; Core_extended__Extended_string</nav><h1>Module <code>Core_extended__Extended_string</code></h1><p>Extensions to <code>Core.Core_String</code>.</p></header><dl><dt class="spec value" id="val-collate"><a href="#val-collate" class="anchor"></a><code><span class="keyword">val</span> collate : string <span>&#45;&gt;</span> string <span>&#45;&gt;</span> int</code></dt><dd><p><code>collate s1 s2</code> sorts string in an order that's usaully more suited for human consumption by treating ints specially, e.g. it will output: <code>[&quot;rfc1.txt&quot;;&quot;rfc822.txt&quot;;&quot;rfc2086.txt&quot;]</code>.</p><p>It works by splitting the strings in numerical and non-numerical chunks and comparing chunks two by two from left to right (and starting on a non numerical chunk):</p><ul><li>Non_numerical chunks are compared using lexicographical ordering.</li><li>Numerical chunks are compared based on the values of the represented ints and the number of trailing zeros.</li></ul><p>It is a total order.</p></dd></dl><dl><dt class="spec value" id="val-unescaped"><a href="#val-unescaped" class="anchor"></a><code><span class="keyword">val</span> unescaped : ?&#8288;strict:bool <span>&#45;&gt;</span> string <span>&#45;&gt;</span> string</code></dt><dd><p><code>unescaped s</code> is the inverse operation of <code>escaped</code>: it takes a string where all the special characters are escaped following the lexical convention of OCaml and returns an unescaped copy. The <code>strict</code> switch is on by default and makes the function treat illegal backslashes as errors. When <code>strict</code> is <code>false</code> every illegal backslash except escaped numeral greater than <code>255</code> is copied literally. The aforementioned numerals still raise errors. This mimics the behaviour of the ocaml lexer.</p></dd></dl><dl><dt class="spec value" id="val-unescaped_res"><a href="#val-unescaped_res" class="anchor"></a><code><span class="keyword">val</span> unescaped_res : ?&#8288;strict:bool <span>&#45;&gt;</span> string <span>&#45;&gt;</span> (string, int * string) <a href="../../core_kernel/Core_kernel/Result/index.html#type-t">Core.Result.t</a></code></dt><dd><p>Same as <code>unescaped</code> but instead of raising <code>Failure _</code> returns an error message with the position in the string in case of failure.</p></dd></dl><dl><dt class="spec value" id="val-squeeze"><a href="#val-squeeze" class="anchor"></a><code><span class="keyword">val</span> squeeze : string <span>&#45;&gt;</span> string</code></dt><dd><p><code>squeeze str</code> reduces all sequences of spaces, newlines, tables, and * carriage returns to single spaces.</p></dd></dl><dl><dt class="spec value" id="val-is_substring_deprecated"><a href="#val-is_substring_deprecated" class="anchor"></a><code><span class="keyword">val</span> is_substring_deprecated : substring:string <span>&#45;&gt;</span> string <span>&#45;&gt;</span> bool</code></dt><dd><p>Use Core.String.is_substring instead of this function. This wrapper is here (for now) to maintain bug compatibility.</p></dd></dl><dl><dt class="spec value" id="val-pad_left"><a href="#val-pad_left" class="anchor"></a><code><span class="keyword">val</span> pad_left : ?&#8288;char:char <span>&#45;&gt;</span> string <span>&#45;&gt;</span> int <span>&#45;&gt;</span> string</code></dt><dd><p><code>pad_left ~char s len</code> Returns <code>s</code> padded to the length <code>len</code> by adding characters <code>char</code> to the left of the string. If s is already longer than <code>len</code> it is returned unchanged.</p></dd></dl><dl><dt class="spec value" id="val-pad_right"><a href="#val-pad_right" class="anchor"></a><code><span class="keyword">val</span> pad_right : ?&#8288;char:char <span>&#45;&gt;</span> string <span>&#45;&gt;</span> int <span>&#45;&gt;</span> string</code></dt><dt class="spec value" id="val-line_break"><a href="#val-line_break" class="anchor"></a><code><span class="keyword">val</span> line_break : len:int <span>&#45;&gt;</span> string <span>&#45;&gt;</span> string list</code></dt><dd><p>deprecated in favour of word_wrap</p></dd></dl><dl><dt class="spec value" id="val-word_wrap"><a href="#val-word_wrap" class="anchor"></a><code><span class="keyword">val</span> word_wrap : ?&#8288;trailing_nl:bool <span>&#45;&gt;</span> ?&#8288;soft_limit:int <span>&#45;&gt;</span> ?&#8288;hard_limit:int <span>&#45;&gt;</span> ?&#8288;nl:string <span>&#45;&gt;</span> string <span>&#45;&gt;</span> string</code></dt><dd><p><code>word_wrap ~soft_limit s</code></p><p>Wraps the string so that it fits the length <code>soft_limit</code>. It doesn't break words unless we go over <code>hard_limit</code>.</p><p>if <code>nl</code> is passed it is inserted instead of the normal newline character.</p></dd></dl><dl><dt class="spec value" id="val-edit_distance"><a href="#val-edit_distance" class="anchor"></a><code><span class="keyword">val</span> edit_distance : ?&#8288;transpose:unit <span>&#45;&gt;</span> string <span>&#45;&gt;</span> string <span>&#45;&gt;</span> int</code></dt><dd><p>Gives the Levenshtein distance between 2 strings, which is the number of insertions, deletions, and substitutions necessary to turn either string into the other. With the <code>transpose</code> argument, it alsos considers transpositions (Damerau-Levenshtein distance).</p></dd></dl></div></body></html>