<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Core_kernel__Bus (core_kernel.Core_kernel__Bus)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../index.html">core_kernel</a> &#x00BB; Core_kernel__Bus</nav><h1>Module <code>Core_kernel__Bus</code></h1><p>A <code>Bus</code> is a publisher/subscriber system within the memory space of the program. A bus has a mutable set of subscribers, which can be modified using <code>subscribe_exn</code> and <code>unsubscribe</code>.</p><p><code>create</code> returns a <code>Bus.Read_write.t</code>, which you can use to <code>write</code> value to the bus. <code>write</code> calls the callbacks of all current subscribers before returning.</p><p>In a <code>('callback, 'phantom) Bus.t</code>, <code>'phantom</code> is a read-write phantom type that controls whether one can read values from or write values to the bus. The phantom type states the capabilities one could ever have access to, not the capabilities that are immediately available. In particular, if one wants to subscribe to a <code>Bus.Read_write.t</code>, one must call <code>read_only</code> on it in order to get a <code>Bus.Read_only.t</code> that can be passed to <code>subscribe_exn</code>. This is deliberate, and is meant to avoid unintentional reads from code that should only be writing.</p></header><dl><dt class="spec module" id="module-Callback_arity"><a href="#module-Callback_arity" class="anchor"></a><code><span class="keyword">module </span><a href="Callback_arity/index.html">Callback_arity</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p><code>Callback_arity</code> states the type of callbacks stored in a bus. Using <code>Callback_arity</code> is an implementation technique that allows callbacks to be defined as ordinary n-ary curried functions, instead of forcing n-ary-variadic callbacks to use tuples. This also avoids extra allocation.</p></dd></dl><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type </span>('callback, 'phantom) t</code></dt></dl><div><div class="spec include"><div class="doc"><details open="open"><summary><span class="def"><code><span class="keyword">include </span><span class="keyword">sig</span> ... <span class="keyword">end</span></code></span></summary><dl><dt class="spec value" id="val-sexp_of_t"><a href="#val-sexp_of_t" class="anchor"></a><code><span class="keyword">val </span>sexp_of_t : (<span class="type-var">'callback</span> <span>&#45;&gt;</span> Sexplib.Sexp.t) <span>&#45;&gt;</span> (<span class="type-var">'phantom</span> <span>&#45;&gt;</span> Sexplib.Sexp.t) <span>&#45;&gt;</span> (<span class="type-var">'callback</span>, <span class="type-var">'phantom</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> Sexplib.Sexp.t</code></dt></dl></details></div></div></div><dl><dt class="spec type" id="type-bus"><a href="#type-bus" class="anchor"></a><code><span class="keyword">type </span>('callback, 'phantom) bus</code><code><span class="keyword"> = </span>(<span class="type-var">'callback</span>, <span class="type-var">'phantom</span>) <a href="index.html#type-t">t</a></code></dt></dl><div class="spec module" id="module-Read_write"><a href="#module-Read_write" class="anchor"></a><code><span class="keyword">module </span><a href="Read_write/index.html">Read_write</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><div class="spec module" id="module-Read_only"><a href="#module-Read_only" class="anchor"></a><code><span class="keyword">module </span><a href="Read_only/index.html">Read_only</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><dl><dt class="spec value" id="val-read_only"><a href="#val-read_only" class="anchor"></a><code><span class="keyword">val </span>read_only : (<span class="type-var">'callback</span>, <span class="type-var">_</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'callback</span> <a href="Read_only/index.html#type-t">Read_only.t</a></code></dt><dt class="spec value" id="val-create"><a href="#val-create" class="anchor"></a><code><span class="keyword">val </span>create : ?&#8288;name:Core_kernel__.Info.t <span>&#45;&gt;</span> Core_kernel__.Source_code_position.t <span>&#45;&gt;</span> <span class="type-var">'callback</span> <a href="Callback_arity/index.html#type-t">Callback_arity.t</a> <span>&#45;&gt;</span> allow_subscription_after_first_write:Core_kernel__.Import.bool <span>&#45;&gt;</span> on_callback_raise:(Core_kernel__.Error.t <span>&#45;&gt;</span> Core_kernel__.Import.unit) <span>&#45;&gt;</span> <span class="type-var">'callback</span> <a href="Read_write/index.html#type-t">Read_write.t</a></code></dt><dd><p>In <code>create [%here] ArityN ~allow_subscription_after_first_write ~on_callback_raise</code>, <code>[%here]</code> is stored in the resulting bus, and contained in <code>%sexp_of: t</code>, which can help with debugging. If <code>allow_subscription_after_first_write</code> is false, then <code>subscribe_exn</code> will raise if it is called after <code>write</code> has been called the first time. If a callback raises, <code>on_callback_raise</code> is called with an error containing the exception. If <code>on_callback_raise</code> raises, then the exception is raised to <code>write</code> and the bus is closed.</p></dd></dl><dl><dt class="spec value" id="val-callback_arity"><a href="#val-callback_arity" class="anchor"></a><code><span class="keyword">val </span>callback_arity : (<span class="type-var">'callback</span>, <span class="type-var">_</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'callback</span> <a href="Callback_arity/index.html#type-t">Callback_arity.t</a></code></dt><dt class="spec value" id="val-num_subscribers"><a href="#val-num_subscribers" class="anchor"></a><code><span class="keyword">val </span>num_subscribers : (<span class="type-var">_</span>, <span class="type-var">_</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> Core_kernel__.Import.int</code></dt><dt class="spec value" id="val-is_closed"><a href="#val-is_closed" class="anchor"></a><code><span class="keyword">val </span>is_closed : (<span class="type-var">_</span>, <span class="type-var">_</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> Core_kernel__.Import.bool</code></dt><dt class="spec value" id="val-close"><a href="#val-close" class="anchor"></a><code><span class="keyword">val </span>close : <span class="type-var">'callback</span> <a href="Read_write/index.html#type-t">Read_write.t</a> <span>&#45;&gt;</span> Core_kernel__.Import.unit</code></dt><dd><p><code>close</code> disallows future <code>write</code>s -- once <code>close t</code> is called, all further calls to <code>write t</code> will raise. <code>close</code> is idempotent. If <code>close</code> is called from within a callback, the current message will still be sent to all subscribed callbacks that have not yet seen it before the close takes effect.</p></dd></dl><dl><dt class="spec value" id="val-write"><a href="#val-write" class="anchor"></a><code><span class="keyword">val </span>write : <span class="type-var">'callback</span> <a href="Read_write/index.html#type-t">Read_write.t</a> <span>&#45;&gt;</span> <span class="type-var">'callback</span></code></dt><dd><p><code>write</code> calls all callbacks currently subscribed to the bus, with no guarantee on the order in which they will be called. <code>write</code> is fast and non-allocating, though the callbacks themselves may allocate.</p><p>Calling <code>write t</code> from within a callback on <code>t</code> or if <code>is_closed t</code> will raise.</p></dd></dl><div class="spec module" id="module-Subscriber"><a href="#module-Subscriber" class="anchor"></a><code><span class="keyword">module </span><a href="Subscriber/index.html">Subscriber</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><dl><dt class="spec value" id="val-subscribe_exn"><a href="#val-subscribe_exn" class="anchor"></a><code><span class="keyword">val </span>subscribe_exn : ?&#8288;on_callback_raise:(Core_kernel__.Error.t <span>&#45;&gt;</span> Core_kernel__.Import.unit) <span>&#45;&gt;</span> <span class="type-var">'callback</span> <a href="Read_only/index.html#type-t">Read_only.t</a> <span>&#45;&gt;</span> Core_kernel__.Source_code_position.t <span>&#45;&gt;</span> f:<span class="type-var">'callback</span> <span>&#45;&gt;</span> <span class="type-var">'callback</span> <a href="Subscriber/index.html#type-t">Subscriber.t</a></code></dt><dd><p><code>subscribe_exn t [%here] ~f</code> adds the callback <code>f</code> to the set of <code>t</code>'s subscribers, and returns a <code>Subscriber.t</code> that can later be used to <code>unsubscribe</code>. <code>[%here]</code> is stored in the <code>Subscriber.t</code>, and contained in <code>%sexp_of: Subscriber.t</code>, which can help with debugging. If <code>subscribe_exn t</code> is called by a callback in <code>t</code>, i.e. during <code>write t</code>, the subscription takes effect for the next <code>write</code>, but does not affect the current <code>write</code>. <code>subscribe_exn</code> takes time proportional to the number of callbacks.</p><p>If <code>on_callback_raise</code> is supplied, then it will be called by <code>write</code> whenever <code>f</code> raises; only if that subsequently raises will <code>t</code>'s <code>on_callback_raise</code> be called. If <code>on_callback_raise</code> is not supplied, then <code>t</code>'s <code>on_callback_raise</code> will be called whenever <code>f</code> raises.</p></dd></dl><dl><dt class="spec value" id="val-iter_exn"><a href="#val-iter_exn" class="anchor"></a><code><span class="keyword">val </span>iter_exn : <span class="type-var">'callback</span> <a href="Read_only/index.html#type-t">Read_only.t</a> <span>&#45;&gt;</span> Core_kernel__.Source_code_position.t <span>&#45;&gt;</span> f:<span class="type-var">'callback</span> <span>&#45;&gt;</span> Core_kernel__.Import.unit</code></dt><dd><p><code>iter_exn t [%here] ~f</code> is <code>ignore (subscribe_exn t [%here] ~callback:f)</code>. This captures the common usage in which one never wants to unsubscribe from a bus.</p></dd></dl><div class="spec module" id="module-Fold_arity"><a href="#module-Fold_arity" class="anchor"></a><code><span class="keyword">module </span><a href="Fold_arity/index.html">Fold_arity</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><dl><dt class="spec value" id="val-fold_exn"><a href="#val-fold_exn" class="anchor"></a><code><span class="keyword">val </span>fold_exn : <span class="type-var">'callback</span> <a href="Read_only/index.html#type-t">Read_only.t</a> <span>&#45;&gt;</span> Core_kernel__.Source_code_position.t <span>&#45;&gt;</span> (<span class="type-var">'callback</span>, <span class="type-var">'f</span>, <span class="type-var">'s</span>) <a href="Fold_arity/index.html#type-t">Fold_arity.t</a> <span>&#45;&gt;</span> init:<span class="type-var">'s</span> <span>&#45;&gt;</span> f:<span class="type-var">'f</span> <span>&#45;&gt;</span> Core_kernel__.Import.unit</code></dt><dd><p><code>fold_exn t [%here] arity ~init ~f</code> folds over the bus events, threading a state value to every call. It is otherwise similar to <code>iter_exn</code>.</p></dd></dl><dl><dt class="spec value" id="val-unsubscribe"><a href="#val-unsubscribe" class="anchor"></a><code><span class="keyword">val </span>unsubscribe : <span class="type-var">'callback</span> <a href="Read_only/index.html#type-t">Read_only.t</a> <span>&#45;&gt;</span> <span class="type-var">'callback</span> <a href="Subscriber/index.html#type-t">Subscriber.t</a> <span>&#45;&gt;</span> Core_kernel__.Import.unit</code></dt><dd><p><code>unsubscribe t subscriber</code> removes the callback corresponding to <code>subscriber</code> from <code>t</code>. <code>unsubscribe</code> never raises and is idempotent. As with <code>subscribe_exn</code>, <code>unsubscribe t</code> during <code>write t</code> takes effect after the current <code>write</code> finishes. Also like <code>subscribe_exn</code>, <code>unsubscribe</code> takes time proportional to the number of callbacks.</p></dd></dl></div></body></html>