<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Core_kernel__Core_map (core_kernel.Core_kernel__Core_map)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../index.html">core_kernel</a> &#x00BB; Core_kernel__Core_map</nav><h1>Module <code>Core_kernel__Core_map</code></h1><p>This module defines the <code>Map</code> module for <code>Core</code>. We use &quot;core_map&quot; as the file name rather than &quot;map&quot; to avoid conflicts with OCaml's standard map module. In this documentation, we use <code>Map</code> to mean this module, not the OCaml standard one.</p><p><code>Map</code> is a functional datastructure (balanced binary tree) implementing finite maps over a totally-ordered domain, called a &quot;key&quot;. The map types and operations appear in three places:</p><pre>    | Map      | polymorphic map operations                                      |
    | Map.Poly | maps that use polymorphic comparison to order keys              |
    | Key.Map  | maps with a fixed key type that use [Key.compare] to order keys |</pre><p>Where <code>Key</code> is any module defining values that can be used as keys of a map, like <code>Int</code>, <code>String</code>, etc. To add this functionality to an arbitrary module, use the <code>Comparable.Make</code> functor.</p><p>One should use <code>Map</code> for functions that access existing maps, like <code>find</code>, <code>mem</code>, <code>add</code>, <code>fold</code>, <code>iter</code>, and <code>to_alist</code>. For functions that create maps, like <code>empty</code>, <code>singleton</code>, and <code>of_alist</code>, one should strive to use the corresponding <code>Key.Map</code> function, which will use the comparison function specifically for <code>Key</code>. As a last resort, if one does not have easy access to a comparison function for the keys in one's map, use <code>Map.Poly</code> to create the map. This will use OCaml's built-in polymorphic comparison to compare keys, which has all the usual performance and robustness problems that entails.</p><p>Parallel to the three kinds of map modules, there are also tree modules <code>Map.Tree</code>, <code>Map.Poly.Tree</code>, and <code>Key.Map.Tree</code>. A tree is a bare representation of a map, without the comparator. Thus tree operations need to obtain the comparator from somewhere. For <code>Map.Poly.Tree</code> and <code>Key.Map.Tree</code>, the comparator is implicit in the module name. For <code>Map.Tree</code>, the comparator must be passed to each operation. The main advantages of trees over maps are slightly improved space usage (there is no outer container holding the comparator) and the ability to marshal trees, because a tree doesn't contain a closure, unlike a map. The main disadvantages of using trees are needing to be more explicit about the comparator, and the possibility of accidental use of polymorphic equality on a tree (for which maps dynamically detect failure due to the presence of a closure in the data structure).</p><p>For a detailed explanation of the interface design, read on.</p><p>An instance of the map type is determined by the types of the map's keys and values, and the comparison function used to order the keys:</p><pre><code class="ml">type ('key, 'value, 'cmp) Map.t </code></pre><p><code>'cmp</code> is a phantom type uniquely identifying the comparison function, as generated by <code>Comparator.Make</code>.</p><p><code>Map.Poly</code> supports arbitrary key and value types, but enforces that the comparison function used to order the keys is polymorphic comparison. <code>Key.Map</code> has a fixed key type and comparison function, and supports arbitrary values.</p><pre><code class="ml">type ('key, 'value) Map.Poly.t = ('key , 'value, Comparator.Poly.t) Map.t
type 'value Key.Map.t          = (Key.t, 'value, Key.comparator   ) Map.t</code></pre><p>The same map operations exist in <code>Map</code>, <code>Map.Poly</code>, and <code>Key.Map</code>, albeit with different types. For example:</p><pre><code class="ml">val Map.length      : (_, _, _) Map.t   -&gt; int
val Map.Poly.length : (_, _) Map.Poly.t -&gt; int
val Key.Map.length  : _ Key.Map.t       -&gt; int</code></pre><p>Because <code>Map.Poly.t</code> and <code>Key.Map.t</code> are exposed as instances of the more general <code>Map.t</code> type, one can use <code>Map.length</code> on any map. The same is true for all of the functions that access an existing map, such as <code>add</code>, <code>change</code>, <code>find</code>, <code>fold</code>, <code>iter</code>, <code>map</code>, <code>to_alist</code>, etc.</p><p>Depending on the number of type variables <code>N</code>, the type of accessor (resp. creator) functions are defined in the module type <code>AccessorsN</code> (resp. <code>CreatorsN</code>) in <code>Core_map_intf</code>. Also for creators, when the comparison function is not fixed, i.e. the <code>'cmp</code> variable of <code>Map.t</code> is free, we need to pass a comparator to the function creating the map. The module type is called <code>Creators3_with_comparator</code>. There is also a module type <code>Accessors3_with_comparator</code> in addition to <code>Accessors3</code> which used for trees since the comparator is not known.</p><nav class="toc"><ul><li><a href="#additional-operations-on-maps">Additional operations on maps</a></li></ul></nav></header><div class="spec module" id="module-Tree"><a href="#module-Tree" class="anchor"></a><code><span class="keyword">module </span><a href="Tree/index.html">Tree</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type </span>('key, +'value, 'cmp) t</code><code><span class="keyword"> = </span>(<span class="type-var">'key</span>, <span class="type-var">'value</span>, <span class="type-var">'cmp</span>) Base.Map.t</code></dt></dl><dl><dt class="spec value" id="val-invariants"><a href="#val-invariants" class="anchor"></a><code><span class="keyword">val </span>invariants : (<span class="type-var">_</span>, <span class="type-var">_</span>, <span class="type-var">_</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> Core_kernel__.Import.bool</code></dt><dd><p>Test if invariants of internal AVL search tree hold.</p></dd></dl><dl><dt class="spec value" id="val-comparator"><a href="#val-comparator" class="anchor"></a><code><span class="keyword">val </span>comparator : (<span class="type-var">'a</span>, <span class="type-var">_</span>, <span class="type-var">'cmp</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span>, <span class="type-var">'cmp</span>) Core_kernel__.Comparator.t</code></dt><dt class="spec value" id="val-empty"><a href="#val-empty" class="anchor"></a><code><span class="keyword">val </span>empty : comparator:(<span class="type-var">'a</span>, <span class="type-var">'cmp</span>) Core_kernel__.Comparator.t <span>&#45;&gt;</span> (<span class="type-var">'a</span>, <span class="type-var">'b</span>, <span class="type-var">'cmp</span>) <a href="index.html#type-t">t</a></code></dt><dd><p>the empty map</p></dd></dl><dl><dt class="spec value" id="val-singleton"><a href="#val-singleton" class="anchor"></a><code><span class="keyword">val </span>singleton : comparator:(<span class="type-var">'a</span>, <span class="type-var">'cmp</span>) Core_kernel__.Comparator.t <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> (<span class="type-var">'a</span>, <span class="type-var">'b</span>, <span class="type-var">'cmp</span>) <a href="index.html#type-t">t</a></code></dt><dd><p>map with one key, data pair</p></dd></dl><dl><dt class="spec value" id="val-of_alist"><a href="#val-of_alist" class="anchor"></a><code><span class="keyword">val </span>of_alist : comparator:(<span class="type-var">'a</span>, <span class="type-var">'cmp</span>) Core_kernel__.Comparator.t <span>&#45;&gt;</span> (<span class="type-var">'a</span><span class="keyword"> * </span><span class="type-var">'b</span>) Core_kernel__.Import.list <span>&#45;&gt;</span> [ `Ok of (<span class="type-var">'a</span>, <span class="type-var">'b</span>, <span class="type-var">'cmp</span>) <a href="index.html#type-t">t</a><span class="keyword"> | </span>`Duplicate_key of <span class="type-var">'a</span> ]</code></dt><dd><p>creates map from association list with unique keys</p></dd></dl><dl><dt class="spec value" id="val-of_alist_or_error"><a href="#val-of_alist_or_error" class="anchor"></a><code><span class="keyword">val </span>of_alist_or_error : comparator:(<span class="type-var">'a</span>, <span class="type-var">'cmp</span>) Core_kernel__.Comparator.t <span>&#45;&gt;</span> (<span class="type-var">'a</span><span class="keyword"> * </span><span class="type-var">'b</span>) Core_kernel__.Import.list <span>&#45;&gt;</span> (<span class="type-var">'a</span>, <span class="type-var">'b</span>, <span class="type-var">'cmp</span>) <a href="index.html#type-t">t</a> Core_kernel__.Or_error.t</code></dt><dd><p>creates map from association list with unique keys. Returns an error if duplicate 'a keys are found.</p></dd></dl><dl><dt class="spec value" id="val-of_alist_exn"><a href="#val-of_alist_exn" class="anchor"></a><code><span class="keyword">val </span>of_alist_exn : comparator:(<span class="type-var">'a</span>, <span class="type-var">'cmp</span>) Core_kernel__.Comparator.t <span>&#45;&gt;</span> (<span class="type-var">'a</span><span class="keyword"> * </span><span class="type-var">'b</span>) Core_kernel__.Import.list <span>&#45;&gt;</span> (<span class="type-var">'a</span>, <span class="type-var">'b</span>, <span class="type-var">'cmp</span>) <a href="index.html#type-t">t</a></code></dt><dd><p>creates map from association list with unique keys. Raises an exception if duplicate 'a keys are found.</p></dd></dl><dl><dt class="spec value" id="val-of_hashtbl_exn"><a href="#val-of_hashtbl_exn" class="anchor"></a><code><span class="keyword">val </span>of_hashtbl_exn : comparator:(<span class="type-var">'a</span>, <span class="type-var">'cmp</span>) Core_kernel__.Comparator.t <span>&#45;&gt;</span> (<span class="type-var">'a</span>, <span class="type-var">'b</span>) Core_kernel__.Core_hashtbl.t <span>&#45;&gt;</span> (<span class="type-var">'a</span>, <span class="type-var">'b</span>, <span class="type-var">'cmp</span>) <a href="index.html#type-t">t</a></code></dt><dd><p><code>of_hashtbl_exn</code> creates a map from bindings present in a hash table. <code>of_hashtbl_exn</code> raises if there are distinct keys <code>a1</code> and <code>a2</code> in the table with <code>comparator.compare a1 a2 = 0</code>, which is only possible if the hash-table comparison function is different than <code>comparator.compare</code>. In the common case, the comparison is the same, in which case <code>of_hashtbl_exn</code> does not raise, regardless of the keys present in the table.</p></dd></dl><dl><dt class="spec value" id="val-of_alist_multi"><a href="#val-of_alist_multi" class="anchor"></a><code><span class="keyword">val </span>of_alist_multi : comparator:(<span class="type-var">'a</span>, <span class="type-var">'cmp</span>) Core_kernel__.Comparator.t <span>&#45;&gt;</span> (<span class="type-var">'a</span><span class="keyword"> * </span><span class="type-var">'b</span>) Core_kernel__.Import.list <span>&#45;&gt;</span> (<span class="type-var">'a</span>, <span class="type-var">'b</span> Core_kernel__.Import.list, <span class="type-var">'cmp</span>) <a href="index.html#type-t">t</a></code></dt><dd><p>creates map from association list with possibly repeated keys.</p></dd></dl><dl><dt class="spec value" id="val-of_alist_fold"><a href="#val-of_alist_fold" class="anchor"></a><code><span class="keyword">val </span>of_alist_fold : comparator:(<span class="type-var">'a</span>, <span class="type-var">'cmp</span>) Core_kernel__.Comparator.t <span>&#45;&gt;</span> (<span class="type-var">'a</span><span class="keyword"> * </span><span class="type-var">'b</span>) Core_kernel__.Import.list <span>&#45;&gt;</span> init:<span class="type-var">'c</span> <span>&#45;&gt;</span> f:(<span class="type-var">'c</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'c</span>) <span>&#45;&gt;</span> (<span class="type-var">'a</span>, <span class="type-var">'c</span>, <span class="type-var">'cmp</span>) <a href="index.html#type-t">t</a></code></dt><dd><p>combines an association list into a map, folding together bound values with common keys</p></dd></dl><dl><dt class="spec value" id="val-of_alist_reduce"><a href="#val-of_alist_reduce" class="anchor"></a><code><span class="keyword">val </span>of_alist_reduce : comparator:(<span class="type-var">'a</span>, <span class="type-var">'cmp</span>) Core_kernel__.Comparator.t <span>&#45;&gt;</span> (<span class="type-var">'a</span><span class="keyword"> * </span><span class="type-var">'b</span>) Core_kernel__.Import.list <span>&#45;&gt;</span> f:(<span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>) <span>&#45;&gt;</span> (<span class="type-var">'a</span>, <span class="type-var">'b</span>, <span class="type-var">'cmp</span>) <a href="index.html#type-t">t</a></code></dt><dd><p>combines an association list into a map, reducing together bound values with common keys</p></dd></dl><dl><dt class="spec value" id="val-of_iteri"><a href="#val-of_iteri" class="anchor"></a><code><span class="keyword">val </span>of_iteri : comparator:(<span class="type-var">'a</span>, <span class="type-var">'cmp</span>) Core_kernel__.Comparator.t <span>&#45;&gt;</span> iteri:(f:(key:<span class="type-var">'a</span> <span>&#45;&gt;</span> data:<span class="type-var">'b</span> <span>&#45;&gt;</span> Core_kernel__.Import.unit) <span>&#45;&gt;</span> Core_kernel__.Import.unit) <span>&#45;&gt;</span> [ `Ok of (<span class="type-var">'a</span>, <span class="type-var">'b</span>, <span class="type-var">'cmp</span>) <a href="index.html#type-t">t</a><span class="keyword"> | </span>`Duplicate_key of <span class="type-var">'a</span> ]</code></dt><dd><p><code>of_iteri ~iteri</code> behaves like <code>of_alist</code>, except that instead of taking a concrete datastruture, it takes an iteration function. For instance, to convert a string table into a map: <code>of_iteri ~comparator ~f:(Hashtbl.iteri table)</code>. It is faster than adding the elements one by one.</p></dd></dl><dl><dt class="spec value" id="val-to_tree"><a href="#val-to_tree" class="anchor"></a><code><span class="keyword">val </span>to_tree : (<span class="type-var">'k</span>, <span class="type-var">'v</span>, <span class="type-var">'cmp</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<span class="type-var">'k</span>, <span class="type-var">'v</span>, <span class="type-var">'cmp</span>) <a href="Tree/index.html#type-t">Tree.t</a></code></dt><dt class="spec value" id="val-of_tree"><a href="#val-of_tree" class="anchor"></a><code><span class="keyword">val </span>of_tree : comparator:(<span class="type-var">'k</span>, <span class="type-var">'cmp</span>) Core_kernel__.Comparator.t <span>&#45;&gt;</span> (<span class="type-var">'k</span>, <span class="type-var">'v</span>, <span class="type-var">'cmp</span>) <a href="Tree/index.html#type-t">Tree.t</a> <span>&#45;&gt;</span> (<span class="type-var">'k</span>, <span class="type-var">'v</span>, <span class="type-var">'cmp</span>) <a href="index.html#type-t">t</a></code></dt><dd><p>Creates a <code>t</code> from a <code>Tree.t</code> and a <code>Comparator.t</code>. This is an O(n) operation as it must discover the length of the <code>Tree.t</code>.</p></dd></dl><dl><dt class="spec value" id="val-of_sorted_array"><a href="#val-of_sorted_array" class="anchor"></a><code><span class="keyword">val </span>of_sorted_array : comparator:(<span class="type-var">'a</span>, <span class="type-var">'cmp</span>) Core_kernel__.Comparator.t <span>&#45;&gt;</span> (<span class="type-var">'a</span><span class="keyword"> * </span><span class="type-var">'b</span>) Core_kernel__.Import.array <span>&#45;&gt;</span> (<span class="type-var">'a</span>, <span class="type-var">'b</span>, <span class="type-var">'cmp</span>) <a href="index.html#type-t">t</a> Core_kernel__.Or_error.t</code></dt><dd><p>creates map from sorted array of key-data pairs. The input array must be sorted, as given by the relevant comparator (either in ascending or descending order), and must not contain any duplicate keys. If either of these conditions do not hold, an error is returned.</p></dd></dl><dl><dt class="spec value" id="val-of_sorted_array_unchecked"><a href="#val-of_sorted_array_unchecked" class="anchor"></a><code><span class="keyword">val </span>of_sorted_array_unchecked : comparator:(<span class="type-var">'a</span>, <span class="type-var">'cmp</span>) Core_kernel__.Comparator.t <span>&#45;&gt;</span> (<span class="type-var">'a</span><span class="keyword"> * </span><span class="type-var">'b</span>) Core_kernel__.Import.array <span>&#45;&gt;</span> (<span class="type-var">'a</span>, <span class="type-var">'b</span>, <span class="type-var">'cmp</span>) <a href="index.html#type-t">t</a></code></dt><dd><p>Like <code>of_sorted_array</code> except it returns a map with broken invariants when an <code>Error</code> would have been returned.</p></dd></dl><dl><dt class="spec value" id="val-of_increasing_iterator_unchecked"><a href="#val-of_increasing_iterator_unchecked" class="anchor"></a><code><span class="keyword">val </span>of_increasing_iterator_unchecked : comparator:(<span class="type-var">'a</span>, <span class="type-var">'cmp</span>) Core_kernel__.Comparator.t <span>&#45;&gt;</span> len:Core_kernel__.Import.int <span>&#45;&gt;</span> f:(Core_kernel__.Import.int <span>&#45;&gt;</span> <span class="type-var">'a</span><span class="keyword"> * </span><span class="type-var">'b</span>) <span>&#45;&gt;</span> (<span class="type-var">'a</span>, <span class="type-var">'b</span>, <span class="type-var">'cmp</span>) <a href="index.html#type-t">t</a></code></dt><dd><p><code>if_increasing_iterator_unchecked ~comparator ~len ~f</code> behaves like <code>of_sorted_array_unchecked ~comparator (Array.init len ~f)</code>, with the additional restriction that a decreasing order is not supported. The advantage is not requiring you to allocate an intermediate array. <code>f</code> will be called with 0, 1, ... <code>len - 1</code>, in order.</p></dd></dl><dl><dt class="spec value" id="val-is_empty"><a href="#val-is_empty" class="anchor"></a><code><span class="keyword">val </span>is_empty : (<span class="type-var">_</span>, <span class="type-var">_</span>, <span class="type-var">_</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> Core_kernel__.Import.bool</code></dt><dd><p>Test whether a map is empty or not.</p></dd></dl><dl><dt class="spec value" id="val-length"><a href="#val-length" class="anchor"></a><code><span class="keyword">val </span>length : (<span class="type-var">_</span>, <span class="type-var">_</span>, <span class="type-var">_</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> Core_kernel__.Import.int</code></dt><dd><p><code>length map</code> </p><dl><dt>returns</dt><dd><p>number of elements in <code>map</code>. O(1), but <code>Tree.length</code> is O(n).</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-add"><a href="#val-add" class="anchor"></a><code><span class="keyword">val </span>add : (<span class="type-var">'k</span>, <span class="type-var">'v</span>, <span class="type-var">'cmp</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> key:<span class="type-var">'k</span> <span>&#45;&gt;</span> data:<span class="type-var">'v</span> <span>&#45;&gt;</span> (<span class="type-var">'k</span>, <span class="type-var">'v</span>, <span class="type-var">'cmp</span>) <a href="index.html#type-t">t</a></code></dt><dd><p>returns a new map with the specified new binding; if the key was already bound, its previous binding disappears.</p></dd></dl><dl><dt class="spec value" id="val-add_multi"><a href="#val-add_multi" class="anchor"></a><code><span class="keyword">val </span>add_multi : (<span class="type-var">'k</span>, <span class="type-var">'v</span> Core_kernel__.Import.list, <span class="type-var">'cmp</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> key:<span class="type-var">'k</span> <span>&#45;&gt;</span> data:<span class="type-var">'v</span> <span>&#45;&gt;</span> (<span class="type-var">'k</span>, <span class="type-var">'v</span> Core_kernel__.Import.list, <span class="type-var">'cmp</span>) <a href="index.html#type-t">t</a></code></dt><dd><p>if key is not present then add a singleton list, otherwise, cons data on the head of the existing list.</p></dd></dl><dl><dt class="spec value" id="val-remove_multi"><a href="#val-remove_multi" class="anchor"></a><code><span class="keyword">val </span>remove_multi : (<span class="type-var">'k</span>, <span class="type-var">'v</span> Core_kernel__.Import.list, <span class="type-var">'cmp</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'k</span> <span>&#45;&gt;</span> (<span class="type-var">'k</span>, <span class="type-var">'v</span> Core_kernel__.Import.list, <span class="type-var">'cmp</span>) <a href="index.html#type-t">t</a></code></dt><dd><p>if key is present then remove its head element; if result is empty, remove the key.</p></dd></dl><dl><dt class="spec value" id="val-change"><a href="#val-change" class="anchor"></a><code><span class="keyword">val </span>change : (<span class="type-var">'k</span>, <span class="type-var">'v</span>, <span class="type-var">'cmp</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'k</span> <span>&#45;&gt;</span> f:(<span class="type-var">'v</span> Core_kernel__.Import.option <span>&#45;&gt;</span> <span class="type-var">'v</span> Core_kernel__.Import.option) <span>&#45;&gt;</span> (<span class="type-var">'k</span>, <span class="type-var">'v</span>, <span class="type-var">'cmp</span>) <a href="index.html#type-t">t</a></code></dt><dd><p><code>change t key ~f</code> returns a new map <code>m</code> that is the same as <code>t</code> on all keys except for <code>key</code>, and whose value for <code>key</code> is defined by <code>f</code>, i.e. <code>find m key = f (find t
    key)</code>.</p></dd></dl><dl><dt class="spec value" id="val-update"><a href="#val-update" class="anchor"></a><code><span class="keyword">val </span>update : (<span class="type-var">'k</span>, <span class="type-var">'v</span>, <span class="type-var">'cmp</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'k</span> <span>&#45;&gt;</span> f:(<span class="type-var">'v</span> Core_kernel__.Import.option <span>&#45;&gt;</span> <span class="type-var">'v</span>) <span>&#45;&gt;</span> (<span class="type-var">'k</span>, <span class="type-var">'v</span>, <span class="type-var">'cmp</span>) <a href="index.html#type-t">t</a></code></dt><dd><p><code>update t key ~f</code> is <code>change t key ~f:(fun o -&gt; Some (f o))</code>.</p></dd></dl><dl><dt class="spec value" id="val-find"><a href="#val-find" class="anchor"></a><code><span class="keyword">val </span>find : (<span class="type-var">'k</span>, <span class="type-var">'v</span>, <span class="type-var">'cmp</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'k</span> <span>&#45;&gt;</span> <span class="type-var">'v</span> Core_kernel__.Import.option</code></dt><dd><p>returns the value bound to the given key, raising <code>Not_found</code> if none such exists</p></dd></dl><dl><dt class="spec value" id="val-find_exn"><a href="#val-find_exn" class="anchor"></a><code><span class="keyword">val </span>find_exn : (<span class="type-var">'k</span>, <span class="type-var">'v</span>, <span class="type-var">'cmp</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'k</span> <span>&#45;&gt;</span> <span class="type-var">'v</span></code></dt><dt class="spec value" id="val-remove"><a href="#val-remove" class="anchor"></a><code><span class="keyword">val </span>remove : (<span class="type-var">'k</span>, <span class="type-var">'v</span>, <span class="type-var">'cmp</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'k</span> <span>&#45;&gt;</span> (<span class="type-var">'k</span>, <span class="type-var">'v</span>, <span class="type-var">'cmp</span>) <a href="index.html#type-t">t</a></code></dt><dd><p>returns a new map with any binding for the key in question removed</p></dd></dl><dl><dt class="spec value" id="val-mem"><a href="#val-mem" class="anchor"></a><code><span class="keyword">val </span>mem : (<span class="type-var">'k</span>, <span class="type-var">_</span>, <span class="type-var">'cmp</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'k</span> <span>&#45;&gt;</span> Core_kernel__.Import.bool</code></dt><dd><p><code>mem map key</code> tests whether <code>map</code> contains a binding for <code>key</code></p></dd></dl><dl><dt class="spec value" id="val-iter_keys"><a href="#val-iter_keys" class="anchor"></a><code><span class="keyword">val </span>iter_keys : (<span class="type-var">'k</span>, <span class="type-var">_</span>, <span class="type-var">_</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> f:(<span class="type-var">'k</span> <span>&#45;&gt;</span> Core_kernel__.Import.unit) <span>&#45;&gt;</span> Core_kernel__.Import.unit</code></dt><dt class="spec value" id="val-iter"><a href="#val-iter" class="anchor"></a><code><span class="keyword">val </span>iter : (<span class="type-var">_</span>, <span class="type-var">'v</span>, <span class="type-var">_</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> f:(<span class="type-var">'v</span> <span>&#45;&gt;</span> Core_kernel__.Import.unit) <span>&#45;&gt;</span> Core_kernel__.Import.unit</code></dt><dt class="spec value" id="val-iteri"><a href="#val-iteri" class="anchor"></a><code><span class="keyword">val </span>iteri : (<span class="type-var">'k</span>, <span class="type-var">'v</span>, <span class="type-var">_</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> f:(key:<span class="type-var">'k</span> <span>&#45;&gt;</span> data:<span class="type-var">'v</span> <span>&#45;&gt;</span> Core_kernel__.Import.unit) <span>&#45;&gt;</span> Core_kernel__.Import.unit</code></dt><dt class="spec value" id="val-iter2"><a href="#val-iter2" class="anchor"></a><code><span class="keyword">val </span>iter2 : (<span class="type-var">'k</span>, <span class="type-var">'v1</span>, <span class="type-var">'cmp</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<span class="type-var">'k</span>, <span class="type-var">'v2</span>, <span class="type-var">'cmp</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> f:(key:<span class="type-var">'k</span> <span>&#45;&gt;</span> data:[ `Left of <span class="type-var">'v1</span><span class="keyword"> | </span>`Right of <span class="type-var">'v2</span><span class="keyword"> | </span>`Both of <span class="type-var">'v1</span><span class="keyword"> * </span><span class="type-var">'v2</span> ] <span>&#45;&gt;</span> Core_kernel__.Import.unit) <span>&#45;&gt;</span> Core_kernel__.Import.unit</code></dt><dd><p>Iterate two maps side by side. Complexity of this function is O(M+N). If two inputs are <code>(0, a); (1, a)</code> and <code>(1, b); (2, b)</code>, <code>f</code> will be called with <code>(0, `Left a); (1,
    `Both (a, b)); (2, `Right b)</code></p></dd></dl><dl><dt class="spec value" id="val-map"><a href="#val-map" class="anchor"></a><code><span class="keyword">val </span>map : (<span class="type-var">'k</span>, <span class="type-var">'v1</span>, <span class="type-var">'cmp</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> f:(<span class="type-var">'v1</span> <span>&#45;&gt;</span> <span class="type-var">'v2</span>) <span>&#45;&gt;</span> (<span class="type-var">'k</span>, <span class="type-var">'v2</span>, <span class="type-var">'cmp</span>) <a href="index.html#type-t">t</a></code></dt><dd><p>returns new map with bound values replaced by f applied to the bound values</p></dd></dl><dl><dt class="spec value" id="val-mapi"><a href="#val-mapi" class="anchor"></a><code><span class="keyword">val </span>mapi : (<span class="type-var">'k</span>, <span class="type-var">'v1</span>, <span class="type-var">'cmp</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> f:(key:<span class="type-var">'k</span> <span>&#45;&gt;</span> data:<span class="type-var">'v1</span> <span>&#45;&gt;</span> <span class="type-var">'v2</span>) <span>&#45;&gt;</span> (<span class="type-var">'k</span>, <span class="type-var">'v2</span>, <span class="type-var">'cmp</span>) <a href="index.html#type-t">t</a></code></dt><dd><p>like <code>map</code>, but function takes both key and data as arguments</p></dd></dl><dl><dt class="spec value" id="val-fold"><a href="#val-fold" class="anchor"></a><code><span class="keyword">val </span>fold : (<span class="type-var">'k</span>, <span class="type-var">'v</span>, <span class="type-var">_</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> init:<span class="type-var">'a</span> <span>&#45;&gt;</span> f:(key:<span class="type-var">'k</span> <span>&#45;&gt;</span> data:<span class="type-var">'v</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p>folds over keys and data in map in increasing order of key.</p></dd></dl><dl><dt class="spec value" id="val-fold_right"><a href="#val-fold_right" class="anchor"></a><code><span class="keyword">val </span>fold_right : (<span class="type-var">'k</span>, <span class="type-var">'v</span>, <span class="type-var">_</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> init:<span class="type-var">'a</span> <span>&#45;&gt;</span> f:(key:<span class="type-var">'k</span> <span>&#45;&gt;</span> data:<span class="type-var">'v</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p>folds over keys and data in map in decreasing order of key.</p></dd></dl><dl><dt class="spec value" id="val-fold2"><a href="#val-fold2" class="anchor"></a><code><span class="keyword">val </span>fold2 : (<span class="type-var">'k</span>, <span class="type-var">'v1</span>, <span class="type-var">'cmp</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<span class="type-var">'k</span>, <span class="type-var">'v2</span>, <span class="type-var">'cmp</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> init:<span class="type-var">'a</span> <span>&#45;&gt;</span> f:(key:<span class="type-var">'k</span> <span>&#45;&gt;</span> data:[ `Left of <span class="type-var">'v1</span><span class="keyword"> | </span>`Right of <span class="type-var">'v2</span><span class="keyword"> | </span>`Both of <span class="type-var">'v1</span><span class="keyword"> * </span><span class="type-var">'v2</span> ] <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p>folds over two maps side by side, like <code>iter2</code>.</p></dd></dl><dl><dt class="spec value" id="val-filter_keys"><a href="#val-filter_keys" class="anchor"></a><code><span class="keyword">val </span>filter_keys : (<span class="type-var">'k</span>, <span class="type-var">'v</span>, <span class="type-var">'cmp</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> f:(<span class="type-var">'k</span> <span>&#45;&gt;</span> Core_kernel__.Import.bool) <span>&#45;&gt;</span> (<span class="type-var">'k</span>, <span class="type-var">'v</span>, <span class="type-var">'cmp</span>) <a href="index.html#type-t">t</a></code></dt><dd><p><code>filter</code>, <code>filteri</code>, <code>filter_keys</code>, <code>filter_map</code>, and <code>filter_mapi</code> run in O(n * lg n) time; they simply accumulate each key &amp; data retained by <code>f</code> into a new map using <code>add</code>.</p></dd></dl><dl><dt class="spec value" id="val-filter"><a href="#val-filter" class="anchor"></a><code><span class="keyword">val </span>filter : (<span class="type-var">'k</span>, <span class="type-var">'v</span>, <span class="type-var">'cmp</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> f:(<span class="type-var">'v</span> <span>&#45;&gt;</span> Core_kernel__.Import.bool) <span>&#45;&gt;</span> (<span class="type-var">'k</span>, <span class="type-var">'v</span>, <span class="type-var">'cmp</span>) <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-filteri"><a href="#val-filteri" class="anchor"></a><code><span class="keyword">val </span>filteri : (<span class="type-var">'k</span>, <span class="type-var">'v</span>, <span class="type-var">'cmp</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> f:(key:<span class="type-var">'k</span> <span>&#45;&gt;</span> data:<span class="type-var">'v</span> <span>&#45;&gt;</span> Core_kernel__.Import.bool) <span>&#45;&gt;</span> (<span class="type-var">'k</span>, <span class="type-var">'v</span>, <span class="type-var">'cmp</span>) <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-filter_map"><a href="#val-filter_map" class="anchor"></a><code><span class="keyword">val </span>filter_map : (<span class="type-var">'k</span>, <span class="type-var">'v1</span>, <span class="type-var">'cmp</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> f:(<span class="type-var">'v1</span> <span>&#45;&gt;</span> <span class="type-var">'v2</span> Core_kernel__.Import.option) <span>&#45;&gt;</span> (<span class="type-var">'k</span>, <span class="type-var">'v2</span>, <span class="type-var">'cmp</span>) <a href="index.html#type-t">t</a></code></dt><dd><p>returns new map with bound values filtered by f applied to the bound values</p></dd></dl><dl><dt class="spec value" id="val-filter_mapi"><a href="#val-filter_mapi" class="anchor"></a><code><span class="keyword">val </span>filter_mapi : (<span class="type-var">'k</span>, <span class="type-var">'v1</span>, <span class="type-var">'cmp</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> f:(key:<span class="type-var">'k</span> <span>&#45;&gt;</span> data:<span class="type-var">'v1</span> <span>&#45;&gt;</span> <span class="type-var">'v2</span> Core_kernel__.Import.option) <span>&#45;&gt;</span> (<span class="type-var">'k</span>, <span class="type-var">'v2</span>, <span class="type-var">'cmp</span>) <a href="index.html#type-t">t</a></code></dt><dd><p>like <code>filter_map</code>, but function takes both key and data as arguments</p></dd></dl><dl><dt class="spec value" id="val-partition_mapi"><a href="#val-partition_mapi" class="anchor"></a><code><span class="keyword">val </span>partition_mapi : (<span class="type-var">'k</span>, <span class="type-var">'v1</span>, <span class="type-var">'cmp</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> f:(key:<span class="type-var">'k</span> <span>&#45;&gt;</span> data:<span class="type-var">'v1</span> <span>&#45;&gt;</span> [ `Fst of <span class="type-var">'v2</span><span class="keyword"> | </span>`Snd of <span class="type-var">'v3</span> ]) <span>&#45;&gt;</span> (<span class="type-var">'k</span>, <span class="type-var">'v2</span>, <span class="type-var">'cmp</span>) <a href="index.html#type-t">t</a><span class="keyword"> * </span>(<span class="type-var">'k</span>, <span class="type-var">'v3</span>, <span class="type-var">'cmp</span>) <a href="index.html#type-t">t</a></code></dt><dd><p><code>partition_mapi t ~f</code> returns two new <code>t</code>s, with each key in <code>t</code> appearing in exactly one of the result maps depending on its mapping in <code>f</code>.</p></dd></dl><dl><dt class="spec value" id="val-partition_map"><a href="#val-partition_map" class="anchor"></a><code><span class="keyword">val </span>partition_map : (<span class="type-var">'k</span>, <span class="type-var">'v1</span>, <span class="type-var">'cmp</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> f:(<span class="type-var">'v1</span> <span>&#45;&gt;</span> [ `Fst of <span class="type-var">'v2</span><span class="keyword"> | </span>`Snd of <span class="type-var">'v3</span> ]) <span>&#45;&gt;</span> (<span class="type-var">'k</span>, <span class="type-var">'v2</span>, <span class="type-var">'cmp</span>) <a href="index.html#type-t">t</a><span class="keyword"> * </span>(<span class="type-var">'k</span>, <span class="type-var">'v3</span>, <span class="type-var">'cmp</span>) <a href="index.html#type-t">t</a></code></dt><dd><p><code>partition_map t ~f = partition_mapi t ~f:(fun ~key:_ ~data -&gt; f data)</code></p></dd></dl><dl><dt class="spec value" id="val-partitioni_tf"><a href="#val-partitioni_tf" class="anchor"></a><code><span class="keyword">val </span>partitioni_tf : (<span class="type-var">'k</span>, <span class="type-var">'v</span>, <span class="type-var">'cmp</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> f:(key:<span class="type-var">'k</span> <span>&#45;&gt;</span> data:<span class="type-var">'v</span> <span>&#45;&gt;</span> Core_kernel__.Import.bool) <span>&#45;&gt;</span> (<span class="type-var">'k</span>, <span class="type-var">'v</span>, <span class="type-var">'cmp</span>) <a href="index.html#type-t">t</a><span class="keyword"> * </span>(<span class="type-var">'k</span>, <span class="type-var">'v</span>, <span class="type-var">'cmp</span>) <a href="index.html#type-t">t</a></code></dt><dd><pre><code class="ml">partitioni_tf t ~f
=
partition_mapi t ~f:(fun ~key ~data -&gt;
  if f ~key ~data
  then `Fst data
  else `Snd data)</code></pre></dd></dl><dl><dt class="spec value" id="val-partition_tf"><a href="#val-partition_tf" class="anchor"></a><code><span class="keyword">val </span>partition_tf : (<span class="type-var">'k</span>, <span class="type-var">'v</span>, <span class="type-var">'cmp</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> f:(<span class="type-var">'v</span> <span>&#45;&gt;</span> Core_kernel__.Import.bool) <span>&#45;&gt;</span> (<span class="type-var">'k</span>, <span class="type-var">'v</span>, <span class="type-var">'cmp</span>) <a href="index.html#type-t">t</a><span class="keyword"> * </span>(<span class="type-var">'k</span>, <span class="type-var">'v</span>, <span class="type-var">'cmp</span>) <a href="index.html#type-t">t</a></code></dt><dd><p><code>partition_tf t ~f = partitioni_tf t ~f:(fun ~key:_ ~data -&gt; f data)</code></p></dd></dl><dl><dt class="spec value" id="val-compare_direct"><a href="#val-compare_direct" class="anchor"></a><code><span class="keyword">val </span>compare_direct : (<span class="type-var">'v</span> <span>&#45;&gt;</span> <span class="type-var">'v</span> <span>&#45;&gt;</span> Core_kernel__.Import.int) <span>&#45;&gt;</span> (<span class="type-var">'k</span>, <span class="type-var">'v</span>, <span class="type-var">'cmp</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<span class="type-var">'k</span>, <span class="type-var">'v</span>, <span class="type-var">'cmp</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> Core_kernel__.Import.int</code></dt><dd><p>Total ordering between maps. The first argument is a total ordering used to compare data associated with equal keys in the two maps.</p></dd></dl><dl><dt class="spec value" id="val-hash_fold_direct"><a href="#val-hash_fold_direct" class="anchor"></a><code><span class="keyword">val </span>hash_fold_direct : <span class="type-var">'k</span> Core_kernel__.Import.Hash.folder <span>&#45;&gt;</span> <span class="type-var">'v</span> Core_kernel__.Import.Hash.folder <span>&#45;&gt;</span> (<span class="type-var">'k</span>, <span class="type-var">'v</span>, <span class="type-var">'cmp</span>) <a href="index.html#type-t">t</a> Core_kernel__.Import.Hash.folder</code></dt><dd><p>Hash function: a building block to use when hashing data structures containing maps in them. <code>hash_fold_direct hash_fold_key</code> is compatible with <code>compare_direct</code> iff <code>hash_fold_key</code> is compatible with <code>(comparator m).compare</code> of the map <code>m</code> being hashed.</p></dd></dl><dl><dt class="spec value" id="val-equal"><a href="#val-equal" class="anchor"></a><code><span class="keyword">val </span>equal : (<span class="type-var">'v</span> <span>&#45;&gt;</span> <span class="type-var">'v</span> <span>&#45;&gt;</span> Core_kernel__.Import.bool) <span>&#45;&gt;</span> (<span class="type-var">'k</span>, <span class="type-var">'v</span>, <span class="type-var">'cmp</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<span class="type-var">'k</span>, <span class="type-var">'v</span>, <span class="type-var">'cmp</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> Core_kernel__.Import.bool</code></dt><dd><p><code>equal cmp m1 m2</code> tests whether the maps <code>m1</code> and <code>m2</code> are equal, that is, contain equal keys and associate them with equal data. <code>cmp</code> is the equality predicate used to compare the data associated with the keys.</p></dd></dl><dl><dt class="spec value" id="val-keys"><a href="#val-keys" class="anchor"></a><code><span class="keyword">val </span>keys : (<span class="type-var">'k</span>, <span class="type-var">_</span>, <span class="type-var">_</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'k</span> Core_kernel__.Import.list</code></dt><dd><p>returns list of keys in map</p></dd></dl><dl><dt class="spec value" id="val-data"><a href="#val-data" class="anchor"></a><code><span class="keyword">val </span>data : (<span class="type-var">_</span>, <span class="type-var">'v</span>, <span class="type-var">_</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'v</span> Core_kernel__.Import.list</code></dt><dd><p>returns list of data in map</p></dd></dl><dl><dt class="spec value" id="val-to_alist"><a href="#val-to_alist" class="anchor"></a><code><span class="keyword">val </span>to_alist : ?&#8288;key_order:[ `Increasing<span class="keyword"> | </span>`Decreasing ] <span>&#45;&gt;</span> (<span class="type-var">'k</span>, <span class="type-var">'v</span>, <span class="type-var">_</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<span class="type-var">'k</span><span class="keyword"> * </span><span class="type-var">'v</span>) Core_kernel__.Import.list</code></dt><dd><p>creates association list from map.</p></dd></dl><dl><dt class="spec value" id="val-validate"><a href="#val-validate" class="anchor"></a><code><span class="keyword">val </span>validate : name:(<span class="type-var">'k</span> <span>&#45;&gt;</span> Core_kernel__.Import.string) <span>&#45;&gt;</span> <span class="type-var">'v</span> Core_kernel__.Import.Validate.check <span>&#45;&gt;</span> (<span class="type-var">'k</span>, <span class="type-var">'v</span>, <span class="type-var">_</span>) <a href="index.html#type-t">t</a> Core_kernel__.Import.Validate.check</code></dt></dl><section><header><h6 id="additional-operations-on-maps"><a href="#additional-operations-on-maps" class="anchor"></a>Additional operations on maps</h6></header><dl><dt class="spec value" id="val-merge"><a href="#val-merge" class="anchor"></a><code><span class="keyword">val </span>merge : (<span class="type-var">'k</span>, <span class="type-var">'v1</span>, <span class="type-var">'cmp</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<span class="type-var">'k</span>, <span class="type-var">'v2</span>, <span class="type-var">'cmp</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> f:(key:<span class="type-var">'k</span> <span>&#45;&gt;</span> [ `Left of <span class="type-var">'v1</span><span class="keyword"> | </span>`Right of <span class="type-var">'v2</span><span class="keyword"> | </span>`Both of <span class="type-var">'v1</span><span class="keyword"> * </span><span class="type-var">'v2</span> ] <span>&#45;&gt;</span> <span class="type-var">'v3</span> Core_kernel__.Import.option) <span>&#45;&gt;</span> (<span class="type-var">'k</span>, <span class="type-var">'v3</span>, <span class="type-var">'cmp</span>) <a href="index.html#type-t">t</a></code></dt><dd><p>merges two maps</p></dd></dl><div class="spec module" id="module-Symmetric_diff_element"><a href="#module-Symmetric_diff_element" class="anchor"></a><code><span class="keyword">module </span><a href="Symmetric_diff_element/index.html">Symmetric_diff_element</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><dl><dt class="spec value" id="val-symmetric_diff"><a href="#val-symmetric_diff" class="anchor"></a><code><span class="keyword">val </span>symmetric_diff : (<span class="type-var">'k</span>, <span class="type-var">'v</span>, <span class="type-var">'cmp</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<span class="type-var">'k</span>, <span class="type-var">'v</span>, <span class="type-var">'cmp</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> data_equal:(<span class="type-var">'v</span> <span>&#45;&gt;</span> <span class="type-var">'v</span> <span>&#45;&gt;</span> Core_kernel__.Import.bool) <span>&#45;&gt;</span> (<span class="type-var">'k</span>, <span class="type-var">'v</span>) <a href="Symmetric_diff_element/index.html#type-t">Symmetric_diff_element.t</a> Core_kernel__.Sequence.t</code></dt><dd><p><code>symmetric_diff t1 t2 ~data_equal</code> returns a list of changes between <code>t1</code> and <code>t2</code>. It is intended to be efficient in the case where <code>t1</code> and <code>t2</code> share a large amount of structure. The keys in the output sequence will be in sorted order.</p></dd></dl><dl><dt class="spec value" id="val-min_elt"><a href="#val-min_elt" class="anchor"></a><code><span class="keyword">val </span>min_elt : (<span class="type-var">'k</span>, <span class="type-var">'v</span>, <span class="type-var">_</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<span class="type-var">'k</span><span class="keyword"> * </span><span class="type-var">'v</span>) Core_kernel__.Import.option</code></dt><dd><p><code>min_elt map</code> </p><dl><dt>returns</dt><dd><p>Some <code>(key, data)</code> pair corresponding to the minimum key in <code>map</code>, None if empty.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-min_elt_exn"><a href="#val-min_elt_exn" class="anchor"></a><code><span class="keyword">val </span>min_elt_exn : (<span class="type-var">'k</span>, <span class="type-var">'v</span>, <span class="type-var">_</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'k</span><span class="keyword"> * </span><span class="type-var">'v</span></code></dt><dt class="spec value" id="val-max_elt"><a href="#val-max_elt" class="anchor"></a><code><span class="keyword">val </span>max_elt : (<span class="type-var">'k</span>, <span class="type-var">'v</span>, <span class="type-var">_</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<span class="type-var">'k</span><span class="keyword"> * </span><span class="type-var">'v</span>) Core_kernel__.Import.option</code></dt><dd><p><code>max_elt map</code> </p><dl><dt>returns</dt><dd><p>Some <code>(key, data)</code> pair corresponding to the maximum key in <code>map</code>, and None if <code>map</code> is empty.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-max_elt_exn"><a href="#val-max_elt_exn" class="anchor"></a><code><span class="keyword">val </span>max_elt_exn : (<span class="type-var">'k</span>, <span class="type-var">'v</span>, <span class="type-var">_</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'k</span><span class="keyword"> * </span><span class="type-var">'v</span></code></dt><dt class="spec value" id="val-for_all"><a href="#val-for_all" class="anchor"></a><code><span class="keyword">val </span>for_all : (<span class="type-var">'k</span>, <span class="type-var">'v</span>, <span class="type-var">_</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> f:(<span class="type-var">'v</span> <span>&#45;&gt;</span> Core_kernel__.Import.bool) <span>&#45;&gt;</span> Core_kernel__.Import.bool</code></dt><dd><p>same semantics as similar functions in List</p></dd></dl><dl><dt class="spec value" id="val-for_alli"><a href="#val-for_alli" class="anchor"></a><code><span class="keyword">val </span>for_alli : (<span class="type-var">'k</span>, <span class="type-var">'v</span>, <span class="type-var">_</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> f:(key:<span class="type-var">'k</span> <span>&#45;&gt;</span> data:<span class="type-var">'v</span> <span>&#45;&gt;</span> Core_kernel__.Import.bool) <span>&#45;&gt;</span> Core_kernel__.Import.bool</code></dt><dt class="spec value" id="val-exists"><a href="#val-exists" class="anchor"></a><code><span class="keyword">val </span>exists : (<span class="type-var">'k</span>, <span class="type-var">'v</span>, <span class="type-var">_</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> f:(<span class="type-var">'v</span> <span>&#45;&gt;</span> Core_kernel__.Import.bool) <span>&#45;&gt;</span> Core_kernel__.Import.bool</code></dt><dt class="spec value" id="val-existsi"><a href="#val-existsi" class="anchor"></a><code><span class="keyword">val </span>existsi : (<span class="type-var">'k</span>, <span class="type-var">'v</span>, <span class="type-var">_</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> f:(key:<span class="type-var">'k</span> <span>&#45;&gt;</span> data:<span class="type-var">'v</span> <span>&#45;&gt;</span> Core_kernel__.Import.bool) <span>&#45;&gt;</span> Core_kernel__.Import.bool</code></dt><dt class="spec value" id="val-count"><a href="#val-count" class="anchor"></a><code><span class="keyword">val </span>count : (<span class="type-var">'k</span>, <span class="type-var">'v</span>, <span class="type-var">_</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> f:(<span class="type-var">'v</span> <span>&#45;&gt;</span> Core_kernel__.Import.bool) <span>&#45;&gt;</span> Core_kernel__.Import.int</code></dt><dt class="spec value" id="val-counti"><a href="#val-counti" class="anchor"></a><code><span class="keyword">val </span>counti : (<span class="type-var">'k</span>, <span class="type-var">'v</span>, <span class="type-var">_</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> f:(key:<span class="type-var">'k</span> <span>&#45;&gt;</span> data:<span class="type-var">'v</span> <span>&#45;&gt;</span> Core_kernel__.Import.bool) <span>&#45;&gt;</span> Core_kernel__.Import.int</code></dt><dt class="spec value" id="val-split"><a href="#val-split" class="anchor"></a><code><span class="keyword">val </span>split : (<span class="type-var">'k</span>, <span class="type-var">'v</span>, <span class="type-var">'cmp</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'k</span> <span>&#45;&gt;</span> (<span class="type-var">'k</span>, <span class="type-var">'v</span>, <span class="type-var">'cmp</span>) <a href="index.html#type-t">t</a><span class="keyword"> * </span>(<span class="type-var">'k</span><span class="keyword"> * </span><span class="type-var">'v</span>) Core_kernel__.Import.option<span class="keyword"> * </span>(<span class="type-var">'k</span>, <span class="type-var">'v</span>, <span class="type-var">'cmp</span>) <a href="index.html#type-t">t</a></code></dt><dd><p><code>split t key</code> returns a map of keys strictly less than <code>key</code>, the mapping of <code>key</code> if any, and a map of keys strictly greater than <code>key</code>.</p><p>Runtime is O(m + log n) where n is the size of the input map, and m is the size of the smaller of the two output maps. The O(m) term is due to the need to calculate the length of the output maps. *</p></dd></dl><dl><dt class="spec value" id="val-append"><a href="#val-append" class="anchor"></a><code><span class="keyword">val </span>append : lower_part:(<span class="type-var">'k</span>, <span class="type-var">'v</span>, <span class="type-var">'cmp</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> upper_part:(<span class="type-var">'k</span>, <span class="type-var">'v</span>, <span class="type-var">'cmp</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> [ `Ok of (<span class="type-var">'k</span>, <span class="type-var">'v</span>, <span class="type-var">'cmp</span>) <a href="index.html#type-t">t</a><span class="keyword"> | </span>`Overlapping_key_ranges ]</code></dt><dd><p><code>append ~lower_part ~upper_part</code> returns <code>`Ok map</code> where map contains all the <code>(key,
    value)</code> pairs from the two input maps if all the keys from <code>lower_part</code> are less than all the keys from <code>upper_part</code>. Otherwise it returns <code>`Overlapping_key_ranges</code>.</p><p>Runtime is O(log n) where n is the size of the larger input map. This can be significantly faster than <code>Map.merge</code> or repeated <code>Map.add</code>.</p><pre><code class="ml">assert (match Map.append ~lower_part ~upper_part with
  | `Ok whole_map -&gt;
    whole_map
    = Map.(of_alist_exn (List.append (to_alist lower_part) (to_alist upper_part)))
  | `Overlapping_key_ranges -&gt; true);</code></pre></dd></dl><dl><dt class="spec value" id="val-subrange"><a href="#val-subrange" class="anchor"></a><code><span class="keyword">val </span>subrange : (<span class="type-var">'k</span>, <span class="type-var">'v</span>, <span class="type-var">'cmp</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> lower_bound:<span class="type-var">'k</span> Core_kernel__.Maybe_bound.t <span>&#45;&gt;</span> upper_bound:<span class="type-var">'k</span> Core_kernel__.Maybe_bound.t <span>&#45;&gt;</span> (<span class="type-var">'k</span>, <span class="type-var">'v</span>, <span class="type-var">'cmp</span>) <a href="index.html#type-t">t</a></code></dt><dd><p><code>subrange t ~lower_bound ~upper_bound</code> returns a map containing all the entries from <code>t</code> whose keys lie inside the interval indicated by <code>~lower_bound</code> and <code>~upper_bound</code>. If this interval is empty, an empty map is returned.</p><p>Runtime is O(m + log n) where n is the size of the input map, and m is the size of the output map. The O(m) term is due to the need to calculate the length of the output map.</p></dd></dl><dl><dt class="spec value" id="val-fold_range_inclusive"><a href="#val-fold_range_inclusive" class="anchor"></a><code><span class="keyword">val </span>fold_range_inclusive : (<span class="type-var">'k</span>, <span class="type-var">'v</span>, <span class="type-var">'cmp</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> min:<span class="type-var">'k</span> <span>&#45;&gt;</span> max:<span class="type-var">'k</span> <span>&#45;&gt;</span> init:<span class="type-var">'a</span> <span>&#45;&gt;</span> f:(key:<span class="type-var">'k</span> <span>&#45;&gt;</span> data:<span class="type-var">'v</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p><code>fold_range_inclusive t ~min ~max ~init ~f</code> folds f (with initial value ~init) over all keys (and their associated values) that are in the range <code>min, max</code> (inclusive).</p></dd></dl><dl><dt class="spec value" id="val-range_to_alist"><a href="#val-range_to_alist" class="anchor"></a><code><span class="keyword">val </span>range_to_alist : (<span class="type-var">'k</span>, <span class="type-var">'v</span>, <span class="type-var">'cmp</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> min:<span class="type-var">'k</span> <span>&#45;&gt;</span> max:<span class="type-var">'k</span> <span>&#45;&gt;</span> (<span class="type-var">'k</span><span class="keyword"> * </span><span class="type-var">'v</span>) Core_kernel__.Import.list</code></dt><dd><p><code>range_to_alist t ~min ~max</code> returns an associative list of the elements whose keys lie in <code>min, max</code> (inclusive), with the smallest key being at the head of the list.</p></dd></dl><dl><dt class="spec value" id="val-closest_key"><a href="#val-closest_key" class="anchor"></a><code><span class="keyword">val </span>closest_key : (<span class="type-var">'k</span>, <span class="type-var">'v</span>, <span class="type-var">'cmp</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> [ `Greater_or_equal_to<span class="keyword"> | </span>`Greater_than<span class="keyword"> | </span>`Less_or_equal_to<span class="keyword"> | </span>`Less_than ] <span>&#45;&gt;</span> <span class="type-var">'k</span> <span>&#45;&gt;</span> (<span class="type-var">'k</span><span class="keyword"> * </span><span class="type-var">'v</span>) Core_kernel__.Import.option</code></dt><dd><p><code>closest_key t dir k</code> returns the <code>(key, value)</code> pair in <code>t</code> with <code>key</code> closest to <code>k</code>, which satisfies the given inequality bound.</p><p>For example, <code>closest_key t `Less_than k</code> would be the pair with the closest key to <code>k</code> where <code>key &lt; k</code>.</p><p><code>to_sequence</code> can be used to get the same results as <code>closest_key</code>. It is less efficient for individual lookups but more efficient for finding many elements starting at some value.</p></dd></dl><dl><dt class="spec value" id="val-nth"><a href="#val-nth" class="anchor"></a><code><span class="keyword">val </span>nth : (<span class="type-var">'k</span>, <span class="type-var">'v</span>, <span class="type-var">_</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> Core_kernel__.Import.int <span>&#45;&gt;</span> (<span class="type-var">'k</span><span class="keyword"> * </span><span class="type-var">'v</span>) Core_kernel__.Import.option</code></dt><dd><p><code>nth t n</code> finds the (key, value) pair of rank n (i.e. such that there are exactly n keys strictly less than the found key), if one exists. O(log(length t) + n) time.</p></dd></dl><dl><dt class="spec value" id="val-nth_exn"><a href="#val-nth_exn" class="anchor"></a><code><span class="keyword">val </span>nth_exn : (<span class="type-var">'k</span>, <span class="type-var">'v</span>, <span class="type-var">_</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> Core_kernel__.Import.int <span>&#45;&gt;</span> <span class="type-var">'k</span><span class="keyword"> * </span><span class="type-var">'v</span></code></dt><dt class="spec value" id="val-rank"><a href="#val-rank" class="anchor"></a><code><span class="keyword">val </span>rank : (<span class="type-var">'k</span>, <span class="type-var">'v</span>, <span class="type-var">'cmp</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'k</span> <span>&#45;&gt;</span> Core_kernel__.Import.int Core_kernel__.Import.option</code></dt><dd><p><code>rank t k</code> if k is in t, returns the number of keys strictly less than k in t, otherwise None</p></dd></dl><dl><dt class="spec value" id="val-to_sequence"><a href="#val-to_sequence" class="anchor"></a><code><span class="keyword">val </span>to_sequence : ?&#8288;order:[ `Increasing_key<span class="keyword"> | </span>`Decreasing_key ] <span>&#45;&gt;</span> ?&#8288;keys_greater_or_equal_to:<span class="type-var">'k</span> <span>&#45;&gt;</span> ?&#8288;keys_less_or_equal_to:<span class="type-var">'k</span> <span>&#45;&gt;</span> (<span class="type-var">'k</span>, <span class="type-var">'v</span>, <span class="type-var">'cmp</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<span class="type-var">'k</span><span class="keyword"> * </span><span class="type-var">'v</span>) Core_kernel__.Sequence.t</code></dt><dd><p><code>to_sequence ?order ?keys_greater_or_equal_to ?keys_less_or_equal_to t</code> gives a sequence of key-value pairs between <code>keys_less_or_equal_to</code> and <code>keys_greater_or_equal_to</code> inclusive, presented in <code>order</code>. If <code>keys_greater_or_equal_to &gt; keys_less_or_equal_to</code>, the sequence is empty. Cost is O(log n) up front and amortized O(1) to produce each element.</p></dd></dl><dl><dt class="spec value" id="val-gen"><a href="#val-gen" class="anchor"></a><code><span class="keyword">val </span>gen : comparator:(<span class="type-var">'k</span>, <span class="type-var">'cmp</span>) Core_kernel__.Comparator.t <span>&#45;&gt;</span> <span class="type-var">'k</span> Core_kernel__.Quickcheck.Generator.t <span>&#45;&gt;</span> <span class="type-var">'v</span> Core_kernel__.Quickcheck.Generator.t <span>&#45;&gt;</span> (<span class="type-var">'k</span>, <span class="type-var">'v</span>, <span class="type-var">'cmp</span>) <a href="index.html#type-t">t</a> Core_kernel__.Quickcheck.Generator.t</code></dt><dt class="spec value" id="val-obs"><a href="#val-obs" class="anchor"></a><code><span class="keyword">val </span>obs : <span class="type-var">'k</span> Core_kernel__.Quickcheck.Observer.t <span>&#45;&gt;</span> <span class="type-var">'v</span> Core_kernel__.Quickcheck.Observer.t <span>&#45;&gt;</span> (<span class="type-var">'k</span>, <span class="type-var">'v</span>, <span class="type-var">'cmp</span>) <a href="index.html#type-t">t</a> Core_kernel__.Quickcheck.Observer.t</code></dt><dt class="spec value" id="val-shrinker"><a href="#val-shrinker" class="anchor"></a><code><span class="keyword">val </span>shrinker : <span class="type-var">'k</span> Core_kernel__.Quickcheck.Shrinker.t <span>&#45;&gt;</span> <span class="type-var">'v</span> Core_kernel__.Quickcheck.Shrinker.t <span>&#45;&gt;</span> (<span class="type-var">'k</span>, <span class="type-var">'v</span>, <span class="type-var">'cmp</span>) <a href="index.html#type-t">t</a> Core_kernel__.Quickcheck.Shrinker.t</code></dt><dd><p>This shrinker and the other shrinkers for maps and trees produce a shrunk value by dropping a key-value pair, shrinking a key or shrinking a value. A shrunk key will override an existing key's value.</p></dd></dl><div class="spec module" id="module-Poly"><a href="#module-Poly" class="anchor"></a><code><span class="keyword">module </span><a href="Poly/index.html">Poly</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span><span class="keyword"> with </span><span class="keyword">type </span>('a, 'b, 'c) <a href="Poly/index.html#type-map">map</a><span class="keyword"> = </span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>, <span class="type-var">'c</span>) <a href="index.html#type-t">t</a></code></div><div class="spec module-type" id="module-type-Key_plain"><a href="#module-type-Key_plain" class="anchor"></a><code><span class="keyword">module type </span>Key_plain = Core_kernel__.Core_map_intf.Key_plain</code></div><div class="spec module-type" id="module-type-Key"><a href="#module-type-Key" class="anchor"></a><code><span class="keyword">module type </span>Key = Core_kernel__.Core_map_intf.Key</code></div><div class="spec module-type" id="module-type-Key_binable"><a href="#module-type-Key_binable" class="anchor"></a><code><span class="keyword">module type </span>Key_binable = Core_kernel__.Core_map_intf.Key_binable</code></div><div class="spec module-type" id="module-type-S_plain"><a href="#module-type-S_plain" class="anchor"></a><code><span class="keyword">module type </span>S_plain = Core_kernel__.Core_map_intf.S_plain</code></div><div class="spec module-type" id="module-type-S"><a href="#module-type-S" class="anchor"></a><code><span class="keyword">module type </span>S = Core_kernel__.Core_map_intf.S</code></div><div class="spec module-type" id="module-type-S_binable"><a href="#module-type-S_binable" class="anchor"></a><code><span class="keyword">module type </span>S_binable = Core_kernel__.Core_map_intf.S_binable</code></div><div class="spec module" id="module-Make_plain"><a href="#module-Make_plain" class="anchor"></a><code><span class="keyword">module </span>Make_plain : <span class="keyword">functor</span> (<a href="Make_plain/index.html#argument-1-Key">Key</a> : <a href="index.html#module-type-Key_plain">Key_plain</a>) <span>&#45;&gt;</span> <a href="index.html#module-type-S_plain">S_plain</a><span class="keyword"> with </span><span class="keyword">type </span><a href="index.html#module-Make_plain">Make_plain</a>.Key.t<span class="keyword"> = </span><a href="Make_plain/index.html#argument-1-Key">Key</a>.t</code></div><div class="spec module" id="module-Make_plain_using_comparator"><a href="#module-Make_plain_using_comparator" class="anchor"></a><code><span class="keyword">module </span>Make_plain_using_comparator : <span class="keyword">functor</span> (<a href="Make_plain_using_comparator/argument-1-Key/index.html">Key</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span>) <span>&#45;&gt;</span> <a href="index.html#module-type-S_plain">S_plain</a><span class="keyword"> with </span><span class="keyword">type </span><a href="index.html#module-Make_plain_using_comparator">Make_plain_using_comparator</a>.Key.t<span class="keyword"> = </span><a href="Make_plain_using_comparator/argument-1-Key/index.html#type-t">Key.t</a><span class="keyword"> with </span><span class="keyword">type </span><a href="index.html#module-Make_plain_using_comparator">Make_plain_using_comparator</a>.Key.comparator_witness<span class="keyword"> = </span><a href="Make_plain_using_comparator/index.html#argument-1-Key">Key</a>.comparator_witness</code></div><div class="spec module" id="module-Make"><a href="#module-Make" class="anchor"></a><code><span class="keyword">module </span>Make : <span class="keyword">functor</span> (<a href="Make/index.html#argument-1-Key">Key</a> : <a href="index.html#module-type-Key">Key</a>) <span>&#45;&gt;</span> <a href="index.html#module-type-S">S</a><span class="keyword"> with </span><span class="keyword">type </span><a href="index.html#module-Make">Make</a>.Key.t<span class="keyword"> = </span><a href="Make/index.html#argument-1-Key">Key</a>.t</code></div><div class="spec module" id="module-Make_using_comparator"><a href="#module-Make_using_comparator" class="anchor"></a><code><span class="keyword">module </span>Make_using_comparator : <span class="keyword">functor</span> (<a href="Make_using_comparator/argument-1-Key/index.html">Key</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span>) <span>&#45;&gt;</span> <a href="index.html#module-type-S">S</a><span class="keyword"> with </span><span class="keyword">type </span><a href="index.html#module-Make_using_comparator">Make_using_comparator</a>.Key.t<span class="keyword"> = </span><a href="Make_using_comparator/argument-1-Key/index.html#type-t">Key.t</a><span class="keyword"> with </span><span class="keyword">type </span><a href="index.html#module-Make_using_comparator">Make_using_comparator</a>.Key.comparator_witness<span class="keyword"> = </span><a href="Make_using_comparator/index.html#argument-1-Key">Key</a>.comparator_witness</code></div><div class="spec module" id="module-Make_binable"><a href="#module-Make_binable" class="anchor"></a><code><span class="keyword">module </span>Make_binable : <span class="keyword">functor</span> (<a href="Make_binable/index.html#argument-1-Key">Key</a> : <a href="index.html#module-type-Key_binable">Key_binable</a>) <span>&#45;&gt;</span> <a href="index.html#module-type-S_binable">S_binable</a><span class="keyword"> with </span><span class="keyword">type </span><a href="index.html#module-Make_binable">Make_binable</a>.Key.t<span class="keyword"> = </span><a href="Make_binable/index.html#argument-1-Key">Key</a>.t</code></div><div class="spec module" id="module-Make_binable_using_comparator"><a href="#module-Make_binable_using_comparator" class="anchor"></a><code><span class="keyword">module </span>Make_binable_using_comparator : <span class="keyword">functor</span> (<a href="Make_binable_using_comparator/argument-1-Key/index.html">Key</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span>) <span>&#45;&gt;</span> <a href="index.html#module-type-S_binable">S_binable</a><span class="keyword"> with </span><span class="keyword">type </span><a href="index.html#module-Make_binable_using_comparator">Make_binable_using_comparator</a>.Key.t<span class="keyword"> = </span><a href="Make_binable_using_comparator/argument-1-Key/index.html#type-t">Key.t</a><span class="keyword"> with </span><span class="keyword">type </span><a href="index.html#module-Make_binable_using_comparator">Make_binable_using_comparator</a>.Key.comparator_witness<span class="keyword"> = </span><a href="Make_binable_using_comparator/index.html#argument-1-Key">Key</a>.comparator_witness</code></div><dl><dt class="spec module" id="module-Stable"><a href="#module-Stable" class="anchor"></a><code><span class="keyword">module </span><a href="Stable/index.html">Stable</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>The following functors may be used to define stable modules</p></dd></dl></section></div></body></html>