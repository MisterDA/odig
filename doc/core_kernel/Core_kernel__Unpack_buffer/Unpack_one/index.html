<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Unpack_one (core_kernel.Core_kernel__Unpack_buffer.Unpack_one)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../../index.html">core_kernel</a> &#x00BB; <a href="../index.html">Core_kernel__Unpack_buffer</a> &#x00BB; Unpack_one</nav><h1>Module <code>Core_kernel__Unpack_buffer.Unpack_one</code></h1></header><aside><p>If <code>unpack_one : ('a, 'partial_unpack) unpack_one</code>, then <code>unpack_one buf ?pos
      ?len ?partial_unpack</code> must unpack at most one value of type <code>'a</code> from <code>buf</code> starting at <code>pos</code>, and not using more than <code>len</code> characters. <code>unpack_one</code> must returns one the following:</p><ul><li><code>`Ok (value, n)</code> -- unpacking succeeded and consumed <code>n</code> bytes, where <code>0 &lt;= n &lt;=
      len</code>. It is possible to have <code>n = 0</code>, e.g. for sexp unpacking, which can only tell it has reached the end of an atom when it encounters the following punctuation character, which if it is left paren, is the start of the following sexp.</li></ul><ul><li><code>`Not_enough_data (p, n)</code> -- unpacking encountered a valid proper prefix of a packed value, and consumed <code>n</code> bytes, where <code>0 &lt;= n &lt;= len</code>. <code>p</code> is a &quot;partial unpack&quot; that can be supplied to a future call to <code>unpack_one</code> to continue unpacking.</li></ul><ul><li><code>`Invalid_data</code> -- unpacking encountered an invalidly packed value.</li></ul><p>A naive <code>unpack_one</code> that only succeeds on a fully packed value could lead to quadratic behavior if a packed value's bytes are input using a linear number of calls to <code>feed</code>.</p></aside><dl><dt class="spec type" id="type-unpacked"><a href="#type-unpacked" class="anchor"></a><code><span class="keyword">type </span>('a, 'partial_unpack) unpacked</code><code><span class="keyword"> = </span>?&#8288;partial_unpack:<span class="type-var">'partial_unpack</span> <span>&#45;&gt;</span> ?&#8288;pos:Core_kernel__.Import.int <span>&#45;&gt;</span> ?&#8288;len:Core_kernel__.Import.int <span>&#45;&gt;</span> Core_kernel__.Bigstring.t <span>&#45;&gt;</span> [ `Ok of <span class="type-var">'a</span><span class="keyword"> * </span>Core_kernel__.Import.int<span class="keyword"> | </span>`Not_enough_data of <span class="type-var">'partial_unpack</span><span class="keyword"> * </span>Core_kernel__.Import.int<span class="keyword"> | </span>`Invalid_data of Core_kernel__.Error.t ]</code></dt><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type </span>'a t</code><code><span class="keyword"> = </span></code><table class="variant"><tr id="type-t.T" class="anchored"><td class="def constructor"><a href="#type-t.T" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">T</span><span class="keyword"> : </span>(<span class="type-var">'a</span>, <span class="type-var">_</span>) <a href="index.html#type-unpacked">unpacked</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></td></tr></table></dt></dl><div><div class="spec include"><div class="doc"><details open="open"><summary><span class="def"><code><span class="keyword">include </span>Core_kernel__.Import.Monad.S<span class="keyword"> with </span><span class="keyword">type </span>'a <a href="../index.html#module-Unpack_one">Unpack_one</a>.t := <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></span></summary><dl><dt class="spec value" id="val-(&gt;&gt;=)"><a href="#val-(&gt;&gt;=)" class="anchor"></a><code><span class="keyword">val </span>(&gt;&gt;=) : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a>) <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-(&gt;&gt;|)"><a href="#val-(&gt;&gt;|)" class="anchor"></a><code><span class="keyword">val </span>(&gt;&gt;|) : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>) <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a></code></dt></dl><div class="spec module" id="module-Monad_infix"><a href="#module-Monad_infix" class="anchor"></a><code><span class="keyword">module </span><a href="Monad_infix/index.html">Monad_infix</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><dl><dt class="spec value" id="val-bind"><a href="#val-bind" class="anchor"></a><code><span class="keyword">val </span>bind : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> f:(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a>) <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-return"><a href="#val-return" class="anchor"></a><code><span class="keyword">val </span>return : <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-map"><a href="#val-map" class="anchor"></a><code><span class="keyword">val </span>map : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> f:(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>) <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-join"><a href="#val-join" class="anchor"></a><code><span class="keyword">val </span>join : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-ignore_m"><a href="#val-ignore_m" class="anchor"></a><code><span class="keyword">val </span>ignore_m : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-all"><a href="#val-all" class="anchor"></a><code><span class="keyword">val </span>all : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> list <span>&#45;&gt;</span> <span class="type-var">'a</span> list <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-all_ignore"><a href="#val-all_ignore" class="anchor"></a><code><span class="keyword">val </span>all_ignore : unit <a href="index.html#type-t">t</a> list <span>&#45;&gt;</span> unit <a href="index.html#type-t">t</a></code></dt></dl><div class="spec module" id="module-Let_syntax"><a href="#module-Let_syntax" class="anchor"></a><code><span class="keyword">module </span><a href="Let_syntax/index.html">Let_syntax</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div></details></div></div></div><dl><dt class="spec value" id="val-create_bin_prot"><a href="#val-create_bin_prot" class="anchor"></a><code><span class="keyword">val </span>create_bin_prot : <span class="type-var">'a</span> Bin_prot.Type_class.reader <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>create_bin_prot reader</code> returns an unpacker that reads the &quot;size-prefixed&quot; bin_prot encoding, in which a value is encoded by first writing the length of the bin_prot data as a 64-bit int, and then writing the data itself. This encoding makes it trivial to know if enough data is available in the buffer, so there is no need to represent partially unpacked values, and hence <code>'partial_unpack = unit</code>.</p></dd></dl><dl><dt class="spec value" id="val-sexp"><a href="#val-sexp" class="anchor"></a><code><span class="keyword">val </span>sexp : Core_kernel__.Std_internal.Sexp.t <a href="index.html#type-t">t</a></code></dt><dd><p>Beware that when unpacking sexps, one cannot tell if one is at the end of an atom until one hits punctuation. So, one should always feed a space (&quot; &quot;) to a sexp unpack buffer after feeding a batch of complete sexps, to ensure that the final sexp is unpacked.</p></dd></dl><dl><dt class="spec value" id="val-char"><a href="#val-char" class="anchor"></a><code><span class="keyword">val </span>char : Core_kernel__.Import.char <a href="index.html#type-t">t</a></code></dt></dl><div class="spec module-type" id="module-type-Equal"><a href="#module-type-Equal" class="anchor"></a><code><span class="keyword">module type </span><a href="module-type-Equal/index.html">Equal</a> = <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><dl><dt class="spec value" id="val-expect"><a href="#val-expect" class="anchor"></a><code><span class="keyword">val </span>expect : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<span class="keyword">module </span><a href="module-type-Equal/index.html">Equal</a> <span class="keyword">with</span> <span class="keyword">type </span><a href="module-type-Equal/index.html#type-t">t</a> <span class="keyword">=</span> <span class="type-var">'a</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> Core_kernel__.Import.unit <a href="index.html#type-t">t</a></code></dt><dd><p><code>expect t equal a</code> returns an unpacker that unpacks using <code>t</code> and then returns <code>`Ok</code> if the unpacked value equals <code>a</code>, or <code>`Invalid_data</code> otherwise.</p></dd></dl><dl><dt class="spec value" id="val-expect_char"><a href="#val-expect_char" class="anchor"></a><code><span class="keyword">val </span>expect_char : Core_kernel__.Import.char <span>&#45;&gt;</span> Core_kernel__.Import.unit <a href="index.html#type-t">t</a></code></dt><dd><p><code>expect_char</code> is <code>expect char (module Char)</code></p></dd></dl><dl><dt class="spec value" id="val-newline"><a href="#val-newline" class="anchor"></a><code><span class="keyword">val </span>newline : Core_kernel__.Import.unit <a href="index.html#type-t">t</a></code></dt></dl></div></body></html>