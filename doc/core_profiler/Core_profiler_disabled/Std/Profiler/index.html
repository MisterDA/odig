<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Profiler (core_profiler.Core_profiler_disabled.Std.Profiler)</title><link rel="stylesheet" href="../../../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../../../index.html">core_profiler</a> &#x00BB; <a href="../../index.html">Core_profiler_disabled</a> &#x00BB; <a href="../index.html">Std</a> &#x00BB; Profiler</nav><h1>Module <code>Std.Profiler</code></h1></header><dl><dt class="spec value" id="val-is_enabled"><a href="#val-is_enabled" class="anchor"></a><code><span class="keyword">val</span> is_enabled : bool</code></dt><dd><p><code>is_enabled</code> can be used to &quot;guard&quot; expensive computations done while recording a metric. For example:</p><pre><code class="ml">Probe.record len &lt;some computation&gt;</code></pre><p>If &lt;some computation&gt; is just a variable reference it is free (when using <code>Core_profiler_disabled</code>). However, if it involves some actual work, it is better to write:</p><pre><code class="ml">if Profiler.is_enabled then Probe.record len &lt;some computation&gt;</code></pre><p>When using online or offline profiling, the boolean is constant <code>true</code> and with disabled profiling, the boolean is <code>false</code>.</p></dd></dl><dl><dt class="spec value" id="val-configure"><a href="#val-configure" class="anchor"></a><code><span class="keyword">val</span> configure : ?&#8288;don't_require_core_profiler_env:unit <span>&#45;&gt;</span> ?&#8288;offline_profiler_data_file:string <span>&#45;&gt;</span> ?&#8288;online_print_time_interval_secs:int <span>&#45;&gt;</span> ?&#8288;online_print_by_default:bool <span>&#45;&gt;</span> unit <span>&#45;&gt;</span> unit</code></dt><dd><p><code>configure</code> lets one set various profiler parameters programmatically.</p><ul><li><code>don't_require_core_profiler_env</code> : To protect against Core_profiler being enabled in production, it will check the environment variable <code>CORE_PROFILER</code> whenever you try to create the first <code>Timer</code> or <code>Probe</code>. Setting <code>don't_require_core_profiler_env</code> disables raising an exception if the <code>CORE_PROFILER</code> environment variable is not set.</li></ul><p>You need to call this before any <code>Timer</code> or <code>Probe</code> has been created. If you set <code>don't_require_core_profiler_env</code> after a <code>Timer</code> or <code>Probe</code> has been created, then it will raise an exception if the value you are trying to set disagrees with that which was read from the environment.</p><ul><li><code>offline_profiler_data_file</code> : This specifies the name of the data file to use. By default this is &quot;profiler.dat&quot;.</li></ul><ul><li><code>online_print_time_interval_secs</code> : This is the rate at which stats should be printed by the online profiler. Stats may not be printed at this rate is one does not call <code>at</code> or <code>safe_to_delay</code> periodically.</li></ul><ul><li><code>online_print_by_default</code> : Setting this to <code>false</code> disables printing stats every time interval. One can print stats by explicitly calling <code>dump_stats</code>.</li></ul><p>The environment variable <code>CORE_PROFILER</code> can be used to configure the app. Also see <code>core_profiler_env_help_string</code> below.</p></dd></dl><dl><dt class="spec value" id="val-safe_to_delay"><a href="#val-safe_to_delay" class="anchor"></a><code><span class="keyword">val</span> safe_to_delay : unit <span>&#45;&gt;</span> unit</code></dt><dd><p>There are several slow operations that may happen occasionally when calling <code>record</code>: allocation, <code>Time_stamp_counter</code> calibration, etc. <code>safe_to_delay</code> checks if they will be necessary soon, and does them in advance. If possible, call this (fairly regularly) from a time-insensitive point in code (or at least, outside any deltas / groups) to reduce the number of spurious jumps in time deltas. If you know for certain that you will be using <code>Core_profiler</code>, you also probably want to call this at startup, to perform the first allocation.</p></dd></dl><dl><dt class="spec value" id="val-dump_stats"><a href="#val-dump_stats" class="anchor"></a><code><span class="keyword">val</span> dump_stats : unit <span>&#45;&gt;</span> unit</code></dt><dd><p>In the online profiler, <code>dump_stats</code> prints a table of stats -- this is the same table that is printed periodically and this function gives the user the option to disable the automatic printing and take control of the printing process.</p><p>In the offline profiler, <code>dump_stats</code> writes out all the collected stats so far. This normally happens <code>at_exit</code> and this function lets the programmer dump the stats earlier.</p></dd></dl></div></body></html>