<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Delta_probe (core_profiler.Core_profiler_disabled__Intf.Profiler_intf.Delta_probe)</title><link rel="stylesheet" href="../../../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../../../index.html">core_profiler</a> &#x00BB; <a href="../../index.html">Core_profiler_disabled__Intf</a> &#x00BB; <a href="../index.html">Profiler_intf</a> &#x00BB; Delta_probe</nav><h1>Module <code>Profiler_intf.Delta_probe</code></h1><p><code>Delta_probe</code> is an optimized two-probe group to track changes to some counter.</p></header><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> t</code></dt><dt class="spec type" id="type-state"><a href="#type-state" class="anchor"></a><code><span class="keyword">type</span> state</code></dt></dl><dl><dt class="spec value" id="val-create"><a href="#val-create" class="anchor"></a><code><span class="keyword">val</span> create : name:string <span>&#45;&gt;</span> units:<a href="../../../Core_profiler_disabled/Profiler_units/index.html#type-t">Core_profiler_disabled.Profiler_units.t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-start"><a href="#val-start" class="anchor"></a><code><span class="keyword">val</span> start : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> unit</code></dt><dd><p>To measure changes in a value, one can call <code>start</code> followed by a call <code>stop</code> after some time. The call to <code>stop</code> will record the delta. Calls to <code>start</code>/<code>stop</code> must be interleaved for each <code>t</code>.</p><p>Calling <code>pause</code> in place of <code>stop</code> causes <code>t</code> to accumulate, but not record, the delta. <code>start</code> and <code>pause</code> can then be interleaved multiple times. Afterwards, calling <code>record</code> will record the sum of the deltas between each <code>start</code>/<code>pause</code>, and reset <code>t</code>.</p><p>Valid sequences should satisfy this regular expression:</p><pre>          start;(pause;start;)*((pause;record;)|stop;)</pre><p>Calling these functions out of order will cause bad data to be recorded. This API does not raise exceptions, so one will not be warned of errors.</p><p>For each <code>t</code>, there are two valid sequences of calls. The first is calling <code>start</code> then <code>stop</code>. The second is calling <code>start</code> then <code>pause</code> an arbitrary number of times, and ending with <code>record</code>.</p></dd></dl><dl><dt class="spec value" id="val-stop"><a href="#val-stop" class="anchor"></a><code><span class="keyword">val</span> stop : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-pause"><a href="#val-pause" class="anchor"></a><code><span class="keyword">val</span> pause : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-record"><a href="#val-record" class="anchor"></a><code><span class="keyword">val</span> record : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-stateless_start"><a href="#val-stateless_start" class="anchor"></a><code><span class="keyword">val</span> stateless_start : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <a href="index.html#type-state">state</a></code></dt><dd><p>These are non-stateful and can be used in Async, wherein multiple jobs might call <code>stateless_start</code> before the corresponding <code>stop_async</code> is called. One can use <code>stateless_start</code> and <code>stateless_stop</code> to wrap async functions roughly like the following. This function cannot be provided as part of the <code>Core_profiler</code> library because we'd like the library to be usable in <code>Async</code> and hence now depend on it.</p><pre><code class="ml">let wrap_async t f x =
  let state = stateless_start t (Gc.minor_words ()) in
  try_with ~run:`Now (fun () -&gt; f x)
  &gt;&gt;= fun res -&gt;
  stateless_stop t state (Gc.minor_words ());
  match res with
  | Ok x -&gt; return x
  | Error ex -&gt; Exn.reraise ex &quot;Core_profiler wrap_async&quot;</code></pre><p>The stateless API does not support pausing. This is because state would require memory allocation if it supported accumulating the counter.</p></dd></dl><dl><dt class="spec value" id="val-stateless_stop"><a href="#val-stateless_stop" class="anchor"></a><code><span class="keyword">val</span> stateless_stop : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-state">state</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> unit</code></dt></dl></div></body></html>