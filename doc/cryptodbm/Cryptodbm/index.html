<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Cryptodbm (cryptodbm.Cryptodbm)</title><link rel="stylesheet" href="../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../index.html">cryptodbm</a> &#x00BB; Cryptodbm</nav><h1>Module <code>Cryptodbm</code></h1><h3 id="encrypted-layer-over-the-dbm-library:-serverless,-key-value-databases-with-symmetric-encryption."><a href="#encrypted-layer-over-the-dbm-library:-serverless,-key-value-databases-with-symmetric-encryption." class="anchor"></a>Encrypted layer over the dbm library: serverless, key-value databases with symmetric encryption.</h3><p>This library provides an encrypted layer on top of the <a href="https://github.com/ocaml/dbm">Dbm</a> and <a href="https://github.com/xavierleroy/cryptokit/">Cryptokit</a> packages. The improvements over Dbm are:</p><ul><li>A single database file may contain <b>several independent subtables</b>, identified by a name (a string).</li><li>Each subtable can be <b>signed and encrypted individually</b>, or encrypted using a global password.</li><li>The whole file can be signed.</li><li><b>Obfuscating data</b> is -optionally- appended to keys, data, and to the whole table, so that two databases with the same content look significantly different, once encrypted.</li><li>Encryption is symmetric: encryption and decryption both use the same password.</li><li>Signature is symmetric: signing and verifying the signature both use the same signword.</li></ul><p>As a quick example, the following uncrypted bindings (key =&gt; data):</p><pre>        &quot;john-doe&quot;        =&gt; &quot;age 36&quot;
        &quot;some secret&quot;     =&gt; &quot;The cake is a lie.&quot;
        &quot;Motto&quot;           =&gt; &quot;For relaxing times, make it Suntory time&quot;</pre><p>are stored as follows in the encrypted file (with variations depending on the password, and other parameters):</p><pre> [S~j....O.Q..tk^.2] =&gt; [...F...).Hsl..tB]
 [...y;....~.:.6V.2] =&gt; [....I...JR..w.E9..G..q=...K....b]
 [..'.C...F.x.3K.y2] =&gt; [1.)9q..M...et.b.]
 [S.....5 Y....8..2] =&gt; [.D........2..u...q.......}Z.b..z.zo.}.l3l.....&gt;.]
 [...xD;@.8..wV..P1....e}....u..`.2] =&gt; [hb..2.._B....Y?0....|.....tM....]
 [K.#i.7j..H.ZZ.^.2] =&gt; [..z....,........]</pre><p>Including several subtables in the same database file avoids having to deal with multiple files to store related information, and also prevents information leak through the number and sizes of a set of database files.</p><p>This library was primarily designed to store encrypted exam files on a university server. A common layout consists in several subtables encrypted with a global password, as well as an uncrypted subtable containing (public) meta-information.</p><p><b>Install and compile</b></p><p>Install using opam: <code>opam install cryptodbm</code></p><p>Compile with ocamlbuild by adding the following to your _tags file:</p><pre>&lt;**/*&gt; : package(cryptodbm)</pre><p><b>Performance</b></p><p>I have not benchmarked this library. Keep in mind that every access (reading or writing a binding) requires to encrypt the key, and encrypt the data (when writing) or decrypt the data (when reading). Don't be pessimistic, though: it seems all right for non critical applications.</p><p>Also, there is only a global key-index for the whole table, no key-index for individual subtables. As a consequence, subtable iterators actually iterate over the whole table index (selecting only the expected subtable indexes).</p><p><b>A few technical details</b></p><p>When a database file is encrypted,</p><ul><li>The only uncrypted binding in the file is the format version number, as well as bindings of uncrypted subtables.</li><li>Because of salt(s), it is not possible for an observer to see when two databases use the same password.</li><li>Because of salt(s), saving twice the same database leads to two files containing totally different bindings. An observer cannot make sure that two databases are equal. However, if the following options are not used, the total number of bindings is the same, as well as the sizes of bindings (which entails that the file sizes are the same too).</li><li>If &quot;max_extra padding&quot; is used, saving twice the same database leads to two files containing bindings with different sizes. If &quot;extra bindings&quot; is used, the total number of bindings is, moreover, different. It is harder for an observer to guess if two database files are possibly equal.</li><li>Because data is encrypted using the salt, password and key, data associated to different keys are encrypted differently. An observer cannot identify bindings with equal data.</li><li>The signature is computed by hashing the salt, signword, all (subtabled) keys and associated data. It is stored after encryption using the salt and the (sub)table password. The hashing function is currently sha256 (see the Cryptokit package).</li></ul><p>See also the <a href="https://github.com/lebotlan/ocaml-cryptodbm">project homepage</a>.</p><p><i>Contact: D. Le Botlan (github.lebotlan@dfgh.met where you replace .met by .net.)</i></p><nav class="toc"><ul><li><a href="#typical-example">Typical example</a></li><li><a href="#basics">Basics</a></li><li><a href="#open,-close,-and-flush-files">Open, close, and flush files</a><ul><li><a href="#open_read">open_read</a></li><li><a href="#open_append">open_append</a></li><li><a href="#open_create">open_create</a></li><li><a href="#open_only_uncrypted">open_only_uncrypted</a></li><li><a href="#close,-flush">close, flush</a></li></ul></li><li><a href="#open-and-create-subtables">Open and create subtables</a><ul><li><a href="#create_subtable">create_subtable</a></li><li><a href="#open_subtable">open_subtable</a></li><li><a href="#append_subtable">append_subtable</a></li><li><a href="#close">close</a></li></ul></li><li><a href="#getters-and-iterators-over-subtables">Getters and iterators over subtables</a></li><li><a href="#operations-on-bindings:-add,-find,-delete,-iterate">Operations on bindings: add, find, delete, iterate</a></li><li><a href="#durable-backup">Durable backup</a></li></ul></nav></header><section><header><h4 id="typical-example"><a href="#typical-example" class="anchor"></a>Typical example</h4><pre><code class="ml">let table = open_append ~file:&quot;/path/to/myfile&quot; ~passwd:&quot;my-secret-passwd&quot; in

let subtable = append_subtable table ~name:&quot;here the subtable name&quot; () in

add subtable ~key:&quot;key1&quot; ~data:&quot;data1&quot; () ;
add subtable ~key:&quot;key2&quot; ~data:&quot;data2&quot; () ;

close table ;
()</code></pre></header><dl><dt class="spec module" id="module-Error"><a href="#module-Error" class="anchor"></a><code><span class="keyword">module</span> <a href="Error/index.html">Error</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>All errors that may occur.</p></dd></dl><aside><p>Notice that all functions may raise <code>Error(DB_Error)</code> when accessing the underlying database.</p></aside></section><section><header><h4 id="basics"><a href="#basics" class="anchor"></a>Basics</h4></header><dl><dt class="spec type" id="type-table"><a href="#type-table" class="anchor"></a><code><span class="keyword">type</span> 'a table</code></dt><dd><p>The type of encrypted-dbm file descriptors. 'a is a phantom type precising the permission: read-only or full access.</p></dd></dl><dl><dt class="spec type" id="type-read"><a href="#type-read" class="anchor"></a><code><span class="keyword">type</span> read</code></dt><dd><p>Phantom type which represents read-only permission.</p></dd></dl><dl><dt class="spec type" id="type-full"><a href="#type-full" class="anchor"></a><code><span class="keyword">type</span> full</code></dt><dd><p>Phantom type which represents read-write permission.</p></dd></dl><dl><dt class="spec type" id="type-subtable"><a href="#type-subtable" class="anchor"></a><code><span class="keyword">type</span> 'a subtable</code></dt><dd><p>Type of a subtable. 'a is the permission.</p></dd></dl></section><section><header><h4 id="open,-close,-and-flush-files"><a href="#open,-close,-and-flush-files" class="anchor"></a>Open, close, and flush files</h4></header><aside><p>The database can be opened in three modes: read mode, write (create) mode, and append mode.</p><p>Note that operations are not thread-safe at the library level: do not share a table or subtable handler between threads. However, multiple processes might access the same database, whenever the low-level dbm permits it (which depends on the low-level dbm library actually used). gdbm allows many readers in parallel, or only one writer and no reader.</p></aside><section><header><h5 id="open_read"><a href="#open_read" class="anchor"></a>open_read</h5></header><dl><dt class="spec value" id="val-open_read"><a href="#val-open_read" class="anchor"></a><code><span class="keyword">val</span> open_read : ?&#8288;iterations:int <span>&#45;&gt;</span> file:string <span>&#45;&gt;</span> passwd:string <span>&#45;&gt;</span> signwd:string <span>&#45;&gt;</span> unit <span>&#45;&gt;</span> <a href="index.html#type-read">read</a> <a href="index.html#type-table">table</a></code></dt><dd><p>Opens an encrypted-dbm file for reading.</p><dl><dt>parameter file</dt><dd><p>The full path to the database file, but without the .pag or .dir extension (when applicable).</p></dd></dl><dl><dt>parameter passwd</dt><dd><p>Use the given password to decrypt. Use the empty string &quot;&quot; if the file is not encrypted. In order to access only uncrypted bindings of an encrypted file, consider <a href="index.html#open_only_uncrypted"><span>open_only_uncrypted</span></a> instead.</p></dd></dl><dl><dt>parameter signwd</dt><dd><p>Use the given signword to check the signature. If the signword is the empty string, do not check the signature.</p></dd></dl><dl><dt>parameter iterations</dt><dd><p>Number of iterations used to map the password/signword. A higher value means a longer time to open the database. A default value is used if missing (around 12000). The same value must be used when reading/writing the database - otherwise the password is not recognized (Bad_password). The same value must be used when signing/checking the signature - oterwise the signature is not recognized (Bad_signature). The number of iterations is NOT saved in the dbfile.</p></dd></dl><dl><dt>returns</dt><dd><p>A new handler to access this database.</p></dd></dl><dl><dt>raises Error(File_not_found)</dt><dd><p>the file does not exist or is not readable.</p></dd></dl><dl><dt>raises Error(Bad_format)</dt><dd><p>the database file uses an incompatible format.</p></dd></dl><dl><dt>raises Error(Bad_password)</dt><dd><p>the non-empty given password is incorrect.</p></dd></dl><dl><dt>raises Error(Bad_signature</dt><dd><p>the database signature does not match the expected signature, using the given non-empty signword.</p></dd></dl><dl><dt>raises Error(No_signature)</dt><dd><p>the database is not signed but a signword is provided.</p></dd></dl><dl><dt>raises Error(Corrupted)</dt><dd><p>the database file does not have the expected structure.</p></dd></dl></dd></dl></section><section><header><h5 id="open_append"><a href="#open_append" class="anchor"></a>open_append</h5></header><dl><dt class="spec value" id="val-open_append"><a href="#val-open_append" class="anchor"></a><code><span class="keyword">val</span> open_append : ?&#8288;iterations:int <span>&#45;&gt;</span> file:string <span>&#45;&gt;</span> passwd:string <span>&#45;&gt;</span> signwd:string <span>&#45;&gt;</span> check_signature:bool <span>&#45;&gt;</span> unit <span>&#45;&gt;</span> <a href="index.html#type-full">full</a> <a href="index.html#type-table">table</a></code></dt><dd><p>Opens an existing encrypted-dbm file in append mode.</p><dl><dt>parameter file</dt><dd><p>The full path to the database file, without the .pag or .dir extension</p></dd></dl><dl><dt>parameter passwd</dt><dd><p>Use the given password to decrypt.</p></dd></dl><dl><dt>parameter signwd</dt><dd><p>Use the given signword to sign the database.</p></dd></dl><dl><dt>parameter check_signature</dt><dd><p>Whether to check the existing signature before appending new data. If the table was not signed, raises No_signature.</p></dd></dl><dl><dt>parameter iterations</dt><dd><p>Number of iterations used to map the password/signword. (See open_read)</p></dd></dl><dl><dt>returns</dt><dd><p>A new handler to access this database.</p></dd></dl><dl><dt>raises Error(File_not_appendable)</dt><dd><p>the file does not exists or is not readable, or is not writeable.</p></dd></dl><dl><dt>raises Error(Bad_format)</dt><dd><p>the database file uses an incompatible format.</p></dd></dl><dl><dt>raises Error(Bad_password)</dt><dd><p>the non-empty given password is incorrect.</p></dd></dl><dl><dt>raises Error(Bad_signature)</dt><dd><p>the database signature does not match the expected signature, and check_signature is true.</p></dd></dl><dl><dt>raises Error(No_signature)</dt><dd><p>the database is not signed, and check_signature is true.</p></dd></dl><dl><dt>raises Error(Corrupted)</dt><dd><p>the database file does not have the expected structure.</p></dd></dl><dl><dt>raises Failure(some</dt><dd><p>message) check_signature is true but the signwd is empty.</p></dd></dl></dd></dl></section><section><header><h5 id="open_create"><a href="#open_create" class="anchor"></a>open_create</h5></header><dl><dt class="spec value" id="val-open_create"><a href="#val-open_create" class="anchor"></a><code><span class="keyword">val</span> open_create : file:string <span>&#45;&gt;</span> ?&#8288;overwrite:bool <span>&#45;&gt;</span> ?&#8288;iterations:int <span>&#45;&gt;</span> passwd:string <span>&#45;&gt;</span> signwd:string <span>&#45;&gt;</span> ?&#8288;max_extra_key:int <span>&#45;&gt;</span> ?&#8288;max_extra_data:int <span>&#45;&gt;</span> ?&#8288;max_extra_bindings:int <span>&#45;&gt;</span> perm:int <span>&#45;&gt;</span> unit <span>&#45;&gt;</span> <a href="index.html#type-full">full</a> <a href="index.html#type-table">table</a></code></dt><dd><p>Creates a new encrypted-dbm file.</p><dl><dt>parameter file</dt><dd><p>The full path to the database file, without the .pag or .dir extension</p></dd></dl><dl><dt>parameter overwrite</dt><dd><p>Indicates if overwriting an existing file is allowed.</p></dd></dl><dl><dt>parameter passwd</dt><dd><p>If a password is provided, use it to encrypt. An empty password means no encryption.</p></dd></dl><dl><dt>parameter signwd</dt><dd><p>If a signword is provided, use it to sign. An empty signword means no signature.</p></dd></dl><dl><dt>parameter iterations</dt><dd><p>Number of iterations used to map the password/signword. (See open_read)</p></dd></dl><dl><dt>parameter max_extra_key</dt><dd><p>Max length of random padding added to keys, default 0.</p></dd></dl><dl><dt>parameter max_extra_data</dt><dd><p>Max length of random padding added to data, default 0.</p></dd></dl><dl><dt>parameter max_extra_bindings</dt><dd><p>(default 0): because the number of bindings of the table can be guessed without knowing the password, random extra bindings can be added to obfuscate the table.</p></dd></dl><dl><dt>parameter perm</dt><dd><p>Unix permission to be used to create the file. Must allow the user to write on this file. Beware that in OCaml, 644 is not equal to 0o644.</p></dd></dl><dl><dt>returns</dt><dd><p>A new handler to access this database.</p></dd></dl><dl><dt>raises Error(File_overwrite)</dt><dd><p>the file already exists and overwriting is not explicitly allowed.</p></dd></dl><dl><dt>raises Error(File_not_writeable)</dt><dd><p>the given permission does not allow writing.</p></dd></dl></dd></dl></section><section><header><h5 id="open_only_uncrypted"><a href="#open_only_uncrypted" class="anchor"></a>open_only_uncrypted</h5></header><dl><dt class="spec value" id="val-open_only_uncrypted"><a href="#val-open_only_uncrypted" class="anchor"></a><code><span class="keyword">val</span> open_only_uncrypted : ?&#8288;iterations:int <span>&#45;&gt;</span> file:string <span>&#45;&gt;</span> signwd:string <span>&#45;&gt;</span> unit <span>&#45;&gt;</span> <a href="index.html#type-read">read</a> <a href="index.html#type-table">table</a></code></dt><dd><p>Opens a table to access only uncrypted subtables.</p><dl><dt>parameter file</dt><dd><p>The full path to the database file, without the .pag or .dir extension</p></dd></dl><dl><dt>parameter signwd</dt><dd><p>Use the given signword to check the signature. If the signword is the empty string, do not check the signature.</p></dd></dl><dl><dt>parameter iterations</dt><dd><p>Used to check the signature (useless if the signwd is empty).</p></dd></dl><dl><dt>raises Error(File_not_found)</dt><dd><p>the file does not exist or is not readable.</p></dd></dl><dl><dt>raises Error(Bad_format)</dt><dd><p>the database file uses an incompatible format.</p></dd></dl><dl><dt>raises Error(Bad_signature)</dt><dd><p>the database signature does not match the expected signature, using the given non-empty signword.</p></dd></dl><dl><dt>raises Error(No_signature)</dt><dd><p>the database is not signed but a signword is provided.</p></dd></dl><dl><dt>raises Error(Corrupted)</dt><dd><p>the database file does not have the expected structure.</p></dd></dl></dd></dl></section><section><header><h5 id="close,-flush"><a href="#close,-flush" class="anchor"></a>close, flush</h5></header><dl><dt class="spec value" id="val-close"><a href="#val-close" class="anchor"></a><code><span class="keyword">val</span> close : <span class="type-var">'a</span> <a href="index.html#type-table">table</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>If in write mode, sign if necessary, add extra bindings if required, then flush and close the file. In read mode, just close the file. All the subtables are automatically closed.</p><dl><dt>raises Error(Is_Closed)</dt><dd><p>the database is already closed.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-flush"><a href="#val-flush" class="anchor"></a><code><span class="keyword">val</span> flush : ?&#8288;backup:bool <span>&#45;&gt;</span> ?&#8288;backup_name:string <span>&#45;&gt;</span> <a href="index.html#type-full">full</a> <a href="index.html#type-table">table</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Sign if necessary, and flush. Optionally make a backup, that is, a copy of the current database file is made (default name is: 'filename'-backup-'date').</p><dl><dt>raises Error(Is_Closed)</dt><dd><p>the database is already closed.</p></dd></dl><dl><dt>raises Error(Backup_failure)</dt><dd><p>something went wrong when doing the backup.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-get_rootfile"><a href="#val-get_rootfile" class="anchor"></a><code><span class="keyword">val</span> get_rootfile : <span class="type-var">'a</span> <a href="index.html#type-table">table</a> <span>&#45;&gt;</span> string</code></dt><dd><p>Returns the root filename (without the .pag or .dir extension).</p></dd></dl></section></section><section><header><h4 id="open-and-create-subtables"><a href="#open-and-create-subtables" class="anchor"></a>Open and create subtables</h4></header><section><header><h5 id="create_subtable"><a href="#create_subtable" class="anchor"></a>create_subtable</h5></header><dl><dt class="spec value" id="val-create_subtable"><a href="#val-create_subtable" class="anchor"></a><code><span class="keyword">val</span> create_subtable : <a href="index.html#type-full">full</a> <a href="index.html#type-table">table</a> <span>&#45;&gt;</span> name:string <span>&#45;&gt;</span> ?&#8288;iterations:int <span>&#45;&gt;</span> passwd:string <span>&#45;&gt;</span> signwd:string <span>&#45;&gt;</span> ?&#8288;max_extra_key:int <span>&#45;&gt;</span> ?&#8288;max_extra_data:int <span>&#45;&gt;</span> unit <span>&#45;&gt;</span> <a href="index.html#type-full">full</a> <a href="index.html#type-subtable">subtable</a></code></dt><dd><p>Creates a standard subtable for writing.</p><dl><dt>parameter name</dt><dd><p>the subtable name. It can be any string.</p></dd></dl><dl><dt>parameter passwd</dt><dd><p>If the passwd is empty, use the global table password. If the global table password is also empty, this subtable will be uncrypted. If the passwd is not empty, use it to encrypt this subtable. Consider <a href="index.html#val-create_uncrypted_subtable"><code>create_uncrypted_subtable</code></a> to create an uncrypted subtable in an encrypted table.</p></dd></dl><dl><dt>parameter signwd</dt><dd><p>If a signwd is provided, use it to sign this subtable.</p></dd></dl><dl><dt>parameter iterations</dt><dd><p>Number of iterations used to map the password/signword. (See open_read). If unspecified, take a default value (not necessarily the value used to open the table itself).</p></dd></dl><dl><dt>parameter max_extra_key</dt><dd><p>Use this max_extra_key (instead of the global table max_extra_key parameter).</p></dd></dl><dl><dt>parameter max_extra_data</dt><dd><p>Use this max_extra_data (instead of the global table max_extra_data parameter).</p></dd></dl><dl><dt>raises Error(Is_Closed)</dt><dd><p>the database is closed.</p></dd></dl><dl><dt>raises Error(Subtable_exists)</dt><dd><p>a standard subtable with this name already exists.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-create_uncrypted_subtable"><a href="#val-create_uncrypted_subtable" class="anchor"></a><code><span class="keyword">val</span> create_uncrypted_subtable : ?&#8288;iterations:int <span>&#45;&gt;</span> <a href="index.html#type-full">full</a> <a href="index.html#type-table">table</a> <span>&#45;&gt;</span> name:string <span>&#45;&gt;</span> signwd:string <span>&#45;&gt;</span> unit <span>&#45;&gt;</span> <a href="index.html#type-full">full</a> <a href="index.html#type-subtable">subtable</a></code></dt><dd><p>Creates an uncrypted subtable (even when the global table is encrypted).</p><dl><dt>parameter name</dt><dd><p>the subtable name. It can be virtually any string.</p></dd></dl><dl><dt>parameter signwd</dt><dd><p>If a signwd is provided, use it to sign this subtable.</p></dd></dl><dl><dt>parameter iterations</dt><dd><p>Used to check the signature (useless if the signwd is empty).</p></dd></dl><dl><dt>raises Error(Is_Closed)</dt><dd><p>the database is closed.</p></dd></dl><dl><dt>raises Error(Subtable_exists)</dt><dd><p>a subtable with this name already exists.</p></dd></dl></dd></dl></section><section><header><h5 id="open_subtable"><a href="#open_subtable" class="anchor"></a>open_subtable</h5></header><dl><dt class="spec value" id="val-open_subtable"><a href="#val-open_subtable" class="anchor"></a><code><span class="keyword">val</span> open_subtable : <span class="type-var">'a</span> <a href="index.html#type-table">table</a> <span>&#45;&gt;</span> name:string <span>&#45;&gt;</span> ?&#8288;iterations:int <span>&#45;&gt;</span> passwd:string <span>&#45;&gt;</span> signwd:string <span>&#45;&gt;</span> unit <span>&#45;&gt;</span> <a href="index.html#type-read">read</a> <a href="index.html#type-subtable">subtable</a></code></dt><dd><p>Open a standard subtable for reading.</p><dl><dt>parameter name</dt><dd><p>the subtable name.</p></dd></dl><dl><dt>parameter passwd</dt><dd><p>If a non-empty password is provided, use it to decrypt.</p></dd></dl><dl><dt>parameter signwd</dt><dd><p>If a non-empty signword is provided, use it to check the signature of this subtable.</p></dd></dl><dl><dt>parameter iterations</dt><dd><p>Number of iterations used to map the password/signword. (See open_read)</p></dd></dl><dl><dt>raises Error(Is_Closed)</dt><dd><p>the database is closed.</p></dd></dl><dl><dt>raises Error(Bad_password)</dt><dd><p>the given password does not match this subtable's password.</p></dd></dl><dl><dt>raises Error(Bad_signature)</dt><dd><p>the subtable signature does not match the expected signature, using the given non-empty signword.</p></dd></dl><dl><dt>raises Error(No_signature)</dt><dd><p>the subtable is not signed, but a signwd was provided.</p></dd></dl><dl><dt>raises Error(Is_Already_Open)</dt><dd><p>this subtable (identified by its name) is already open.</p></dd></dl><dl><dt>raises Error(No_subtable)</dt><dd><p>no subtable with this name exists (if the subtable is explicitly uncrypted, use <a href="index.html#val-open_uncrypted_subtable"><code>open_uncrypted_subtable</code></a> instead).</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-open_uncrypted_subtable"><a href="#val-open_uncrypted_subtable" class="anchor"></a><code><span class="keyword">val</span> open_uncrypted_subtable : ?&#8288;iterations:int <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-table">table</a> <span>&#45;&gt;</span> name:string <span>&#45;&gt;</span> signwd:string <span>&#45;&gt;</span> unit <span>&#45;&gt;</span> <a href="index.html#type-read">read</a> <a href="index.html#type-subtable">subtable</a></code></dt><dd><p>Open an uncrypted subtable for reading.</p><dl><dt>parameter name</dt><dd><p>the subtable name.</p></dd></dl><dl><dt>parameter signwd</dt><dd><p>If a non-empty signword is provided, use it to check the signature of this subtable.</p></dd></dl><dl><dt>parameter iterations</dt><dd><p>Used to check the signature (useless if the signwd is empty).</p></dd></dl><dl><dt>raises Error(Is_Closed)</dt><dd><p>the database is closed.</p></dd></dl><dl><dt>raises Error(Bad_signature)</dt><dd><p>the subtable signature does not match the expected signature, using the given non-empty signword.</p></dd></dl><dl><dt>raises Error(No_signature)</dt><dd><p>the subtable is not signed, but a signwd was provided.</p></dd></dl><dl><dt>raises Error(Is_Already_Open)</dt><dd><p>this subtable (identified by its name) is already open.</p></dd></dl><dl><dt>raises Error(No_subtable)</dt><dd><p>no uncrypted subtable with this name exists.</p></dd></dl></dd></dl></section><section><header><h5 id="append_subtable"><a href="#append_subtable" class="anchor"></a>append_subtable</h5></header><dl><dt class="spec value" id="val-append_subtable"><a href="#val-append_subtable" class="anchor"></a><code><span class="keyword">val</span> append_subtable : <a href="index.html#type-full">full</a> <a href="index.html#type-table">table</a> <span>&#45;&gt;</span> name:string <span>&#45;&gt;</span> ?&#8288;iterations:int <span>&#45;&gt;</span> passwd:string <span>&#45;&gt;</span> signwd:string <span>&#45;&gt;</span> check_signature:bool <span>&#45;&gt;</span> unit <span>&#45;&gt;</span> <a href="index.html#type-full">full</a> <a href="index.html#type-subtable">subtable</a></code></dt><dd><p>Open a standard subtable for appending bindings.</p><dl><dt>parameter name</dt><dd><p>the subtable name.</p></dd></dl><dl><dt>parameter passwd</dt><dd><p>If a non-empty password is provided, use it to decrypt and encrypt.</p></dd></dl><dl><dt>parameter signwd</dt><dd><p>Use the given signword to sign this subtable.</p></dd></dl><dl><dt>parameter check_signature</dt><dd><p>Whether to check the existing signature before appending new data. If the subtable was not signed, this parameter has no effect.</p></dd></dl><dl><dt>parameter iterations</dt><dd><p>Number of iterations used to map the password/signword. (See open_read)</p></dd></dl><dl><dt>raises Error(Is_Closed)</dt><dd><p>the database is closed.</p></dd></dl><dl><dt>raises Error(Bad_password)</dt><dd><p>the given password does not match this subtable's password.</p></dd></dl><dl><dt>raises Error(Bad_signature)</dt><dd><p>the subtable signature does not match the expected signature, using the given non-empty signword.</p></dd></dl><dl><dt>raises Error(No_signature)</dt><dd><p>the subtable is not signed, but a signwd was provided.</p></dd></dl><dl><dt>raises Error(Is_Already_Open)</dt><dd><p>this subtable (identified by its name) is already open.</p></dd></dl><dl><dt>raises Error(No_subtable)</dt><dd><p>no standard subtable with this name exists (if the subtable is explicitly uncrypted, use <a href="index.html#val-append_uncrypted_subtable"><code>append_uncrypted_subtable</code></a> instead).</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-append_uncrypted_subtable"><a href="#val-append_uncrypted_subtable" class="anchor"></a><code><span class="keyword">val</span> append_uncrypted_subtable : ?&#8288;iterations:int <span>&#45;&gt;</span> <a href="index.html#type-full">full</a> <a href="index.html#type-table">table</a> <span>&#45;&gt;</span> name:string <span>&#45;&gt;</span> signwd:string <span>&#45;&gt;</span> check_signature:bool <span>&#45;&gt;</span> unit <span>&#45;&gt;</span> <a href="index.html#type-full">full</a> <a href="index.html#type-subtable">subtable</a></code></dt><dd><p>Open an uncrypted subtable for appending bindings.</p><dl><dt>parameter name</dt><dd><p>the subtable name.</p></dd></dl><dl><dt>parameter signwd</dt><dd><p>Use the given signword to sign this subtable.</p></dd></dl><dl><dt>parameter check_signature</dt><dd><p>Whether to check the existing signature before appending new data. If the subtable was not signed, this parameter has no effect.</p></dd></dl><dl><dt>parameter iterations</dt><dd><p>Used to check the signature (useless if the signwd is empty).</p></dd></dl><dl><dt>raises Error(Is_Closed)</dt><dd><p>the database is closed.</p></dd></dl><dl><dt>raises Error(Bad_signature)</dt><dd><p>the subtable signature does not match the expected signature, using the given non-empty signword.</p></dd></dl><dl><dt>raises Error(No_signature)</dt><dd><p>the subtable is not signed, but a signwd was provided.</p></dd></dl><dl><dt>raises Error(Is_Already_Open)</dt><dd><p>this subtable (identified by its name) is already open.</p></dd></dl><dl><dt>raises Error(No_subtable)</dt><dd><p>no uncrypted subtable with this name exists.</p></dd></dl></dd></dl></section><section><header><h5 id="close"><a href="#close" class="anchor"></a>close</h5></header><dl><dt class="spec value" id="val-close_subtable"><a href="#val-close_subtable" class="anchor"></a><code><span class="keyword">val</span> close_subtable : <span class="type-var">'a</span> <a href="index.html#type-subtable">subtable</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>If in write mode, sign if necessary, then flush and close the subtable. In read mode, just close the subtable.</p><dl><dt>raises Error(Is_Closed)</dt><dd><p>the subtable is already closed.</p></dd></dl></dd></dl></section></section><section><header><h4 id="getters-and-iterators-over-subtables"><a href="#getters-and-iterators-over-subtables" class="anchor"></a>Getters and iterators over subtables</h4></header><dl><dt class="spec value" id="val-get_number"><a href="#val-get_number" class="anchor"></a><code><span class="keyword">val</span> get_number : <span class="type-var">'a</span> <a href="index.html#type-subtable">subtable</a> <span>&#45;&gt;</span> int</code></dt><dd><p>Returns this subtable's identifier (a number).</p></dd></dl><dl><dt class="spec value" id="val-get_name"><a href="#val-get_name" class="anchor"></a><code><span class="keyword">val</span> get_name : <span class="type-var">'a</span> <a href="index.html#type-subtable">subtable</a> <span>&#45;&gt;</span> string</code></dt><dd><p>Returns this subtable's name.</p></dd></dl><dl><dt class="spec value" id="val-iter_subtables"><a href="#val-iter_subtables" class="anchor"></a><code><span class="keyword">val</span> iter_subtables : <span class="type-var">'a</span> <a href="index.html#type-table">table</a> <span>&#45;&gt;</span> (string <span>&#45;&gt;</span> int <span>&#45;&gt;</span> unit) <span>&#45;&gt;</span> unit</code></dt><dd><p>Iterate over standard subtables. The function is applied to the subtable name and number.</p><dl><dt>raises Error(Is_Closed)</dt><dd><p>the table is already closed.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-iter_uncrypted_subtables"><a href="#val-iter_uncrypted_subtables" class="anchor"></a><code><span class="keyword">val</span> iter_uncrypted_subtables : <span class="type-var">'a</span> <a href="index.html#type-table">table</a> <span>&#45;&gt;</span> (string <span>&#45;&gt;</span> int <span>&#45;&gt;</span> unit) <span>&#45;&gt;</span> unit</code></dt><dd><p>Iterate over uncrypted subtables.</p><dl><dt>raises Error(Is_Closed)</dt><dd><p>the table is already closed.</p></dd></dl></dd></dl></section><section><header><h4 id="operations-on-bindings:-add,-find,-delete,-iterate"><a href="#operations-on-bindings:-add,-find,-delete,-iterate" class="anchor"></a>Operations on bindings: add, find, delete, iterate</h4></header><dl><dt class="spec value" id="val-add"><a href="#val-add" class="anchor"></a><code><span class="keyword">val</span> add : ?&#8288;may_overwrite:bool <span>&#45;&gt;</span> <a href="index.html#type-full">full</a> <a href="index.html#type-subtable">subtable</a> <span>&#45;&gt;</span> key:string <span>&#45;&gt;</span> data:string <span>&#45;&gt;</span> unit</code></dt><dd><p><code>add subt key data</code> binds <code>key</code> to <code>data</code> in subtable <code>subt</code>. By default, overwriting an existing binding is forbidden.</p><dl><dt>parameter may_overwrite</dt><dd><p>if true, replacing an old binding by a new binding is permitted.</p></dd></dl><dl><dt>raises Error(Overwrite)</dt><dd><p>the key is already bound and <code>may_overwrite</code> is false.</p></dd></dl><dl><dt>raises Error(Is_Closed)</dt><dd><p>the subtable is already closed.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-find"><a href="#val-find" class="anchor"></a><code><span class="keyword">val</span> find : <span class="type-var">'a</span> <a href="index.html#type-subtable">subtable</a> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> string</code></dt><dd><p><code>find subt key</code> returns the data associated to <code>key</code> in subtable <code>subt</code>.</p><dl><dt>raises Error(Unbound)</dt><dd><p>the key is not bound in this subtable.</p></dd></dl><dl><dt>raises Error(Is_Closed)</dt><dd><p>the subtable is already closed.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-delete"><a href="#val-delete" class="anchor"></a><code><span class="keyword">val</span> delete : <a href="index.html#type-full">full</a> <a href="index.html#type-subtable">subtable</a> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> unit</code></dt><dd><p><code>delete subt key</code> removes the binding associated to <code>key</code> in subtable <code>subt</code>.</p><dl><dt>raises Error(Unbound)</dt><dd><p>the key is not bound in this subtable.</p></dd></dl><dl><dt>raises Error(Is_Closed)</dt><dd><p>the subtable is already closed.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-clear"><a href="#val-clear" class="anchor"></a><code><span class="keyword">val</span> clear : <a href="index.html#type-full">full</a> <a href="index.html#type-subtable">subtable</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>clear subt</code> removes all the bindings in subtable <code>subt</code>.</p><dl><dt>raises Error(Is_Closed)</dt><dd><p>the subtable is already closed.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-iter"><a href="#val-iter" class="anchor"></a><code><span class="keyword">val</span> iter : <span class="type-var">'a</span> <a href="index.html#type-subtable">subtable</a> <span>&#45;&gt;</span> (string <span>&#45;&gt;</span> string <span>&#45;&gt;</span> unit) <span>&#45;&gt;</span> unit</code></dt><dd><p>Iterate over all pairs (key, data) of the given subtable.</p><dl><dt>raises Error(Is_Closed)</dt><dd><p>the subtable is already closed.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-iterkey"><a href="#val-iterkey" class="anchor"></a><code><span class="keyword">val</span> iterkey : <span class="type-var">'a</span> <a href="index.html#type-subtable">subtable</a> <span>&#45;&gt;</span> (string <span>&#45;&gt;</span> unit) <span>&#45;&gt;</span> unit</code></dt><dd><p>Iterate over all keys of the given subtable. Faster than <code>iter</code> since data is not decrypted.</p><dl><dt>raises Error(Is_Closed)</dt><dd><p>the subtable is already closed.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-fold"><a href="#val-fold" class="anchor"></a><code><span class="keyword">val</span> fold : <span class="type-var">'a</span> <a href="index.html#type-subtable">subtable</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> (string <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>) <span>&#45;&gt;</span> <span class="type-var">'b</span></code></dt><dd><p>See iter.</p></dd></dl><dl><dt class="spec value" id="val-iter_extra_bindings"><a href="#val-iter_extra_bindings" class="anchor"></a><code><span class="keyword">val</span> iter_extra_bindings : <span class="type-var">'a</span> <a href="index.html#type-table">table</a> <span>&#45;&gt;</span> (string <span>&#45;&gt;</span> string <span>&#45;&gt;</span> unit) <span>&#45;&gt;</span> unit</code></dt><dd><p>For debugging.</p></dd></dl></section><section><header><h4 id="durable-backup"><a href="#durable-backup" class="anchor"></a>Durable backup</h4></header><aside><p>The underlying database file is managed by the dbm library actually installed on the runtime platform. For portability, or to ensure that your data does not depend on a particular version of the dbm library, you can use these functions which convert dbm files to and from an ad-hoc, very simple binary format.</p></aside><dl><dt class="spec value" id="val-export"><a href="#val-export" class="anchor"></a><code><span class="keyword">val</span> export : <a href="index.html#type-read">read</a> <a href="index.html#type-table">table</a> <span>&#45;&gt;</span> binfile:string <span>&#45;&gt;</span> unit</code></dt><dd><p>Exports a dbfile to a durable binary format. The dbfile must be opened for reading (open_only_uncrypted suffices, in case the passwords are not known). Note that the binary file just mirrors the dbfile (that is, they both contain the same encrypted &amp; uncrypted data).</p></dd></dl><dl><dt class="spec value" id="val-import"><a href="#val-import" class="anchor"></a><code><span class="keyword">val</span> import : binfile:string <span>&#45;&gt;</span> dbfile:string <span>&#45;&gt;</span> unit</code></dt><dd><p>Imports a binary file to a dbfile. <code>dbfile</code> is the output dbfile, without .pag or .dir extension</p></dd></dl></section></div></body></html>