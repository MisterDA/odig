<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Csv (csvfields.Csvlib.Csv)</title><link rel="stylesheet" href="../../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../../index.html">csvfields</a> &#x00BB; <a href="../index.html">Csvlib</a> &#x00BB; Csv</nav><h1>Module <code>Csvlib.Csv</code></h1></header><aside><p>csv.mli - comma separated values parser * * $Id: csv.mli,v 1.5 2005/05/24 13:52:50 rich Exp $</p></aside><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> t</code><code> = string list list</code></dt><dd><p>Representation of CSV files.</p></dd></dl><dl><dt class="spec exception" id="exception-Bad_CSV_file"><a href="#exception-Bad_CSV_file" class="anchor"></a><code><span class="keyword">exception</span> </code><code><span class="exception">Bad_CSV_file</span> <span class="keyword">of</span> string</code></dt><dd><p>Badly formed CSV files throw this exception.</p></dd></dl><dl><dt class="spec value" id="val-lines"><a href="#val-lines" class="anchor"></a><code><span class="keyword">val</span> lines : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int</code></dt><dd><p>Work out the number of lines in a CSV file.</p></dd></dl><dl><dt class="spec value" id="val-columns"><a href="#val-columns" class="anchor"></a><code><span class="keyword">val</span> columns : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int</code></dt><dd><p>Work out the (maximum) number of columns in a CSV file. Note that each * line may be a different length, so this finds the one with the most * columns.</p></dd></dl><dl><dt class="spec value" id="val-load_in"><a href="#val-load_in" class="anchor"></a><code><span class="keyword">val</span> load_in : ?&#8288;separator:char <span>&#45;&gt;</span> <a href="../../../ocaml/Stdlib/index.html#type-in_channel">Stdlib.in_channel</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Load a CSV file. * </p><dl><dt>parameter chan</dt><dd><p>Input file stream</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-load"><a href="#val-load" class="anchor"></a><code><span class="keyword">val</span> load : ?&#8288;separator:char <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Load a CSV file. * </p><dl><dt>parameter filename</dt><dd><p>CSV filename.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-load_string"><a href="#val-load_string" class="anchor"></a><code><span class="keyword">val</span> load_string : ?&#8288;separator:char <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Load a CSV from a string. * </p><dl><dt>parameter s</dt><dd><p>String whose contents is the entire CSV.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-load_rows"><a href="#val-load_rows" class="anchor"></a><code><span class="keyword">val</span> load_rows : ?&#8288;separator:char <span>&#45;&gt;</span> (string list <span>&#45;&gt;</span> unit) <span>&#45;&gt;</span> <a href="../../../ocaml/Stdlib/index.html#type-in_channel">Stdlib.in_channel</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>For very large CSV files which cannot be processed in memory at once, * this function is appropriate. It parses the input one row at a time and * calls your function once for each row. * * Note that if you CSV file contains cells which have embedded * line feeds, then it is non-trivial to parse these lines and * pass them correctly to <code>load_rows</code>. * * </p><dl><dt>parameter f</dt><dd><p>Callout function. * </p><p>@param chan</p><p>Input file stream.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-load_rows_inchar"><a href="#val-load_rows_inchar" class="anchor"></a><code><span class="keyword">val</span> load_rows_inchar : ?&#8288;separator:char <span>&#45;&gt;</span> (string list <span>&#45;&gt;</span> unit) <span>&#45;&gt;</span> (unit <span>&#45;&gt;</span> char) <span>&#45;&gt;</span> unit</code></dt><dd><p>Works exactly like <code>load_rows</code> except that instead of reading from * a descriptor, it calls a read_char function. This function * throws <code>End_of_file</code> on the end of input.</p></dd></dl><dl><dt class="spec value" id="val-trim"><a href="#val-trim" class="anchor"></a><code><span class="keyword">val</span> trim : ?&#8288;top:bool <span>&#45;&gt;</span> ?&#8288;left:bool <span>&#45;&gt;</span> ?&#8288;right:bool <span>&#45;&gt;</span> ?&#8288;bottom:bool <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>This takes a CSV file and trims empty cells. * * All four of the option arguments (<code>~top</code>, <code>~left</code>, <code>~right</code>, <code>~bottom</code>) * default to <code>true</code>. * * The exact behaviour is: * * <code>~right</code>: If true, remove any empty cells at the right hand end of * any row. The number of columns in the resulting CSV structure will * not necessarily be the same for each row. * * <code>~top</code>: If true, remove any empty rows (no cells, or containing just empty * cells) from the top of the CSV structure. * * <code>~bottom</code>: If true, remove any empty rows from the bottom of the * CSV structure. * * <code>~left</code>: If true, remove any empty columns from the left of the * CSV structure. Note that <code>~left</code> and <code>~right</code> are quite different: * <code>~left</code> considers the whole CSV structure, whereas <code>~right</code> considers * each row in isolation.</p></dd></dl><dl><dt class="spec value" id="val-square"><a href="#val-square" class="anchor"></a><code><span class="keyword">val</span> square : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Make the CSV data &quot;square&quot; (actually rectangular). This pads out * each row with empty cells so that all rows are the same length as * the longest row. After this operation, every row will have length * <a href="index.html#val-columns"><code>columns</code></a>.</p></dd></dl><dl><dt class="spec value" id="val-associate"><a href="#val-associate" class="anchor"></a><code><span class="keyword">val</span> associate : string list <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (string * string) list list</code></dt><dd><p><code>associate header data</code> takes a block of data and converts each * row in turn into an assoc list which maps column header to data cell. * * Typically a spreadsheet will have the format: * </p><pre>  *   header1   header2   header3
  *   data11    data12    data13
  *   data21    data22    data23
  *     ...
  *</pre><p>* * This function arranges the data into a more usable form which is * robust against changes in column ordering. The output of the * function is: * </p><pre>  *   [ [&quot;header1&quot;, &quot;data11&quot;; &quot;header2&quot;, &quot;data12&quot;; &quot;header3&quot;, &quot;data13&quot;];
  *     [&quot;header1&quot;, &quot;data21&quot;; &quot;header2&quot;, &quot;data22&quot;; &quot;header3&quot;, &quot;data23&quot;];
  *     etc. ]
  *</pre><p>* * Each row is turned into an assoc list (see <span class="xref-unresolved" title="unresolved reference to &quot;List.assoc&quot;"><code>List</code>.assoc</span>). * * If a row is too short, it is padded with empty cells (<code>&quot;&quot;</code>). If * a row is too long, it is truncated. * * You would typically call this function as: * * </p><pre>  * let header, data = match csv with h :: d -&gt; h, d | [] -&gt; assert false;;
  * let data = Csv.associate header data;;
  *</pre><p>* * The header strings are shared, so the actual space in memory consumed * by the spreadsheet is not much larger.</p></dd></dl><dl><dt class="spec value" id="val-print"><a href="#val-print" class="anchor"></a><code><span class="keyword">val</span> print : ?&#8288;separator:char <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Print string list list - same as <code>save_out stdout</code></p></dd></dl><dl><dt class="spec value" id="val-save_fn"><a href="#val-save_fn" class="anchor"></a><code><span class="keyword">val</span> save_fn : ?&#8288;separator:char <span>&#45;&gt;</span> (string <span>&#45;&gt;</span> unit) <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Save the string list list, writing the strings by calling the given * given functon.</p></dd></dl><dl><dt class="spec value" id="val-save_out"><a href="#val-save_out" class="anchor"></a><code><span class="keyword">val</span> save_out : ?&#8288;separator:char <span>&#45;&gt;</span> <a href="../../../ocaml/Stdlib/index.html#type-out_channel">Stdlib.out_channel</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Save string list list to a channel.</p></dd></dl><dl><dt class="spec value" id="val-save"><a href="#val-save" class="anchor"></a><code><span class="keyword">val</span> save : ?&#8288;separator:char <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Save string list list to a file.</p></dd></dl><dl><dt class="spec value" id="val-print_readable"><a href="#val-print_readable" class="anchor"></a><code><span class="keyword">val</span> print_readable : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Print the CSV data to <code>stdout</code> in a human-readable format. Not much * is guaranteed about how the CSV is printed, except that it will be * easier to follow than a &quot;raw&quot; output done with <a href="index.html#val-print"><code>print</code></a>. This is * a one-way operation. There is no easy way to parse the output of * this command back into CSV data.</p></dd></dl><dl><dt class="spec value" id="val-save_out_readable"><a href="#val-save_out_readable" class="anchor"></a><code><span class="keyword">val</span> save_out_readable : <a href="../../../ocaml/Stdlib/index.html#type-out_channel">Stdlib.out_channel</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>As for <a href="index.html#val-print_readable"><code>print_readable</code></a>, allowing the output to be sent to a channel.</p></dd></dl><dl><dt class="spec value" id="val-save_fn_readable"><a href="#val-save_fn_readable" class="anchor"></a><code><span class="keyword">val</span> save_fn_readable : (string <span>&#45;&gt;</span> unit) <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt></dl></div></body></html>