<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Ctypes (ctypes.Ctypes)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../index.html">ctypes</a> &#x00BB; Ctypes</nav><h1>Module <code>Ctypes</code></h1><p>The core ctypes module.</p><p>The main points of interest are the set of functions for describing C types (see <code>types</code>) and the set of functions for accessing C values (see <a href="index.html#values"><span>Values representing C values</span></a>). The <span class="xref-unresolved" title="unresolved reference to &quot;Foreign.foreign&quot;"><code>Foreign</code>.foreign</span> function uses C type descriptions to bind external C values.</p><nav class="toc"><ul><li><a href="#pointer_types">Pointer types</a></li><li><a href="#c-compatible-pointers">C-compatible pointers</a></li><li><a href="#c-array-types">C array types</a></li><li><a href="#bigarray-types">Bigarray types</a></li><li><a href="#struct-and-union-types">Struct and union types</a></li><li><a href="#operations-on-types">Operations on types</a></li><li><a href="#values">Values representing C values</a><ul><li><a href="#pointer-values">Pointer values</a></li><li><a href="#array-values">Array values</a><ul><li><a href="#c-array-values">C array values</a></li><li><a href="#bigarray-values">Bigarray values</a></li></ul></li><li><a href="#struct-and-union-values">Struct and union values</a></li><li><a href="#coercions">Coercions</a></li></ul></li><li><a href="#binding-interfaces">binding interfaces</a></li><li><a href="#exceptions">Exceptions</a></li></ul></nav></header><section><header><h5 id="pointer_types"><a href="#pointer_types" class="anchor"></a>Pointer types</h5></header><dl><dt class="spec type" id="type-pointer"><a href="#type-pointer" class="anchor"></a><code><span class="keyword">type </span>('a, 'b) pointer</code><code><span class="keyword"> = </span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>) Ctypes_static.pointer</code></dt><dd><p>The type of pointer values. A value of type <code>('a, [`C]) pointer</code> contains a C-compatible pointer, and a value of type <code>('a, [`OCaml]) pointer</code> contains a pointer to a value that can be moved by OCaml runtime.</p></dd></dl></section><section><header><h5 id="c-compatible-pointers"><a href="#c-compatible-pointers" class="anchor"></a>C-compatible pointers</h5></header><dl><dt class="spec type" id="type-ptr"><a href="#type-ptr" class="anchor"></a><code><span class="keyword">type </span>'a ptr</code><code><span class="keyword"> = </span>(<span class="type-var">'a</span>, [ `C ]) <a href="index.html#type-pointer">pointer</a></code></dt><dd><p>The type of C-compatible pointer values. A value of type <code>t ptr</code> can be used to read and write values of type <code>t</code> at particular addresses.</p></dd></dl><dl><dt class="spec type" id="type-ocaml"><a href="#type-ocaml" class="anchor"></a><code><span class="keyword">type </span>'a ocaml</code><code><span class="keyword"> = </span><span class="type-var">'a</span> Ctypes_static.ocaml</code></dt><dd><p>The type of pointer values pointing directly into OCaml values. <b>Pointers of this type should never be captured by external code</b>. In particular, functions accepting <code>'a ocaml</code> pointers must not invoke any OCaml code.</p></dd></dl></section><section><header><h5 id="c-array-types"><a href="#c-array-types" class="anchor"></a>C array types</h5></header><dl><dt class="spec type" id="type-carray"><a href="#type-carray" class="anchor"></a><code><span class="keyword">type </span>'a carray</code><code><span class="keyword"> = </span><span class="type-var">'a</span> Ctypes_static.carray</code></dt><dd><p>The type of C array values. A value of type <code>t carray</code> can be used to read and write array objects in C-managed storage.</p></dd></dl></section><section><header><h5 id="bigarray-types"><a href="#bigarray-types" class="anchor"></a>Bigarray types</h5></header><dl><dt class="spec type" id="type-bigarray_class"><a href="#type-bigarray_class" class="anchor"></a><code><span class="keyword">type </span>'a bigarray_class</code><code><span class="keyword"> = </span><span class="type-var">'a</span> Ctypes_static.bigarray_class</code></dt><dd><p>The type of Bigarray classes. There are four instances, one for each of the Bigarray submodules.</p></dd></dl><dl><dt class="spec value" id="val-genarray"><a href="#val-genarray" class="anchor"></a><code><span class="keyword">val </span>genarray : &lt; element : <span class="type-var">'a</span>; layout : <span class="type-var">'l</span>; ba_repr : <span class="type-var">'b</span>; bigarray : (<span class="type-var">'a</span>, <span class="type-var">'b</span>, <span class="type-var">'l</span>) Bigarray.Genarray.t; carray : <span class="type-var">'a</span> <a href="index.html#type-carray">carray</a>; dims : int array; &gt; <a href="index.html#type-bigarray_class">bigarray_class</a></code></dt><dd><p>The class of <span class="xref-unresolved" title="unresolved reference to &quot;Bigarray.Genarray.t&quot;"><span class="xref-unresolved" title="unresolved reference to &quot;Bigarray.Genarray&quot;"><code>Bigarray</code>.Genarray</span>.t</span> values</p></dd></dl><dl><dt class="spec value" id="val-array1"><a href="#val-array1" class="anchor"></a><code><span class="keyword">val </span>array1 : &lt; element : <span class="type-var">'a</span>; layout : <span class="type-var">'l</span>; ba_repr : <span class="type-var">'b</span>; bigarray : (<span class="type-var">'a</span>, <span class="type-var">'b</span>, <span class="type-var">'l</span>) Bigarray.Array1.t; carray : <span class="type-var">'a</span> <a href="index.html#type-carray">carray</a>; dims : int; &gt; <a href="index.html#type-bigarray_class">bigarray_class</a></code></dt><dd><p>The class of <span class="xref-unresolved" title="unresolved reference to &quot;Bigarray.Array1.t&quot;"><span class="xref-unresolved" title="unresolved reference to &quot;Bigarray.Array1&quot;"><code>Bigarray</code>.Array1</span>.t</span> values</p></dd></dl><dl><dt class="spec value" id="val-array2"><a href="#val-array2" class="anchor"></a><code><span class="keyword">val </span>array2 : &lt; element : <span class="type-var">'a</span>; layout : <span class="type-var">'l</span>; ba_repr : <span class="type-var">'b</span>; bigarray : (<span class="type-var">'a</span>, <span class="type-var">'b</span>, <span class="type-var">'l</span>) Bigarray.Array2.t; carray : <span class="type-var">'a</span> <a href="index.html#type-carray">carray</a> <a href="index.html#type-carray">carray</a>; dims : int<span class="keyword"> * </span>int; &gt; <a href="index.html#type-bigarray_class">bigarray_class</a></code></dt><dd><p>The class of <span class="xref-unresolved" title="unresolved reference to &quot;Bigarray.Array2.t&quot;"><span class="xref-unresolved" title="unresolved reference to &quot;Bigarray.Array2&quot;"><code>Bigarray</code>.Array2</span>.t</span> values</p></dd></dl><dl><dt class="spec value" id="val-array3"><a href="#val-array3" class="anchor"></a><code><span class="keyword">val </span>array3 : &lt; element : <span class="type-var">'a</span>; layout : <span class="type-var">'l</span>; ba_repr : <span class="type-var">'b</span>; bigarray : (<span class="type-var">'a</span>, <span class="type-var">'b</span>, <span class="type-var">'l</span>) Bigarray.Array3.t; carray : <span class="type-var">'a</span> <a href="index.html#type-carray">carray</a> <a href="index.html#type-carray">carray</a> <a href="index.html#type-carray">carray</a>; dims : int<span class="keyword"> * </span>int<span class="keyword"> * </span>int; &gt; <a href="index.html#type-bigarray_class">bigarray_class</a></code></dt><dd><p>The class of <span class="xref-unresolved" title="unresolved reference to &quot;Bigarray.Array3.t&quot;"><span class="xref-unresolved" title="unresolved reference to &quot;Bigarray.Array3&quot;"><code>Bigarray</code>.Array3</span>.t</span> values</p></dd></dl></section><section><header><h4 id="struct-and-union-types"><a href="#struct-and-union-types" class="anchor"></a>Struct and union types</h4></header><dl><dt class="spec type" id="type-structured"><a href="#type-structured" class="anchor"></a><code><span class="keyword">type </span>('a, 'kind) structured</code><code><span class="keyword"> = </span>(<span class="type-var">'a</span>, <span class="type-var">'kind</span>) Ctypes_static.structured</code></dt><dd><p>The base type of values representing C struct and union types. The <code>'kind</code> parameter is a polymorphic variant type indicating whether the type represents a struct (<code>`Struct</code>) or a union (<code>`Union</code>).</p></dd></dl><dl><dt class="spec type" id="type-structure"><a href="#type-structure" class="anchor"></a><code><span class="keyword">type </span>'a structure</code><code><span class="keyword"> = </span>(<span class="type-var">'a</span>, [ `Struct ]) <a href="index.html#type-structured">structured</a></code></dt><dd><p>The type of values representing C struct types.</p></dd></dl><dl><dt class="spec type" id="type-union"><a href="#type-union" class="anchor"></a><code><span class="keyword">type </span>'a union</code><code><span class="keyword"> = </span>(<span class="type-var">'a</span>, [ `Union ]) <a href="index.html#type-structured">structured</a></code></dt><dd><p>The type of values representing C union types.</p></dd></dl><dl><dt class="spec type" id="type-field"><a href="#type-field" class="anchor"></a><code><span class="keyword">type </span>('a, 't) field</code><code><span class="keyword"> = </span>(<span class="type-var">'a</span>, <span class="type-var">'t</span>) Ctypes_static.field</code></dt><dd><p>The type of values representing C struct or union members (called &quot;fields&quot; here). A value of type <code>(a, s) field</code> represents a field of type <code>a</code> in a struct or union of type <code>s</code>.</p></dd></dl><dl><dt class="spec type" id="type-abstract"><a href="#type-abstract" class="anchor"></a><code><span class="keyword">type </span>'a abstract</code><code><span class="keyword"> = </span><span class="type-var">'a</span> Ctypes_static.abstract</code></dt><dd><p>The type of abstract values. The purpose of the <code>abstract</code> type is to represent values whose type varies from platform to platform.</p><p>For example, the type <code>pthread_t</code> is a pointer on some platforms, an integer on other platforms, and a struct on a third set of platforms. One way to deal with this kind of situation is to have possibly-platform-specific code which interrogates the C type in some way to help determine an appropriate representation. Another way is to use <code>abstract</code>, leaving the representation opaque.</p><p>(Note, however, that although <code>pthread_t</code> is a convenient example, since the type used to implement it varies significantly across platforms, it's not actually a good match for <code>abstract</code>, since values of type <code>pthread_t</code> are passed and returned by value.)</p></dd></dl><div><div class="spec include"><div class="doc"><details open="open"><summary><span class="def"><code><span class="keyword">include </span>Ctypes_types.TYPE<span class="keyword"> with </span><span class="keyword">type </span>'a <a href="index.html">Ctypes</a>.typ<span class="keyword"> = </span><span class="type-var">'a</span> Ctypes_static.typ<span class="keyword"> and </span><span class="keyword">type </span>('a, 's) <a href="index.html">Ctypes</a>.field := (<span class="type-var">'a</span>, <span class="type-var">'s</span>) <a href="index.html#type-field">field</a></code></span></summary><dl><dt class="spec type" id="type-typ"><a href="#type-typ" class="anchor"></a><code><span class="keyword">type </span>'a typ</code><code><span class="keyword"> = </span><span class="type-var">'a</span> Ctypes_static.typ</code></dt></dl><dl><dt class="spec value" id="val-void"><a href="#val-void" class="anchor"></a><code><span class="keyword">val </span>void : unit <a href="index.html#type-typ">typ</a></code></dt><dt class="spec value" id="val-char"><a href="#val-char" class="anchor"></a><code><span class="keyword">val </span>char : char <a href="index.html#type-typ">typ</a></code></dt><dt class="spec value" id="val-schar"><a href="#val-schar" class="anchor"></a><code><span class="keyword">val </span>schar : int <a href="index.html#type-typ">typ</a></code></dt><dt class="spec value" id="val-short"><a href="#val-short" class="anchor"></a><code><span class="keyword">val </span>short : int <a href="index.html#type-typ">typ</a></code></dt><dt class="spec value" id="val-int"><a href="#val-int" class="anchor"></a><code><span class="keyword">val </span>int : int <a href="index.html#type-typ">typ</a></code></dt><dt class="spec value" id="val-long"><a href="#val-long" class="anchor"></a><code><span class="keyword">val </span>long : Signed.long <a href="index.html#type-typ">typ</a></code></dt><dt class="spec value" id="val-llong"><a href="#val-llong" class="anchor"></a><code><span class="keyword">val </span>llong : Signed.llong <a href="index.html#type-typ">typ</a></code></dt><dt class="spec value" id="val-nativeint"><a href="#val-nativeint" class="anchor"></a><code><span class="keyword">val </span>nativeint : nativeint <a href="index.html#type-typ">typ</a></code></dt><dt class="spec value" id="val-int8_t"><a href="#val-int8_t" class="anchor"></a><code><span class="keyword">val </span>int8_t : int <a href="index.html#type-typ">typ</a></code></dt><dt class="spec value" id="val-int16_t"><a href="#val-int16_t" class="anchor"></a><code><span class="keyword">val </span>int16_t : int <a href="index.html#type-typ">typ</a></code></dt><dt class="spec value" id="val-int32_t"><a href="#val-int32_t" class="anchor"></a><code><span class="keyword">val </span>int32_t : int32 <a href="index.html#type-typ">typ</a></code></dt><dt class="spec value" id="val-int64_t"><a href="#val-int64_t" class="anchor"></a><code><span class="keyword">val </span>int64_t : int64 <a href="index.html#type-typ">typ</a></code></dt></dl><div class="spec module" id="module-Intptr"><a href="#module-Intptr" class="anchor"></a><code><span class="keyword">module </span>Intptr : Signed.S</code></div><dl><dt class="spec value" id="val-intptr_t"><a href="#val-intptr_t" class="anchor"></a><code><span class="keyword">val </span>intptr_t : <a href="index.html#module-Intptr">Intptr</a>.t <a href="index.html#type-typ">typ</a></code></dt></dl><div class="spec module" id="module-Ptrdiff"><a href="#module-Ptrdiff" class="anchor"></a><code><span class="keyword">module </span>Ptrdiff : Signed.S</code></div><dl><dt class="spec value" id="val-ptrdiff_t"><a href="#val-ptrdiff_t" class="anchor"></a><code><span class="keyword">val </span>ptrdiff_t : <a href="index.html#module-Ptrdiff">Ptrdiff</a>.t <a href="index.html#type-typ">typ</a></code></dt><dt class="spec value" id="val-camlint"><a href="#val-camlint" class="anchor"></a><code><span class="keyword">val </span>camlint : int <a href="index.html#type-typ">typ</a></code></dt><dt class="spec value" id="val-uchar"><a href="#val-uchar" class="anchor"></a><code><span class="keyword">val </span>uchar : Unsigned.uchar <a href="index.html#type-typ">typ</a></code></dt><dt class="spec value" id="val-bool"><a href="#val-bool" class="anchor"></a><code><span class="keyword">val </span>bool : bool <a href="index.html#type-typ">typ</a></code></dt><dt class="spec value" id="val-uint8_t"><a href="#val-uint8_t" class="anchor"></a><code><span class="keyword">val </span>uint8_t : Unsigned.uint8 <a href="index.html#type-typ">typ</a></code></dt><dt class="spec value" id="val-uint16_t"><a href="#val-uint16_t" class="anchor"></a><code><span class="keyword">val </span>uint16_t : Unsigned.uint16 <a href="index.html#type-typ">typ</a></code></dt><dt class="spec value" id="val-uint32_t"><a href="#val-uint32_t" class="anchor"></a><code><span class="keyword">val </span>uint32_t : Unsigned.uint32 <a href="index.html#type-typ">typ</a></code></dt><dt class="spec value" id="val-uint64_t"><a href="#val-uint64_t" class="anchor"></a><code><span class="keyword">val </span>uint64_t : Unsigned.uint64 <a href="index.html#type-typ">typ</a></code></dt><dt class="spec value" id="val-size_t"><a href="#val-size_t" class="anchor"></a><code><span class="keyword">val </span>size_t : Unsigned.size_t <a href="index.html#type-typ">typ</a></code></dt><dt class="spec value" id="val-ushort"><a href="#val-ushort" class="anchor"></a><code><span class="keyword">val </span>ushort : Unsigned.ushort <a href="index.html#type-typ">typ</a></code></dt><dt class="spec value" id="val-sint"><a href="#val-sint" class="anchor"></a><code><span class="keyword">val </span>sint : Signed.sint <a href="index.html#type-typ">typ</a></code></dt><dt class="spec value" id="val-uint"><a href="#val-uint" class="anchor"></a><code><span class="keyword">val </span>uint : Unsigned.uint <a href="index.html#type-typ">typ</a></code></dt><dt class="spec value" id="val-ulong"><a href="#val-ulong" class="anchor"></a><code><span class="keyword">val </span>ulong : Unsigned.ulong <a href="index.html#type-typ">typ</a></code></dt><dt class="spec value" id="val-ullong"><a href="#val-ullong" class="anchor"></a><code><span class="keyword">val </span>ullong : Unsigned.ullong <a href="index.html#type-typ">typ</a></code></dt></dl><div class="spec module" id="module-Uintptr"><a href="#module-Uintptr" class="anchor"></a><code><span class="keyword">module </span>Uintptr : Unsigned.S</code></div><dl><dt class="spec value" id="val-uintptr_t"><a href="#val-uintptr_t" class="anchor"></a><code><span class="keyword">val </span>uintptr_t : <a href="index.html#module-Uintptr">Uintptr</a>.t <a href="index.html#type-typ">typ</a></code></dt><dt class="spec value" id="val-float"><a href="#val-float" class="anchor"></a><code><span class="keyword">val </span>float : float <a href="index.html#type-typ">typ</a></code></dt><dt class="spec value" id="val-double"><a href="#val-double" class="anchor"></a><code><span class="keyword">val </span>double : float <a href="index.html#type-typ">typ</a></code></dt><dt class="spec value" id="val-ldouble"><a href="#val-ldouble" class="anchor"></a><code><span class="keyword">val </span>ldouble : LDouble.t <a href="index.html#type-typ">typ</a></code></dt><dt class="spec value" id="val-complex32"><a href="#val-complex32" class="anchor"></a><code><span class="keyword">val </span>complex32 : Complex.t <a href="index.html#type-typ">typ</a></code></dt><dt class="spec value" id="val-complex64"><a href="#val-complex64" class="anchor"></a><code><span class="keyword">val </span>complex64 : Complex.t <a href="index.html#type-typ">typ</a></code></dt><dt class="spec value" id="val-complexld"><a href="#val-complexld" class="anchor"></a><code><span class="keyword">val </span>complexld : ComplexL.t <a href="index.html#type-typ">typ</a></code></dt><dt class="spec value" id="val-ptr"><a href="#val-ptr" class="anchor"></a><code><span class="keyword">val </span>ptr : <span class="type-var">'a</span> <a href="index.html#type-typ">typ</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> Ctypes_static.ptr <a href="index.html#type-typ">typ</a></code></dt><dt class="spec value" id="val-ptr_opt"><a href="#val-ptr_opt" class="anchor"></a><code><span class="keyword">val </span>ptr_opt : <span class="type-var">'a</span> <a href="index.html#type-typ">typ</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> Ctypes_static.ptr option <a href="index.html#type-typ">typ</a></code></dt><dt class="spec value" id="val-string"><a href="#val-string" class="anchor"></a><code><span class="keyword">val </span>string : string <a href="index.html#type-typ">typ</a></code></dt><dt class="spec value" id="val-string_opt"><a href="#val-string_opt" class="anchor"></a><code><span class="keyword">val </span>string_opt : string option <a href="index.html#type-typ">typ</a></code></dt><dt class="spec value" id="val-ocaml_string"><a href="#val-ocaml_string" class="anchor"></a><code><span class="keyword">val </span>ocaml_string : string Ctypes_static.ocaml <a href="index.html#type-typ">typ</a></code></dt><dt class="spec value" id="val-ocaml_bytes"><a href="#val-ocaml_bytes" class="anchor"></a><code><span class="keyword">val </span>ocaml_bytes : Bytes.t Ctypes_static.ocaml <a href="index.html#type-typ">typ</a></code></dt><dt class="spec value" id="val-array"><a href="#val-array" class="anchor"></a><code><span class="keyword">val </span>array : int <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-typ">typ</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> Ctypes_static.carray <a href="index.html#type-typ">typ</a></code></dt><dt class="spec value" id="val-bigarray"><a href="#val-bigarray" class="anchor"></a><code><span class="keyword">val </span>bigarray : &lt; ba_repr : <span class="type-var">'b</span>; bigarray : <span class="type-var">'bigarray</span>; carray : <span class="type-var">'c</span>; dims : <span class="type-var">'dims</span>; element : <span class="type-var">'a</span>; layout : Bigarray.c_layout; &gt; Ctypes_static.bigarray_class <span>&#45;&gt;</span> <span class="type-var">'dims</span> <span>&#45;&gt;</span> (<span class="type-var">'a</span>, <span class="type-var">'b</span>) Bigarray.kind <span>&#45;&gt;</span> <span class="type-var">'bigarray</span> <a href="index.html#type-typ">typ</a></code></dt><dt class="spec value" id="val-fortran_bigarray"><a href="#val-fortran_bigarray" class="anchor"></a><code><span class="keyword">val </span>fortran_bigarray : &lt; ba_repr : <span class="type-var">'b</span>; bigarray : <span class="type-var">'bigarray</span>; carray : <span class="type-var">'c</span>; dims : <span class="type-var">'dims</span>; element : <span class="type-var">'a</span>; layout : Bigarray.fortran_layout; &gt; Ctypes_static.bigarray_class <span>&#45;&gt;</span> <span class="type-var">'dims</span> <span>&#45;&gt;</span> (<span class="type-var">'a</span>, <span class="type-var">'b</span>) Bigarray.kind <span>&#45;&gt;</span> <span class="type-var">'bigarray</span> <a href="index.html#type-typ">typ</a></code></dt><dt class="spec value" id="val-typ_of_bigarray_kind"><a href="#val-typ_of_bigarray_kind" class="anchor"></a><code><span class="keyword">val </span>typ_of_bigarray_kind : (<span class="type-var">'a</span>, <span class="type-var">'b</span>) Bigarray.kind <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-typ">typ</a></code></dt><dt class="spec value" id="val-structure"><a href="#val-structure" class="anchor"></a><code><span class="keyword">val </span>structure : string <span>&#45;&gt;</span> <span class="type-var">'s</span> Ctypes_static.structure <a href="index.html#type-typ">typ</a></code></dt><dt class="spec value" id="val-union"><a href="#val-union" class="anchor"></a><code><span class="keyword">val </span>union : string <span>&#45;&gt;</span> <span class="type-var">'s</span> Ctypes_static.union <a href="index.html#type-typ">typ</a></code></dt><dt class="spec value" id="val-field"><a href="#val-field" class="anchor"></a><code><span class="keyword">val </span>field : (<span class="type-var">'s</span>, [&lt; `Struct<span class="keyword"> | </span>`Union ]<span class="keyword"> as </span>b) Ctypes_static.structured <a href="index.html#type-typ">typ</a> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-typ">typ</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span>, (<span class="type-var">'s</span>, <span class="type-var">'b</span>) Ctypes_static.structured) <a href="index.html#type-field">field</a></code></dt><dt class="spec value" id="val-seal"><a href="#val-seal" class="anchor"></a><code><span class="keyword">val </span>seal : (<span class="type-var">'a</span>, [&lt; `Struct<span class="keyword"> | </span>`Union ]) Ctypes_static.structured <a href="index.html#type-typ">typ</a> <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-view"><a href="#val-view" class="anchor"></a><code><span class="keyword">val </span>view : ?&#8288;format_typ:((Format.formatter <span>&#45;&gt;</span> unit) <span>&#45;&gt;</span> Format.formatter <span>&#45;&gt;</span> unit) <span>&#45;&gt;</span> ?&#8288;format:(Format.formatter <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> unit) <span>&#45;&gt;</span> read:(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>) <span>&#45;&gt;</span> write:(<span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'a</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-typ">typ</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-typ">typ</a></code></dt><dt class="spec value" id="val-typedef"><a href="#val-typedef" class="anchor"></a><code><span class="keyword">val </span>typedef : <span class="type-var">'a</span> <a href="index.html#type-typ">typ</a> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-typ">typ</a></code></dt><dt class="spec value" id="val-abstract"><a href="#val-abstract" class="anchor"></a><code><span class="keyword">val </span>abstract : name:string <span>&#45;&gt;</span> size:int <span>&#45;&gt;</span> alignment:int <span>&#45;&gt;</span> <span class="type-var">'a</span> Ctypes_static.abstract <a href="index.html#type-typ">typ</a></code></dt><dt class="spec value" id="val-lift_typ"><a href="#val-lift_typ" class="anchor"></a><code><span class="keyword">val </span>lift_typ : <span class="type-var">'a</span> Ctypes_static.typ <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-typ">typ</a></code></dt></dl><dl><dt class="spec type" id="type-fn"><a href="#type-fn" class="anchor"></a><code><span class="keyword">type </span>'a fn</code><code><span class="keyword"> = </span><span class="type-var">'a</span> Ctypes_static.fn</code></dt></dl><dl><dt class="spec value" id="val-(@-&gt;)"><a href="#val-(@-&gt;)" class="anchor"></a><code><span class="keyword">val </span>(@-&gt;) : <span class="type-var">'a</span> <a href="index.html#type-typ">typ</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-fn">fn</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>) <a href="index.html#type-fn">fn</a></code></dt><dt class="spec value" id="val-returning"><a href="#val-returning" class="anchor"></a><code><span class="keyword">val </span>returning : <span class="type-var">'a</span> <a href="index.html#type-typ">typ</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-fn">fn</a></code></dt></dl><dl><dt class="spec type" id="type-static_funptr"><a href="#type-static_funptr" class="anchor"></a><code><span class="keyword">type </span>'a static_funptr</code><code><span class="keyword"> = </span><span class="type-var">'a</span> Ctypes_static.static_funptr</code></dt></dl><dl><dt class="spec value" id="val-static_funptr"><a href="#val-static_funptr" class="anchor"></a><code><span class="keyword">val </span>static_funptr : <span class="type-var">'a</span> <a href="index.html#type-fn">fn</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> Ctypes_static.static_funptr <a href="index.html#type-typ">typ</a></code></dt></dl></details></div></div></div></section><section><header><h4 id="operations-on-types"><a href="#operations-on-types" class="anchor"></a>Operations on types</h4></header><dl><dt class="spec value" id="val-sizeof"><a href="#val-sizeof" class="anchor"></a><code><span class="keyword">val </span>sizeof : <span class="type-var">'a</span> <a href="index.html#type-typ">typ</a> <span>&#45;&gt;</span> int</code></dt><dd><p><code>sizeof t</code> computes the size in bytes of the type <code>t</code>. The exception <a href="index.html#exception-IncompleteType"><code>IncompleteType</code></a> is raised if <code>t</code> is incomplete.</p></dd></dl><dl><dt class="spec value" id="val-alignment"><a href="#val-alignment" class="anchor"></a><code><span class="keyword">val </span>alignment : <span class="type-var">'a</span> <a href="index.html#type-typ">typ</a> <span>&#45;&gt;</span> int</code></dt><dd><p><code>alignment t</code> computes the alignment requirements of the type <code>t</code>. The exception <a href="index.html#exception-IncompleteType"><code>IncompleteType</code></a> is raised if <code>t</code> is incomplete.</p></dd></dl><dl><dt class="spec value" id="val-format_typ"><a href="#val-format_typ" class="anchor"></a><code><span class="keyword">val </span>format_typ : ?&#8288;name:string <span>&#45;&gt;</span> Format.formatter <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-typ">typ</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Pretty-print a C representation of the type to the specified formatter.</p></dd></dl><dl><dt class="spec value" id="val-format_fn"><a href="#val-format_fn" class="anchor"></a><code><span class="keyword">val </span>format_fn : ?&#8288;name:string <span>&#45;&gt;</span> Format.formatter <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-fn">fn</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Pretty-print a C representation of the function type to the specified formatter.</p></dd></dl><dl><dt class="spec value" id="val-string_of_typ"><a href="#val-string_of_typ" class="anchor"></a><code><span class="keyword">val </span>string_of_typ : ?&#8288;name:string <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-typ">typ</a> <span>&#45;&gt;</span> string</code></dt><dd><p>Return a C representation of the type.</p></dd></dl><dl><dt class="spec value" id="val-string_of_fn"><a href="#val-string_of_fn" class="anchor"></a><code><span class="keyword">val </span>string_of_fn : ?&#8288;name:string <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-fn">fn</a> <span>&#45;&gt;</span> string</code></dt><dd><p>Return a C representation of the function type.</p></dd></dl></section><section><header><h3 id="values"><a href="#values" class="anchor"></a>Values representing C values</h3></header><dl><dt class="spec value" id="val-format"><a href="#val-format" class="anchor"></a><code><span class="keyword">val </span>format : <span class="type-var">'a</span> <a href="index.html#type-typ">typ</a> <span>&#45;&gt;</span> Format.formatter <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> unit</code></dt><dd><p>Pretty-print a representation of the C value to the specified formatter.</p></dd></dl><dl><dt class="spec value" id="val-string_of"><a href="#val-string_of" class="anchor"></a><code><span class="keyword">val </span>string_of : <span class="type-var">'a</span> <a href="index.html#type-typ">typ</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> string</code></dt><dd><p>Return a string representation of the C value.</p></dd></dl><section><header><h4 id="pointer-values"><a href="#pointer-values" class="anchor"></a>Pointer values</h4></header><dl><dt class="spec value" id="val-null"><a href="#val-null" class="anchor"></a><code><span class="keyword">val </span>null : unit <a href="index.html#type-ptr">ptr</a></code></dt><dd><p>A null pointer.</p></dd></dl><dl><dt class="spec value" id="val-(!@)"><a href="#val-(!@)" class="anchor"></a><code><span class="keyword">val </span>(!@) : <span class="type-var">'a</span> <a href="index.html#type-ptr">ptr</a> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p><code>!@ p</code> dereferences the pointer <code>p</code>. If the reference type is a scalar type then dereferencing constructs a new value. If the reference type is an aggregate type then dereferencing returns a value that references the memory pointed to by <code>p</code>.</p></dd></dl><dl><dt class="spec value" id="val-(&lt;-@)"><a href="#val-(&lt;-@)" class="anchor"></a><code><span class="keyword">val </span>(&lt;-@) : <span class="type-var">'a</span> <a href="index.html#type-ptr">ptr</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>p &lt;-@ v</code> writes the value <code>v</code> to the address <code>p</code>.</p></dd></dl><dl><dt class="spec value" id="val-(+@)"><a href="#val-(+@)" class="anchor"></a><code><span class="keyword">val </span>(+@) : (<span class="type-var">'a</span>, <span class="type-var">'b</span>) <a href="index.html#type-pointer">pointer</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> (<span class="type-var">'a</span>, <span class="type-var">'b</span>) <a href="index.html#type-pointer">pointer</a></code></dt><dd><p>If <code>p</code> is a pointer to an array element then <code>p +@ n</code> computes the address of the <code>n</code>th next element.</p></dd></dl><dl><dt class="spec value" id="val-(-@)"><a href="#val-(-@)" class="anchor"></a><code><span class="keyword">val </span>(-@) : (<span class="type-var">'a</span>, <span class="type-var">'b</span>) <a href="index.html#type-pointer">pointer</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> (<span class="type-var">'a</span>, <span class="type-var">'b</span>) <a href="index.html#type-pointer">pointer</a></code></dt><dd><p>If <code>p</code> is a pointer to an array element then <code>p -@ n</code> computes the address of the nth previous element.</p></dd></dl><dl><dt class="spec value" id="val-ptr_diff"><a href="#val-ptr_diff" class="anchor"></a><code><span class="keyword">val </span>ptr_diff : (<span class="type-var">'a</span>, <span class="type-var">'b</span>) <a href="index.html#type-pointer">pointer</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span>, <span class="type-var">'b</span>) <a href="index.html#type-pointer">pointer</a> <span>&#45;&gt;</span> int</code></dt><dd><p><code>ptr_diff p q</code> computes <code>q - p</code>. As in C, both <code>p</code> and <code>q</code> must point into the same array, and the result value is the difference of the subscripts of the two array elements.</p></dd></dl><dl><dt class="spec value" id="val-from_voidp"><a href="#val-from_voidp" class="anchor"></a><code><span class="keyword">val </span>from_voidp : <span class="type-var">'a</span> <a href="index.html#type-typ">typ</a> <span>&#45;&gt;</span> unit <a href="index.html#type-ptr">ptr</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-ptr">ptr</a></code></dt><dd><p>Conversion from <code>void *</code>.</p></dd></dl><dl><dt class="spec value" id="val-to_voidp"><a href="#val-to_voidp" class="anchor"></a><code><span class="keyword">val </span>to_voidp : <span class="type-var">_</span> <a href="index.html#type-ptr">ptr</a> <span>&#45;&gt;</span> unit <a href="index.html#type-ptr">ptr</a></code></dt><dd><p>Conversion to <code>void *</code>.</p></dd></dl><dl><dt class="spec value" id="val-allocate"><a href="#val-allocate" class="anchor"></a><code><span class="keyword">val </span>allocate : ?&#8288;finalise:(<span class="type-var">'a</span> <a href="index.html#type-ptr">ptr</a> <span>&#45;&gt;</span> unit) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-typ">typ</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-ptr">ptr</a></code></dt><dd><p><code>allocate t v</code> allocates a fresh value of type <code>t</code>, initialises it with <code>v</code> and returns its address. The argument <code>?finalise</code>, if present, will be called just before the memory is freed. The value will be automatically freed after no references to the pointer remain within the calling OCaml program.</p></dd></dl><dl><dt class="spec value" id="val-allocate_n"><a href="#val-allocate_n" class="anchor"></a><code><span class="keyword">val </span>allocate_n : ?&#8288;finalise:(<span class="type-var">'a</span> <a href="index.html#type-ptr">ptr</a> <span>&#45;&gt;</span> unit) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-typ">typ</a> <span>&#45;&gt;</span> count:int <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-ptr">ptr</a></code></dt><dd><p><code>allocate_n t ~count:n</code> allocates a fresh array with element type <code>t</code> and length <code>n</code>, and returns its address. The argument <code>?finalise</code>, if present, will be called just before the memory is freed. The array will be automatically freed after no references to the pointer remain within the calling OCaml program. The memory is allocated with libc's <code>calloc</code> and is guaranteed to be zero-filled.</p></dd></dl><dl><dt class="spec value" id="val-ptr_compare"><a href="#val-ptr_compare" class="anchor"></a><code><span class="keyword">val </span>ptr_compare : <span class="type-var">'a</span> <a href="index.html#type-ptr">ptr</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-ptr">ptr</a> <span>&#45;&gt;</span> int</code></dt><dd><p>If <code>p</code> and <code>q</code> are pointers to elements <code>i</code> and <code>j</code> of the same array then <code>ptr_compare p q</code> compares the indexes of the elements. The result is negative if <code>i</code> is less than <code>j</code>, positive if <code>i</code> is greater than <code>j</code>, and zero if <code>i</code> and <code>j</code> are equal.</p></dd></dl><dl><dt class="spec value" id="val-is_null"><a href="#val-is_null" class="anchor"></a><code><span class="keyword">val </span>is_null : <span class="type-var">'a</span> <a href="index.html#type-ptr">ptr</a> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>is_null p</code> is true when <code>p</code> is a null pointer.</p></dd></dl><dl><dt class="spec value" id="val-reference_type"><a href="#val-reference_type" class="anchor"></a><code><span class="keyword">val </span>reference_type : <span class="type-var">'a</span> <a href="index.html#type-ptr">ptr</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-typ">typ</a></code></dt><dd><p>Retrieve the reference type of a pointer.</p></dd></dl><dl><dt class="spec value" id="val-ptr_of_raw_address"><a href="#val-ptr_of_raw_address" class="anchor"></a><code><span class="keyword">val </span>ptr_of_raw_address : nativeint <span>&#45;&gt;</span> unit <a href="index.html#type-ptr">ptr</a></code></dt><dd><p>Convert the numeric representation of an address to a pointer</p></dd></dl><dl><dt class="spec value" id="val-funptr_of_raw_address"><a href="#val-funptr_of_raw_address" class="anchor"></a><code><span class="keyword">val </span>funptr_of_raw_address : nativeint <span>&#45;&gt;</span> (unit <span>&#45;&gt;</span> unit) Ctypes_static.static_funptr</code></dt><dd><p>Convert the numeric representation of an address to a function pointer</p></dd></dl><dl><dt class="spec value" id="val-raw_address_of_ptr"><a href="#val-raw_address_of_ptr" class="anchor"></a><code><span class="keyword">val </span>raw_address_of_ptr : unit <a href="index.html#type-ptr">ptr</a> <span>&#45;&gt;</span> nativeint</code></dt><dd><p><code>raw_address_of_ptr p</code> returns the numeric representation of p.</p><p>Note that the return value remains valid only as long as the pointed-to object is alive. If <code>p</code> is a managed object (e.g. a value returned by <a href="index.html#val-make"><code>make</code></a>) then unless the caller retains a reference to <code>p</code>, the object may be collected, invalidating the returned address.</p></dd></dl><dl><dt class="spec value" id="val-string_from_ptr"><a href="#val-string_from_ptr" class="anchor"></a><code><span class="keyword">val </span>string_from_ptr : char <a href="index.html#type-ptr">ptr</a> <span>&#45;&gt;</span> length:int <span>&#45;&gt;</span> string</code></dt><dd><p><code>string_from_ptr p ~length</code> creates a string initialized with the <code>length</code> characters at address <code>p</code>.</p><p>Raise <code>Invalid_argument &quot;Ctypes.string_from_ptr&quot;</code> if <code>length</code> is negative.</p></dd></dl><dl><dt class="spec value" id="val-ocaml_string_start"><a href="#val-ocaml_string_start" class="anchor"></a><code><span class="keyword">val </span>ocaml_string_start : string <span>&#45;&gt;</span> string <a href="index.html#type-ocaml">ocaml</a></code></dt><dd><p><code>ocaml_string_start s</code> allows to pass a pointer to the contents of an OCaml string directly to a C function.</p></dd></dl><dl><dt class="spec value" id="val-ocaml_bytes_start"><a href="#val-ocaml_bytes_start" class="anchor"></a><code><span class="keyword">val </span>ocaml_bytes_start : Bytes.t <span>&#45;&gt;</span> Bytes.t <a href="index.html#type-ocaml">ocaml</a></code></dt><dd><p><code>ocaml_bytes_start s</code> allows to pass a pointer to the contents of an OCaml byte array directly to a C function.</p></dd></dl></section><section><header><h4 id="array-values"><a href="#array-values" class="anchor"></a>Array values</h4></header><section><header><h5 id="c-array-values"><a href="#c-array-values" class="anchor"></a>C array values</h5></header><dl><dt class="spec module" id="module-CArray"><a href="#module-CArray" class="anchor"></a><code><span class="keyword">module </span><a href="CArray/index.html">CArray</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Operations on C arrays.</p></dd></dl></section><section><header><h5 id="bigarray-values"><a href="#bigarray-values" class="anchor"></a>Bigarray values</h5></header><dl><dt class="spec value" id="val-bigarray_start"><a href="#val-bigarray_start" class="anchor"></a><code><span class="keyword">val </span>bigarray_start : &lt; element : <span class="type-var">'a</span>; layout : <span class="type-var">'l</span>; ba_repr : <span class="type-var">_</span>; bigarray : <span class="type-var">'b</span>; carray : <span class="type-var">_</span>; dims : <span class="type-var">_</span>; &gt; <a href="index.html#type-bigarray_class">bigarray_class</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-ptr">ptr</a></code></dt><dd><p>Return the address of the first element of the given Bigarray value.</p></dd></dl><dl><dt class="spec value" id="val-bigarray_of_ptr"><a href="#val-bigarray_of_ptr" class="anchor"></a><code><span class="keyword">val </span>bigarray_of_ptr : &lt; element : <span class="type-var">'a</span>; layout : Bigarray.c_layout; ba_repr : <span class="type-var">'f</span>; bigarray : <span class="type-var">'b</span>; carray : <span class="type-var">_</span>; dims : <span class="type-var">'i</span>; &gt; <a href="index.html#type-bigarray_class">bigarray_class</a> <span>&#45;&gt;</span> <span class="type-var">'i</span> <span>&#45;&gt;</span> (<span class="type-var">'a</span>, <span class="type-var">'f</span>) Bigarray.kind <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-ptr">ptr</a> <span>&#45;&gt;</span> <span class="type-var">'b</span></code></dt><dd><p><code>bigarray_of_ptr c dims k p</code> converts the C pointer <code>p</code> to a C-layout bigarray value. No copy is made; the bigarray references the memory pointed to by <code>p</code>.</p></dd></dl><dl><dt class="spec value" id="val-fortran_bigarray_of_ptr"><a href="#val-fortran_bigarray_of_ptr" class="anchor"></a><code><span class="keyword">val </span>fortran_bigarray_of_ptr : &lt; element : <span class="type-var">'a</span>; layout : Bigarray.fortran_layout; ba_repr : <span class="type-var">'f</span>; bigarray : <span class="type-var">'b</span>; carray : <span class="type-var">_</span>; dims : <span class="type-var">'i</span>; &gt; <a href="index.html#type-bigarray_class">bigarray_class</a> <span>&#45;&gt;</span> <span class="type-var">'i</span> <span>&#45;&gt;</span> (<span class="type-var">'a</span>, <span class="type-var">'f</span>) Bigarray.kind <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-ptr">ptr</a> <span>&#45;&gt;</span> <span class="type-var">'b</span></code></dt><dd><p><code>fortran_bigarray_of_ptr c dims k p</code> converts the C pointer <code>p</code> to a Fortran-layout bigarray value. No copy is made; the bigarray references the memory pointed to by <code>p</code>.</p></dd></dl><dl><dt class="spec value" id="val-array_of_bigarray"><a href="#val-array_of_bigarray" class="anchor"></a><code><span class="keyword">val </span>array_of_bigarray : &lt; element : <span class="type-var">_</span>; layout : Bigarray.c_layout; ba_repr : <span class="type-var">_</span>; bigarray : <span class="type-var">'b</span>; carray : <span class="type-var">'c</span>; dims : <span class="type-var">_</span>; &gt; <a href="index.html#type-bigarray_class">bigarray_class</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'c</span></code></dt><dd><p><code>array_of_bigarray c b</code> converts the bigarray value <code>b</code> to a value of type <a href="CArray/index.html#type-t"><code>CArray.t</code></a>. No copy is made; the result occupies the same memory as <code>b</code>.</p></dd></dl><aside><p>Convert a Bigarray value to a C array.</p></aside><dl><dt class="spec value" id="val-bigarray_of_array"><a href="#val-bigarray_of_array" class="anchor"></a><code><span class="keyword">val </span>bigarray_of_array : &lt; element : <span class="type-var">'a</span>; layout : Bigarray.c_layout; ba_repr : <span class="type-var">'f</span>; bigarray : <span class="type-var">'b</span>; carray : <span class="type-var">'c</span> <a href="index.html#type-carray">carray</a>; dims : <span class="type-var">'i</span>; &gt; <a href="index.html#type-bigarray_class">bigarray_class</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span>, <span class="type-var">'f</span>) Bigarray.kind <span>&#45;&gt;</span> <span class="type-var">'c</span> <a href="index.html#type-carray">carray</a> <span>&#45;&gt;</span> <span class="type-var">'b</span></code></dt><dd><p><code>bigarray_of_array c k a</code> converts the <a href="CArray/index.html#type-t"><code>CArray.t</code></a> value <code>a</code> to a C-layout bigarray value. No copy is made; the result occupies the same memory as <code>a</code>.</p></dd></dl></section></section><section><header><h4 id="struct-and-union-values"><a href="#struct-and-union-values" class="anchor"></a>Struct and union values</h4></header><dl><dt class="spec value" id="val-make"><a href="#val-make" class="anchor"></a><code><span class="keyword">val </span>make : ?&#8288;finalise:(<span class="type-var">'s</span> <span>&#45;&gt;</span> unit) <span>&#45;&gt;</span> (<span class="type-var">_</span>, <span class="type-var">_</span>) <a href="index.html#type-structured">structured</a><span class="keyword"> as </span>s <a href="index.html#type-typ">typ</a> <span>&#45;&gt;</span> <span class="type-var">'s</span></code></dt><dd><p>Allocate a fresh, uninitialised structure or union value. The argument <code>?finalise</code>, if present, will be called just before the underlying memory is freed.</p></dd></dl><dl><dt class="spec value" id="val-setf"><a href="#val-setf" class="anchor"></a><code><span class="keyword">val </span>setf : (<span class="type-var">_</span>, <span class="type-var">_</span>) <a href="index.html#type-structured">structured</a><span class="keyword"> as </span>s <span>&#45;&gt;</span> (<span class="type-var">'a</span>, <span class="type-var">'s</span>) <a href="index.html#type-field">field</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>setf s f v</code> overwrites the value of the field <code>f</code> in the structure or union <code>s</code> with <code>v</code>.</p></dd></dl><dl><dt class="spec value" id="val-getf"><a href="#val-getf" class="anchor"></a><code><span class="keyword">val </span>getf : (<span class="type-var">_</span>, <span class="type-var">_</span>) <a href="index.html#type-structured">structured</a><span class="keyword"> as </span>s <span>&#45;&gt;</span> (<span class="type-var">'a</span>, <span class="type-var">'s</span>) <a href="index.html#type-field">field</a> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p><code>getf s f</code> retrieves the value of the field <code>f</code> in the structure or union <code>s</code>. The semantics for non-scalar types are non-copying, as for <a href="index.html#val-(!@)"><code>(!@)</code></a>.</p></dd></dl><dl><dt class="spec value" id="val-(@.)"><a href="#val-(@.)" class="anchor"></a><code><span class="keyword">val </span>(@.) : (<span class="type-var">_</span>, <span class="type-var">_</span>) <a href="index.html#type-structured">structured</a><span class="keyword"> as </span>s <span>&#45;&gt;</span> (<span class="type-var">'a</span>, <span class="type-var">'s</span>) <a href="index.html#type-field">field</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-ptr">ptr</a></code></dt><dd><p><code>s @. f</code> computes the address of the field <code>f</code> in the structure or union value <code>s</code>.</p></dd></dl><dl><dt class="spec value" id="val-(|-&gt;)"><a href="#val-(|-&gt;)" class="anchor"></a><code><span class="keyword">val </span>(|-&gt;) : (<span class="type-var">_</span>, <span class="type-var">_</span>) <a href="index.html#type-structured">structured</a><span class="keyword"> as </span>s <a href="index.html#type-ptr">ptr</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span>, <span class="type-var">'s</span>) <a href="index.html#type-field">field</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-ptr">ptr</a></code></dt><dd><p><code>p |-&gt; f</code> computes the address of the field <code>f</code> in the structure or union value pointed to by <code>p</code>.</p></dd></dl><dl><dt class="spec value" id="val-offsetof"><a href="#val-offsetof" class="anchor"></a><code><span class="keyword">val </span>offsetof : (<span class="type-var">_</span>, <span class="type-var">_</span> <a href="index.html#type-structure">structure</a>) <a href="index.html#type-field">field</a> <span>&#45;&gt;</span> int</code></dt><dd><p><code>offsetof f</code> returns the offset, in bytes, of the field <code>f</code> from the beginning of the associated struct type.</p></dd></dl><dl><dt class="spec value" id="val-field_type"><a href="#val-field_type" class="anchor"></a><code><span class="keyword">val </span>field_type : (<span class="type-var">'a</span>, <span class="type-var">_</span>) <a href="index.html#type-field">field</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-typ">typ</a></code></dt><dd><p><code>field_type f</code> returns the type of the field <code>f</code>.</p></dd></dl><dl><dt class="spec value" id="val-field_name"><a href="#val-field_name" class="anchor"></a><code><span class="keyword">val </span>field_name : (<span class="type-var">_</span>, <span class="type-var">_</span>) <a href="index.html#type-field">field</a> <span>&#45;&gt;</span> string</code></dt><dd><p><code>field_name f</code> returns the name of the field <code>f</code>.</p></dd></dl><dl><dt class="spec value" id="val-addr"><a href="#val-addr" class="anchor"></a><code><span class="keyword">val </span>addr : (<span class="type-var">_</span>, <span class="type-var">_</span>) <a href="index.html#type-structured">structured</a><span class="keyword"> as </span>s <span>&#45;&gt;</span> <span class="type-var">'s</span> <a href="index.html#type-ptr">ptr</a></code></dt><dd><p><code>addr s</code> returns the address of the structure or union <code>s</code>.</p></dd></dl></section><section><header><h4 id="coercions"><a href="#coercions" class="anchor"></a>Coercions</h4></header><dl><dt class="spec value" id="val-coerce"><a href="#val-coerce" class="anchor"></a><code><span class="keyword">val </span>coerce : <span class="type-var">'a</span> <a href="index.html#type-typ">typ</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-typ">typ</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span></code></dt><dd><p><code>coerce t1 t2</code> returns a coercion function between the types represented by <code>t1</code> and <code>t2</code>. If <code>t1</code> cannot be coerced to <code>t2</code>, <code>coerce</code> raises <a href="index.html#exception-Uncoercible"><code>Uncoercible</code></a>.</p><p>The following coercions are currently supported:</p><ul><li>All function and object pointer types are intercoercible.</li><li>Any type may be coerced to <a href="index.html#val-void"><code>void</code></a></li><li>There is a coercion between a <a href="index.html#val-view"><code>view</code></a> and another type <code>t</code> (in either direction) if there is a coercion between the representation type underlying the view and <code>t</code>.</li><li>Coercion is transitive: if <code>t1</code> is coercible to <code>t2</code> and <code>t2</code> is coercible to <code>t3</code>, then <code>t1</code> is directly coercible to <code>t3</code>.</li></ul><p>The set of supported coercions is subject to change. Future versions of ctypes may both add new types of coercion and restrict the existing coercions.</p></dd></dl><dl><dt class="spec value" id="val-coerce_fn"><a href="#val-coerce_fn" class="anchor"></a><code><span class="keyword">val </span>coerce_fn : <span class="type-var">'a</span> <a href="index.html#type-fn">fn</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-fn">fn</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span></code></dt><dd><p><code>coerce_fn f1 f2</code> returns a coercion function between the function types represented by <code>f1</code> and <code>f2</code>. If <code>f1</code> cannot be coerced to <code>f2</code>, <code>coerce_fn</code> raises <a href="index.html#exception-Uncoercible"><code>Uncoercible</code></a>.</p><p>A function type <code>f1</code> may be coerced to another function type <code>f2</code> if all of the following hold:</p><ul><li>the C types described by <code>f1</code> and <code>f2</code> have the same arity</li></ul><ul><li>each argument of <code>f2</code> may be coerced to the corresponding argument of <code>f1</code></li></ul><ul><li>the return type of <code>f1</code> may be coerced to the return type of <code>f2</code></li></ul><p>The set of supported coercions is subject to change. Future versions of ctypes may both add new types of coercion and restrict the existing coercions.</p></dd></dl></section></section><section><header><h3 id="binding-interfaces"><a href="#binding-interfaces" class="anchor"></a>binding interfaces</h3><p>.</p></header><dl><dt class="spec module-type" id="module-type-FOREIGN"><a href="#module-type-FOREIGN" class="anchor"></a><code><span class="keyword">module type </span><a href="module-type-FOREIGN/index.html">FOREIGN</a> = <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Foreign function binding interface.</p></dd></dl><dl><dt class="spec module-type" id="module-type-TYPE"><a href="#module-type-TYPE" class="anchor"></a><code><span class="keyword">module type </span><a href="module-type-TYPE/index.html">TYPE</a> = <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Foreign types binding interface.</p></dd></dl><dl><dt class="spec module" id="module-Root"><a href="#module-Root" class="anchor"></a><code><span class="keyword">module </span><a href="Root/index.html">Root</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd></dd></dl></section><section><header><h3 id="exceptions"><a href="#exceptions" class="anchor"></a>Exceptions</h3></header><dl><dt class="spec exception" id="exception-Unsupported"><a href="#exception-Unsupported" class="anchor"></a><code><span class="keyword">exception </span></code><code><span class="exception">Unsupported</span><span class="keyword"> of </span>string</code></dt><dd><p>An attempt was made to use a feature not currently supported by ctypes. In practice this refers to attempts to use an union, array or abstract type as an argument or return type of a function.</p></dd></dl><dl><dt class="spec exception" id="exception-ModifyingSealedType"><a href="#exception-ModifyingSealedType" class="anchor"></a><code><span class="keyword">exception </span></code><code><span class="exception">ModifyingSealedType</span><span class="keyword"> of </span>string</code></dt><dd><p>An attempt was made to modify a sealed struct or union type description.</p></dd></dl><dl><dt class="spec exception" id="exception-IncompleteType"><a href="#exception-IncompleteType" class="anchor"></a><code><span class="keyword">exception </span></code><code><span class="exception">IncompleteType</span></code></dt><dd><p>An attempt was made to compute the size or alignment of an incomplete type.</p><p>The incomplete types are struct and union types that have not been sealed, and the void type.</p><p>It is not permitted to compute the size or alignment requirements of an incomplete type, to use it as a struct or union member, to read or write a value of the type through a pointer or to use it as the referenced type in pointer arithmetic. Additionally, incomplete struct and union types cannot be used as argument or return types.</p></dd></dl><dl><dt class="spec type" id="type-uncoercible_info"><a href="#type-uncoercible_info" class="anchor"></a><code><span class="keyword">type </span>uncoercible_info</code></dt></dl><dl><dt class="spec exception" id="exception-Uncoercible"><a href="#exception-Uncoercible" class="anchor"></a><code><span class="keyword">exception </span></code><code><span class="exception">Uncoercible</span><span class="keyword"> of </span><a href="index.html#type-uncoercible_info">uncoercible_info</a></code></dt><dd><p>An attempt was made to coerce between uncoercible types.</p></dd></dl></section></div></body></html>