<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Depyt (depyt.Depyt)</title><link rel="stylesheet" href="../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../index.html">depyt</a> &#x00BB; Depyt</nav><h1>Module <code>Depyt</code></h1><p>Yet-an-other type combinator library</p><p><code>Depyt</code> provides type combinators to define runtime representation for OCaml types and <a href="index.html#generics"><span>generic operations</span></a> to manipulate values with a runtime type representation.</p><p>The type combinators supports all the usual <a href="index.html#primitives"><span>type primitives</span></a> but also compact definitions of <a href="index.html#records"><span>records</span></a> and <a href="index.html#variants"><span>variants</span></a>. It also allows to define the runtime representation of <a href="index.html#recursive"><span>recursive types</span></a>.</p><p><code>Depyt</code> is a modern reboot of <a href="https://github.com/mirage/dyntype">Dyntype</a> but using <a href="https://en.wikipedia.org/wiki/Generalized_algebraic_data_type">GADT</a>s-based combinators instead of syntax-extensions. When we originally wrote <code>Dyntype</code> (in 2012) GADTs were not available in <i>OCaml</i> and <a href="https://github.com/ocaml/camlp4">camlp4</a> was everywhere -- this is not the case anymore. Finally, <code>Depyt</code> avoids some of the performance caveats present in <code>Dyntype</code> by avoiding allocating and converting between intermediate formats.</p><p><em>0.2.0 — <a href="https://github.com/samoht/depyt">homepage</a></em></p><nav class="toc"><ul><li><a href="#depyt">Depyt</a></li><li><a href="#primitives">Primitives</a></li><li><a href="#records">Records</a></li><li><a href="#variants">Variants</a></li><li><a href="#recursive">Recursive definitions</a></li><li><a href="#proj">Bijections</a></li><li><a href="#generics">Generic Operations</a><ul><li><a href="#binary-serialization">Binary serialization</a></li><li><a href="#json-converters">JSON converters</a></li></ul></li></ul></nav></header><section><header><h2 id="depyt"><a href="#depyt" class="anchor"></a>Depyt</h2></header><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> 'a t</code></dt><dd><p>The type for runtime representation of values of type <code>'a</code>.</p></dd></dl></section><section><header><h2 id="primitives"><a href="#primitives" class="anchor"></a>Primitives</h2></header><dl><dt class="spec value" id="val-unit"><a href="#val-unit" class="anchor"></a><code><span class="keyword">val</span> unit : unit <a href="index.html#type-t">t</a></code></dt><dd><p><code>unit</code> is a representation of the unit type.</p></dd></dl><dl><dt class="spec value" id="val-bool"><a href="#val-bool" class="anchor"></a><code><span class="keyword">val</span> bool : bool <a href="index.html#type-t">t</a></code></dt><dd><p><code>bool</code> is a representation of the boolean type.</p></dd></dl><dl><dt class="spec value" id="val-char"><a href="#val-char" class="anchor"></a><code><span class="keyword">val</span> char : char <a href="index.html#type-t">t</a></code></dt><dd><p><code>char</code> is a representation of the character type.</p></dd></dl><dl><dt class="spec value" id="val-int"><a href="#val-int" class="anchor"></a><code><span class="keyword">val</span> int : int <a href="index.html#type-t">t</a></code></dt><dd><p><code>int</code> is a representation of the integer type.</p></dd></dl><dl><dt class="spec value" id="val-int32"><a href="#val-int32" class="anchor"></a><code><span class="keyword">val</span> int32 : int32 <a href="index.html#type-t">t</a></code></dt><dd><p><code>int32</code> is a representation of the 32-bit integers type.</p></dd></dl><dl><dt class="spec value" id="val-int64"><a href="#val-int64" class="anchor"></a><code><span class="keyword">val</span> int64 : int64 <a href="index.html#type-t">t</a></code></dt><dd><p><code>int64</code> is a representation of the 64-bit integer type.</p></dd></dl><dl><dt class="spec value" id="val-float"><a href="#val-float" class="anchor"></a><code><span class="keyword">val</span> float : float <a href="index.html#type-t">t</a></code></dt><dd><p><code>float</code> is a representation of the float type.</p></dd></dl><dl><dt class="spec value" id="val-string"><a href="#val-string" class="anchor"></a><code><span class="keyword">val</span> string : string <a href="index.html#type-t">t</a></code></dt><dd><p><code>string</code> is a representation of the string type.</p></dd></dl><dl><dt class="spec value" id="val-list"><a href="#val-list" class="anchor"></a><code><span class="keyword">val</span> list : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> list <a href="index.html#type-t">t</a></code></dt><dd><p><code>list t</code> is a representation of list of values of type <code>t</code>.</p></dd></dl><dl><dt class="spec value" id="val-array"><a href="#val-array" class="anchor"></a><code><span class="keyword">val</span> array : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> array <a href="index.html#type-t">t</a></code></dt><dd><p><code>array t</code> is a representation of array of values of type <code>t</code>.</p></dd></dl><dl><dt class="spec value" id="val-option"><a href="#val-option" class="anchor"></a><code><span class="keyword">val</span> option : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> option <a href="index.html#type-t">t</a></code></dt><dd><p><code>option t</code> is a representation of value of type <code>t option</code>.</p></dd></dl><dl><dt class="spec value" id="val-pair"><a href="#val-pair" class="anchor"></a><code><span class="keyword">val</span> pair : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span> * <span class="type-var">'b</span>) <a href="index.html#type-t">t</a></code></dt><dd><p><code>pair x y</code> is a representation of values of type <code>x * y</code>.</p></dd></dl><dl><dt class="spec value" id="val-triple"><a href="#val-triple" class="anchor"></a><code><span class="keyword">val</span> triple : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'c</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span> * <span class="type-var">'b</span> * <span class="type-var">'c</span>) <a href="index.html#type-t">t</a></code></dt><dd><p><code>triple x y z</code> is a representation of values of type <code>x * y *
    z</code>.</p></dd></dl></section><section><header><h2 id="records"><a href="#records" class="anchor"></a>Records</h2></header><dl><dt class="spec type" id="type-field"><a href="#type-field" class="anchor"></a><code><span class="keyword">type</span> ('a, 'b) field</code></dt><dd><p>The type for fields holding values of type <code>'b</code> and belonging to a record of type <code>'a</code>.</p></dd></dl><dl><dt class="spec value" id="val-field"><a href="#val-field" class="anchor"></a><code><span class="keyword">val</span> field : string <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'a</span>) <span>&#45;&gt;</span> (<span class="type-var">'b</span>, <span class="type-var">'a</span>) <a href="index.html#type-field">field</a></code></dt><dd><p><code>field n t g</code> is the representation of the field <code>n</code> of type <code>t</code> with getter <code>g</code>.</p><p>For instance:</p><pre><code class="ml">type t = { foo: string option }

let foo = field &quot;foo&quot; (option string) (fun t -&gt; t.x)</code></pre></dd></dl><dl><dt class="spec type" id="type-open_record"><a href="#type-open_record" class="anchor"></a><code><span class="keyword">type</span> ('a, 'b, 'c) open_record</code></dt><dd><p>The type for representing open records of type <code>'a</code> with constructors of type <code>'b</code>. <code>'c</code> represents the fields missings to the record, e.g. an open record initially holds <code>'c = 'b</code> and it can can be <a href="index.html#val-sealr"><span>sealed</span></a> when <code>'c = 'a</code>.</p></dd></dl><dl><dt class="spec value" id="val-sealr"><a href="#val-sealr" class="anchor"></a><code><span class="keyword">val</span> sealr : (<span class="type-var">'a</span>, <span class="type-var">'b</span>, <span class="type-var">'a</span>) <a href="index.html#type-open_record">open_record</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>sealr r</code> seal the open record <code>r</code>.</p></dd></dl><dl><dt class="spec value" id="val-(|+)"><a href="#val-(|+)" class="anchor"></a><code><span class="keyword">val</span> (|+) : (<span class="type-var">'a</span>, <span class="type-var">'b</span>, <span class="type-var">'c</span> <span>&#45;&gt;</span> <span class="type-var">'d</span>) <a href="index.html#type-open_record">open_record</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span>, <span class="type-var">'c</span>) <a href="index.html#type-field">field</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span>, <span class="type-var">'b</span>, <span class="type-var">'d</span>) <a href="index.html#type-open_record">open_record</a></code></dt><dd><p><code>r |+ f</code> adds the field <code>f</code> to the open record <code>r</code>.</p></dd></dl><dl><dt class="spec value" id="val-record"><a href="#val-record" class="anchor"></a><code><span class="keyword">val</span> record : string <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> (<span class="type-var">'a</span>, <span class="type-var">'b</span>, <span class="type-var">'b</span>) <a href="index.html#type-open_record">open_record</a></code></dt><dd><p><code>record n f fs</code> is the representation of the record called <code>n</code> of type <code>'a</code> using <code>f</code> as constructor and with the fields <code>fs</code>.</p><p>Putting all together:</p><pre><code class="ml">type t = { foo: string; bar = (int * string) list; }

let t =
  record &quot;t&quot; (fun foo -&gt; { foo })
  |+ field &quot;foo&quot; string (fun t -&gt; t.foo)
  |+ field &quot;bar&quot; (list (pair int string)) (fun t -&gt; t.bar)
  |&gt; sealr</code></pre></dd></dl></section><section><header><h2 id="variants"><a href="#variants" class="anchor"></a>Variants</h2></header><dl><dt class="spec type" id="type-case"><a href="#type-case" class="anchor"></a><code><span class="keyword">type</span> ('a, 'b) case</code></dt><dd><p>The type for representing variant cases of type <code>'a</code> with patterns of type <code>'b</code>.</p></dd></dl><dl><dt class="spec type" id="type-case_p"><a href="#type-case_p" class="anchor"></a><code><span class="keyword">type</span> 'a case_p</code></dt><dd><p>The type for representing patterns for a variant of type <code>'a</code>.</p></dd></dl><dl><dt class="spec value" id="val-case0"><a href="#val-case0" class="anchor"></a><code><span class="keyword">val</span> case0 : string <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> (<span class="type-var">'a</span>, <span class="type-var">'a</span> <a href="index.html#type-case_p">case_p</a>) <a href="index.html#type-case">case</a></code></dt><dd><p><code>case0 n v</code> is a representation of a variant case <code>n</code> with no argument and a singleton pattern. e.g.</p><pre><code class="ml">type t = Foo

let foo = case0 &quot;Foo&quot; Foo</code></pre></dd></dl><dl><dt class="spec value" id="val-case1"><a href="#val-case1" class="anchor"></a><code><span class="keyword">val</span> case1 : string <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'a</span>) <span>&#45;&gt;</span> (<span class="type-var">'a</span>, <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-case_p">case_p</a>) <a href="index.html#type-case">case</a></code></dt><dd><p><code>case1 n t c</code> is a representation of a variant case <code>n</code> with 1 argument of type <code>t</code> and a pattern <code>c</code> an function with one argument of type <code>t</code>. e.g.</p><pre><code class="ml">type t = Foo of string

let foo = case1 &quot;Foo&quot; string (fun s -&gt; Foo s)</code></pre></dd></dl><dl><dt class="spec type" id="type-open_variant"><a href="#type-open_variant" class="anchor"></a><code><span class="keyword">type</span> ('a, 'b, 'c) open_variant</code></dt><dd><p>The type for representing open variants of type <code>'a</code> with pattern matching of type <code>'b</code>. <code>'c</code> represents the missing cases for the variant, e.g. initially variant hols <code>c' = 'b</code> and it can be <a href="index.html#val-sealv"><span>sealed</span></a> when <code>'c = 'a</code>.</p></dd></dl><dl><dt class="spec value" id="val-sealv"><a href="#val-sealv" class="anchor"></a><code><span class="keyword">val</span> sealv : (<span class="type-var">'a</span>, <span class="type-var">'b</span>, <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-case_p">case_p</a>) <a href="index.html#type-open_variant">open_variant</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>sealv v</code> seals the open variant <code>v</code>.</p></dd></dl><dl><dt class="spec value" id="val-(|~)"><a href="#val-(|~)" class="anchor"></a><code><span class="keyword">val</span> (|~) : (<span class="type-var">'a</span>, <span class="type-var">'b</span>, <span class="type-var">'c</span> <span>&#45;&gt;</span> <span class="type-var">'d</span>) <a href="index.html#type-open_variant">open_variant</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span>, <span class="type-var">'c</span>) <a href="index.html#type-case">case</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span>, <span class="type-var">'b</span>, <span class="type-var">'d</span>) <a href="index.html#type-open_variant">open_variant</a></code></dt><dd><p><code>v |~ c</code> is <code>v</code> augmented with the case <code>c</code>.</p></dd></dl><dl><dt class="spec value" id="val-variant"><a href="#val-variant" class="anchor"></a><code><span class="keyword">val</span> variant : string <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> (<span class="type-var">'a</span>, <span class="type-var">'b</span>, <span class="type-var">'b</span>) <a href="index.html#type-open_variant">open_variant</a></code></dt><dd><p><code>variant n c p</code> is a representation of a variant type containing the cases <code>c</code> and using <code>p</code> to deconstruct values.</p><p>Putting all together:</p><pre><code class="ml">type t = Foo | Bar of string

let t =
  variant &quot;t&quot; (fun foo bar -&gt; function
    | Foo   -&gt; foo
    | Bar s -&gt; bar s)
  |~ case0 &quot;Foo&quot; Foo
  |~ case1 &quot;Bar&quot; string (fun x -&gt; Bar x)
  |&gt; sealr</code></pre></dd></dl><dl><dt class="spec value" id="val-enum"><a href="#val-enum" class="anchor"></a><code><span class="keyword">val</span> enum : string <span>&#45;&gt;</span> (string * <span class="type-var">'a</span>) list <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>enum n l</code> is a representation of the variant type which has only constant variant case. e.g.</p><pre><code class="ml">type t = Foo | Bar | Toto

let t = enum &quot;t&quot; [&quot;Foo&quot;, Foo; &quot;Bar&quot;, Bar; &quot;Toto&quot;, Toto]</code></pre></dd></dl></section><section><header><h2 id="recursive"><a href="#recursive" class="anchor"></a>Recursive definitions</h2><p><code>Depyt</code> allows to create a limited form of recursive records and variants.</p><p><b>TODO</b>: describe the limitations, e.g. only regular recursion and no use of the generics inside the <code>mu*</code> functions and the usual caveats with recursive values (such as infinite loops on most of the generics which don't check sharing).</p></header><dl><dt class="spec value" id="val-mu"><a href="#val-mu" class="anchor"></a><code><span class="keyword">val</span> mu : (<span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>mu f</code> is the representation <code>r</code> such that <code>r = mu r</code>.</p><p>For instance:</p><pre><code class="ml">type x = { x: x option }

let x = mu (fun x -&gt;
    record &quot;x&quot; (fun x -&gt; { x })
    |+ field &quot;x&quot; x (fun x -&gt; x.x)
    |&gt; sealr)</code></pre></dd></dl><dl><dt class="spec value" id="val-mu2"><a href="#val-mu2" class="anchor"></a><code><span class="keyword">val</span> mu2 : (<span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> * <span class="type-var">'b</span> <a href="index.html#type-t">t</a>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> * <span class="type-var">'b</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>mu2 f</code> is the representations <code>r</code> and <code>s</code> such that <code>r, s = mu2 r
    s</code>.</p><p>For instance:</p><pre><code class="ml">type r = { foo: int; bar: string list; z: z option }
and z = { x: int; r: r list }

(* Build the representation of [r] knowing [z]'s. *)
let mkr z =
  record &quot;r&quot; (fun foo bar z -&gt; { foo; bar; z })
  |+ field &quot;foo&quot; int (fun t -&gt; t.foo)
  |+ field &quot;bar&quot; (list string) (fun t -&gt; t.bar)
  |+ field &quot;z&quot; (option z) (fun t -&gt; t.z)
  |&gt; sealr

(* And the representation of [z] knowing [r]'s. *)
let mkz r =
  record &quot;z&quot; (fun x r -&gt; { x; r })
  |+ field &quot;x&quot; int (fun t -&gt; t.x)
  |+ field &quot;r&quot; (list r) (fun t -&gt; t.r)
  |&gt; sealr

(* Tie the loop. *)
let r, z = mu2 (fun r z -&gt; mkr z, mkz y)</code></pre></dd></dl></section><section><header><h2 id="proj"><a href="#proj" class="anchor"></a>Bijections</h2><p>Sometimes it is not always possible to describe precisely a type (or it could be too tedious) and it is easier to describe the relation with an other know type. This is what bijections are about.</p></header><dl><dt class="spec value" id="val-like"><a href="#val-like" class="anchor"></a><code><span class="keyword">val</span> like : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>) <span>&#45;&gt;</span> (<span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'a</span>) <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>like x f g</code> is the description of a type which looks like <code>x</code> using the bijetion <code>(f, g)</code>.</p></dd></dl></section><section><header><h2 id="generics"><a href="#generics" class="anchor"></a>Generic Operations</h2><p>Given a value <code>'a t</code>, it is possible to define generic operations on value of type <code>'a</code> such as pretty-printing, parsing and unparsing.</p></header><dl><dt class="spec value" id="val-dump"><a href="#val-dump" class="anchor"></a><code><span class="keyword">val</span> dump : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="../../fmt/Fmt/index.html#type-t">Fmt.t</a></code></dt><dd><p><code>dump t</code> dumps the values of type <code>t</code> as a parsable OCaml expression.</p></dd></dl><dl><dt class="spec value" id="val-equal"><a href="#val-equal" class="anchor"></a><code><span class="keyword">val</span> equal : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>equal t</code> is the equality function between values of type <code>t</code>.</p></dd></dl><dl><dt class="spec value" id="val-compare"><a href="#val-compare" class="anchor"></a><code><span class="keyword">val</span> compare : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> int</code></dt><dd><p><code>compare t</code> compares values of type <code>t</code>.</p></dd></dl><section><header><h3 id="binary-serialization"><a href="#binary-serialization" class="anchor"></a>Binary serialization</h3></header><dl><dt class="spec type" id="type-buffer"><a href="#type-buffer" class="anchor"></a><code><span class="keyword">type</span> buffer</code><code> = </code><table class="variant"><tr id="type-buffer.C" class="anchored"><td class="def constructor"><a href="#type-buffer.C" class="anchor"></a><code>| </code><code><span class="constructor">C</span> <span class="keyword">of</span> <a href="../../cstruct/Cstruct/index.html#type-t">Cstruct.t</a></code></td></tr><tr id="type-buffer.B" class="anchored"><td class="def constructor"><a href="#type-buffer.B" class="anchor"></a><code>| </code><code><span class="constructor">B</span> <span class="keyword">of</span> bytes</code></td></tr></table></dt><dd><p>The type for buffers.</p></dd></dl><dl><dt class="spec value" id="val-size_of"><a href="#val-size_of" class="anchor"></a><code><span class="keyword">val</span> size_of : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> int</code></dt><dd><p><code>size_of t</code> is the size needed to serialize values of type <code>t</code>.</p></dd></dl><dl><dt class="spec value" id="val-write"><a href="#val-write" class="anchor"></a><code><span class="keyword">val</span> write : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-buffer">buffer</a> <span>&#45;&gt;</span> pos:int <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> int</code></dt><dd><p><code>write t</code> serializes values of type <code>t</code>. Use <code>size_of</code> to pre-determine the size of the buffer.</p></dd></dl><dl><dt class="spec value" id="val-read"><a href="#val-read" class="anchor"></a><code><span class="keyword">val</span> read : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-buffer">buffer</a> <span>&#45;&gt;</span> pos:int <span>&#45;&gt;</span> int * <span class="type-var">'a</span></code></dt><dd><p><code>read t</code> reads a serialization of a value of type <code>t</code>.</p></dd></dl></section><section><header><h3 id="json-converters"><a href="#json-converters" class="anchor"></a>JSON converters</h3></header><dl><dt class="spec value" id="val-pp_json"><a href="#val-pp_json" class="anchor"></a><code><span class="keyword">val</span> pp_json : ?&#8288;minify:bool <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="../../fmt/Fmt/index.html#type-t">Fmt.t</a></code></dt><dd><p>Similar to <a href="index.html#val-dump"><code>dump</code></a> but pretty-prints the JSON representation instead of the OCaml one. See <a href="index.html#val-encode_json"><code>encode_json</code></a> for details about the encoding.</p><p>For instance:</p><pre><code class="ml">type t = { foo: int option; bar: string list };;

let t =
  record &quot;r&quot; (fun foo bar -&gt; { foo; bar })
  |+ field &quot;foo&quot; (option int) (fun t -&gt; t.foo)
  |+ field &quot;bar&quot; (list string) (fun t -&gt; t.bar)
  |&gt; sealr

let s = Fmt.strf &quot;%a\n&quot; (pp t) { foo = None; bar = [&quot;foo&quot;] }
(* s is &quot;{ foo = None; bar = [\&quot;foo\&quot;]; }&quot; *)

let j = Fmt.strf &quot;%a\n&quot; (pp_json t) { foo = None; bar = [&quot;foo&quot;] }
(* j is &quot;{ \&quot;bar\&quot;:[\&quot;foo\&quot;] }&quot; *)</code></pre><p><b>NOTE:</b> this will automatically convert JSON fragments to valid JSON objects by adding an enclosing array if necessary.</p></dd></dl><dl><dt class="spec value" id="val-encode_json"><a href="#val-encode_json" class="anchor"></a><code><span class="keyword">val</span> encode_json : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../../jsonm/Jsonm/index.html#type-encoder">Jsonm.encoder</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>encode_json t e</code> encodes <code>t</code> into the <a href="http://erratique.ch/software/jsonm">jsonm</a> encoder <code>e</code>. The encoding is a relatively straightforward translation of the OCaml structure into JSON. The main highlights are:</p><ul><li>OCaml <code>ints</code> are translated into JSON floats.</li><li>OCaml strings are translated into JSON strings. You must then ensure that the OCaml strings contains only valid UTF-8 characters.</li><li>OCaml record fields of type <code>'a option</code> are automatically unboxed in their JSON representation. If the value if <code>None</code>, the field is removed from the JSON object.</li><li>variant cases built using <a href="index.html#val-case0"><code>case0</code></a> are represented as strings.</li><li>variant cases built using <a href="index.html#val-case1"><code>case1</code></a> are represented as a record with one field; the field name is the name of the variant.</li></ul><p><b>NOTE:</b> this can be used to encode JSON fragments. That's the responsibility of the caller to ensure that the encoded JSON fragment fits properly into a well-formed JSON object.</p></dd></dl><dl><dt class="spec value" id="val-decode_json"><a href="#val-decode_json" class="anchor"></a><code><span class="keyword">val</span> decode_json : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../../jsonm/Jsonm/index.html#type-decoder">Jsonm.decoder</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span>, string) <a href="../../result/Result/index.html#type-result">Result.result</a></code></dt><dd><p><code>decode_json t e</code> decodes values of type <code>t</code> from the <a href="http://erratique.ch/software/jsonm">jsonm</a> decoder <code>e</code>.</p></dd></dl><dl><dt class="spec value" id="val-decode_json_lexemes"><a href="#val-decode_json_lexemes" class="anchor"></a><code><span class="keyword">val</span> decode_json_lexemes : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../../jsonm/Jsonm/index.html#type-lexeme">Jsonm.lexeme</a> list <span>&#45;&gt;</span> (<span class="type-var">'a</span>, string) <a href="../../result/Result/index.html#type-result">Result.result</a></code></dt><dd><p><code>decode_json_lexemes</code> is similar to <a href="index.html#val-decode_json"><code>decode_json</code></a> but use an already decoded list of JSON lexemes instead of a decoder.</p></dd></dl></section></section></div></body></html>