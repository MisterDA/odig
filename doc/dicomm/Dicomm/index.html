<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Dicomm (dicomm.Dicomm)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../index.html">dicomm</a> &#x00BB; Dicomm</nav><h1>Module <code>Dicomm</code></h1><p>Non-blocking streaming DICOM data element decoder.</p><p><code>Dicomm</code> is a non-blocking streaming decoder to <a href="index.html#decode"><span>decode</span></a> DICOM data elements.</p><p>Consult the <a href="index.html#model"><span>data model</span></a>, <a href="index.html#props"><span>features and limitations</span></a> and <a href="index.html#examples"><span>examples</span></a> of use.</p><p><em>Release v0.0.0-17-g86c7a0c — %%MAINTAINER%%</em></p><h4 id="references"><a href="#references" class="anchor"></a>References</h4><ul><li>NEMA. <em><a href="http://medical.nema.org/standard.html">The DICOM Standard</a></em>, 2011.</li></ul><nav class="toc"><ul><li><a href="#model">Data model</a></li><li><a href="#decode">Decode</a></li><li><a href="#manual">Manual sources</a></li><li><a href="#errors">Error recovery</a></li><li><a href="#props">Features and limitations</a></li><li><a href="#pixels">Pixel data</a></li><li><a href="#examples">Examples</a></li></ul></nav></header><section><header><h2 id="model"><a href="#model" class="anchor"></a>Data model</h2></header><dl><dt class="spec type" id="type-syntax"><a href="#type-syntax" class="anchor"></a><code><span class="keyword">type </span>syntax</code><span class="keyword"> = </span><code>[ </code><table class="variant"><tr id="type-syntax.File" class="anchored"><td class="def constructor"><a href="#type-syntax.File" class="anchor"></a><code><span class="keyword">| </span></code><code>`File</code></td></tr><tr id="type-syntax.LE_explicit" class="anchored"><td class="def constructor"><a href="#type-syntax.LE_explicit" class="anchor"></a><code><span class="keyword">| </span></code><code>`LE_explicit</code></td></tr><tr id="type-syntax.BE_explicit" class="anchored"><td class="def constructor"><a href="#type-syntax.BE_explicit" class="anchor"></a><code><span class="keyword">| </span></code><code>`BE_explicit</code></td></tr><tr id="type-syntax.LE_implicit" class="anchored"><td class="def constructor"><a href="#type-syntax.LE_implicit" class="anchor"></a><code><span class="keyword">| </span></code><code>`LE_implicit</code></td></tr></table><code> ]</code></dt><dd><p>The type for transfer syntaxes. See <a href="index.html#type-decoder"><code>decoder</code></a>.</p></dd></dl><dl><dt class="spec type" id="type-vr"><a href="#type-vr" class="anchor"></a><code><span class="keyword">type </span>vr</code><span class="keyword"> = </span><code>[ </code><table class="variant"><tr id="type-vr.AE" class="anchored"><td class="def constructor"><a href="#type-vr.AE" class="anchor"></a><code><span class="keyword">| </span></code><code>`AE</code></td></tr><tr id="type-vr.AS" class="anchored"><td class="def constructor"><a href="#type-vr.AS" class="anchor"></a><code><span class="keyword">| </span></code><code>`AS</code></td></tr><tr id="type-vr.AT" class="anchored"><td class="def constructor"><a href="#type-vr.AT" class="anchor"></a><code><span class="keyword">| </span></code><code>`AT</code></td></tr><tr id="type-vr.CS" class="anchored"><td class="def constructor"><a href="#type-vr.CS" class="anchor"></a><code><span class="keyword">| </span></code><code>`CS</code></td></tr><tr id="type-vr.DA" class="anchored"><td class="def constructor"><a href="#type-vr.DA" class="anchor"></a><code><span class="keyword">| </span></code><code>`DA</code></td></tr><tr id="type-vr.DS" class="anchored"><td class="def constructor"><a href="#type-vr.DS" class="anchor"></a><code><span class="keyword">| </span></code><code>`DS</code></td></tr><tr id="type-vr.DT" class="anchored"><td class="def constructor"><a href="#type-vr.DT" class="anchor"></a><code><span class="keyword">| </span></code><code>`DT</code></td></tr><tr id="type-vr.FL" class="anchored"><td class="def constructor"><a href="#type-vr.FL" class="anchor"></a><code><span class="keyword">| </span></code><code>`FL</code></td></tr><tr id="type-vr.FD" class="anchored"><td class="def constructor"><a href="#type-vr.FD" class="anchor"></a><code><span class="keyword">| </span></code><code>`FD</code></td></tr><tr id="type-vr.IS" class="anchored"><td class="def constructor"><a href="#type-vr.IS" class="anchor"></a><code><span class="keyword">| </span></code><code>`IS</code></td></tr><tr id="type-vr.LO" class="anchored"><td class="def constructor"><a href="#type-vr.LO" class="anchor"></a><code><span class="keyword">| </span></code><code>`LO</code></td></tr><tr id="type-vr.LT" class="anchored"><td class="def constructor"><a href="#type-vr.LT" class="anchor"></a><code><span class="keyword">| </span></code><code>`LT</code></td></tr><tr id="type-vr.OB" class="anchored"><td class="def constructor"><a href="#type-vr.OB" class="anchor"></a><code><span class="keyword">| </span></code><code>`OB</code></td></tr><tr id="type-vr.OF" class="anchored"><td class="def constructor"><a href="#type-vr.OF" class="anchor"></a><code><span class="keyword">| </span></code><code>`OF</code></td></tr><tr id="type-vr.OW" class="anchored"><td class="def constructor"><a href="#type-vr.OW" class="anchor"></a><code><span class="keyword">| </span></code><code>`OW</code></td></tr><tr id="type-vr.PN" class="anchored"><td class="def constructor"><a href="#type-vr.PN" class="anchor"></a><code><span class="keyword">| </span></code><code>`PN</code></td></tr><tr id="type-vr.SH" class="anchored"><td class="def constructor"><a href="#type-vr.SH" class="anchor"></a><code><span class="keyword">| </span></code><code>`SH</code></td></tr><tr id="type-vr.SL" class="anchored"><td class="def constructor"><a href="#type-vr.SL" class="anchor"></a><code><span class="keyword">| </span></code><code>`SL</code></td></tr><tr id="type-vr.SQ" class="anchored"><td class="def constructor"><a href="#type-vr.SQ" class="anchor"></a><code><span class="keyword">| </span></code><code>`SQ</code></td></tr><tr id="type-vr.SS" class="anchored"><td class="def constructor"><a href="#type-vr.SS" class="anchor"></a><code><span class="keyword">| </span></code><code>`SS</code></td></tr><tr id="type-vr.ST" class="anchored"><td class="def constructor"><a href="#type-vr.ST" class="anchor"></a><code><span class="keyword">| </span></code><code>`ST</code></td></tr><tr id="type-vr.TM" class="anchored"><td class="def constructor"><a href="#type-vr.TM" class="anchor"></a><code><span class="keyword">| </span></code><code>`TM</code></td></tr><tr id="type-vr.UI" class="anchored"><td class="def constructor"><a href="#type-vr.UI" class="anchor"></a><code><span class="keyword">| </span></code><code>`UI</code></td></tr><tr id="type-vr.UL" class="anchored"><td class="def constructor"><a href="#type-vr.UL" class="anchor"></a><code><span class="keyword">| </span></code><code>`UL</code></td></tr><tr id="type-vr.UN" class="anchored"><td class="def constructor"><a href="#type-vr.UN" class="anchor"></a><code><span class="keyword">| </span></code><code>`UN</code></td></tr><tr id="type-vr.US" class="anchored"><td class="def constructor"><a href="#type-vr.US" class="anchor"></a><code><span class="keyword">| </span></code><code>`US</code></td></tr><tr id="type-vr.UT" class="anchored"><td class="def constructor"><a href="#type-vr.UT" class="anchor"></a><code><span class="keyword">| </span></code><code>`UT</code></td></tr></table><code> ]</code></dt><dd><p>The type for value representations.</p></dd></dl><dl><dt class="spec value" id="val-pp_vr"><a href="#val-pp_vr" class="anchor"></a><code><span class="keyword">val </span>pp_vr : Format.formatter <span>&#45;&gt;</span> <a href="index.html#type-vr">vr</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>pp_vr ppf vr</code> prints an unspecified representation of <code>vr</code> on <code>ppf</code>.</p></dd></dl><dl><dt class="spec type" id="type-tag"><a href="#type-tag" class="anchor"></a><code><span class="keyword">type </span>tag</code></dt><dd><p>The type for data elements tags.</p></dd></dl><dl><dt class="spec module" id="module-Tag"><a href="#module-Tag" class="anchor"></a><code><span class="keyword">module </span><a href="Tag/index.html">Tag</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Data elements tags and data dictionary.</p></dd></dl><dl><dt class="spec module" id="module-Uid"><a href="#module-Uid" class="anchor"></a><code><span class="keyword">module </span><a href="Uid/index.html">Uid</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Unique identifiers (UID).</p></dd></dl><dl><dt class="spec type" id="type-time"><a href="#type-time" class="anchor"></a><code><span class="keyword">type </span>time</code><span class="keyword"> = </span><code>[ </code><table class="variant"><tr id="type-time.Stamp" class="anchored"><td class="def constructor"><a href="#type-time.Stamp" class="anchor"></a><code><span class="keyword">| </span></code><code>`Stamp<span class="keyword"> of </span>float<span class="keyword"> * </span>float option</code></td></tr><tr id="type-time.Daytime" class="anchored"><td class="def constructor"><a href="#type-time.Daytime" class="anchor"></a><code><span class="keyword">| </span></code><code>`Daytime<span class="keyword"> of </span>float</code></td></tr></table><code> ]</code></dt><dd><p>The type for representing times.</p><ul><li><code>`Stamp (u, tz)</code> is used for <code>`DA</code> and <code>`DT</code> value representations. <code>u</code> should be interpreted as an absolute time in POSIX seconds since 1970-01-01 00:00:00 UTC. <code>tz</code> is a timezone offset in seconds. If <code>tz</code> is <code>None</code>, time is in local time.</li><li><code>`Daytime s</code> is used for <code>`TM</code>, it's a time point in a day in seconds since 00:00:00.</li></ul></dd></dl><dl><dt class="spec value" id="val-pp_time"><a href="#val-pp_time" class="anchor"></a><code><span class="keyword">val </span>pp_time : Format.formatter <span>&#45;&gt;</span> <a href="index.html#type-time">time</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>pp_time ppf t</code> prints an unspecified representation of <code>t</code> on <code>ppf</code>.</p></dd></dl><dl><dt class="spec type" id="type-bigarray"><a href="#type-bigarray" class="anchor"></a><code><span class="keyword">type </span>('a, 'b) bigarray</code><code><span class="keyword"> = </span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>, Bigarray.c_layout) Bigarray.Array1.t</code></dt><dd><p>The type for bigarrays.</p></dd></dl><dl><dt class="spec type" id="type-value"><a href="#type-value" class="anchor"></a><code><span class="keyword">type </span>value</code><span class="keyword"> = </span><code>[ </code><table class="variant"><tr id="type-value.String" class="anchored"><td class="def constructor"><a href="#type-value.String" class="anchor"></a><code><span class="keyword">| </span></code><code>`String<span class="keyword"> of </span>[ `One of string<span class="keyword"> | </span>`Many of string list ]</code></td></tr><tr id="type-value.UInt8" class="anchored"><td class="def constructor"><a href="#type-value.UInt8" class="anchor"></a><code><span class="keyword">| </span></code><code>`UInt8<span class="keyword"> of </span>(int, Bigarray.int8_unsigned_elt) <a href="index.html#type-bigarray">bigarray</a></code></td></tr><tr id="type-value.Int16" class="anchored"><td class="def constructor"><a href="#type-value.Int16" class="anchor"></a><code><span class="keyword">| </span></code><code>`Int16<span class="keyword"> of </span>(int, Bigarray.int16_signed_elt) <a href="index.html#type-bigarray">bigarray</a></code></td></tr><tr id="type-value.UInt16" class="anchored"><td class="def constructor"><a href="#type-value.UInt16" class="anchor"></a><code><span class="keyword">| </span></code><code>`UInt16<span class="keyword"> of </span>(int, Bigarray.int16_unsigned_elt) <a href="index.html#type-bigarray">bigarray</a></code></td></tr><tr id="type-value.Int32" class="anchored"><td class="def constructor"><a href="#type-value.Int32" class="anchor"></a><code><span class="keyword">| </span></code><code>`Int32<span class="keyword"> of </span>(int32, Bigarray.int32_elt) <a href="index.html#type-bigarray">bigarray</a></code></td></tr><tr id="type-value.UInt32" class="anchored"><td class="def constructor"><a href="#type-value.UInt32" class="anchor"></a><code><span class="keyword">| </span></code><code>`UInt32<span class="keyword"> of </span>(int32, Bigarray.int32_elt) <a href="index.html#type-bigarray">bigarray</a></code></td></tr><tr id="type-value.Float32" class="anchored"><td class="def constructor"><a href="#type-value.Float32" class="anchor"></a><code><span class="keyword">| </span></code><code>`Float32<span class="keyword"> of </span>(float, Bigarray.float32_elt) <a href="index.html#type-bigarray">bigarray</a></code></td></tr><tr id="type-value.Float64" class="anchored"><td class="def constructor"><a href="#type-value.Float64" class="anchor"></a><code><span class="keyword">| </span></code><code>`Float64<span class="keyword"> of </span>(float, Bigarray.float64_elt) <a href="index.html#type-bigarray">bigarray</a></code></td></tr><tr id="type-value.Tag" class="anchored"><td class="def constructor"><a href="#type-value.Tag" class="anchor"></a><code><span class="keyword">| </span></code><code>`Tag<span class="keyword"> of </span>[ `One of <a href="Tag/index.html#type-t">Tag.t</a><span class="keyword"> | </span>`Many of <a href="Tag/index.html#type-t">Tag.t</a> list ]</code></td></tr><tr id="type-value.Time" class="anchored"><td class="def constructor"><a href="#type-value.Time" class="anchor"></a><code><span class="keyword">| </span></code><code>`Time<span class="keyword"> of </span>[ `One of <a href="index.html#type-time">time</a><span class="keyword"> | </span>`Many of <a href="index.html#type-time">time</a> list ]</code></td></tr></table><code> ]</code></dt><dd><p>The type for values. VR are mapped to cases as given below.</p><ul><li><code>`String</code> for <code>`AE</code>, <code>`AS</code>, <code>`CS</code>, <code>`DA</code>, <code>`DT</code>, <code>`LO</code>, <code>`LT</code>, <code>`PN</code>, <code>`SH</code>, <code>`ST</code>, <code>`TM</code>, <code>`UI</code>, <code>`UT</code>.</li><li><code>`UInt8</code> for <code>`OB</code>, <code>`UN</code></li><li><code>`Int16</code> for <code>`SS</code></li><li><code>`UInt16</code> for <code>`US</code>, <code>`OW</code></li><li><code>`Int32</code> for <code>`IS</code>, <code>`SL</code>.</li><li><code>`UInt32</code> for <code>`UL</code>.</li><li><code>`Float32</code> for <code>`FL</code>, <code>`OF</code></li><li><code>`Float64</code> for <code>`DS</code>, <code>`FD</code></li><li><code>`Tag</code> for <code>`AT</code></li><li><code>`Time</code> is TODO</li></ul><p>This should be documented in VR cases but ocamldoc doesn't support documentation in polymporphic variants.</p></dd></dl><dl><dt class="spec value" id="val-pp_value"><a href="#val-pp_value" class="anchor"></a><code><span class="keyword">val </span>pp_value : ?&#8288;limit:int <span>&#45;&gt;</span> Format.formatter <span>&#45;&gt;</span> [&lt; <a href="index.html#type-value">value</a> ] <span>&#45;&gt;</span> unit</code></dt><dd><p><code>pp_value limit ppf v</code> prints an unspecified textual representation of <code>v</code> on <code>ppf</code>. <code>limit</code> is the maximal number of printed element arrays.</p></dd></dl><dl><dt class="spec type" id="type-element"><a href="#type-element" class="anchor"></a><code><span class="keyword">type </span>element</code><code><span class="keyword"> = </span><a href="Tag/index.html#type-t">Tag.t</a><span class="keyword"> * </span><a href="index.html#type-vr">vr</a><span class="keyword"> * </span><a href="index.html#type-value">value</a></code></dt><dd><p>The type for data elements.</p></dd></dl><dl><dt class="spec value" id="val-pp_element"><a href="#val-pp_element" class="anchor"></a><code><span class="keyword">val </span>pp_element : Format.formatter <span>&#45;&gt;</span> <a href="index.html#type-element">element</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>pp_element names ppf v</code> prints and unspecified textual representation of <code>v</code> on <code>ppf</code>. If <code>names</code> is <code>true</code> (defaults to <code>false</code></p></dd></dl><dl><dt class="spec type" id="type-lexeme"><a href="#type-lexeme" class="anchor"></a><code><span class="keyword">type </span>lexeme</code><span class="keyword"> = </span><code>[ </code><table class="variant"><tr id="type-lexeme.E" class="anchored"><td class="def constructor"><a href="#type-lexeme.E" class="anchor"></a><code><span class="keyword">| </span></code><code>`E<span class="keyword"> of </span><a href="index.html#type-element">element</a></code></td></tr><tr id="type-lexeme.Ss" class="anchored"><td class="def constructor"><a href="#type-lexeme.Ss" class="anchor"></a><code><span class="keyword">| </span></code><code>`Ss<span class="keyword"> of </span><a href="Tag/index.html#type-t">Tag.t</a></code></td></tr><tr id="type-lexeme.Se" class="anchored"><td class="def constructor"><a href="#type-lexeme.Se" class="anchor"></a><code><span class="keyword">| </span></code><code>`Se<span class="keyword"> of </span><a href="Tag/index.html#type-t">Tag.t</a></code></td></tr><tr id="type-lexeme.I" class="anchored"><td class="def constructor"><a href="#type-lexeme.I" class="anchor"></a><code><span class="keyword">| </span></code><code>`I</code></td></tr></table><code> ]</code></dt><dd><p>The type for DICOM lexemes. <code>`Ss</code> and <code>`Se</code> are respectively for starting and ending sequences of data elements items (SQ value representation).</p><p>A <em>well-formed</em> sequence of lexemes belongs to the language of the <code>dicom</code> grammar:</p><pre><code class="ml">dicom = `E e / `Es t *(`I dicom) `Ee t / dicom</code></pre><p>A <a href="index.html#decode"><span>decoder</span></a> returns only well-formed sequences of lexemes or <code>`Error</code>s are returned.</p></dd></dl><dl><dt class="spec value" id="val-pp_lexeme"><a href="#val-pp_lexeme" class="anchor"></a><code><span class="keyword">val </span>pp_lexeme : Format.formatter <span>&#45;&gt;</span> [&lt; <a href="index.html#type-lexeme">lexeme</a> ] <span>&#45;&gt;</span> unit</code></dt><dd><p><code>pp_lexeme names ppf l</code> prints an unspecified textual representation of <code>l</code> on ppf.</p></dd></dl></section><section><header><h2 id="decode"><a href="#decode" class="anchor"></a>Decode</h2></header><dl><dt class="spec type" id="type-error"><a href="#type-error" class="anchor"></a><code><span class="keyword">type </span>error</code><span class="keyword"> = </span><code>[ </code><table class="variant"><tr id="type-error.Eoi" class="anchored"><td class="def constructor"><a href="#type-error.Eoi" class="anchor"></a><code><span class="keyword">| </span></code><code>`Eoi<span class="keyword"> of </span>[ `File_preamble<span class="keyword"> | </span>`File_dicom_prefix<span class="keyword"> | </span>`Tag_or_eoi<span class="keyword"> | </span>`Tag<span class="keyword"> | </span>`Reserved of <a href="Tag/index.html#type-t">Tag.t</a><span class="keyword"> | </span>`Vr of <a href="Tag/index.html#type-t">Tag.t</a><span class="keyword"> | </span>`Value_length of <a href="Tag/index.html#type-t">Tag.t</a><span class="keyword"> | </span>`Value of <a href="Tag/index.html#type-t">Tag.t</a> ]</code></td></tr><tr id="type-error.Value_length_overflow" class="anchored"><td class="def constructor"><a href="#type-error.Value_length_overflow" class="anchor"></a><code><span class="keyword">| </span></code><code>`Value_length_overflow<span class="keyword"> of </span><a href="Tag/index.html#type-t">Tag.t</a></code></td></tr><tr id="type-error.Value_length_undefined" class="anchored"><td class="def constructor"><a href="#type-error.Value_length_undefined" class="anchor"></a><code><span class="keyword">| </span></code><code>`Value_length_undefined<span class="keyword"> of </span><a href="Tag/index.html#type-t">Tag.t</a></code></td></tr><tr id="type-error.Value_length_mismatch" class="anchored"><td class="def constructor"><a href="#type-error.Value_length_mismatch" class="anchor"></a><code><span class="keyword">| </span></code><code>`Value_length_mismatch<span class="keyword"> of </span><a href="Tag/index.html#type-t">Tag.t</a><span class="keyword"> * </span>int<span class="keyword"> * </span>int</code></td></tr><tr id="type-error.Unknown_vr" class="anchored"><td class="def constructor"><a href="#type-error.Unknown_vr" class="anchor"></a><code><span class="keyword">| </span></code><code>`Unknown_vr<span class="keyword"> of </span><a href="Tag/index.html#type-t">Tag.t</a><span class="keyword"> * </span>string</code></td></tr><tr id="type-error.Parse_int" class="anchored"><td class="def constructor"><a href="#type-error.Parse_int" class="anchor"></a><code><span class="keyword">| </span></code><code>`Parse_int<span class="keyword"> of </span><a href="Tag/index.html#type-t">Tag.t</a><span class="keyword"> * </span>string</code></td></tr><tr id="type-error.Parse_float" class="anchored"><td class="def constructor"><a href="#type-error.Parse_float" class="anchor"></a><code><span class="keyword">| </span></code><code>`Parse_float<span class="keyword"> of </span><a href="Tag/index.html#type-t">Tag.t</a><span class="keyword"> * </span>string</code></td></tr><tr id="type-error.Parse_time" class="anchored"><td class="def constructor"><a href="#type-error.Parse_time" class="anchor"></a><code><span class="keyword">| </span></code><code>`Parse_time<span class="keyword"> of </span><a href="Tag/index.html#type-t">Tag.t</a><span class="keyword"> * </span>string</code></td></tr><tr id="type-error.Parse_file_dicom_prefix" class="anchored"><td class="def constructor"><a href="#type-error.Parse_file_dicom_prefix" class="anchor"></a><code><span class="keyword">| </span></code><code>`Parse_file_dicom_prefix</code></td></tr><tr id="type-error.File_syntax_unspecified" class="anchored"><td class="def constructor"><a href="#type-error.File_syntax_unspecified" class="anchor"></a><code><span class="keyword">| </span></code><code>`File_syntax_unspecified</code></td></tr><tr id="type-error.File_syntax_vr_not_uid" class="anchored"><td class="def constructor"><a href="#type-error.File_syntax_vr_not_uid" class="anchor"></a><code><span class="keyword">| </span></code><code>`File_syntax_vr_not_uid<span class="keyword"> of </span><a href="index.html#type-vr">vr</a></code></td></tr></table><code> ]</code></dt></dl><aside><p>The type for decoding errors.</p></aside><dl><dt class="spec value" id="val-pp_error"><a href="#val-pp_error" class="anchor"></a><code><span class="keyword">val </span>pp_error : Format.formatter <span>&#45;&gt;</span> [&lt; <a href="index.html#type-error">error</a> ] <span>&#45;&gt;</span> unit</code></dt><dd><p><code>pp_error e</code> prints an unspecified representation of <code>e</code> on <code>ppf</code>.</p></dd></dl><dl><dt class="spec type" id="type-src"><a href="#type-src" class="anchor"></a><code><span class="keyword">type </span>src</code><span class="keyword"> = </span><code>[ </code><table class="variant"><tr id="type-src.Channel" class="anchored"><td class="def constructor"><a href="#type-src.Channel" class="anchor"></a><code><span class="keyword">| </span></code><code>`Channel<span class="keyword"> of </span>Pervasives.in_channel</code></td></tr><tr id="type-src.Manual" class="anchored"><td class="def constructor"><a href="#type-src.Manual" class="anchor"></a><code><span class="keyword">| </span></code><code>`Manual</code></td></tr><tr id="type-src.String" class="anchored"><td class="def constructor"><a href="#type-src.String" class="anchor"></a><code><span class="keyword">| </span></code><code>`String<span class="keyword"> of </span>string</code></td></tr></table><code> ]</code></dt><dd><p>The type for input sources. With a <code>`Manual</code> source the client must provide input with <a href="Manual/index.html#val-src"><code>Manual.src</code></a>.</p></dd></dl><dl><dt class="spec type" id="type-decoder"><a href="#type-decoder" class="anchor"></a><code><span class="keyword">type </span>decoder</code></dt><dd><p>The type for decoders.</p></dd></dl><dl><dt class="spec value" id="val-decoder"><a href="#val-decoder" class="anchor"></a><code><span class="keyword">val </span>decoder : ?&#8288;vr:(<a href="Tag/index.html#type-t">Tag.t</a> <span>&#45;&gt;</span> <a href="index.html#type-vr">vr</a>) <span>&#45;&gt;</span> syntax:<a href="index.html#type-syntax">syntax</a> <span>&#45;&gt;</span> [&lt; <a href="index.html#type-src">src</a> ] <span>&#45;&gt;</span> <a href="index.html#type-decoder">decoder</a></code></dt><dd><p><code>decoder private_tag file src</code> is a DICOM decoder that inputs DICOM data elements from <code>src</code> according to <code>syntax</code>.</p><p>If <code>syntax</code> is <code>`File</code>, the decoder first parses a DICOM file preamble and the DICM prefix reporting an error if it fails to do so. Decodes then return the DICOM file meta information and the decoder automatically switch to the right syntax for decoding the data object.</p><p>If decoding is done using the implicit syntax <code>vr</code> is called on tags that return <code>None</code> on <code>Tag.vr</code> to determine the value representation to use (defaults to <code>fun _ -&gt; `UN</code>).</p></dd></dl><dl><dt class="spec value" id="val-decode"><a href="#val-decode" class="anchor"></a><code><span class="keyword">val </span>decode : <a href="index.html#type-decoder">decoder</a> <span>&#45;&gt;</span> [ `Await<span class="keyword"> | </span>`End<span class="keyword"> | </span>`Error of <a href="index.html#type-error">error</a><span class="keyword"> | </span>`Lexeme of <a href="index.html#type-lexeme">lexeme</a> ]</code></dt><dd><p><code>decode d</code> is:</p><ul><li><code>`Await</code> if <code>d</code> has a <code>`Manual</code> source and awaits more imput. The client must use <a href="Manual/index.html#val-src"><code>Manual.src</code></a> to provide it.</li><li><code>`Lexeme l</code> if a lexeme <code>l</code> was decoded.</li><li><code>`End</code> if the end of input was reached.</li><li><code>`Error e</code> if a decoding error occured. If the client is interested in a best-effort decoding it can still continue to decode after an error see <a href="index.html#errors"><span>Error recovery</span></a>.</li></ul></dd></dl><dl><dt class="spec value" id="val-decoded_range"><a href="#val-decoded_range" class="anchor"></a><code><span class="keyword">val </span>decoded_range : <a href="index.html#type-decoder">decoder</a> <span>&#45;&gt;</span> int<span class="keyword"> * </span>int</code></dt><dd><p><code>decoded_range d</code> is the range of bytes spanning the last <code>`Lexeme</code> or <code>`Error</code> decoded by <code>d</code>.</p></dd></dl><dl><dt class="spec value" id="val-decoder_src"><a href="#val-decoder_src" class="anchor"></a><code><span class="keyword">val </span>decoder_src : <a href="index.html#type-decoder">decoder</a> <span>&#45;&gt;</span> <a href="index.html#type-src">src</a></code></dt><dd><p><code>decoder_src d</code> is <code>d</code>'s input source.</p></dd></dl><dl><dt class="spec value" id="val-decoder_syntax"><a href="#val-decoder_syntax" class="anchor"></a><code><span class="keyword">val </span>decoder_syntax : <a href="index.html#type-decoder">decoder</a> <span>&#45;&gt;</span> <a href="index.html#type-syntax">syntax</a></code></dt><dd><p><code>decoder_syntax d</code> is <code>d</code>'s decoded syntax.</p></dd></dl><dl><dt class="spec value" id="val-pp_decode"><a href="#val-pp_decode" class="anchor"></a><code><span class="keyword">val </span>pp_decode : Format.formatter <span>&#45;&gt;</span> [&lt; `Await<span class="keyword"> | </span>`End<span class="keyword"> | </span>`Error of <a href="index.html#type-error">error</a><span class="keyword"> | </span>`Lexeme of <a href="index.html#type-lexeme">lexeme</a> ] <span>&#45;&gt;</span> unit</code></dt><dd><p><code>pp_decode ppf v</code> prints an unspecified representation of <code>v</code> on <code>ppf</code>.</p></dd></dl></section><section><header><h2 id="manual"><a href="#manual" class="anchor"></a>Manual sources</h2></header><dl><dt class="spec module" id="module-Manual"><a href="#module-Manual" class="anchor"></a><code><span class="keyword">module </span><a href="Manual/index.html">Manual</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Manual sources.</p></dd></dl></section><section><header><h2 id="errors"><a href="#errors" class="anchor"></a>Error recovery</h2><p>After a decoding error, if best-effort decoding is performed. The following happens before continuing:</p><ul><li><code>`Eoi _</code>, `End is eventually returned.</li><li><code>`File_syntax_unspecified</code>, continues with <code>`LE_implicit</code>.</li><li><code>`File_syntax_vr_not_uid</code>, ignores the VR and parses as an UID.</li><li><code>`Parse_int</code>, <code>`Parse_float</code>, <code>`Parse_time</code> skips the data element.</li><li><code>`Unknown_vr</code>, continues assuming a <code>UN</code> value representation.</li><li><code>`Value_length_overflow</code>, skips the data element.</li><li><code>`Value_length_undefined</code>, skips the data element whose value is assumed to be of 0xFFFFFFFF bytes (this may not be very useful).</li><li><code>`Value_length_mismatch</code>, skips the data element.</li></ul></header></section><section><header><h2 id="props"><a href="#props" class="anchor"></a>Features and limitations</h2><p>On decoding:</p><ul><li>Values are always returned unpadded. Strings are unpadded by '\x20' or '\x00' (DICOM mandates '\x20' for strings but some images are padded with '\x00' in the wild).</li><li>Value representation that exceed their length are not reported as errors.</li><li>Value representation <code>`AS</code> is unparsed and returned as a string.</li><li>Value representation <code>`IS</code> are parsed with <code>Int32.of_string</code> and <code>`FS</code> with <code>float_of_string</code>.</li><li>Value representation and multiplicity of data elements are not checked for errors against the standard. You can do so by using functions from the <a href="Tag/index.html"><code>Tag</code></a> module.</li><li>In the implicit syntax, if a tag may have multiple VR (see the result of <a href="Tag/index.html#val-vr"><code>Tag.vr</code></a>). In that case we unconditionally map <code>`OB_or_OW</code> to <code>`OW</code>, <code>`US_or_SS</code> to <code>`US</code>, <code>`US_or_OW</code> to <code>`US</code> <code>`US_or_SS_or_OW</code> to <code>`US</code>. Depending on contextual information you may want to reinterpret that data differently, see PS 3.5 Annex A.1.</li><li>Item and sequence delimitation items are not returned.</li><li>Size limitations on 32 bits platforms. Values are limited by <span class="xref-unresolved" title="unresolved reference to &quot;Sys.max_string_length&quot;"><code>Sys</code>.max_string_length</span>, In each of these cases the error <code>`Size_overflow</code> is returned and the data element is skipped. Note that none of this should happen on 64 bits platforms. This limitation could be lifted in future versions of the library.</li></ul></header></section><section><header><h2 id="pixels"><a href="#pixels" class="anchor"></a>Pixel data</h2><p>On decoding for DICOM bitmap data, the pixel representation tag <code>(0028,0103)</code> is captured and if tag <code>(7FE0, 0010)</code> has a 16 bits representation the value is mapped to `UInt16 or `Int16 accordingly.</p></header></section><section><header><h2 id="examples"><a href="#examples" class="anchor"></a>Examples</h2></header></section></div></body></html>