<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Dolmen_std__Statement (dolmen.Dolmen_std__Statement)</title><link rel="stylesheet" href="../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../index.html">dolmen</a> &#x00BB; Dolmen_std__Statement</nav><h1>Module <code>Dolmen_std__Statement</code></h1><p>Standard imlplementation of statements. This module provides a reasonable and standard implementation of statements, that can directly be used to instantiated the various functors of the dolmen library. These statements are closer to smtlib statements than to other languages statements because it is easier to express other languages statements using smtlib's than the other way around. Still, a generalisation of smtlib statements was needed so as not to lose some important distinctions between conjectures and assertions for instance.</p><nav class="toc"><ul><li><a href="#type-definitions">Type definitions</a></li><li><a href="#implemented-interfaces">Implemented interfaces</a></li><li><a href="#additional-functions">Additional functions</a></li></ul></nav></header><section><header><h3 id="type-definitions"><a href="#type-definitions" class="anchor"></a>Type definitions</h3></header><dl><dt class="spec type" id="type-term"><a href="#type-term" class="anchor"></a><code><span class="keyword">type</span> term</code><code> = <a href="../Dolmen_std/Term/index.html#type-t">Dolmen_std.Term.t</a></code></dt><dt class="spec type" id="type-location"><a href="#type-location" class="anchor"></a><code><span class="keyword">type</span> location</code><code> = <a href="../Dolmen_std/ParseLocation/index.html#type-t">Dolmen_std.ParseLocation.t</a></code></dt><dd><p>Type aliases for readability.</p></dd></dl><dl><dt class="spec type" id="type-inductive"><a href="#type-inductive" class="anchor"></a><code><span class="keyword">type</span> inductive</code><code> = </code><code>{</code><table class="record"><tr id="type-inductive.id" class="anchored"><td class="def field"><a href="#type-inductive.id" class="anchor"></a><code>id : <a href="../Dolmen_std/Id/index.html#type-t">Dolmen_std.Id.t</a>;</code></td></tr><tr id="type-inductive.vars" class="anchored"><td class="def field"><a href="#type-inductive.vars" class="anchor"></a><code>vars : <a href="index.html#type-term">term</a> list;</code></td></tr><tr id="type-inductive.cstrs" class="anchored"><td class="def field"><a href="#type-inductive.cstrs" class="anchor"></a><code>cstrs : (<a href="../Dolmen_std/Id/index.html#type-t">Dolmen_std.Id.t</a> * <a href="index.html#type-term">term</a> list) list;</code></td></tr><tr id="type-inductive.loc" class="anchored"><td class="def field"><a href="#type-inductive.loc" class="anchor"></a><code>loc : <a href="index.html#type-location">location</a> option;</code></td></tr></table><code>}</code></dt><dd><p>The type for inductive type declarations. The &quot;vars&quot; field if used to store polymorphic variables of the inductive type. For instance, a polymorphic type for lists would have a single variable &quot;a&quot;. The constructors each have a name and a list of concrete arguments types (they all implicitly take as many type arguments as there are variables). So, for instance, the polymorphic list type would have two constructors:</p><ul><li><code>&quot;Nil&quot;, []</code></li><li><code>&quot;Cons&quot;, [var &quot;a&quot;]</code></li></ul></dd></dl><dl><dt class="spec type" id="type-descr"><a href="#type-descr" class="anchor"></a><code><span class="keyword">type</span> descr</code><code> = </code><table class="variant"><tr id="type-descr.Pack" class="anchored"><td class="def constructor"><a href="#type-descr.Pack" class="anchor"></a><code>| </code><code><span class="constructor">Pack</span> <span class="keyword">of</span> <a href="index.html#type-t">t</a> list</code></td><td class="doc"><p>Pack a list of statements that have a semantic meaning (for instance a list of mutually recursive inductive definitions).</p></td></tr><tr id="type-descr.Pop" class="anchored"><td class="def constructor"><a href="#type-descr.Pop" class="anchor"></a><code>| </code><code><span class="constructor">Pop</span> <span class="keyword">of</span> int</code></td><td class="doc"><p>Pop the stack of assertions as many times as specified.</p></td></tr><tr id="type-descr.Push" class="anchored"><td class="def constructor"><a href="#type-descr.Push" class="anchor"></a><code>| </code><code><span class="constructor">Push</span> <span class="keyword">of</span> int</code></td><td class="doc"><p>Push as many new levels on the stack of assertions as specified.</p></td></tr><tr id="type-descr.Reset_assertions" class="anchored"><td class="def constructor"><a href="#type-descr.Reset_assertions" class="anchor"></a><code>| </code><code><span class="constructor">Reset_assertions</span></code></td><td class="doc"><p>Reset all assertions.</p></td></tr><tr id="type-descr.Plain" class="anchored"><td class="def constructor"><a href="#type-descr.Plain" class="anchor"></a><code>| </code><code><span class="constructor">Plain</span> <span class="keyword">of</span> <a href="index.html#type-term">term</a></code></td><td class="doc"><p>A plain statement ontaining a term with no defined semantics.</p></td></tr><tr id="type-descr.Prove" class="anchored"><td class="def constructor"><a href="#type-descr.Prove" class="anchor"></a><code>| </code><code><span class="constructor">Prove</span> <span class="keyword">of</span> <a href="index.html#type-term">term</a> list</code></td><td class="doc"><p>Try and prove the current sequent, under some local assumptions.</p></td></tr><tr id="type-descr.Clause" class="anchored"><td class="def constructor"><a href="#type-descr.Clause" class="anchor"></a><code>| </code><code><span class="constructor">Clause</span> <span class="keyword">of</span> <a href="index.html#type-term">term</a> list</code></td><td class="doc"><p>Add the given clause on the left side of the current sequent.</p></td></tr><tr id="type-descr.Antecedent" class="anchored"><td class="def constructor"><a href="#type-descr.Antecedent" class="anchor"></a><code>| </code><code><span class="constructor">Antecedent</span> <span class="keyword">of</span> <a href="index.html#type-term">term</a></code></td><td class="doc"><p>Add the given proposition on the left of the current sequent.</p></td></tr><tr id="type-descr.Consequent" class="anchored"><td class="def constructor"><a href="#type-descr.Consequent" class="anchor"></a><code>| </code><code><span class="constructor">Consequent</span> <span class="keyword">of</span> <a href="index.html#type-term">term</a></code></td><td class="doc"><p>Add the given proposition on the right of the current sequent.</p></td></tr><tr id="type-descr.Include" class="anchored"><td class="def constructor"><a href="#type-descr.Include" class="anchor"></a><code>| </code><code><span class="constructor">Include</span> <span class="keyword">of</span> string</code></td><td class="doc"><p>File include, qualified include paths, if any, are stored in the attribute.</p></td></tr><tr id="type-descr.Set_logic" class="anchored"><td class="def constructor"><a href="#type-descr.Set_logic" class="anchor"></a><code>| </code><code><span class="constructor">Set_logic</span> <span class="keyword">of</span> string</code></td><td class="doc"><p>Set the logic to use for proving.</p></td></tr><tr id="type-descr.Get_info" class="anchored"><td class="def constructor"><a href="#type-descr.Get_info" class="anchor"></a><code>| </code><code><span class="constructor">Get_info</span> <span class="keyword">of</span> string</code></td><td class="doc"><p>Get required information.</p></td></tr><tr id="type-descr.Set_info" class="anchored"><td class="def constructor"><a href="#type-descr.Set_info" class="anchor"></a><code>| </code><code><span class="constructor">Set_info</span> <span class="keyword">of</span> <a href="index.html#type-term">term</a></code></td><td class="doc"><p>Set the information value.</p></td></tr><tr id="type-descr.Get_option" class="anchored"><td class="def constructor"><a href="#type-descr.Get_option" class="anchor"></a><code>| </code><code><span class="constructor">Get_option</span> <span class="keyword">of</span> string</code></td><td class="doc"><p>Get the required option value.</p></td></tr><tr id="type-descr.Set_option" class="anchored"><td class="def constructor"><a href="#type-descr.Set_option" class="anchor"></a><code>| </code><code><span class="constructor">Set_option</span> <span class="keyword">of</span> <a href="index.html#type-term">term</a></code></td><td class="doc"><p>Set the option value.</p></td></tr><tr id="type-descr.Def" class="anchored"><td class="def constructor"><a href="#type-descr.Def" class="anchor"></a><code>| </code><code><span class="constructor">Def</span> <span class="keyword">of</span> <a href="../Dolmen_std/Id/index.html#type-t">Dolmen_std.Id.t</a> * <a href="index.html#type-term">term</a></code></td><td class="doc"><p>Symbol definition, i.e the symbol is equal to the given term.</p></td></tr><tr id="type-descr.Decl" class="anchored"><td class="def constructor"><a href="#type-descr.Decl" class="anchor"></a><code>| </code><code><span class="constructor">Decl</span> <span class="keyword">of</span> <a href="../Dolmen_std/Id/index.html#type-t">Dolmen_std.Id.t</a> * <a href="index.html#type-term">term</a></code></td><td class="doc"><p>Symbol declaration, i.e the symbol has the given term as its type.</p></td></tr><tr id="type-descr.Inductive" class="anchored"><td class="def constructor"><a href="#type-descr.Inductive" class="anchor"></a><code>| </code><code><span class="constructor">Inductive</span> <span class="keyword">of</span> <a href="index.html#type-inductive">inductive</a></code></td><td class="doc"><p>Inductive type definition, see the <code>inductive</code> type.</p></td></tr><tr id="type-descr.Get_proof" class="anchored"><td class="def constructor"><a href="#type-descr.Get_proof" class="anchor"></a><code>| </code><code><span class="constructor">Get_proof</span></code></td><td class="doc"><p>Get the proof of the last sequent (if it was proved).</p></td></tr><tr id="type-descr.Get_unsat_core" class="anchored"><td class="def constructor"><a href="#type-descr.Get_unsat_core" class="anchor"></a><code>| </code><code><span class="constructor">Get_unsat_core</span></code></td><td class="doc"><p>Get the unsat core of the last sequent.</p></td></tr><tr id="type-descr.Get_unsat_assumptions" class="anchored"><td class="def constructor"><a href="#type-descr.Get_unsat_assumptions" class="anchor"></a><code>| </code><code><span class="constructor">Get_unsat_assumptions</span></code></td><td class="doc"><p>Get the local assumptions in the unsat core of the last sequent.</p></td></tr><tr id="type-descr.Get_model" class="anchored"><td class="def constructor"><a href="#type-descr.Get_model" class="anchor"></a><code>| </code><code><span class="constructor">Get_model</span></code></td><td class="doc"><p>Get the current model of the prover.</p></td></tr><tr id="type-descr.Get_value" class="anchored"><td class="def constructor"><a href="#type-descr.Get_value" class="anchor"></a><code>| </code><code><span class="constructor">Get_value</span> <span class="keyword">of</span> <a href="index.html#type-term">term</a> list</code></td><td class="doc"><p>Get the value of some terms in the current model of the prover.</p></td></tr><tr id="type-descr.Get_assignment" class="anchored"><td class="def constructor"><a href="#type-descr.Get_assignment" class="anchor"></a><code>| </code><code><span class="constructor">Get_assignment</span></code></td><td class="doc"><p>Get the assignment of labbeled formulas (see smtlib manual).</p></td></tr><tr id="type-descr.Get_assertions" class="anchored"><td class="def constructor"><a href="#type-descr.Get_assertions" class="anchor"></a><code>| </code><code><span class="constructor">Get_assertions</span></code></td><td class="doc"><p>Get the current set of assertions.</p></td></tr><tr id="type-descr.Echo" class="anchored"><td class="def constructor"><a href="#type-descr.Echo" class="anchor"></a><code>| </code><code><span class="constructor">Echo</span> <span class="keyword">of</span> string</code></td><td class="doc"><p>Prints the string.</p></td></tr><tr id="type-descr.Reset" class="anchored"><td class="def constructor"><a href="#type-descr.Reset" class="anchor"></a><code>| </code><code><span class="constructor">Reset</span></code></td><td class="doc"><p>Full reset of the prove to initial state.</p></td></tr><tr id="type-descr.Exit" class="anchored"><td class="def constructor"><a href="#type-descr.Exit" class="anchor"></a><code>| </code><code><span class="constructor">Exit</span></code></td><td class="doc"><p>Exit the interactive loop.</p></td></tr></table></dt><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">and</span> t</code><code> = </code><code>{</code><table class="record"><tr id="type-t.id" class="anchored"><td class="def field"><a href="#type-t.id" class="anchor"></a><code>id : <a href="../Dolmen_std/Id/index.html#type-t">Dolmen_std.Id.t</a>;</code></td></tr><tr id="type-t.descr" class="anchored"><td class="def field"><a href="#type-t.descr" class="anchor"></a><code>descr : <a href="index.html#type-descr">descr</a>;</code></td></tr><tr id="type-t.attr" class="anchored"><td class="def field"><a href="#type-t.attr" class="anchor"></a><code>attr : <a href="index.html#type-term">term</a> option;</code></td></tr><tr id="type-t.loc" class="anchored"><td class="def field"><a href="#type-t.loc" class="anchor"></a><code>loc : <a href="index.html#type-location">location</a> option;</code></td></tr></table><code>}</code></dt><dd><p>The type of statements. Statements have optional location and attributes (or annotations). Additionally the each have a name (which mainly comes from tptp statements), that can very well be the empty string (and so it is likely <b>not</b> unique).</p></dd></dl></section><section><header><h3 id="implemented-interfaces"><a href="#implemented-interfaces" class="anchor"></a>Implemented interfaces</h3></header><div><div class="spec include"><div class="doc"><details open="open"><summary><span class="def"><code><span class="keyword">include</span> <a href="../Dolmen_intf/Stmt/index.html#module-type-Logic">Dolmen_intf.Stmt.Logic</a> <span class="keyword">with</span> <span class="keyword">type</span> <a href="../Dolmen_intf/Stmt/module-type-Logic/index.html#type-t">t</a> := <a href="index.html#type-t">t</a> <span class="keyword">and</span> <span class="keyword">type</span> <a href="../Dolmen_intf/Stmt/module-type-Logic/index.html#type-id">id</a> := <a href="../Dolmen_std/Id/index.html#type-t">Dolmen_std.Id.t</a> <span class="keyword">and</span> <span class="keyword">type</span> <a href="../Dolmen_intf/Stmt/module-type-Logic/index.html#type-term">term</a> := <a href="index.html#type-term">term</a> <span class="keyword">and</span> <span class="keyword">type</span> <a href="../Dolmen_intf/Stmt/module-type-Logic/index.html#type-location">location</a> := <a href="index.html#type-location">location</a></code></span></summary><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> t</code></dt><dd><p>The type of statements.</p></dd></dl><dl><dt class="spec type" id="type-id"><a href="#type-id" class="anchor"></a><code><span class="keyword">type</span> id</code></dt><dd><p>The type of identifiers.</p></dd></dl><dl><dt class="spec type" id="type-term"><a href="#type-term" class="anchor"></a><code><span class="keyword">type</span> term</code></dt><dd><p>The type of terms used in statements.</p></dd></dl><dl><dt class="spec type" id="type-location"><a href="#type-location" class="anchor"></a><code><span class="keyword">type</span> location</code></dt><dd><p>The type of locations attached to statements.</p></dd></dl><section><header><h3 id="optional-infos-for-statements"><a href="#optional-infos-for-statements" class="anchor"></a>Optional infos for statements</h3></header><dl><dt class="spec value" id="val-annot"><a href="#val-annot" class="anchor"></a><code><span class="keyword">val</span> annot : ?&#8288;loc:<a href="index.html#type-location">location</a> <span>&#45;&gt;</span> <a href="index.html#type-term">term</a> <span>&#45;&gt;</span> <a href="index.html#type-term">term</a> list <span>&#45;&gt;</span> <a href="index.html#type-term">term</a></code></dt><dd><p>Constructors for annotations. Annotations are mainly used in TPTP.</p></dd></dl></section><section><header><h3 id="generic-statements"><a href="#generic-statements" class="anchor"></a>Generic statements</h3></header><dl><dt class="spec value" id="val-import"><a href="#val-import" class="anchor"></a><code><span class="keyword">val</span> import : ?&#8288;loc:<a href="index.html#type-location">location</a> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Import directive. Same as <code>include_</code> but without filtering on the statements to import.</p></dd></dl><dl><dt class="spec value" id="val-include_"><a href="#val-include_" class="anchor"></a><code><span class="keyword">val</span> include_ : ?&#8288;loc:<a href="index.html#type-location">location</a> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <a href="index.html#type-id">id</a> list <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Inlcude directive. <code>include file l</code> means to include in the current scope the directives from file <code>file</code> that appear in <code>l</code>. If <code>l</code> is the empty list, all directives should be imported.</p></dd></dl></section><section><header><h3 id="dimacs&amp;icnf-statements"><a href="#dimacs&amp;icnf-statements" class="anchor"></a>Dimacs&amp;iCNF Statements</h3></header><dl><dt class="spec value" id="val-p_cnf"><a href="#val-p_cnf" class="anchor"></a><code><span class="keyword">val</span> p_cnf : ?&#8288;loc:<a href="index.html#type-location">location</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Header of dimacs files. First argument is the number of variables, second is the number of clauses.</p></dd></dl><dl><dt class="spec value" id="val-clause"><a href="#val-clause" class="anchor"></a><code><span class="keyword">val</span> clause : ?&#8288;loc:<a href="index.html#type-location">location</a> <span>&#45;&gt;</span> <a href="index.html#type-term">term</a> list <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Add to the current set of assertions the given list of terms as a clause.</p></dd></dl><dl><dt class="spec value" id="val-assumption"><a href="#val-assumption" class="anchor"></a><code><span class="keyword">val</span> assumption : ?&#8288;loc:<a href="index.html#type-location">location</a> <span>&#45;&gt;</span> <a href="index.html#type-term">term</a> list <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Solve the current set of assertions, with the given assumptions.</p></dd></dl></section><section><header><h3 id="smtlib-statements"><a href="#smtlib-statements" class="anchor"></a>Smtlib statements</h3></header><dl><dt class="spec value" id="val-pop"><a href="#val-pop" class="anchor"></a><code><span class="keyword">val</span> pop : ?&#8288;loc:<a href="index.html#type-location">location</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-push"><a href="#val-push" class="anchor"></a><code><span class="keyword">val</span> push : ?&#8288;loc:<a href="index.html#type-location">location</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Directives for manipulating the set of assertions. Push directives creates backtrack point that can be reached using Pop directives.</p></dd></dl><dl><dt class="spec value" id="val-reset_assertions"><a href="#val-reset_assertions" class="anchor"></a><code><span class="keyword">val</span> reset_assertions : ?&#8288;loc:<a href="index.html#type-location">location</a> <span>&#45;&gt;</span> unit <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Reset all assertions that hase been pushed.</p></dd></dl><dl><dt class="spec value" id="val-assert_"><a href="#val-assert_" class="anchor"></a><code><span class="keyword">val</span> assert_ : ?&#8288;loc:<a href="index.html#type-location">location</a> <span>&#45;&gt;</span> <a href="index.html#type-term">term</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Add an assertion to the current set of assertions.</p></dd></dl><dl><dt class="spec value" id="val-check_sat"><a href="#val-check_sat" class="anchor"></a><code><span class="keyword">val</span> check_sat : ?&#8288;loc:<a href="index.html#type-location">location</a> <span>&#45;&gt;</span> <a href="index.html#type-term">term</a> list <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Directive that instructs the prover to solve the current set of assertions, undr some local assumptions.</p></dd></dl><dl><dt class="spec value" id="val-set_logic"><a href="#val-set_logic" class="anchor"></a><code><span class="keyword">val</span> set_logic : ?&#8288;loc:<a href="index.html#type-location">location</a> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Set the logic to be used for solving.</p></dd></dl><dl><dt class="spec value" id="val-get_info"><a href="#val-get_info" class="anchor"></a><code><span class="keyword">val</span> get_info : ?&#8288;loc:<a href="index.html#type-location">location</a> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-set_info"><a href="#val-set_info" class="anchor"></a><code><span class="keyword">val</span> set_info : ?&#8288;loc:<a href="index.html#type-location">location</a> <span>&#45;&gt;</span> <a href="index.html#type-term">term</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Getter and setter for various informations (see smtlib manual).</p></dd></dl><dl><dt class="spec value" id="val-get_option"><a href="#val-get_option" class="anchor"></a><code><span class="keyword">val</span> get_option : ?&#8288;loc:<a href="index.html#type-location">location</a> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-set_option"><a href="#val-set_option" class="anchor"></a><code><span class="keyword">val</span> set_option : ?&#8288;loc:<a href="index.html#type-location">location</a> <span>&#45;&gt;</span> <a href="index.html#type-term">term</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Getter and setter for prover options (see smtlib manual).</p></dd></dl><dl><dt class="spec value" id="val-type_decl"><a href="#val-type_decl" class="anchor"></a><code><span class="keyword">val</span> type_decl : ?&#8288;loc:<a href="index.html#type-location">location</a> <span>&#45;&gt;</span> <a href="index.html#type-id">id</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Type declaration. <code>type_decl s n</code> declare <code>s</code> as a type constructor with arity <code>n</code>.</p></dd></dl><dl><dt class="spec value" id="val-type_def"><a href="#val-type_def" class="anchor"></a><code><span class="keyword">val</span> type_def : ?&#8288;loc:<a href="index.html#type-location">location</a> <span>&#45;&gt;</span> <a href="index.html#type-id">id</a> <span>&#45;&gt;</span> <a href="index.html#type-id">id</a> list <span>&#45;&gt;</span> <a href="index.html#type-term">term</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Type definition. <code>type_def f args body</code> declare that <code>f(args) = body</code>, i.e any occurence of &quot;f(l)&quot; should be replaced by <code>body</code> where the &quot;args&quot; have been substituted by their corresponding value in <code>l</code>.</p></dd></dl><dl><dt class="spec value" id="val-datatypes"><a href="#val-datatypes" class="anchor"></a><code><span class="keyword">val</span> datatypes : ?&#8288;loc:<a href="index.html#type-location">location</a> <span>&#45;&gt;</span> (<a href="index.html#type-id">id</a> * <a href="index.html#type-term">term</a> list * (<a href="index.html#type-id">id</a> * <a href="index.html#type-term">term</a> list) list) list <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Inductive type definitions. TODO: some more documentation.</p></dd></dl><dl><dt class="spec value" id="val-fun_decl"><a href="#val-fun_decl" class="anchor"></a><code><span class="keyword">val</span> fun_decl : ?&#8288;loc:<a href="index.html#type-location">location</a> <span>&#45;&gt;</span> <a href="index.html#type-id">id</a> <span>&#45;&gt;</span> <a href="index.html#type-term">term</a> list <span>&#45;&gt;</span> <a href="index.html#type-term">term</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Symbol declaration. <code>fun_decl f args ret</code> defines <code>f</code> as a function which takes arguments of type as described in <code>args</code> and which returns a value of type <code>ret</code>.</p></dd></dl><dl><dt class="spec value" id="val-fun_def"><a href="#val-fun_def" class="anchor"></a><code><span class="keyword">val</span> fun_def : ?&#8288;loc:<a href="index.html#type-location">location</a> <span>&#45;&gt;</span> <a href="index.html#type-id">id</a> <span>&#45;&gt;</span> <a href="index.html#type-term">term</a> list <span>&#45;&gt;</span> <a href="index.html#type-term">term</a> <span>&#45;&gt;</span> <a href="index.html#type-term">term</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Symbol definition. <code>fun_def f args ret body</code> means that &quot;f(args) = (body : ret)&quot;, i.e f is a function symbol with arguments <code>args</code>, and which returns the value <code>body</code> which is of type <code>ret</code>.</p></dd></dl><dl><dt class="spec value" id="val-funs_def_rec"><a href="#val-funs_def_rec" class="anchor"></a><code><span class="keyword">val</span> funs_def_rec : ?&#8288;loc:<a href="index.html#type-location">location</a> <span>&#45;&gt;</span> (<a href="index.html#type-id">id</a> * <a href="index.html#type-term">term</a> list * <a href="index.html#type-term">term</a> * <a href="index.html#type-term">term</a>) list <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Define a list of mutually recursive functions. Each functions has the same definition as in <code>fun_def</code></p></dd></dl><dl><dt class="spec value" id="val-get_proof"><a href="#val-get_proof" class="anchor"></a><code><span class="keyword">val</span> get_proof : ?&#8288;loc:<a href="index.html#type-location">location</a> <span>&#45;&gt;</span> unit <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>If the last call to <code>check_sat</code> returned UNSAT, then instruct the prover to return the proof of unsat.</p></dd></dl><dl><dt class="spec value" id="val-get_unsat_core"><a href="#val-get_unsat_core" class="anchor"></a><code><span class="keyword">val</span> get_unsat_core : ?&#8288;loc:<a href="index.html#type-location">location</a> <span>&#45;&gt;</span> unit <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>If the last call to <code>check_sat</code> returned UNSAT, then instruct the prover to return the unsat core of the unsatisfiability proof, i.e the smallest set of assertions needed to prove <code>false</code>.</p></dd></dl><dl><dt class="spec value" id="val-get_unsat_assumptions"><a href="#val-get_unsat_assumptions" class="anchor"></a><code><span class="keyword">val</span> get_unsat_assumptions : ?&#8288;loc:<a href="index.html#type-location">location</a> <span>&#45;&gt;</span> unit <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>If the last call to <code>check_sat</code> returned UNSAT, then instruct the prover to return a subset of the local assumptions that is sufficient to deduce UNSAT.</p></dd></dl><dl><dt class="spec value" id="val-get_model"><a href="#val-get_model" class="anchor"></a><code><span class="keyword">val</span> get_model : ?&#8288;loc:<a href="index.html#type-location">location</a> <span>&#45;&gt;</span> unit <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>If the last call to <code>check_sat</code> returned SAT, then return the associated model.</p></dd></dl><dl><dt class="spec value" id="val-get_value"><a href="#val-get_value" class="anchor"></a><code><span class="keyword">val</span> get_value : ?&#8288;loc:<a href="index.html#type-location">location</a> <span>&#45;&gt;</span> <a href="index.html#type-term">term</a> list <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Instructs the prover to return the values of the given closed quantifier-free terms.</p></dd></dl><dl><dt class="spec value" id="val-get_assignment"><a href="#val-get_assignment" class="anchor"></a><code><span class="keyword">val</span> get_assignment : ?&#8288;loc:<a href="index.html#type-location">location</a> <span>&#45;&gt;</span> unit <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Instructs the prover to return truth assignemnt for labelled formulas (see smtlib manual for more information).</p></dd></dl><dl><dt class="spec value" id="val-get_assertions"><a href="#val-get_assertions" class="anchor"></a><code><span class="keyword">val</span> get_assertions : ?&#8288;loc:<a href="index.html#type-location">location</a> <span>&#45;&gt;</span> unit <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Instructs the prover to print all current assertions.</p></dd></dl><dl><dt class="spec value" id="val-echo"><a href="#val-echo" class="anchor"></a><code><span class="keyword">val</span> echo : ?&#8288;loc:<a href="index.html#type-location">location</a> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Print the given sting.</p></dd></dl><dl><dt class="spec value" id="val-reset"><a href="#val-reset" class="anchor"></a><code><span class="keyword">val</span> reset : ?&#8288;loc:<a href="index.html#type-location">location</a> <span>&#45;&gt;</span> unit <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Full reset of the prover state.</p></dd></dl><dl><dt class="spec value" id="val-exit"><a href="#val-exit" class="anchor"></a><code><span class="keyword">val</span> exit : ?&#8288;loc:<a href="index.html#type-location">location</a> <span>&#45;&gt;</span> unit <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Exit directive (used in interactive mode).</p></dd></dl></section><section><header><h3 id="tptp-statements"><a href="#tptp-statements" class="anchor"></a>TPTP Statements</h3></header><dl><dt class="spec value" id="val-tpi"><a href="#val-tpi" class="anchor"></a><code><span class="keyword">val</span> tpi : ?&#8288;loc:<a href="index.html#type-location">location</a> <span>&#45;&gt;</span> ?&#8288;annot:<a href="index.html#type-term">term</a> <span>&#45;&gt;</span> <a href="index.html#type-id">id</a> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <a href="index.html#type-term">term</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-thf"><a href="#val-thf" class="anchor"></a><code><span class="keyword">val</span> thf : ?&#8288;loc:<a href="index.html#type-location">location</a> <span>&#45;&gt;</span> ?&#8288;annot:<a href="index.html#type-term">term</a> <span>&#45;&gt;</span> <a href="index.html#type-id">id</a> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <a href="index.html#type-term">term</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-tff"><a href="#val-tff" class="anchor"></a><code><span class="keyword">val</span> tff : ?&#8288;loc:<a href="index.html#type-location">location</a> <span>&#45;&gt;</span> ?&#8288;annot:<a href="index.html#type-term">term</a> <span>&#45;&gt;</span> <a href="index.html#type-id">id</a> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <a href="index.html#type-term">term</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-fof"><a href="#val-fof" class="anchor"></a><code><span class="keyword">val</span> fof : ?&#8288;loc:<a href="index.html#type-location">location</a> <span>&#45;&gt;</span> ?&#8288;annot:<a href="index.html#type-term">term</a> <span>&#45;&gt;</span> <a href="index.html#type-id">id</a> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <a href="index.html#type-term">term</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-cnf"><a href="#val-cnf" class="anchor"></a><code><span class="keyword">val</span> cnf : ?&#8288;loc:<a href="index.html#type-location">location</a> <span>&#45;&gt;</span> ?&#8288;annot:<a href="index.html#type-term">term</a> <span>&#45;&gt;</span> <a href="index.html#type-id">id</a> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <a href="index.html#type-term">term</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>TPTP directives. <code>tptp name role t</code> instructs the prover to register a new directive with the given name, role and term. Current tptp roles are:</p><ul><li><code>&quot;axiom&quot;, &quot;hypothesis&quot;, &quot;definition&quot;, &quot;lemma&quot;, &quot;theorem&quot;</code> acts as new assertions/declartions</li><li><p><code>&quot;assumption&quot;, &quot;conjecture&quot;</code> are proposition that need to be proved, and then can be used to prove other propositions. They are equivalent to the following sequence of smtlib statements:</p><ul><li><code>push 1</code></li><li><code>assert (not t)</code></li><li><code>check_sat</code></li><li><code>pop 1</code></li><li><code>assert t</code></li></ul></li><li><code>&quot;negated_conjecture&quot;</code> is the same as <code>&quot;conjecture&quot;</code>, but the given proposition is false (i.e its negation is the proposition to prove).</li><li><code>&quot;type&quot;</code> declares a new symbol and its type</li><li><code>&quot;plain&quot;, &quot;unknown&quot;, &quot;fi_domain&quot;, &quot;fi_functors&quot;, &quot;fi_predicates&quot;</code> are valid roles with no specified semantics</li><li>any other role is an error</li></ul></dd></dl></section><section><header><h3 id="zipperposition-statements"><a href="#zipperposition-statements" class="anchor"></a>Zipperposition statements</h3></header><dl><dt class="spec value" id="val-data"><a href="#val-data" class="anchor"></a><code><span class="keyword">val</span> data : ?&#8288;loc:<a href="index.html#type-location">location</a> <span>&#45;&gt;</span> ?&#8288;attrs:<a href="index.html#type-term">term</a> list <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> list <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Packs a list of mutually recursive inductive type declarations into a single statement.</p></dd></dl><dl><dt class="spec value" id="val-defs"><a href="#val-defs" class="anchor"></a><code><span class="keyword">val</span> defs : ?&#8288;loc:<a href="index.html#type-location">location</a> <span>&#45;&gt;</span> ?&#8288;attrs:<a href="index.html#type-term">term</a> list <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> list <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Packs a list of mutually recursive definitions into a single statement.</p></dd></dl><dl><dt class="spec value" id="val-rewrite"><a href="#val-rewrite" class="anchor"></a><code><span class="keyword">val</span> rewrite : ?&#8288;loc:<a href="index.html#type-location">location</a> <span>&#45;&gt;</span> ?&#8288;attrs:<a href="index.html#type-term">term</a> list <span>&#45;&gt;</span> <a href="index.html#type-term">term</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Declare a rewrite rule, i.e a universally quantified equality or equivalence that can be oriented according to a specific ordering.</p></dd></dl><dl><dt class="spec value" id="val-goal"><a href="#val-goal" class="anchor"></a><code><span class="keyword">val</span> goal : ?&#8288;loc:<a href="index.html#type-location">location</a> <span>&#45;&gt;</span> ?&#8288;attrs:<a href="index.html#type-term">term</a> list <span>&#45;&gt;</span> <a href="index.html#type-term">term</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>The goal, i.e the propositional formula to prove.</p></dd></dl><dl><dt class="spec value" id="val-assume"><a href="#val-assume" class="anchor"></a><code><span class="keyword">val</span> assume : ?&#8288;loc:<a href="index.html#type-location">location</a> <span>&#45;&gt;</span> ?&#8288;attrs:<a href="index.html#type-term">term</a> list <span>&#45;&gt;</span> <a href="index.html#type-term">term</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Adds an hypothesis.</p></dd></dl><dl><dt class="spec value" id="val-lemma"><a href="#val-lemma" class="anchor"></a><code><span class="keyword">val</span> lemma : ?&#8288;loc:<a href="index.html#type-location">location</a> <span>&#45;&gt;</span> ?&#8288;attrs:<a href="index.html#type-term">term</a> list <span>&#45;&gt;</span> <a href="index.html#type-term">term</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Lemmas.</p></dd></dl><dl><dt class="spec value" id="val-decl"><a href="#val-decl" class="anchor"></a><code><span class="keyword">val</span> decl : ?&#8288;loc:<a href="index.html#type-location">location</a> <span>&#45;&gt;</span> ?&#8288;attrs:<a href="index.html#type-term">term</a> list <span>&#45;&gt;</span> <a href="index.html#type-id">id</a> <span>&#45;&gt;</span> <a href="index.html#type-term">term</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Symbol declaration. <code>decl name ty</code> declares a new symbol <code>name</code> with type <code>ty</code>.</p></dd></dl><dl><dt class="spec value" id="val-definition"><a href="#val-definition" class="anchor"></a><code><span class="keyword">val</span> definition : ?&#8288;loc:<a href="index.html#type-location">location</a> <span>&#45;&gt;</span> ?&#8288;attrs:<a href="index.html#type-term">term</a> list <span>&#45;&gt;</span> <a href="index.html#type-id">id</a> <span>&#45;&gt;</span> <a href="index.html#type-term">term</a> <span>&#45;&gt;</span> <a href="index.html#type-term">term</a> list <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Symbol definition. <code>def name ty term</code> defines a new symbol <code>name</code> of type <code>ty</code> which is equal to <code>term</code>.</p></dd></dl><dl><dt class="spec value" id="val-inductive"><a href="#val-inductive" class="anchor"></a><code><span class="keyword">val</span> inductive : ?&#8288;loc:<a href="index.html#type-location">location</a> <span>&#45;&gt;</span> ?&#8288;attrs:<a href="index.html#type-term">term</a> list <span>&#45;&gt;</span> <a href="index.html#type-id">id</a> <span>&#45;&gt;</span> <a href="index.html#type-term">term</a> list <span>&#45;&gt;</span> (<a href="index.html#type-id">id</a> * <a href="index.html#type-term">term</a> list) list <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Inductive type definitions. <code>inductive name vars l</code> defines an inductive type <code>name</code>, with polymorphic variables <code>vars</code>, and with a list of inductive constructors <code>l</code>.</p></dd></dl></section></details></div></div></div></section><section><header><h3 id="additional-functions"><a href="#additional-functions" class="anchor"></a>Additional functions</h3></header><dl><dt class="spec value" id="val-pp"><a href="#val-pp" class="anchor"></a><code><span class="keyword">val</span> pp : <a href="../../ocaml/Stdlib/Buffer/index.html#type-t">Stdlib.Buffer.t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-print"><a href="#val-print" class="anchor"></a><code><span class="keyword">val</span> print : <a href="../../ocaml/Stdlib/Format/index.html#type-formatter">Stdlib.Format.formatter</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Printing functions for statements.</p></dd></dl><dl><dt class="spec value" id="val-prove"><a href="#val-prove" class="anchor"></a><code><span class="keyword">val</span> prove : ?&#8288;loc:<a href="index.html#type-location">location</a> <span>&#45;&gt;</span> unit <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Emit a <code>Prove</code> statement.</p></dd></dl><dl><dt class="spec value" id="val-pack"><a href="#val-pack" class="anchor"></a><code><span class="keyword">val</span> pack : ?&#8288;id:<a href="../Dolmen_std/Id/index.html#type-t">Dolmen_std.Id.t</a> <span>&#45;&gt;</span> ?&#8288;loc:<a href="index.html#type-location">location</a> <span>&#45;&gt;</span> ?&#8288;attr:<a href="index.html#type-term">term</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> list <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Pack a list of statements into a single one.</p></dd></dl><dl><dt class="spec value" id="val-normalize"><a href="#val-normalize" class="anchor"></a><code><span class="keyword">val</span> normalize : (<a href="../Dolmen_std/Term/index.html#type-t">Dolmen_std.Term.t</a> <span>&#45;&gt;</span> <a href="../Dolmen_std/Term/index.html#type-t">Dolmen_std.Term.t</a>) <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Normalize statements with regards to a normalization function on terms.</p></dd></dl></section></div></body></html>