<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Dolmen_std__Term (dolmen.Dolmen_std__Term)</title><link rel="stylesheet" href="../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../index.html">dolmen</a> &#x00BB; Dolmen_std__Term</nav><h1>Module <code>Dolmen_std__Term</code></h1><p>Standard implementation of terms</p><nav class="toc"><ul><li><a href="#type-definitions">Type definitions</a></li><li><a href="#standard-functions">Standard functions</a></li><li><a href="#implemented-interfaces">Implemented interfaces</a></li><li><a href="#term-inspection">Term inspection</a></li><li><a href="#additional-functions">Additional functions</a></li><li><a href="#term-mapping">Term mapping</a></li></ul></nav></header><section><header><h3 id="type-definitions"><a href="#type-definitions" class="anchor"></a>Type definitions</h3></header><dl><dt class="spec type" id="type-location"><a href="#type-location" class="anchor"></a><code><span class="keyword">type</span> location</code><code> = <a href="../Dolmen_std/ParseLocation/index.html#type-t">Dolmen_std.ParseLocation.t</a></code></dt><dt class="spec type" id="type-builtin"><a href="#type-builtin" class="anchor"></a><code><span class="keyword">type</span> builtin</code><code> = </code><table class="variant"><tr id="type-builtin.Wildcard" class="anchored"><td class="def constructor"><a href="#type-builtin.Wildcard" class="anchor"></a><code>| </code><code><span class="constructor">Wildcard</span></code></td><td class="doc"><p>Wildcard symbol, i.e placeholder for an expression to be inferred, typically during type-checking.</p></td></tr><tr id="type-builtin.Ttype" class="anchored"><td class="def constructor"><a href="#type-builtin.Ttype" class="anchor"></a><code>| </code><code><span class="constructor">Ttype</span></code></td><td class="doc"><p>Builtin symbol for the type of Types.</p></td></tr><tr id="type-builtin.Prop" class="anchored"><td class="def constructor"><a href="#type-builtin.Prop" class="anchor"></a><code>| </code><code><span class="constructor">Prop</span></code></td><td class="doc"><p>Builtin symbol for the type of propositions.</p></td></tr><tr id="type-builtin.True" class="anchored"><td class="def constructor"><a href="#type-builtin.True" class="anchor"></a><code>| </code><code><span class="constructor">True</span></code></td><td class="doc"><p>The <code>true</code> propositional constant.</p></td></tr><tr id="type-builtin.False" class="anchored"><td class="def constructor"><a href="#type-builtin.False" class="anchor"></a><code>| </code><code><span class="constructor">False</span></code></td><td class="doc"><p>The <code>false</code> propositional constant.</p></td></tr><tr id="type-builtin.Eq" class="anchored"><td class="def constructor"><a href="#type-builtin.Eq" class="anchor"></a><code>| </code><code><span class="constructor">Eq</span></code></td><td class="doc"><p>Should all arguments be pariwise equal ?</p></td></tr><tr id="type-builtin.Distinct" class="anchored"><td class="def constructor"><a href="#type-builtin.Distinct" class="anchor"></a><code>| </code><code><span class="constructor">Distinct</span></code></td><td class="doc"><p>Should all arguments be pairwise distinct ?</p></td></tr><tr id="type-builtin.Ite" class="anchored"><td class="def constructor"><a href="#type-builtin.Ite" class="anchor"></a><code>| </code><code><span class="constructor">Ite</span></code></td><td class="doc"><p>Condional, usually applied to 3 terms (the condition, the then branch and the else branch).</p></td></tr><tr id="type-builtin.Sequent" class="anchored"><td class="def constructor"><a href="#type-builtin.Sequent" class="anchor"></a><code>| </code><code><span class="constructor">Sequent</span></code></td><td class="doc"><p>Sequent as term, usually takes two argument (left side, and right side of the sequent), which are respectively a conjunction and a disjunction of propositional formulas.</p></td></tr><tr id="type-builtin.Int" class="anchored"><td class="def constructor"><a href="#type-builtin.Int" class="anchor"></a><code>| </code><code><span class="constructor">Int</span></code></td><td class="doc"><p>Builtin integer type. Currently specific to Zipperposition format; other languages might use constants with pre-defined name, such as tptp's &quot;$int&quot;.</p></td></tr><tr id="type-builtin.Minus" class="anchored"><td class="def constructor"><a href="#type-builtin.Minus" class="anchor"></a><code>| </code><code><span class="constructor">Minus</span></code></td><td class="doc"><p>Arithmetic unary minus.</p></td></tr><tr id="type-builtin.Add" class="anchored"><td class="def constructor"><a href="#type-builtin.Add" class="anchor"></a><code>| </code><code><span class="constructor">Add</span></code></td><td class="doc"><p>Arithmetic addition.</p></td></tr><tr id="type-builtin.Sub" class="anchored"><td class="def constructor"><a href="#type-builtin.Sub" class="anchor"></a><code>| </code><code><span class="constructor">Sub</span></code></td><td class="doc"><p>Arithmetic substraction.</p></td></tr><tr id="type-builtin.Mult" class="anchored"><td class="def constructor"><a href="#type-builtin.Mult" class="anchor"></a><code>| </code><code><span class="constructor">Mult</span></code></td><td class="doc"><p>Arithmetic multiplication.</p></td></tr><tr id="type-builtin.Lt" class="anchored"><td class="def constructor"><a href="#type-builtin.Lt" class="anchor"></a><code>| </code><code><span class="constructor">Lt</span></code></td><td class="doc"><p>Arithmetic &quot;less than&quot; comparison (strict).</p></td></tr><tr id="type-builtin.Leq" class="anchored"><td class="def constructor"><a href="#type-builtin.Leq" class="anchor"></a><code>| </code><code><span class="constructor">Leq</span></code></td><td class="doc"><p>Arithmetic &quot;lesser or equal&quot; comparison.</p></td></tr><tr id="type-builtin.Gt" class="anchored"><td class="def constructor"><a href="#type-builtin.Gt" class="anchor"></a><code>| </code><code><span class="constructor">Gt</span></code></td><td class="doc"><p>Arithmetic &quot;greater than&quot; comparison.</p></td></tr><tr id="type-builtin.Geq" class="anchored"><td class="def constructor"><a href="#type-builtin.Geq" class="anchor"></a><code>| </code><code><span class="constructor">Geq</span></code></td><td class="doc"><p>Arithmetic &quot;greater or equal&quot; comparison.</p></td></tr><tr id="type-builtin.Subtype" class="anchored"><td class="def constructor"><a href="#type-builtin.Subtype" class="anchor"></a><code>| </code><code><span class="constructor">Subtype</span></code></td><td class="doc"><p>Subtyping relation</p></td></tr><tr id="type-builtin.Product" class="anchored"><td class="def constructor"><a href="#type-builtin.Product" class="anchor"></a><code>| </code><code><span class="constructor">Product</span></code></td><td class="doc"><p>Product type constructor</p></td></tr><tr id="type-builtin.Union" class="anchored"><td class="def constructor"><a href="#type-builtin.Union" class="anchor"></a><code>| </code><code><span class="constructor">Union</span></code></td><td class="doc"><p>Union type constructor</p></td></tr><tr id="type-builtin.Not" class="anchored"><td class="def constructor"><a href="#type-builtin.Not" class="anchor"></a><code>| </code><code><span class="constructor">Not</span></code></td><td class="doc"><p>Propositional negation</p></td></tr><tr id="type-builtin.And" class="anchored"><td class="def constructor"><a href="#type-builtin.And" class="anchor"></a><code>| </code><code><span class="constructor">And</span></code></td><td class="doc"><p>Propositional conjunction</p></td></tr><tr id="type-builtin.Or" class="anchored"><td class="def constructor"><a href="#type-builtin.Or" class="anchor"></a><code>| </code><code><span class="constructor">Or</span></code></td><td class="doc"><p>Propositional disjunction</p></td></tr><tr id="type-builtin.Nand" class="anchored"><td class="def constructor"><a href="#type-builtin.Nand" class="anchor"></a><code>| </code><code><span class="constructor">Nand</span></code></td><td class="doc"><p>Propositional not-and connective</p></td></tr><tr id="type-builtin.Xor" class="anchored"><td class="def constructor"><a href="#type-builtin.Xor" class="anchor"></a><code>| </code><code><span class="constructor">Xor</span></code></td><td class="doc"><p>Propositional exclusive disjunction</p></td></tr><tr id="type-builtin.Nor" class="anchored"><td class="def constructor"><a href="#type-builtin.Nor" class="anchor"></a><code>| </code><code><span class="constructor">Nor</span></code></td><td class="doc"><p>Propositional not-or</p></td></tr><tr id="type-builtin.Imply" class="anchored"><td class="def constructor"><a href="#type-builtin.Imply" class="anchor"></a><code>| </code><code><span class="constructor">Imply</span></code></td><td class="doc"><p>Propositional implication</p></td></tr><tr id="type-builtin.Implied" class="anchored"><td class="def constructor"><a href="#type-builtin.Implied" class="anchor"></a><code>| </code><code><span class="constructor">Implied</span></code></td><td class="doc"><p>Propositional left implication (i.e implication with reversed arguments).</p></td></tr><tr id="type-builtin.Equiv" class="anchored"><td class="def constructor"><a href="#type-builtin.Equiv" class="anchor"></a><code>| </code><code><span class="constructor">Equiv</span></code></td><td class="doc"><p>Propositional equivalence</p></td></tr></table></dt><dd><p>The type of builtins symbols for terms. Some languages have specific syntax for logical connectives (tptp's'&amp;&amp;' or '||' for isntance) whereas some (smtlib for instance) don't and treat them as constants.</p></dd></dl><dl><dt class="spec type" id="type-binder"><a href="#type-binder" class="anchor"></a><code><span class="keyword">type</span> binder</code><code> = </code><table class="variant"><tr id="type-binder.All" class="anchored"><td class="def constructor"><a href="#type-binder.All" class="anchor"></a><code>| </code><code><span class="constructor">All</span></code></td><td class="doc"><p>Universal quantification. Each term in the list of quantified terms should represent a variable (optionnally typed using the <a href="index.html#type-descr.Colon"><code>Colon</code></a> constructor.</p></td></tr><tr id="type-binder.Ex" class="anchored"><td class="def constructor"><a href="#type-binder.Ex" class="anchor"></a><code>| </code><code><span class="constructor">Ex</span></code></td><td class="doc"><p>Existencial quantification Each term in the list of quantified terms should represent a variable (optionnally typed using the <a href="index.html#type-descr.Colon"><code>Colon</code></a> constructor.</p></td></tr><tr id="type-binder.Pi" class="anchored"><td class="def constructor"><a href="#type-binder.Pi" class="anchor"></a><code>| </code><code><span class="constructor">Pi</span></code></td><td class="doc"><p>Polymorphic type quantification in function type Each term in the list of quantified terms should represent a variable (optionnally typed using the <a href="index.html#type-descr.Colon"><code>Colon</code></a> constructor.</p></td></tr><tr id="type-binder.Arrow" class="anchored"><td class="def constructor"><a href="#type-binder.Arrow" class="anchor"></a><code>| </code><code><span class="constructor">Arrow</span></code></td><td class="doc"><p>The arrow binder, for function types. Allows for curified types, if wanted.</p></td></tr><tr id="type-binder.Let" class="anchored"><td class="def constructor"><a href="#type-binder.Let" class="anchor"></a><code>| </code><code><span class="constructor">Let</span></code></td><td class="doc"><p>Let bindings (either propositional or for terms). Term boud by a let can have many forms depending on the language, but usual shapes are:</p><ul><li>an equality (using the builtin <a href="index.html#type-builtin.Eq"><code>Eq</code></a>) between a variable (optionnally typed using the <a href="index.html#type-descr.Colon"><code>Colon</code></a> constructor), and a term (e.g. in tptp)</li><li>an equivalence (using the builtin <a href="index.html#type-builtin.Equiv"><code>Equiv</code></a>) between a variable (optionnally typed using the <a href="index.html#type-descr.Colon"><code>Colon</code></a> constructor), and a term/proposition (e.g. in tptp)</li><li>a variable and a term juxtaposed using the <a href="index.html#type-descr.Colon"><code>Colon</code></a> constructor (e.g. in smtlib)</li></ul></td></tr><tr id="type-binder.Fun" class="anchored"><td class="def constructor"><a href="#type-binder.Fun" class="anchor"></a><code>| </code><code><span class="constructor">Fun</span></code></td><td class="doc"><p>Lambda, i.e function abstraction binder. Boud terms are the variables bound by the lambda, optionnally typed using the <a href="index.html#type-descr.Colon"><code>Colon</code></a> constructor.</p></td></tr><tr id="type-binder.Choice" class="anchored"><td class="def constructor"><a href="#type-binder.Choice" class="anchor"></a><code>| </code><code><span class="constructor">Choice</span></code></td><td class="doc"><p>Indefinite description, or epsilon terms. Likely to have its usual shape change fllowing tptp's recent changes.</p></td></tr><tr id="type-binder.Description" class="anchored"><td class="def constructor"><a href="#type-binder.Description" class="anchor"></a><code>| </code><code><span class="constructor">Description</span></code></td><td class="doc"><p>Definite description. Likely to have its usual shape change fllowing tptp's recent changes.</p></td></tr></table></dt><dd><p>The type of binders, these are pretty much always builtin in all languages.</p></dd></dl><dl><dt class="spec type" id="type-descr"><a href="#type-descr" class="anchor"></a><code><span class="keyword">type</span> descr</code><code> = </code><table class="variant"><tr id="type-descr.Symbol" class="anchored"><td class="def constructor"><a href="#type-descr.Symbol" class="anchor"></a><code>| </code><code><span class="constructor">Symbol</span> <span class="keyword">of</span> <a href="../Dolmen_std/Id/index.html#type-t">Dolmen_std.Id.t</a></code></td><td class="doc"><p>Constants, variables, etc... any string-identified non-builtin atomic term.</p></td></tr><tr id="type-descr.Builtin" class="anchored"><td class="def constructor"><a href="#type-descr.Builtin" class="anchor"></a><code>| </code><code><span class="constructor">Builtin</span> <span class="keyword">of</span> <a href="index.html#type-builtin">builtin</a></code></td><td class="doc"><p>Predefined builtins, i.e constants with lexical or syntaxic defintion in the source language.</p></td></tr><tr id="type-descr.Colon" class="anchored"><td class="def constructor"><a href="#type-descr.Colon" class="anchor"></a><code>| </code><code><span class="constructor">Colon</span> <span class="keyword">of</span> <a href="index.html#type-t">t</a> * <a href="index.html#type-t">t</a></code></td><td class="doc"><p>Juxtaposition of terms, usually used to annotate a term with its type (for quantified variables, functions arguments, etc...).</p></td></tr><tr id="type-descr.App" class="anchored"><td class="def constructor"><a href="#type-descr.App" class="anchor"></a><code>| </code><code><span class="constructor">App</span> <span class="keyword">of</span> <a href="index.html#type-t">t</a> * <a href="index.html#type-t">t</a> list</code></td><td class="doc"><p>Higher-order application</p></td></tr><tr id="type-descr.Binder" class="anchored"><td class="def constructor"><a href="#type-descr.Binder" class="anchor"></a><code>| </code><code><span class="constructor">Binder</span> <span class="keyword">of</span> <a href="index.html#type-binder">binder</a> * <a href="index.html#type-t">t</a> list * <a href="index.html#type-t">t</a></code></td><td class="doc"><p>Binder (quantifiers, local functions, ...), see the <a href="index.html#type-binder"><code>binder</code></a> type for more information.</p></td></tr><tr id="type-descr.Match" class="anchored"><td class="def constructor"><a href="#type-descr.Match" class="anchor"></a><code>| </code><code><span class="constructor">Match</span> <span class="keyword">of</span> <a href="index.html#type-t">t</a> * (<a href="index.html#type-t">t</a> * <a href="index.html#type-t">t</a>) list</code></td><td class="doc"><p>Pattern matching, the list contains tuples of the form <code>(pattern,branch)</code>.</p></td></tr></table></dt><dd><p>The AST for terms</p></dd></dl><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">and</span> t</code><code> = </code><code>{</code><table class="record"><tr id="type-t.term" class="anchored"><td class="def field"><a href="#type-t.term" class="anchor"></a><code>term : <a href="index.html#type-descr">descr</a>;</code></td></tr><tr id="type-t.attr" class="anchored"><td class="def field"><a href="#type-t.attr" class="anchor"></a><code>attr : <a href="index.html#type-t">t</a> list;</code></td></tr><tr id="type-t.loc" class="anchored"><td class="def field"><a href="#type-t.loc" class="anchor"></a><code>loc : <a href="index.html#type-location">location</a> option;</code></td></tr></table><code>}</code></dt><dd><p>The type of terms. A record containing an optional location, and a description of the term.</p></dd></dl></section><section><header><h3 id="standard-functions"><a href="#standard-functions" class="anchor"></a>Standard functions</h3></header><dl><dt class="spec value" id="val-equal"><a href="#val-equal" class="anchor"></a><code><span class="keyword">val</span> equal : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dt class="spec value" id="val-compare"><a href="#val-compare" class="anchor"></a><code><span class="keyword">val</span> compare : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int</code></dt><dd><p>Equality and comparison</p></dd></dl><dl><dt class="spec value" id="val-pp"><a href="#val-pp" class="anchor"></a><code><span class="keyword">val</span> pp : <a href="../../ocaml/Stdlib/Buffer/index.html#type-t">Stdlib.Buffer.t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-print"><a href="#val-print" class="anchor"></a><code><span class="keyword">val</span> print : <a href="../../ocaml/Stdlib/Format/index.html#type-formatter">Stdlib.Format.formatter</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-print_builtin"><a href="#val-print_builtin" class="anchor"></a><code><span class="keyword">val</span> print_builtin : <a href="../../ocaml/Stdlib/Format/index.html#type-formatter">Stdlib.Format.formatter</a> <span>&#45;&gt;</span> <a href="index.html#type-builtin">builtin</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Printing functionson buffer and formatters.</p></dd></dl></section><section><header><h3 id="implemented-interfaces"><a href="#implemented-interfaces" class="anchor"></a>Implemented interfaces</h3></header><div><div class="spec include"><div class="doc"><p>Include the Logic interface. This interface defines almost all term building functions that you may want to use.</p><details open="open"><summary><span class="def"><code><span class="keyword">include</span> <a href="../Dolmen_intf/Term/index.html#module-type-Logic">Dolmen_intf.Term.Logic</a> <span class="keyword">with</span> <span class="keyword">type</span> <a href="../Dolmen_intf/Term/module-type-Logic/index.html#type-t">t</a> := <a href="index.html#type-t">t</a> <span class="keyword">and</span> <span class="keyword">type</span> <a href="../Dolmen_intf/Term/module-type-Logic/index.html#type-id">id</a> := <a href="../Dolmen_std/Id/index.html#type-t">Dolmen_std.Id.t</a> <span class="keyword">and</span> <span class="keyword">type</span> <a href="../Dolmen_intf/Term/module-type-Logic/index.html#type-location">location</a> := <a href="index.html#type-location">location</a></code></span></summary><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> t</code></dt><dd><p>The type of terms.</p></dd></dl><dl><dt class="spec type" id="type-id"><a href="#type-id" class="anchor"></a><code><span class="keyword">type</span> id</code></dt><dd><p>The type of identifiers used for constants.</p></dd></dl><dl><dt class="spec type" id="type-location"><a href="#type-location" class="anchor"></a><code><span class="keyword">type</span> location</code></dt><dd><p>The type of locations attached to terms.</p></dd></dl><section><header><h4 id="predefined-terms"><a href="#predefined-terms" class="anchor"></a>Predefined terms</h4></header><dl><dt class="spec value" id="val-eq_t"><a href="#val-eq_t" class="anchor"></a><code><span class="keyword">val</span> eq_t : ?&#8288;loc:<a href="index.html#type-location">location</a> <span>&#45;&gt;</span> unit <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-neq_t"><a href="#val-neq_t" class="anchor"></a><code><span class="keyword">val</span> neq_t : ?&#8288;loc:<a href="index.html#type-location">location</a> <span>&#45;&gt;</span> unit <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>The terms representing equality and disequality, respectively.</p></dd></dl><dl><dt class="spec value" id="val-wildcard"><a href="#val-wildcard" class="anchor"></a><code><span class="keyword">val</span> wildcard : ?&#8288;loc:<a href="index.html#type-location">location</a> <span>&#45;&gt;</span> unit <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>The wildcard term, usually used in place of type arguments to explicit polymorphic functions to not explicit types that can be inferred by the type-checker.</p></dd></dl><dl><dt class="spec value" id="val-tType"><a href="#val-tType" class="anchor"></a><code><span class="keyword">val</span> tType : ?&#8288;loc:<a href="index.html#type-location">location</a> <span>&#45;&gt;</span> unit <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>The type of types, defined as specific token by the Zipperposition format; in other languages, will be represented as a constant (the &quot;$tType&quot; constant in tptp for instance). Used to define new types, or quantify type variables in languages that support polymorphism.</p></dd></dl><dl><dt class="spec value" id="val-ty_int"><a href="#val-ty_int" class="anchor"></a><code><span class="keyword">val</span> ty_int : ?&#8288;loc:<a href="index.html#type-location">location</a> <span>&#45;&gt;</span> unit <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>The type of integers, defined as a specific token by the Zipperposition format; in other languages, it might be represented as a constant with a specific name (for isntance, tptp's &quot;$int&quot;) .</p></dd></dl><dl><dt class="spec value" id="val-prop"><a href="#val-prop" class="anchor"></a><code><span class="keyword">val</span> prop : ?&#8288;loc:<a href="index.html#type-location">location</a> <span>&#45;&gt;</span> unit <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>The type of propositions. Also defined as a lexical token by the Zipperposition format. Will be defined as a constant in most other languages (for instance, &quot;$o&quot; in tptp).</p></dd></dl><dl><dt class="spec value" id="val-true_"><a href="#val-true_" class="anchor"></a><code><span class="keyword">val</span> true_ : ?&#8288;loc:<a href="index.html#type-location">location</a> <span>&#45;&gt;</span> unit <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-false_"><a href="#val-false_" class="anchor"></a><code><span class="keyword">val</span> false_ : ?&#8288;loc:<a href="index.html#type-location">location</a> <span>&#45;&gt;</span> unit <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>The constants for the true and false propositional constants. Again defined as lexical token in the Zipperposition format, while treated as a constant in other languages (&quot;$true&quot; in tptp).</p></dd></dl><dl><dt class="spec value" id="val-not_t"><a href="#val-not_t" class="anchor"></a><code><span class="keyword">val</span> not_t : ?&#8288;loc:<a href="index.html#type-location">location</a> <span>&#45;&gt;</span> unit <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-or_t"><a href="#val-or_t" class="anchor"></a><code><span class="keyword">val</span> or_t : ?&#8288;loc:<a href="index.html#type-location">location</a> <span>&#45;&gt;</span> unit <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-and_t"><a href="#val-and_t" class="anchor"></a><code><span class="keyword">val</span> and_t : ?&#8288;loc:<a href="index.html#type-location">location</a> <span>&#45;&gt;</span> unit <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-xor_t"><a href="#val-xor_t" class="anchor"></a><code><span class="keyword">val</span> xor_t : ?&#8288;loc:<a href="index.html#type-location">location</a> <span>&#45;&gt;</span> unit <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-nor_t"><a href="#val-nor_t" class="anchor"></a><code><span class="keyword">val</span> nor_t : ?&#8288;loc:<a href="index.html#type-location">location</a> <span>&#45;&gt;</span> unit <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-nand_t"><a href="#val-nand_t" class="anchor"></a><code><span class="keyword">val</span> nand_t : ?&#8288;loc:<a href="index.html#type-location">location</a> <span>&#45;&gt;</span> unit <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-equiv_t"><a href="#val-equiv_t" class="anchor"></a><code><span class="keyword">val</span> equiv_t : ?&#8288;loc:<a href="index.html#type-location">location</a> <span>&#45;&gt;</span> unit <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-implied_t"><a href="#val-implied_t" class="anchor"></a><code><span class="keyword">val</span> implied_t : ?&#8288;loc:<a href="index.html#type-location">location</a> <span>&#45;&gt;</span> unit <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-implies_t"><a href="#val-implies_t" class="anchor"></a><code><span class="keyword">val</span> implies_t : ?&#8288;loc:<a href="index.html#type-location">location</a> <span>&#45;&gt;</span> unit <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Standard logical connectives viewed as terms. <code>implies_t</code> is usual right implication, i.e <code>apply implies_t [p; q] </code> is &quot;p implies q&quot;, while <code>apply implied_t [p; q ]</code> means &quot;p is implied by q&quot; or &quot;q implies p&quot;.</p></dd></dl><dl><dt class="spec value" id="val-data_t"><a href="#val-data_t" class="anchor"></a><code><span class="keyword">val</span> data_t : ?&#8288;loc:<a href="index.html#type-location">location</a> <span>&#45;&gt;</span> unit <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Term without semantic meaning, used for creating &quot;data&quot; terms. Used in tptp's annotations, and with similar meaning as smtlib's s-expressions (as used in the <code>sexpr</code> function defined later).</p></dd></dl></section><section><header><h4 id="terms-leaf-constructors"><a href="#terms-leaf-constructors" class="anchor"></a>Terms leaf constructors</h4></header><dl><dt class="spec value" id="val-var"><a href="#val-var" class="anchor"></a><code><span class="keyword">val</span> var : ?&#8288;loc:<a href="index.html#type-location">location</a> <span>&#45;&gt;</span> <a href="index.html#type-id">id</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-const"><a href="#val-const" class="anchor"></a><code><span class="keyword">val</span> const : ?&#8288;loc:<a href="index.html#type-location">location</a> <span>&#45;&gt;</span> <a href="index.html#type-id">id</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Variable and constant constructors. While in some languages they can distinguished at the lexical level (in tptp for instance), in most languages, it is an issue dependant on scoping rules, so terms parsed from an smtlib file will have all variables parsed as constants.</p></dd></dl><dl><dt class="spec value" id="val-atom"><a href="#val-atom" class="anchor"></a><code><span class="keyword">val</span> atom : ?&#8288;loc:<a href="index.html#type-location">location</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Atoms are used for dimacs cnf parsing. Positive integers denotes variables, and negative integers denote the negation of the variable corresponding to their absolute value.</p></dd></dl><dl><dt class="spec value" id="val-distinct"><a href="#val-distinct" class="anchor"></a><code><span class="keyword">val</span> distinct : ?&#8288;loc:<a href="index.html#type-location">location</a> <span>&#45;&gt;</span> <a href="index.html#type-id">id</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Used in tptp to specify constants different from other constants, for instance the 'distinct' &quot;Apple&quot; should be syntactically different from the &quot;Apple&quot; constant. Can be safely aliased to the <code>const</code> function as the <code>distinct</code> function is always given strings already enclosed with quotes, so in the example above, <code>const</code> would be called with <code>&quot;Apple&quot;</code> as string argument, while <code>distinct</code> would be called with the string <code>&quot;\&quot;Apple\&quot;&quot;</code></p></dd></dl><dl><dt class="spec value" id="val-int"><a href="#val-int" class="anchor"></a><code><span class="keyword">val</span> int : ?&#8288;loc:<a href="index.html#type-location">location</a> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-rat"><a href="#val-rat" class="anchor"></a><code><span class="keyword">val</span> rat : ?&#8288;loc:<a href="index.html#type-location">location</a> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-real"><a href="#val-real" class="anchor"></a><code><span class="keyword">val</span> real : ?&#8288;loc:<a href="index.html#type-location">location</a> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-hexa"><a href="#val-hexa" class="anchor"></a><code><span class="keyword">val</span> hexa : ?&#8288;loc:<a href="index.html#type-location">location</a> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-binary"><a href="#val-binary" class="anchor"></a><code><span class="keyword">val</span> binary : ?&#8288;loc:<a href="index.html#type-location">location</a> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Constructors for words defined as numeric formats by the languages specifications. These also can be safely aliased to <code>const</code>.</p></dd></dl></section><section><header><h4 id="term-constructors"><a href="#term-constructors" class="anchor"></a>Term constructors</h4></header><dl><dt class="spec value" id="val-colon"><a href="#val-colon" class="anchor"></a><code><span class="keyword">val</span> colon : ?&#8288;loc:<a href="index.html#type-location">location</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Represents juxtaposition of two terms, usually denoted &quot;t : t'&quot; in most languages, and mainly used to annotated terms with their supposed, or defined, type.</p></dd></dl><dl><dt class="spec value" id="val-eq"><a href="#val-eq" class="anchor"></a><code><span class="keyword">val</span> eq : ?&#8288;loc:<a href="index.html#type-location">location</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-not_"><a href="#val-not_" class="anchor"></a><code><span class="keyword">val</span> not_ : ?&#8288;loc:<a href="index.html#type-location">location</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-or_"><a href="#val-or_" class="anchor"></a><code><span class="keyword">val</span> or_ : ?&#8288;loc:<a href="index.html#type-location">location</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> list <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-and_"><a href="#val-and_" class="anchor"></a><code><span class="keyword">val</span> and_ : ?&#8288;loc:<a href="index.html#type-location">location</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> list <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-imply"><a href="#val-imply" class="anchor"></a><code><span class="keyword">val</span> imply : ?&#8288;loc:<a href="index.html#type-location">location</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-equiv"><a href="#val-equiv" class="anchor"></a><code><span class="keyword">val</span> equiv : ?&#8288;loc:<a href="index.html#type-location">location</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Proposition construction functions. The conjunction and disjunction are n-ary instead of binary mostly because they are in smtlib (and that is subsumes the binary case).</p></dd></dl><dl><dt class="spec value" id="val-apply"><a href="#val-apply" class="anchor"></a><code><span class="keyword">val</span> apply : ?&#8288;loc:<a href="index.html#type-location">location</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> list <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Application constructor, seen as higher order application rather than first-order application for the following reasons: being able to parse tptp's THF, having location attached to function symbols.</p></dd></dl><dl><dt class="spec value" id="val-ite"><a href="#val-ite" class="anchor"></a><code><span class="keyword">val</span> ite : ?&#8288;loc:<a href="index.html#type-location">location</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Conditional constructor, both for first-order terms and propositions. Used in the following schema: <code>ite condition then_branch else_branch</code>.</p></dd></dl><dl><dt class="spec value" id="val-match_"><a href="#val-match_" class="anchor"></a><code><span class="keyword">val</span> match_ : ?&#8288;loc:<a href="index.html#type-location">location</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<a href="index.html#type-t">t</a> * <a href="index.html#type-t">t</a>) list <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Pattern matching. The first term is the term to match, and each tuple in the list is a match case, which is a pair of a pattern and a match branch.</p></dd></dl><dl><dt class="spec value" id="val-pi"><a href="#val-pi" class="anchor"></a><code><span class="keyword">val</span> pi : ?&#8288;loc:<a href="index.html#type-location">location</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> list <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-letin"><a href="#val-letin" class="anchor"></a><code><span class="keyword">val</span> letin : ?&#8288;loc:<a href="index.html#type-location">location</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> list <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-forall"><a href="#val-forall" class="anchor"></a><code><span class="keyword">val</span> forall : ?&#8288;loc:<a href="index.html#type-location">location</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> list <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-exists"><a href="#val-exists" class="anchor"></a><code><span class="keyword">val</span> exists : ?&#8288;loc:<a href="index.html#type-location">location</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> list <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-lambda"><a href="#val-lambda" class="anchor"></a><code><span class="keyword">val</span> lambda : ?&#8288;loc:<a href="index.html#type-location">location</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> list <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-choice"><a href="#val-choice" class="anchor"></a><code><span class="keyword">val</span> choice : ?&#8288;loc:<a href="index.html#type-location">location</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> list <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-description"><a href="#val-description" class="anchor"></a><code><span class="keyword">val</span> description : ?&#8288;loc:<a href="index.html#type-location">location</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> list <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Binders for variables. Takes a list of terms as first argument for simplicity, the lists will almost always be a list of variables, optionally typed using the <code>colon</code> term constructor.</p><ul><li>Pi is the polymorphic type quantification, for instance the polymorphic identity function has type: &quot;Pi alpha. alpha -&gt; alpha&quot;</li><li>Letin is local binding, takes a list of equality of equivalences whose left hand-side is a variable.</li><li>Forall is universal quantification</li><li>Exists is existential quantification</li><li>Lambda is used for function construction</li><li>Choice is the choice operator, also called indefinite description, or also epsilon terms, i.e &quot;Choice x. p(x)&quot; is one &quot;x&quot; such that &quot;p(x)&quot; is true.</li><li>Description is the definite description, i.e &quot;Description x. p(x)&quot; is the <b>only</b> &quot;x&quot; that satisfies p.</li></ul></dd></dl></section><section><header><h4 id="type-constructors"><a href="#type-constructors" class="anchor"></a>Type constructors</h4></header><dl><dt class="spec value" id="val-arrow"><a href="#val-arrow" class="anchor"></a><code><span class="keyword">val</span> arrow : ?&#8288;loc:<a href="index.html#type-location">location</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Function type constructor, for curryfied functions. Functions that takes multiple arguments in first-order terms (and so naturally not curryfied) will take a product as only argument (see the following <code>product</code> function).</p></dd></dl><dl><dt class="spec value" id="val-product"><a href="#val-product" class="anchor"></a><code><span class="keyword">val</span> product : ?&#8288;loc:<a href="index.html#type-location">location</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Product type constructor, used for instance in the types of functions that takes multiple arguments in a non-curry way.</p></dd></dl><dl><dt class="spec value" id="val-union"><a href="#val-union" class="anchor"></a><code><span class="keyword">val</span> union : ?&#8288;loc:<a href="index.html#type-location">location</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Union type constructor, currently used in tptp's THF format.</p></dd></dl><dl><dt class="spec value" id="val-subtype"><a href="#val-subtype" class="anchor"></a><code><span class="keyword">val</span> subtype : ?&#8288;loc:<a href="index.html#type-location">location</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Subtype relation for types.</p></dd></dl></section><section><header><h4 id="arithmetic-constructors"><a href="#arithmetic-constructors" class="anchor"></a>Arithmetic constructors</h4></header><dl><dt class="spec value" id="val-uminus"><a href="#val-uminus" class="anchor"></a><code><span class="keyword">val</span> uminus : ?&#8288;loc:<a href="index.html#type-location">location</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Arithmetic unary minus.</p></dd></dl><dl><dt class="spec value" id="val-add"><a href="#val-add" class="anchor"></a><code><span class="keyword">val</span> add : ?&#8288;loc:<a href="index.html#type-location">location</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Arithmetic addition.</p></dd></dl><dl><dt class="spec value" id="val-sub"><a href="#val-sub" class="anchor"></a><code><span class="keyword">val</span> sub : ?&#8288;loc:<a href="index.html#type-location">location</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Arithmetic substraction.</p></dd></dl><dl><dt class="spec value" id="val-mult"><a href="#val-mult" class="anchor"></a><code><span class="keyword">val</span> mult : ?&#8288;loc:<a href="index.html#type-location">location</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Arithmetic multiplication.</p></dd></dl><dl><dt class="spec value" id="val-lt"><a href="#val-lt" class="anchor"></a><code><span class="keyword">val</span> lt : ?&#8288;loc:<a href="index.html#type-location">location</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Arithmetic &quot;lesser than&quot; comparison (strict).</p></dd></dl><dl><dt class="spec value" id="val-leq"><a href="#val-leq" class="anchor"></a><code><span class="keyword">val</span> leq : ?&#8288;loc:<a href="index.html#type-location">location</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Arithmetic &quot;lesser or equal&quot; comparison.</p></dd></dl><dl><dt class="spec value" id="val-gt"><a href="#val-gt" class="anchor"></a><code><span class="keyword">val</span> gt : ?&#8288;loc:<a href="index.html#type-location">location</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Arithmetic &quot;greater than&quot; comparison (strict).</p></dd></dl><dl><dt class="spec value" id="val-geq"><a href="#val-geq" class="anchor"></a><code><span class="keyword">val</span> geq : ?&#8288;loc:<a href="index.html#type-location">location</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Arithmetic &quot;greater or equal&quot; comparison.</p></dd></dl></section><section><header><h4 id="special-constructions"><a href="#special-constructions" class="anchor"></a>Special constructions</h4></header><dl><dt class="spec value" id="val-quoted"><a href="#val-quoted" class="anchor"></a><code><span class="keyword">val</span> quoted : ?&#8288;loc:<a href="index.html#type-location">location</a> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Create an attribute from a quoted string (in Zf).</p></dd></dl><dl><dt class="spec value" id="val-sequent"><a href="#val-sequent" class="anchor"></a><code><span class="keyword">val</span> sequent : ?&#8288;loc:<a href="index.html#type-location">location</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> list <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> list <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Sequents as terms</p></dd></dl><dl><dt class="spec value" id="val-annot"><a href="#val-annot" class="anchor"></a><code><span class="keyword">val</span> annot : ?&#8288;loc:<a href="index.html#type-location">location</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> list <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Attach a list of attributes (also called annotations) to a term. Attributes have no logical meaning (they can be safely ignored), but may serve to give hints or meta-information.</p></dd></dl><dl><dt class="spec value" id="val-sexpr"><a href="#val-sexpr" class="anchor"></a><code><span class="keyword">val</span> sexpr : ?&#8288;loc:<a href="index.html#type-location">location</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> list <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>S-expressions (for smtlib attributes), should probably be related to the <code>data_t</code> term.</p></dd></dl></section></details></div></div></div></section><section><header><h3 id="term-inspection"><a href="#term-inspection" class="anchor"></a>Term inspection</h3></header><dl><dt class="spec value" id="val-fv"><a href="#val-fv" class="anchor"></a><code><span class="keyword">val</span> fv : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../Dolmen_std/Id/index.html#type-t">Dolmen_std.Id.t</a> list</code></dt><dd><p>Return the list of free variables (i.e currently, Ids that are in the <code>Var</code> namespace).</p></dd></dl></section><section><header><h3 id="additional-functions"><a href="#additional-functions" class="anchor"></a>Additional functions</h3></header><dl><dt class="spec value" id="val-builtin"><a href="#val-builtin" class="anchor"></a><code><span class="keyword">val</span> builtin : <a href="index.html#type-builtin">builtin</a> <span>&#45;&gt;</span> ?&#8288;loc:<a href="index.html#type-location">location</a> <span>&#45;&gt;</span> unit <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Make a builtin.</p></dd></dl><dl><dt class="spec value" id="val-fun_ty"><a href="#val-fun_ty" class="anchor"></a><code><span class="keyword">val</span> fun_ty : ?&#8288;loc:<a href="index.html#type-location">location</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> list <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Multi-arguments function type constructor.</p></dd></dl><dl><dt class="spec value" id="val-add_attr"><a href="#val-add_attr" class="anchor"></a><code><span class="keyword">val</span> add_attr : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>add_attr attr term</code> rturns a term <code>t</code> equal to <code>term</code>, but with <code>attr</code> added to the list of attributes.</p></dd></dl><dl><dt class="spec value" id="val-add_attrs"><a href="#val-add_attrs" class="anchor"></a><code><span class="keyword">val</span> add_attrs : <a href="index.html#type-t">t</a> list <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Same as <code>add_attr</code> but adds a list of attributes.</p></dd></dl><dl><dt class="spec value" id="val-set_attrs"><a href="#val-set_attrs" class="anchor"></a><code><span class="keyword">val</span> set_attrs : <a href="index.html#type-t">t</a> list <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Set the given list of terms as th attributes of the given term. Will fail (with an assertion) if the given term already have some assertion. In such cases, use add_attr instead.</p></dd></dl></section><section><header><h3 id="term-mapping"><a href="#term-mapping" class="anchor"></a>Term mapping</h3><p>The main use of terms mapper is to map fuctions over some terms. Traditionally, a mapping will usually only care about a few syntax cases and leav all other untouched. In these cases, it is useful to override the identity mapper, redefining only the fields needed.</p></header><dl><dt class="spec type" id="type-mapper"><a href="#type-mapper" class="anchor"></a><code><span class="keyword">type</span> 'a mapper</code><code> = </code><code>{</code><table class="record"><tr id="type-mapper.symbol" class="anchored"><td class="def field"><a href="#type-mapper.symbol" class="anchor"></a><code>symbol : <span class="type-var">'a</span> <a href="index.html#type-mapper">mapper</a> <span>&#45;&gt;</span> attr:<a href="index.html#type-t">t</a> list <span>&#45;&gt;</span> loc:<a href="index.html#type-location">location</a> option <span>&#45;&gt;</span> <a href="../Dolmen_std/Id/index.html#type-t">Dolmen_std.Id.t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span>;</code></td></tr><tr id="type-mapper.builtin" class="anchored"><td class="def field"><a href="#type-mapper.builtin" class="anchor"></a><code>builtin : <span class="type-var">'a</span> <a href="index.html#type-mapper">mapper</a> <span>&#45;&gt;</span> attr:<a href="index.html#type-t">t</a> list <span>&#45;&gt;</span> loc:<a href="index.html#type-location">location</a> option <span>&#45;&gt;</span> <a href="index.html#type-builtin">builtin</a> <span>&#45;&gt;</span> <span class="type-var">'a</span>;</code></td></tr><tr id="type-mapper.colon" class="anchored"><td class="def field"><a href="#type-mapper.colon" class="anchor"></a><code>colon : <span class="type-var">'a</span> <a href="index.html#type-mapper">mapper</a> <span>&#45;&gt;</span> attr:<a href="index.html#type-t">t</a> list <span>&#45;&gt;</span> loc:<a href="index.html#type-location">location</a> option <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span>;</code></td></tr><tr id="type-mapper.app" class="anchored"><td class="def field"><a href="#type-mapper.app" class="anchor"></a><code>app : <span class="type-var">'a</span> <a href="index.html#type-mapper">mapper</a> <span>&#45;&gt;</span> attr:<a href="index.html#type-t">t</a> list <span>&#45;&gt;</span> loc:<a href="index.html#type-location">location</a> option <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> list <span>&#45;&gt;</span> <span class="type-var">'a</span>;</code></td></tr><tr id="type-mapper.binder" class="anchored"><td class="def field"><a href="#type-mapper.binder" class="anchor"></a><code>binder : <span class="type-var">'a</span> <a href="index.html#type-mapper">mapper</a> <span>&#45;&gt;</span> attr:<a href="index.html#type-t">t</a> list <span>&#45;&gt;</span> loc:<a href="index.html#type-location">location</a> option <span>&#45;&gt;</span> <a href="index.html#type-binder">binder</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> list <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span>;</code></td></tr><tr id="type-mapper.pmatch" class="anchored"><td class="def field"><a href="#type-mapper.pmatch" class="anchor"></a><code>pmatch : <span class="type-var">'a</span> <a href="index.html#type-mapper">mapper</a> <span>&#45;&gt;</span> attr:<a href="index.html#type-t">t</a> list <span>&#45;&gt;</span> loc:<a href="index.html#type-location">location</a> option <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<a href="index.html#type-t">t</a> * <a href="index.html#type-t">t</a>) list <span>&#45;&gt;</span> <span class="type-var">'a</span>;</code></td></tr></table><code>}</code></dt><dd><p>The type of a mapper on terms.</p></dd></dl><dl><dt class="spec value" id="val-id_mapper"><a href="#val-id_mapper" class="anchor"></a><code><span class="keyword">val</span> id_mapper : <a href="index.html#type-t">t</a> <a href="index.html#type-mapper">mapper</a></code></dt><dd><p>The identity mapper: maps any term to itself.</p></dd></dl><dl><dt class="spec value" id="val-map"><a href="#val-map" class="anchor"></a><code><span class="keyword">val</span> map : <span class="type-var">'a</span> <a href="index.html#type-mapper">mapper</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p>Apply a mapper to a term.</p></dd></dl></section></div></body></html>