<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Ecaml__Process (ecaml.Ecaml__Process)</title><link rel="stylesheet" href="../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../index.html">ecaml</a> &#x00BB; Ecaml__Process</nav><h1>Module <code>Ecaml__Process</code></h1><p><code>Process</code> is used to create &quot;subprocesses&quot; or &quot;child processes&quot; of the Emacs process, which is their &quot;parent process&quot;. A subprocess of Emacs may be &quot;synchronous&quot; or &quot;asynchronous&quot;, depending on how it is created. When you create a synchronous subprocess, the program waits for the subprocess to terminate before continuing execution. When you create an asynchronous subprocess, it can run in parallel with Emacs. This kind of subprocess is represented within Emacs by a <code>Process.t</code>. Programs can use this object to communicate with the subprocess or to control it. For example, you can send signals, obtain status information, receive output from the process, or send input to it.</p><p><code>(Info-goto-node &quot;(elisp)Processes&quot;)</code>.</p></header><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> t</code><code> = <a href="../Ecaml__/Process0/index.html#type-t">Ecaml__.Process0.t</a></code></dt></dl><div><div class="spec include"><div class="doc"><details open="open"><summary><span class="def"><code><span class="keyword">include</span> <span class="keyword">sig</span> ... <span class="keyword">end</span></code></span></summary><dl><dt class="spec value" id="val-sexp_of_t"><a href="#val-sexp_of_t" class="anchor"></a><code><span class="keyword">val</span> sexp_of_t : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../../sexplib0/Sexplib0/Sexp/index.html#type-t">Ppx_sexp_conv_lib.Sexp.t</a></code></dt></dl></details></div></div></div><div><div class="spec include"><div class="doc"><details open="open"><summary><span class="def"><code><span class="keyword">include</span> <a href="../../base/Base/Equal/index.html#module-type-S">Core_kernel.Equal.S</a> <span class="keyword">with</span> <span class="keyword">type</span> <a href="../../base/Base/Equal/module-type-S/index.html#type-t">t</a> := <a href="index.html#type-t">t</a></code></span></summary><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> t</code></dt></dl><dl><dt class="spec value" id="val-equal"><a href="#val-equal" class="anchor"></a><code><span class="keyword">val</span> equal : <a href="index.html#type-t">t</a> <a href="../../core_kernel/Core_kernel/Equal/index.html#type-equal">Core_kernel.Equal.equal</a></code></dt></dl></details></div></div></div><div><div class="spec include"><div class="doc"><details open="open"><summary><span class="def"><code><span class="keyword">include</span> <a href="../Ecaml/Value/index.html#module-type-Subtype">Ecaml.Value.Subtype</a> <span class="keyword">with</span> <span class="keyword">type</span> <a href="../Ecaml/Value/module-type-Subtype/index.html#type-t">t</a> := <a href="index.html#type-t">t</a></code></span></summary><dl><dt class="spec type" id="type-value"><a href="#type-value" class="anchor"></a><code><span class="keyword">type</span> value</code></dt><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> t</code><code> = <span class="keyword">private</span> <a href="index.html#type-value">value</a></code></dt><dd><p>We expose <code>private value</code> for free identity conversions when the value is nested in some covariant type, e.g. <code>(symbols : Symbol.t list :&gt; Value.t list)</code> rather than <code>List.map symbols ~f:Symbol.to_value</code>.</p></dd></dl><div><div class="spec include"><div class="doc"><details open="open"><summary><span class="def"><code><span class="keyword">include</span> <span class="keyword">sig</span> ... <span class="keyword">end</span></code></span></summary><dl><dt class="spec value" id="val-sexp_of_t"><a href="#val-sexp_of_t" class="anchor"></a><code><span class="keyword">val</span> sexp_of_t : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../../sexplib0/Sexplib0/Sexp/index.html#type-t">Ppx_sexp_conv_lib.Sexp.t</a></code></dt></dl></details></div></div></div><dl><dt class="spec value" id="val-eq"><a href="#val-eq" class="anchor"></a><code><span class="keyword">val</span> eq : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>eq t1 t2 = Value.eq (to_value t1) (to_value t2)</code>, i.e. <code>eq</code> checks whether the Emacs values underlying <code>t1</code> and <code>t2</code> are physically equal. This is different than <code>phys_equal t1 t2</code>, because we don't always wrap <code>eq</code> Emacs values in <code>phys_equal</code> OCaml values. I.e. <code>phys_equal t1 t2</code> implies <code>eq t1 t2</code>, but not the converse.</p></dd></dl><div><div class="spec include"><div class="doc"><details open="open"><summary><span class="def"><code><span class="keyword">include</span> <a href="../Ecaml__/Valueable0/index.html#module-type-S">Ecaml__.Valueable0.S</a> <span class="keyword">with</span> <span class="keyword">type</span> <a href="../Ecaml__/Valueable0/module-type-S/index.html#type-t">t</a> := <a href="index.html#type-t">t</a></code></span></summary><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> t</code></dt><dt class="spec type" id="type-type_"><a href="#type-type_" class="anchor"></a><code><span class="keyword">type</span> 'a type_</code></dt></dl><dl><dt class="spec value" id="val-of_value_exn"><a href="#val-of_value_exn" class="anchor"></a><code><span class="keyword">val</span> of_value_exn : <a href="../Ecaml__/Value0/index.html#type-t">Ecaml__.Value0.t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-to_value"><a href="#val-to_value" class="anchor"></a><code><span class="keyword">val</span> to_value : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../Ecaml__/Value0/index.html#type-t">Ecaml__.Value0.t</a></code></dt><dt class="spec value" id="val-type_"><a href="#val-type_" class="anchor"></a><code><span class="keyword">val</span> type_ : <a href="index.html#type-t">t</a> <a href="index.html#type-type_">type_</a></code></dt></dl></details></div></div></div></details></div></div></div><dl><dt class="spec value" id="val-buffer"><a href="#val-buffer" class="anchor"></a><code><span class="keyword">val</span> buffer : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../Ecaml/Buffer/index.html#type-t">Ecaml.Buffer.t</a> option</code></dt><dd><p>Accessors</p><p><code>(describe-function 'process-buffer)</code></p></dd></dl><dl><dt class="spec value" id="val-command"><a href="#val-command" class="anchor"></a><code><span class="keyword">val</span> command : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> string list option</code></dt><dd><p><code>(describe-function 'process-buffer)</code></p><p><code>(describe-function 'process-command)</code></p></dd></dl><dl><dt class="spec value" id="val-name"><a href="#val-name" class="anchor"></a><code><span class="keyword">val</span> name : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> string</code></dt><dd><p><code>(describe-function 'process-command)</code></p><p><code>(describe-function 'process-name)</code></p></dd></dl><dl><dt class="spec value" id="val-pid"><a href="#val-pid" class="anchor"></a><code><span class="keyword">val</span> pid : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../../core_kernel/Core_kernel/Pid/index.html#type-t">Core_kernel.Pid.t</a> option</code></dt><dd><p><code>(describe-function 'process-name)</code></p><p><code>(describe-function 'process-id)</code></p></dd></dl><dl><dt class="spec value" id="val-query_on_exit"><a href="#val-query_on_exit" class="anchor"></a><code><span class="keyword">val</span> query_on_exit : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>(describe-function 'process-id)</code></p><p><code>(describe-function 'process-query-on-exit-flag)</code></p></dd></dl><dl><dt class="spec value" id="val-status"><a href="#val-status" class="anchor"></a><code><span class="keyword">val</span> status : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../Ecaml/Symbol/index.html#type-t">Ecaml.Symbol.t</a></code></dt><dd><p><code>(describe-function 'process-query-on-exit-flag)</code></p><p><code>(describe-function 'process-status)</code></p></dd></dl><dl><dt class="spec value" id="val-set_query_on_exit"><a href="#val-set_query_on_exit" class="anchor"></a><code><span class="keyword">val</span> set_query_on_exit : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool <span>&#45;&gt;</span> unit</code></dt><dd><p><code>set_query_on_exit t</code> specifies whether Emacs should query the user about killing <code>t</code> when it exits. <code>(describe-function 'set-process-query-on-exit-flag)</code>.</p></dd></dl><dl><dt class="spec value" id="val-all_emacs_children"><a href="#val-all_emacs_children" class="anchor"></a><code><span class="keyword">val</span> all_emacs_children : unit <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> list</code></dt><dd><p><code>(describe-function 'process-list)</code></p></dd></dl><dl><dt class="spec value" id="val-create"><a href="#val-create" class="anchor"></a><code><span class="keyword">val</span> create : ?&#8288;buffer:<a href="../Ecaml/Buffer/index.html#type-t">Ecaml.Buffer.t</a> <span>&#45;&gt;</span> unit <span>&#45;&gt;</span> args:string list <span>&#45;&gt;</span> name:string <span>&#45;&gt;</span> prog:string <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>(Info-goto-node &quot;(elisp)Asynchronous Processes&quot;)</code> <code>(describe-function 'start-process)</code></p></dd></dl><dl><dt class="spec value" id="val-find_by_name"><a href="#val-find_by_name" class="anchor"></a><code><span class="keyword">val</span> find_by_name : string <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> option</code></dt><dd><p><code>(describe-function 'get-process)</code> <code>(Info-goto-node &quot;(elisp)Process Information&quot;)</code></p></dd></dl><div class="spec module" id="module-Call"><a href="#module-Call" class="anchor"></a><code><span class="keyword">module</span> <a href="Call/index.html">Call</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><dl><dt class="spec value" id="val-call_result_exn"><a href="#val-call_result_exn" class="anchor"></a><code><span class="keyword">val</span> call_result_exn : ?&#8288;input:<a href="Call/Input/index.html#type-t">Call.Input.t</a> <span>&#45;&gt;</span> ?&#8288;output:<a href="Call/Output/index.html#type-t">Call.Output.t</a> <span>&#45;&gt;</span> ?&#8288;redisplay_on_output:bool <span>&#45;&gt;</span> ?&#8288;working_directory:<a href="../Ecaml/Working_directory/index.html#type-t">Ecaml.Working_directory.t</a> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> string list <span>&#45;&gt;</span> <a href="Call/Result/index.html#type-t">Call.Result.t</a></code></dt><dd><p><code>(Info-goto-node &quot;(elisp)Synchronous Processes&quot;)</code> <code>(describe-function 'call-process)</code></p></dd></dl><dl><dt class="spec value" id="val-call_exn"><a href="#val-call_exn" class="anchor"></a><code><span class="keyword">val</span> call_exn : ?&#8288;input:<a href="Call/Input/index.html#type-t">Call.Input.t</a> <span>&#45;&gt;</span> ?&#8288;working_directory:<a href="../Ecaml/Working_directory/index.html#type-t">Ecaml.Working_directory.t</a> <span>&#45;&gt;</span> ?&#8288;strip_whitespace:bool <span>&#45;&gt;</span> string <span>&#45;&gt;</span> string list <span>&#45;&gt;</span> string</code></dt><dd><p><code>call_exn</code> runs <code>call_result_exn</code>, strips whitespace from stdout+stderr if <code>strip_whitespace</code> is <code>true</code>, and returns the resulting string, raising on nonzero exit.</p></dd></dl><dl><dt class="spec value" id="val-call_expect_no_output_exn"><a href="#val-call_expect_no_output_exn" class="anchor"></a><code><span class="keyword">val</span> call_expect_no_output_exn : ?&#8288;input:<a href="Call/Input/index.html#type-t">Call.Input.t</a> <span>&#45;&gt;</span> ?&#8288;working_directory:<a href="../Ecaml/Working_directory/index.html#type-t">Ecaml.Working_directory.t</a> <span>&#45;&gt;</span> ?&#8288;strip_whitespace:bool <span>&#45;&gt;</span> string <span>&#45;&gt;</span> string list <span>&#45;&gt;</span> unit</code></dt><dd><p><code>call_expect_no_output_exn</code> runs <code>call_result_exn</code> and raises if the command output is not the empty string or on nonzero exit.</p></dd></dl><dl><dt class="spec value" id="val-shell_command_result"><a href="#val-shell_command_result" class="anchor"></a><code><span class="keyword">val</span> shell_command_result : ?&#8288;input:<a href="Call/Input/index.html#type-t">Call.Input.t</a> <span>&#45;&gt;</span> ?&#8288;output:<a href="Call/Output/index.html#type-t">Call.Output.t</a> <span>&#45;&gt;</span> ?&#8288;redisplay_on_output:bool <span>&#45;&gt;</span> ?&#8288;working_directory:<a href="../Ecaml/Working_directory/index.html#type-t">Ecaml.Working_directory.t</a> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <a href="Call/Result/index.html#type-t">Call.Result.t</a></code></dt><dt class="spec value" id="val-shell_command_exn"><a href="#val-shell_command_exn" class="anchor"></a><code><span class="keyword">val</span> shell_command_exn : ?&#8288;input:<a href="Call/Input/index.html#type-t">Call.Input.t</a> <span>&#45;&gt;</span> ?&#8288;working_directory:<a href="../Ecaml/Working_directory/index.html#type-t">Ecaml.Working_directory.t</a> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> string</code></dt><dd><p><code>shell_command_exn command</code> runs <code>command</code> in a subshell, strips whitespace from stdout+stderr, and returns the resulting string, raising on nonzero exit.</p></dd></dl><dl><dt class="spec value" id="val-create_unix_network_process"><a href="#val-create_unix_network_process" class="anchor"></a><code><span class="keyword">val</span> create_unix_network_process : unit <span>&#45;&gt;</span> filter:(<a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../Ecaml/Text/index.html#type-t">Ecaml.Text.t</a> <span>&#45;&gt;</span> unit) <span>&#45;&gt;</span> name:string <span>&#45;&gt;</span> socket_path:string <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>(Info-goto-node &quot;(elisp)Network Servers&quot;)</code> <code>(describe-function 'make-network-process)</code></p></dd></dl><dl><dt class="spec value" id="val-kill"><a href="#val-kill" class="anchor"></a><code><span class="keyword">val</span> kill : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>(Info-goto-node &quot;(elisp)Deleting Processes&quot;)</code>, <code>(describe-function
    'delete-process)</code>.</p></dd></dl></div></body></html>