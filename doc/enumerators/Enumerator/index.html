<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Enumerator (enumerators.Enumerator)</title><link rel="stylesheet" href="../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../index.html">enumerators</a> &#x00BB; Enumerator</nav><h1>Module <code>Enumerator</code></h1><p>Finite lazy enumerators.</p><p>Enumerators are a memory-efficient way of manipulating finite sequences.</p><nav class="toc"><ul><li><a href="#constructors">Constructors</a></li><li><a href="#transformations">Transformations</a></li><li><a href="#combinators">Combinators</a></li><li><a href="#debug">Debug</a></li></ul></nav></header><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> 'a t</code></dt></dl><dl><dt class="spec exception" id="exception-Out_of_bounds"><a href="#exception-Out_of_bounds" class="anchor"></a><code><span class="keyword">exception</span> </code><code><span class="exception">Out_of_bounds</span></code></dt><dd><p>Raised when an index is out of the bounds of an enumerator.</p></dd></dl><dl><dt class="spec value" id="val-nth"><a href="#val-nth" class="anchor"></a><code><span class="keyword">val</span> nth : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int64 <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p>Retrieve the element at a given index.</p></dd></dl><dl><dt class="spec value" id="val-elements"><a href="#val-elements" class="anchor"></a><code><span class="keyword">val</span> elements : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> list</code></dt><dd><p>Get all the elements of an enumeration in order.</p></dd></dl><dl><dt class="spec value" id="val-size"><a href="#val-size" class="anchor"></a><code><span class="keyword">val</span> size : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int64</code></dt><dd><p>Get the number of elements of an enumeration.</p></dd></dl><dl><dt class="spec value" id="val-size_int"><a href="#val-size_int" class="anchor"></a><code><span class="keyword">val</span> size_int : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int</code></dt><dd><p>Same as <code>Int64.to_int (size e)</code>. May overflow.</p></dd></dl><dl><dt class="spec value" id="val-is_empty"><a href="#val-is_empty" class="anchor"></a><code><span class="keyword">val</span> is_empty : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p>Test whether an enumeration is empty.</p></dd></dl><dl><dt class="spec value" id="val-fold_left"><a href="#val-fold_left" class="anchor"></a><code><span class="keyword">val</span> fold_left : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'a</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p><code>fold_left f acc a</code> computes <code>f (... (f (f acc a.(0)) a.(1)) ...)
    a.(n-1)</code>, where n is the size of the enumerator <code>a</code>.</p></dd></dl><dl><dt class="spec value" id="val-map"><a href="#val-map" class="anchor"></a><code><span class="keyword">val</span> map : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Map a function over an enumerator.</p></dd></dl><dl><dt class="spec value" id="val-iter"><a href="#val-iter" class="anchor"></a><code><span class="keyword">val</span> iter : (<span class="type-var">'a</span> <span>&#45;&gt;</span> unit) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Apply a function to the elements of an enumerator.</p></dd></dl><dl><dt class="spec value" id="val-memoize"><a href="#val-memoize" class="anchor"></a><code><span class="keyword">val</span> memoize : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Allocate an array to hold intermediate values.</p></dd></dl><section><header><h3 id="constructors"><a href="#constructors" class="anchor"></a>Constructors</h3></header><dl><dt class="spec value" id="val-make"><a href="#val-make" class="anchor"></a><code><span class="keyword">val</span> make : <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Enumerate the elements of the list, in the order defined by the list.</p></dd></dl><dl><dt class="spec value" id="val-of_list"><a href="#val-of_list" class="anchor"></a><code><span class="keyword">val</span> of_list : <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Same as <code>make</code>.</p></dd></dl><dl><dt class="spec type" id="type-set"><a href="#type-set" class="anchor"></a><code><span class="keyword">type</span> ('t, 'elt) set</code><code> = (<span class="keyword">module</span> <a href="../../ocaml/Stdlib/Set/module-type-S/index.html">Stdlib.Set.S</a> <span class="keyword">with</span> <span class="keyword">type</span> <a href="../../ocaml/Stdlib/Set/module-type-S/index.html#type-elt">elt</a> = <span class="type-var">'elt</span> <span class="keyword">and</span> <span class="keyword">type</span> <a href="../../ocaml/Stdlib/Set/module-type-S/index.html#type-t">t</a> = <span class="type-var">'t</span>)</code></dt></dl><dl><dt class="spec value" id="val-of_set"><a href="#val-of_set" class="anchor"></a><code><span class="keyword">val</span> of_set : (<span class="type-var">'t</span>, <span class="type-var">'elt</span>) <a href="index.html#type-set">set</a> <span>&#45;&gt;</span> <span class="type-var">'t</span> <span>&#45;&gt;</span> <span class="type-var">'elt</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Build an enumerator from a set.</p></dd></dl><dl><dt class="spec value" id="val-empty"><a href="#val-empty" class="anchor"></a><code><span class="keyword">val</span> empty : <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Empty enumerator.</p></dd></dl><dl><dt class="spec value" id="val-constant"><a href="#val-constant" class="anchor"></a><code><span class="keyword">val</span> constant : <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Singleton enumerator.</p></dd></dl><dl><dt class="spec value" id="val-constant_delayed"><a href="#val-constant_delayed" class="anchor"></a><code><span class="keyword">val</span> constant_delayed : (unit <span>&#45;&gt;</span> <span class="type-var">'a</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Enumerate a singleton which shall be recomputed each time it is enumerated.</p></dd></dl><dl><dt class="spec value" id="val-range"><a href="#val-range" class="anchor"></a><code><span class="keyword">val</span> range : int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int <a href="index.html#type-t">t</a></code></dt><dd><p><code>range a b</code> produces an enumerator for the integers between <code>a</code> and <code>b</code> included. If <code>b &lt; a</code> the range is empty.</p></dd></dl></section><section><header><h3 id="transformations"><a href="#transformations" class="anchor"></a>Transformations</h3></header><dl><dt class="spec value" id="val-firstn"><a href="#val-firstn" class="anchor"></a><code><span class="keyword">val</span> firstn : int64 <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> list * <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>firstn n e</code> enumerates the first <code>n</code> elements from the enumerator <code>e</code>. If the enumerator has less than <code>n</code> elements, it will only enumerate those.</p></dd></dl><dl><dt class="spec value" id="val-filter"><a href="#val-filter" class="anchor"></a><code><span class="keyword">val</span> filter : (<span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Apply a filter on an enumerator. Warning: this combinator evaluates its elements.</p></dd></dl><dl><dt class="spec value" id="val-partition"><a href="#val-partition" class="anchor"></a><code><span class="keyword">val</span> partition : (<span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> * <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>partition p e</code> returns a pair of enumerators <code>(e1, e2)</code>, where <code>e1</code> is the enumerator of all the elements of <code>e</code> that satisfy the predicate <code>p</code>, and <code>e2</code> is the enumerator of all the elements of <code>e</code> that do not satisfy <code>p</code>. The order of the elements from the input enumerator is preserved. Evaluates its elements.</p></dd></dl><dl><dt class="spec value" id="val-shuffle"><a href="#val-shuffle" class="anchor"></a><code><span class="keyword">val</span> shuffle : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Enumerate over a random permutation of an existing enumerator. Warning: This can take a lot of time on large enumerators.</p></dd></dl><dl><dt class="spec value" id="val-scalar_left"><a href="#val-scalar_left" class="anchor"></a><code><span class="keyword">val</span> scalar_left : <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span> * <span class="type-var">'b</span>) <a href="index.html#type-t">t</a></code></dt><dd><p><code>scalar_left a e</code> enumerates <code>(a, e0), (a, e1), ...</code> where <code>e0, e1, ...</code> are the elements of the enumerator <code>e</code>.</p></dd></dl><dl><dt class="spec value" id="val-scalar_right"><a href="#val-scalar_right" class="anchor"></a><code><span class="keyword">val</span> scalar_right : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> (<span class="type-var">'a</span> * <span class="type-var">'b</span>) <a href="index.html#type-t">t</a></code></dt><dd><p><code>scalar_right e b</code> enumerates <code>(e0, b), (e1, b), ...</code> where <code>e0, e1, ...</code> are the elements of the enumerator <code>e</code>.</p></dd></dl><dl><dt class="spec value" id="val-bitset"><a href="#val-bitset" class="anchor"></a><code><span class="keyword">val</span> bitset : ?&#8288;k:int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int <a href="index.html#type-t">t</a></code></dt><dd><p><code>bitset n</code> enumerates a bitset of size <code>n</code> represented as integers. <code>bitset ~k n</code> enumerates the elements having at most <code>k</code> ones in their binary representation.</p><p>Elements with fewer ones come first in the enumeration. For example: <code>bitset ~k:2 3</code> returns <code>[0b000; 0b001; 0b010; 0b100; 0b011; 0b101; 0b110]</code>.</p><p><code>n</code> must be less than <code>Sys.word_size - 2</code> (e.g., 30 or 62, depending on your architecture).</p></dd></dl></section><section><header><h3 id="combinators"><a href="#combinators" class="anchor"></a>Combinators</h3></header><dl><dt class="spec value" id="val-append"><a href="#val-append" class="anchor"></a><code><span class="keyword">val</span> append : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>append a b</code> enumerates all the elements of <code>a</code> then all the elements of <code>b</code>.</p></dd></dl><dl><dt class="spec value" id="val-interleave"><a href="#val-interleave" class="anchor"></a><code><span class="keyword">val</span> interleave : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Interleave two enumerators until one of them becomes empty and then append the remaining one after that.</p></dd></dl><dl><dt class="spec value" id="val-product"><a href="#val-product" class="anchor"></a><code><span class="keyword">val</span> product : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span> * <span class="type-var">'b</span>) <a href="index.html#type-t">t</a></code></dt><dd><p>Enumerate pairs.</p></dd></dl><dl><dt class="spec value" id="val-squash"><a href="#val-squash" class="anchor"></a><code><span class="keyword">val</span> squash : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Concatenate an enumerator of enumerators.</p></dd></dl><dl><dt class="spec value" id="val-round_robin"><a href="#val-round_robin" class="anchor"></a><code><span class="keyword">val</span> round_robin : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Squash enumerators in round-robin order.</p></dd></dl><dl><dt class="spec value" id="val-subset"><a href="#val-subset" class="anchor"></a><code><span class="keyword">val</span> subset : ?&#8288;k:int <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> list <span>&#45;&gt;</span> <span class="type-var">'a</span> list <a href="index.html#type-t">t</a> <a href="index.html#type-t">t</a></code></dt><dd><p>Enumerate balanced subsets.</p><p>This enumerates groups (as enumerators) of tuples (as lists). Each list contains at most one element from each of the input enumerators.</p><p>For instance, to enumerate subsets for <code>[1; 2] and [[3; 4]], [subset] enumerates
    four groups.  The first group enumerates the empty list, the second group enumerates
    the singletons from [[1; 2]], the third group enumerates singletons from [[3; 4]]
    and the fourth group enumerates the pairs with the first element from [[1; 2]] and
    the second element from [[3; 4]].
    If the argument [k] is supplied, lists longer than [k] will be ignored.
    The order in the resulting lists is the same as in the input enumerator list. For
    example, an element of [a] will never appear after an element of [b] in the lists of
    [subset a b].
    If you do not need the grouping, you can apply [squash] or [round_robin] to the
    result to get an enumerator of lists. </code></p></dd></dl><dl><dt class="spec value" id="val-choose_k_from_list"><a href="#val-choose_k_from_list" class="anchor"></a><code><span class="keyword">val</span> choose_k_from_list : k:int <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> list <span>&#45;&gt;</span> <span class="type-var">'a</span> list <a href="index.html#type-t">t</a> <a href="index.html#type-t">t</a></code></dt><dd><p>Generate all sets of <code>k</code> elements by picking at most one element per input list.</p><p>Sets are grouped (as enumerators) by the subset of enumerators from which the selection is made. See <code>subset</code> for more information on how grouping is done.</p><p>The argument <code>k</code> must be greater than zero.</p></dd></dl><dl><dt class="spec value" id="val-maybe"><a href="#val-maybe" class="anchor"></a><code><span class="keyword">val</span> maybe : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>maybe f e</code> builds the enumerator of <code>x; f x</code> for <code>x</code> in <code>e</code>.</p></dd></dl><dl><dt class="spec value" id="val-maybe_cons"><a href="#val-maybe_cons" class="anchor"></a><code><span class="keyword">val</span> maybe_cons : <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> list <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> list <a href="index.html#type-t">t</a></code></dt><dd><p><code>maybe_cons h e</code> builds the enumerator of <code>x; h::x</code> for <code>x</code> in <code>e</code></p></dd></dl><dl><dt class="spec value" id="val-maybe_some_of"><a href="#val-maybe_some_of" class="anchor"></a><code><span class="keyword">val</span> maybe_some_of : k:int <span>&#45;&gt;</span> <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'a</span> list <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> list <a href="index.html#type-t">t</a></code></dt><dd><p><code>maybe_some_of k l e</code> builds the subsets of size <code>k</code> from <code>l</code> and for each such subset <code>s1</code> and each <code>s2</code> in <code>e</code>, builds <code>s1 @
    s2</code>.</p></dd></dl></section><section><header><h3 id="debug"><a href="#debug" class="anchor"></a>Debug</h3></header><dl><dt class="spec value" id="val-depth"><a href="#val-depth" class="anchor"></a><code><span class="keyword">val</span> depth : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int</code></dt><dd><p>Return the depth of an enumerator, that is, the number of combinators that this enumerator is based on. It is reset when a combinator that evaluates the elements of an enumerator is applied.</p></dd></dl></section></div></body></html>