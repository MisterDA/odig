<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>BigEndian (extunix.ExtUnixAll.BigEndian)</title><link rel="stylesheet" href="../../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../../index.html">extunix</a> &#x00BB; <a href="../index.html">ExtUnixAll</a> &#x00BB; BigEndian</nav><h1>Module <code>ExtUnixAll.BigEndian</code></h1><h3 id="big-endian-functions"><a href="#big-endian-functions" class="anchor"></a>big endian functions</h3><p><b>Author:</b> Goswin von Brederlow</p></header><dl><dt class="spec value" id="val-uint16_from_host"><a href="#val-uint16_from_host" class="anchor"></a><code><span class="keyword">val</span> uint16_from_host : int <span>&#45;&gt;</span> int</code></dt><dd><p><code>uint16_from_host u16</code> converts an unsigned 16bit integer from host to big endian byte order</p></dd></dl><dl><dt class="spec value" id="val-int16_from_host"><a href="#val-int16_from_host" class="anchor"></a><code><span class="keyword">val</span> int16_from_host : int <span>&#45;&gt;</span> int</code></dt><dd><p><code>int16_from_host i16</code> converts a signed 16bit integer from host to big endian byte order</p></dd></dl><dl><dt class="spec value" id="val-uint16_to_host"><a href="#val-uint16_to_host" class="anchor"></a><code><span class="keyword">val</span> uint16_to_host : int <span>&#45;&gt;</span> int</code></dt><dd><p><code>uint16_to_host u16</code> converts an unsigned 16bit integer from big endian to host byte order</p></dd></dl><dl><dt class="spec value" id="val-int16_to_host"><a href="#val-int16_to_host" class="anchor"></a><code><span class="keyword">val</span> int16_to_host : int <span>&#45;&gt;</span> int</code></dt><dd><p><code>int16_to_host i16</code> converts a signed 16bit integer from big endian to host byte order</p></dd></dl><dl><dt class="spec value" id="val-uint31_from_host"><a href="#val-uint31_from_host" class="anchor"></a><code><span class="keyword">val</span> uint31_from_host : int <span>&#45;&gt;</span> int</code></dt><dd><p><code>uint31_from_host u31</code> converts an unsigned 31bit integer from host to big endian byte order</p></dd></dl><dl><dt class="spec value" id="val-int31_from_host"><a href="#val-int31_from_host" class="anchor"></a><code><span class="keyword">val</span> int31_from_host : int <span>&#45;&gt;</span> int</code></dt><dd><p><code>int31_from_host i31</code> converts a signed 31bit integer from host to big endian byte order</p></dd></dl><dl><dt class="spec value" id="val-uint31_to_host"><a href="#val-uint31_to_host" class="anchor"></a><code><span class="keyword">val</span> uint31_to_host : int <span>&#45;&gt;</span> int</code></dt><dd><p><code>uint31_to_host u31</code> converts an unsigned 31bit integer from big endian to host byte order</p></dd></dl><dl><dt class="spec value" id="val-int31_to_host"><a href="#val-int31_to_host" class="anchor"></a><code><span class="keyword">val</span> int31_to_host : int <span>&#45;&gt;</span> int</code></dt><dd><p><code>int31_to_host i31</code> converts a signed 31bit integer from big endian to host byte order</p></dd></dl><dl><dt class="spec value" id="val-int32_from_host"><a href="#val-int32_from_host" class="anchor"></a><code><span class="keyword">val</span> int32_from_host : int32 <span>&#45;&gt;</span> int32</code></dt><dd><p><code>int32_from_host int32</code> converts a 32bit integer from host to big endian byte order</p></dd></dl><dl><dt class="spec value" id="val-int32_to_host"><a href="#val-int32_to_host" class="anchor"></a><code><span class="keyword">val</span> int32_to_host : int32 <span>&#45;&gt;</span> int32</code></dt><dd><p><code>int32_to_host int32</code> converts a 32bit integer from big endian to host byte order</p></dd></dl><dl><dt class="spec value" id="val-int64_from_host"><a href="#val-int64_from_host" class="anchor"></a><code><span class="keyword">val</span> int64_from_host : int64 <span>&#45;&gt;</span> int64</code></dt><dd><p><code>int64_from_host int64</code> converts a 64bit integer from host to big endian byte order</p></dd></dl><dl><dt class="spec value" id="val-int64_to_host"><a href="#val-int64_to_host" class="anchor"></a><code><span class="keyword">val</span> int64_to_host : int64 <span>&#45;&gt;</span> int64</code></dt><dd><p><code>int64_to_host int64</code> converts a 64bit integer from big endian to host byte order</p></dd></dl><dl><dt class="spec value" id="val-unsafe_get_uint8"><a href="#val-unsafe_get_uint8" class="anchor"></a><code><span class="keyword">val</span> unsafe_get_uint8 : string <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int</code></dt><dd><p><code>unsafe_get_X str off</code> extract integer of type <code>X</code> from string <code>str</code> starting at offset <code>off</code>. Unsigned types are 0 extended and signed types are sign extended to fill the ocaml type. Bounds checking is not performed. Use with caution and only when the program logic guarantees that the access is within bounds.</p><p>Note: The 31bit functions extract a 32bit integer and return it as ocaml int. On 32bit platforms this can overflow as ocaml integers are 31bit signed there. No error is reported if this occurs. Use with care. Note: The same applies to 63bit functions.</p></dd></dl><dl><dt class="spec value" id="val-unsafe_get_int8"><a href="#val-unsafe_get_int8" class="anchor"></a><code><span class="keyword">val</span> unsafe_get_int8 : string <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int</code></dt><dt class="spec value" id="val-unsafe_get_uint16"><a href="#val-unsafe_get_uint16" class="anchor"></a><code><span class="keyword">val</span> unsafe_get_uint16 : string <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int</code></dt><dt class="spec value" id="val-unsafe_get_int16"><a href="#val-unsafe_get_int16" class="anchor"></a><code><span class="keyword">val</span> unsafe_get_int16 : string <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int</code></dt><dt class="spec value" id="val-unsafe_get_uint31"><a href="#val-unsafe_get_uint31" class="anchor"></a><code><span class="keyword">val</span> unsafe_get_uint31 : string <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int</code></dt><dt class="spec value" id="val-unsafe_get_int31"><a href="#val-unsafe_get_int31" class="anchor"></a><code><span class="keyword">val</span> unsafe_get_int31 : string <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int</code></dt><dt class="spec value" id="val-unsafe_get_int32"><a href="#val-unsafe_get_int32" class="anchor"></a><code><span class="keyword">val</span> unsafe_get_int32 : string <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int32</code></dt><dt class="spec value" id="val-unsafe_get_uint63"><a href="#val-unsafe_get_uint63" class="anchor"></a><code><span class="keyword">val</span> unsafe_get_uint63 : string <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int</code></dt><dt class="spec value" id="val-unsafe_get_int63"><a href="#val-unsafe_get_int63" class="anchor"></a><code><span class="keyword">val</span> unsafe_get_int63 : string <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int</code></dt><dt class="spec value" id="val-unsafe_get_int64"><a href="#val-unsafe_get_int64" class="anchor"></a><code><span class="keyword">val</span> unsafe_get_int64 : string <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int64</code></dt><dt class="spec value" id="val-get_uint8"><a href="#val-get_uint8" class="anchor"></a><code><span class="keyword">val</span> get_uint8 : string <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int</code></dt><dd><p><code>get_X str off</code> same as <code>unsafe_get_X</code> but with bounds checking.</p></dd></dl><dl><dt class="spec value" id="val-get_int8"><a href="#val-get_int8" class="anchor"></a><code><span class="keyword">val</span> get_int8 : string <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int</code></dt><dt class="spec value" id="val-get_uint16"><a href="#val-get_uint16" class="anchor"></a><code><span class="keyword">val</span> get_uint16 : string <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int</code></dt><dt class="spec value" id="val-get_int16"><a href="#val-get_int16" class="anchor"></a><code><span class="keyword">val</span> get_int16 : string <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int</code></dt><dt class="spec value" id="val-get_uint31"><a href="#val-get_uint31" class="anchor"></a><code><span class="keyword">val</span> get_uint31 : string <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int</code></dt><dt class="spec value" id="val-get_int31"><a href="#val-get_int31" class="anchor"></a><code><span class="keyword">val</span> get_int31 : string <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int</code></dt><dt class="spec value" id="val-get_int32"><a href="#val-get_int32" class="anchor"></a><code><span class="keyword">val</span> get_int32 : string <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int32</code></dt><dt class="spec value" id="val-get_uint63"><a href="#val-get_uint63" class="anchor"></a><code><span class="keyword">val</span> get_uint63 : string <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int</code></dt><dt class="spec value" id="val-get_int63"><a href="#val-get_int63" class="anchor"></a><code><span class="keyword">val</span> get_int63 : string <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int</code></dt><dt class="spec value" id="val-get_int64"><a href="#val-get_int64" class="anchor"></a><code><span class="keyword">val</span> get_int64 : string <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int64</code></dt><dt class="spec value" id="val-unsafe_set_uint8"><a href="#val-unsafe_set_uint8" class="anchor"></a><code><span class="keyword">val</span> unsafe_set_uint8 : <a href="../../../ocaml/Stdlib/Bytes/index.html#type-t">Stdlib.Bytes.t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> unit</code></dt><dd><p><code>unsafe_set_X buf off v</code> stores the integer <code>v</code> as type <code>X</code> in the buffer <code>buf</code> starting at offset <code>off</code>. Bounds checking is not performed. Use with caution and only when the program logic guarantees that the access is within bounds.</p><p>Note: The 31bit functions store an ocaml int as 32bit integer. On 32bit platforms ocaml integers are 31bit signed and will be sign extended to 32bit first. Use with care. Note: The same applies to 63bit functions.</p></dd></dl><dl><dt class="spec value" id="val-unsafe_set_int8"><a href="#val-unsafe_set_int8" class="anchor"></a><code><span class="keyword">val</span> unsafe_set_int8 : <a href="../../../ocaml/Stdlib/Bytes/index.html#type-t">Stdlib.Bytes.t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-unsafe_set_uint16"><a href="#val-unsafe_set_uint16" class="anchor"></a><code><span class="keyword">val</span> unsafe_set_uint16 : <a href="../../../ocaml/Stdlib/Bytes/index.html#type-t">Stdlib.Bytes.t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-unsafe_set_int16"><a href="#val-unsafe_set_int16" class="anchor"></a><code><span class="keyword">val</span> unsafe_set_int16 : <a href="../../../ocaml/Stdlib/Bytes/index.html#type-t">Stdlib.Bytes.t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-unsafe_set_uint31"><a href="#val-unsafe_set_uint31" class="anchor"></a><code><span class="keyword">val</span> unsafe_set_uint31 : <a href="../../../ocaml/Stdlib/Bytes/index.html#type-t">Stdlib.Bytes.t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-unsafe_set_int31"><a href="#val-unsafe_set_int31" class="anchor"></a><code><span class="keyword">val</span> unsafe_set_int31 : <a href="../../../ocaml/Stdlib/Bytes/index.html#type-t">Stdlib.Bytes.t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-unsafe_set_int32"><a href="#val-unsafe_set_int32" class="anchor"></a><code><span class="keyword">val</span> unsafe_set_int32 : <a href="../../../ocaml/Stdlib/Bytes/index.html#type-t">Stdlib.Bytes.t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int32 <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-unsafe_set_uint63"><a href="#val-unsafe_set_uint63" class="anchor"></a><code><span class="keyword">val</span> unsafe_set_uint63 : <a href="../../../ocaml/Stdlib/Bytes/index.html#type-t">Stdlib.Bytes.t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-unsafe_set_int63"><a href="#val-unsafe_set_int63" class="anchor"></a><code><span class="keyword">val</span> unsafe_set_int63 : <a href="../../../ocaml/Stdlib/Bytes/index.html#type-t">Stdlib.Bytes.t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-unsafe_set_int64"><a href="#val-unsafe_set_int64" class="anchor"></a><code><span class="keyword">val</span> unsafe_set_int64 : <a href="../../../ocaml/Stdlib/Bytes/index.html#type-t">Stdlib.Bytes.t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int64 <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-set_uint8"><a href="#val-set_uint8" class="anchor"></a><code><span class="keyword">val</span> set_uint8 : <a href="../../../ocaml/Stdlib/Bytes/index.html#type-t">Stdlib.Bytes.t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> unit</code></dt><dd><p><code>set_X buf off v</code> same as <code>unsafe_set_X</code> but with bounds checking.</p></dd></dl><dl><dt class="spec value" id="val-set_int8"><a href="#val-set_int8" class="anchor"></a><code><span class="keyword">val</span> set_int8 : <a href="../../../ocaml/Stdlib/Bytes/index.html#type-t">Stdlib.Bytes.t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-set_uint16"><a href="#val-set_uint16" class="anchor"></a><code><span class="keyword">val</span> set_uint16 : <a href="../../../ocaml/Stdlib/Bytes/index.html#type-t">Stdlib.Bytes.t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-set_int16"><a href="#val-set_int16" class="anchor"></a><code><span class="keyword">val</span> set_int16 : <a href="../../../ocaml/Stdlib/Bytes/index.html#type-t">Stdlib.Bytes.t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-set_uint31"><a href="#val-set_uint31" class="anchor"></a><code><span class="keyword">val</span> set_uint31 : <a href="../../../ocaml/Stdlib/Bytes/index.html#type-t">Stdlib.Bytes.t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-set_int31"><a href="#val-set_int31" class="anchor"></a><code><span class="keyword">val</span> set_int31 : <a href="../../../ocaml/Stdlib/Bytes/index.html#type-t">Stdlib.Bytes.t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-set_int32"><a href="#val-set_int32" class="anchor"></a><code><span class="keyword">val</span> set_int32 : <a href="../../../ocaml/Stdlib/Bytes/index.html#type-t">Stdlib.Bytes.t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int32 <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-set_uint63"><a href="#val-set_uint63" class="anchor"></a><code><span class="keyword">val</span> set_uint63 : <a href="../../../ocaml/Stdlib/Bytes/index.html#type-t">Stdlib.Bytes.t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-set_int63"><a href="#val-set_int63" class="anchor"></a><code><span class="keyword">val</span> set_int63 : <a href="../../../ocaml/Stdlib/Bytes/index.html#type-t">Stdlib.Bytes.t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-set_int64"><a href="#val-set_int64" class="anchor"></a><code><span class="keyword">val</span> set_int64 : <a href="../../../ocaml/Stdlib/Bytes/index.html#type-t">Stdlib.Bytes.t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int64 <span>&#45;&gt;</span> unit</code></dt></dl></div></body></html>