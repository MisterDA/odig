<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Fcl_domain (facile.Facile__.Fcl_domain)</title><link rel="stylesheet" href="../../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../../index.html">facile</a> &#x00BB; <a href="../index.html">Facile__</a> &#x00BB; Fcl_domain</nav><h1>Module <code>Facile__.Fcl_domain</code></h1></header><aside><p>Domain Operations</p></aside><aside><p>This module provides functions to create and handle domains, which are useful to build variables and perform propagation (i.e. domain filtering).</p></aside><dl><dt class="spec type" id="type-elt"><a href="#type-elt" class="anchor"></a><code><span class="keyword">type</span> elt</code><code> = int</code></dt><dd><p>Type of element of domains (for generic interface, <code>Var.ATTR}</code>).</p></dd></dl><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> t</code></dt><dd><p>Type of finite domains of integers (functional: no in-place modifications, domains can be shared). Standard equality and comparison can be used on domains.</p></dd></dl><aside><p><code> \subsection{Building New Domains} </code></p></aside><dl><dt class="spec value" id="val-empty"><a href="#val-empty" class="anchor"></a><code><span class="keyword">val</span> empty : <a href="index.html#type-t">t</a></code></dt><dd><p>The empty domain.</p></dd></dl><dl><dt class="spec value" id="val-create"><a href="#val-create" class="anchor"></a><code><span class="keyword">val</span> create : <a href="index.html#type-elt">elt</a> list <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>create l</code> builds a new domain containing the values of <code>l</code>. Removes duplicates and sorts values. Returns <code>empty</code> if <code>l</code> is empty.</p></dd></dl><dl><dt class="spec value" id="val-unsafe_create"><a href="#val-unsafe_create" class="anchor"></a><code><span class="keyword">val</span> unsafe_create : <a href="index.html#type-elt">elt</a> list <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>unsafe_create l</code> builds a new domain containing the values of <code>l</code>. <code>l</code> must be sorted and must not contain duplicate values, otherwise the behaviour is unspecified. Returns <code>empty</code> if <code>l</code> is empty. It is a more efficient variant of <code>create</code>.</p></dd></dl><dl><dt class="spec value" id="val-interval"><a href="#val-interval" class="anchor"></a><code><span class="keyword">val</span> interval : <a href="index.html#type-elt">elt</a> <span>&#45;&gt;</span> <a href="index.html#type-elt">elt</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>interval inf sup</code> returns the domain of all integers in the closed interval <code>[inf..sup]</code>. Raise <code>Invalid_argument</code> if <code>inf &gt; sup</code>.</p></dd></dl><dl><dt class="spec value" id="val-int"><a href="#val-int" class="anchor"></a><code><span class="keyword">val</span> int : <a href="index.html#type-t">t</a></code></dt><dd><p>The largest representable domain. Handy to create variables for which bounds cannot be previously known. It is actually much smaller than <code>interval min_int max_int</code> (which really is the biggest one) to try to prevent overflows while computing bounds of expressions involving such variables.</p></dd></dl><dl><dt class="spec value" id="val-boolean"><a href="#val-boolean" class="anchor"></a><code><span class="keyword">val</span> boolean : <a href="index.html#type-t">t</a></code></dt><dd><p>The domain containing <code>0</code> and <code>1</code>.</p></dd></dl><aside><p><code> \subsection{Access} </code></p></aside><dl><dt class="spec value" id="val-is_empty"><a href="#val-is_empty" class="anchor"></a><code><span class="keyword">val</span> is_empty : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>is_empty d</code> tests whether the domain <code>d</code> is empty or not.</p></dd></dl><dl><dt class="spec value" id="val-size"><a href="#val-size" class="anchor"></a><code><span class="keyword">val</span> size : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-elt">elt</a></code></dt><dd><p><code>size d</code> returns the number of integers in <code>d</code>.</p></dd></dl><dl><dt class="spec value" id="val-min"><a href="#val-min" class="anchor"></a><code><span class="keyword">val</span> min : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-elt">elt</a></code></dt><dt class="spec value" id="val-max"><a href="#val-max" class="anchor"></a><code><span class="keyword">val</span> max : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-elt">elt</a></code></dt><dd><p><code>min d</code> (resp. <code>max d</code>) returns the lower (resp. upper) bound of <code>d</code>. If <code>d</code> is empty, the behaviour is unspecified (incorrect return value or exception raised).</p></dd></dl><dl><dt class="spec value" id="val-min_max"><a href="#val-min_max" class="anchor"></a><code><span class="keyword">val</span> min_max : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-elt">elt</a> * <a href="index.html#type-elt">elt</a></code></dt><dd><p><code>min_max d</code> returns both the lower and upper bound of <code>d</code>. If <code>d</code> is empty, the behaviour is unspecified (incorrect return value or exception raised).</p></dd></dl><dl><dt class="spec value" id="val-iter"><a href="#val-iter" class="anchor"></a><code><span class="keyword">val</span> iter : (<a href="index.html#type-elt">elt</a> <span>&#45;&gt;</span> unit) <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>iter f d</code> successively applies function <code>f</code> to all element of <code>d</code> in increasing order.</p></dd></dl><dl><dt class="spec value" id="val-interval_iter"><a href="#val-interval_iter" class="anchor"></a><code><span class="keyword">val</span> interval_iter : (<a href="index.html#type-elt">elt</a> <span>&#45;&gt;</span> <a href="index.html#type-elt">elt</a> <span>&#45;&gt;</span> unit) <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>interval_iter f d</code> successively applies function <code>f</code> to the bounds of all the disjoint intervals of <code>d</code> in increasing order. E.g. a suitable function <code>f</code> to print a domain can be defined as <code>fun mini maxi -&gt; Printf.printf &quot;%d..%d &quot; mini maxi</code>.</p></dd></dl><dl><dt class="spec value" id="val-mem"><a href="#val-mem" class="anchor"></a><code><span class="keyword">val</span> mem : <a href="index.html#type-elt">elt</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dt class="spec value" id="val-member"><a href="#val-member" class="anchor"></a><code><span class="keyword">val</span> member : <a href="index.html#type-elt">elt</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>member n d</code> tests if <code>n</code> belongs to <code>d</code>.</p></dd></dl><dl><dt class="spec value" id="val-values"><a href="#val-values" class="anchor"></a><code><span class="keyword">val</span> values : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-elt">elt</a> list</code></dt><dd><p><code>value d</code> returns the list of values of the domain <code>d</code></p></dd></dl><dl><dt class="spec value" id="val-fprint_elt"><a href="#val-fprint_elt" class="anchor"></a><code><span class="keyword">val</span> fprint_elt : <a href="../../../ocaml/Stdlib/index.html#type-out_channel">Stdlib.out_channel</a> <span>&#45;&gt;</span> <a href="index.html#type-elt">elt</a> <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-fprint"><a href="#val-fprint" class="anchor"></a><code><span class="keyword">val</span> fprint : <a href="../../../ocaml/Stdlib/index.html#type-out_channel">Stdlib.out_channel</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Pretty printing of elements and domains.</p></dd></dl><dl><dt class="spec value" id="val-sprint"><a href="#val-sprint" class="anchor"></a><code><span class="keyword">val</span> sprint : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> string</code></dt><dd><p><code>sprint d</code> returns a string representation of <code>d</code>.</p></dd></dl><dl><dt class="spec value" id="val-included"><a href="#val-included" class="anchor"></a><code><span class="keyword">val</span> included : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>included d1 d2</code> tests whether domain <code>d1</code> is included in domain <code>d2</code>.</p></dd></dl><dl><dt class="spec value" id="val-smallest_geq"><a href="#val-smallest_geq" class="anchor"></a><code><span class="keyword">val</span> smallest_geq : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-elt">elt</a> <span>&#45;&gt;</span> <a href="index.html#type-elt">elt</a></code></dt><dt class="spec value" id="val-greatest_leq"><a href="#val-greatest_leq" class="anchor"></a><code><span class="keyword">val</span> greatest_leq : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-elt">elt</a> <span>&#45;&gt;</span> <a href="index.html#type-elt">elt</a></code></dt><dd><p><code>smallest_geq dom val</code> (resp. <code>greatest_leq dom val</code>) returns the smallest (resp. greatest) value in <code>dom</code> greater (resp. smaller) than or equal to <code>val</code>. Raises <code>Not_found</code> if <code>max dom &lt; val</code> (resp. <code>min dom &gt; val</code>).</p></dd></dl><dl><dt class="spec value" id="val-largest_hole_around"><a href="#val-largest_hole_around" class="anchor"></a><code><span class="keyword">val</span> largest_hole_around : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-elt">elt</a> <span>&#45;&gt;</span> <a href="index.html#type-elt">elt</a> * <a href="index.html#type-elt">elt</a></code></dt><dd><p><code>largest_hole_around dom val</code> returns the largest hole (interval) in <code>dom</code> centred around <code>val</code>. Returns <code>(val, val)</code> if <code>val</code> belongs to <code>dom</code> and raises <code>Not_found</code> if <code>val</code> is outside <code>dom</code> bounds. Equivalent to <code>(greatest_leq dom val, smallest_geq dom val)</code> but faster.</p></dd></dl><dl><dt class="spec value" id="val-choose"><a href="#val-choose" class="anchor"></a><code><span class="keyword">val</span> choose : (<a href="index.html#type-elt">elt</a> <span>&#45;&gt;</span> <a href="index.html#type-elt">elt</a> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-elt">elt</a></code></dt><dd><p><code>choose ord d</code> returns the mininum value of <code>d</code> for order <code>ord</code>. Raises <code>Not_found</code> if <code>d</code> is empty.</p></dd></dl><aside><p><code> \subsection{Operations} </code></p></aside><dl><dt class="spec value" id="val-add"><a href="#val-add" class="anchor"></a><code><span class="keyword">val</span> add : <a href="index.html#type-elt">elt</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>add n d</code> returns <code>d</code> <code> $\cup$</code> <code>{n}</code>.</p></dd></dl><dl><dt class="spec value" id="val-remove"><a href="#val-remove" class="anchor"></a><code><span class="keyword">val</span> remove : <a href="index.html#type-elt">elt</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>remove n d</code> returns <code>d</code> <code> $\setminus$ </code> <code>{n}</code>. Returns <code>d</code> if <code>n</code> is not in <code>d</code>.</p></dd></dl><dl><dt class="spec value" id="val-remove_up"><a href="#val-remove_up" class="anchor"></a><code><span class="keyword">val</span> remove_up : <a href="index.html#type-elt">elt</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-remove_low"><a href="#val-remove_low" class="anchor"></a><code><span class="keyword">val</span> remove_low : <a href="index.html#type-elt">elt</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>remove_up n d</code> (resp. <code>remove_low n d</code>) returns <code>d</code> <code> $\setminus$ </code> <code>[n+1..max_int]</code> (resp. <code>d</code> <code> $\setminus$ </code> <code>[min_int..n-1]</code>), i.e. removes values stricly greater (resp. less) than <code>n</code>.</p></dd></dl><dl><dt class="spec value" id="val-remove_low_up"><a href="#val-remove_low_up" class="anchor"></a><code><span class="keyword">val</span> remove_low_up : <a href="index.html#type-elt">elt</a> <span>&#45;&gt;</span> <a href="index.html#type-elt">elt</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>remove_low_up low up d</code> is a shortcut for <code>remove_up up (remove_low low d)</code>.</p></dd></dl><dl><dt class="spec value" id="val-remove_closed_inter"><a href="#val-remove_closed_inter" class="anchor"></a><code><span class="keyword">val</span> remove_closed_inter : <a href="index.html#type-elt">elt</a> <span>&#45;&gt;</span> <a href="index.html#type-elt">elt</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>remove_closed_inter inf sup d</code> returns <code>d</code> <code> $\setminus$ </code> <code>[inf..sup]</code>, i.e. removes values greater than or equal to <code>inf</code> and less or equal to <code>sup</code> in <code>d</code>. Returns <code>d</code> if <code>inf &gt; sup</code>.</p></dd></dl><dl><dt class="spec value" id="val-remove_min"><a href="#val-remove_min" class="anchor"></a><code><span class="keyword">val</span> remove_min : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-remove_max"><a href="#val-remove_max" class="anchor"></a><code><span class="keyword">val</span> remove_max : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>remove_min d</code> (resp. <code>remove_max d</code>) returns <code>d</code> without its lower (resp. upper) bound. Raises <code>Invalid_argument</code> if <code>d</code> is empty.</p></dd></dl><dl><dt class="spec value" id="val-intersection"><a href="#val-intersection" class="anchor"></a><code><span class="keyword">val</span> intersection : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-union"><a href="#val-union" class="anchor"></a><code><span class="keyword">val</span> union : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Intersection (resp. union) on domains.</p></dd></dl><dl><dt class="spec value" id="val-difference"><a href="#val-difference" class="anchor"></a><code><span class="keyword">val</span> difference : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>difference big small</code> returns <code>big</code> <code> $\setminus$ </code> <code>small</code>. <code>small</code> must be included in <code>big</code>, otherwise the behaviour is unspecified (incorrect return value or exception raised).</p></dd></dl><dl><dt class="spec value" id="val-diff"><a href="#val-diff" class="anchor"></a><code><span class="keyword">val</span> diff : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>diff d1 d2</code> returns <code>d1</code> <code> $\setminus$ </code> <code>d2</code>, i.e. domain of elements in <code>d1</code> which are not in <code>d2</code>.</p></dd></dl><dl><dt class="spec value" id="val-minus"><a href="#val-minus" class="anchor"></a><code><span class="keyword">val</span> minus : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>minus d</code> returns the domain of opposite values of <code>d</code>.</p></dd></dl><dl><dt class="spec value" id="val-plus"><a href="#val-plus" class="anchor"></a><code><span class="keyword">val</span> plus : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-elt">elt</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>plus d n</code> translates a domain by <code>n</code>.</p></dd></dl><dl><dt class="spec value" id="val-times"><a href="#val-times" class="anchor"></a><code><span class="keyword">val</span> times : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-elt">elt</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>times d k</code> expands a domain by factor <code>k</code>.</p></dd></dl><dl><dt class="spec value" id="val-compare"><a href="#val-compare" class="anchor"></a><code><span class="keyword">val</span> compare : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-elt">elt</a></code></dt><dd><p><code>compare d1 d2</code> is a comparison function working first on the cardinal, then (if <code>d1</code> and <code>d2</code> have the same size) on the lexicographic order of the domains (expressed in extension).</p></dd></dl><dl><dt class="spec value" id="val-compare_elt"><a href="#val-compare_elt" class="anchor"></a><code><span class="keyword">val</span> compare_elt : <a href="index.html#type-elt">elt</a> <span>&#45;&gt;</span> <a href="index.html#type-elt">elt</a> <span>&#45;&gt;</span> <a href="index.html#type-elt">elt</a></code></dt><dd><p><code>compare_elt e1 e2</code> is a comparison function on elements of domains. Convenient to use the <code>Domain</code> module as a functor argument as in module <code>Var</code><code>Var}</code>.</p></dd></dl><dl><dt class="spec value" id="val-disjoint"><a href="#val-disjoint" class="anchor"></a><code><span class="keyword">val</span> disjoint : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>disjoint d1 d2</code> tests whether <code>d1</code> and <code>d2</code> are disjoint.</p></dd></dl></div></body></html>