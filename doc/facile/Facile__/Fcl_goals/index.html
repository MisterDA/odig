<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Fcl_goals (facile.Facile__.Fcl_goals)</title><link rel="stylesheet" href="../../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../../index.html">facile</a> &#x00BB; <a href="../index.html">Facile__</a> &#x00BB; Fcl_goals</nav><h1>Module <code>Facile__.Fcl_goals</code></h1><nav class="toc"><ul><li><a href="#building-and-solving-goals">Building and Solving Goals</a><ul><li><a href="#access">Access</a></li><li><a href="#creation">Creation</a></li><li><a href="#operators-and-built-in-goals">Operators and Built-in Goals</a><ul><li><a href="#instantiation-of-finite-domain-variables">Instantiation of Finite Domain Variables</a></li><li><a href="#instantiation-of-set-variables">Instantiation of Set Variables</a></li></ul></li><li><a href="#operations-on-array-of-variables">Operations on Array of Variables</a></li><li><a href="#operations-on-list-of-variables">Operations on List of Variables</a></li><li><a href="#optimization">Optimization</a></li><li><a href="#search-strategy">Search Strategy</a></li><li><a href="#solving">Solving</a></li></ul></li></ul></nav></header><section><header><h2 id="building-and-solving-goals"><a href="#building-and-solving-goals" class="anchor"></a>Building and Solving Goals</h2></header><aside><p>This module provides functions and operators to build goals that will control the search, i.e. mainly choose and instantiate variables.</p></aside><section><header><h3 id="access"><a href="#access" class="anchor"></a>Access</h3></header><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> t</code></dt><dd><p>The type of goals.</p></dd></dl><dl><dt class="spec value" id="val-name"><a href="#val-name" class="anchor"></a><code><span class="keyword">val</span> name : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> string</code></dt><dd><p><code>name g</code> returns the name of the goal <code>g</code>.</p></dd></dl><dl><dt class="spec value" id="val-fprint"><a href="#val-fprint" class="anchor"></a><code><span class="keyword">val</span> fprint : <a href="../../../ocaml/Stdlib/index.html#type-out_channel">Stdlib.out_channel</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>fprint chan g</code> prints the name of goal <code>g</code> on channel <code>chan</code>.</p></dd></dl></section><section><header><h3 id="creation"><a href="#creation" class="anchor"></a>Creation</h3></header><dl><dt class="spec value" id="val-fail"><a href="#val-fail" class="anchor"></a><code><span class="keyword">val</span> fail : <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-success"><a href="#val-success" class="anchor"></a><code><span class="keyword">val</span> success : <a href="index.html#type-t">t</a></code></dt><dd><p>Failure (resp. success). Neutral element for the disjunction (resp. conjunction) over goals. Could be implemented as <code>create (fun () -&gt; Stak.fail &quot;fail&quot;)</code> (resp. <code>create (fun () -&gt; ())</code>).</p></dd></dl><dl><dt class="spec value" id="val-atomic"><a href="#val-atomic" class="anchor"></a><code><span class="keyword">val</span> atomic : ?&#8288;name:string <span>&#45;&gt;</span> (unit <span>&#45;&gt;</span> unit) <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>atomic ~name:&quot;atomic&quot; f</code> returns a goal calling function <code>f</code>. <code>f</code> must take <code>()</code> as argument and return <code>()</code>. <code>name</code> default value is <code>&quot;atomic&quot;</code>.</p></dd></dl><dl><dt class="spec value" id="val-create"><a href="#val-create" class="anchor"></a><code><span class="keyword">val</span> create : ?&#8288;name:string <span>&#45;&gt;</span> (<span class="type-var">'a</span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>create ~name:&quot;create&quot; f a</code> returns a goal calling <code>f a</code>. <code>f</code> should return a goal (success to stop). <code>name</code> default value is <code>&quot;create&quot;</code>.</p></dd></dl><dl><dt class="spec value" id="val-create_rec"><a href="#val-create_rec" class="anchor"></a><code><span class="keyword">val</span> create_rec : ?&#8288;name:string <span>&#45;&gt;</span> (<a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a>) <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>create_rec ~name:&quot;create_rec&quot; f</code> returns a goal calling <code>f</code>. <code>f</code> takes the goal itself as argument and should return a goal (success to stop). Useful to write recursive goals. <code>name</code> default value is <code>&quot;create_rec&quot;</code>.</p></dd></dl></section><section><header><h3 id="operators-and-built-in-goals"><a href="#operators-and-built-in-goals" class="anchor"></a>Operators and Built-in Goals</h3></header><dl><dt class="spec value" id="val-(&amp;&amp;~)"><a href="#val-(&amp;&amp;~)" class="anchor"></a><code><span class="keyword">val</span> (&amp;&amp;~) : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-(||~)"><a href="#val-(||~)" class="anchor"></a><code><span class="keyword">val</span> (||~) : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Conjunction and disjunction over goals. Note that these two operators do have the <b>same priority</b>. Goals expressions must therefore be carefully parenthesized to produce the expected result.</p></dd></dl><dl><dt class="spec value" id="val-forto"><a href="#val-forto" class="anchor"></a><code><span class="keyword">val</span> forto : int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> (int <span>&#45;&gt;</span> <a href="index.html#type-t">t</a>) <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-fordownto"><a href="#val-fordownto" class="anchor"></a><code><span class="keyword">val</span> fordownto : int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> (int <span>&#45;&gt;</span> <a href="index.html#type-t">t</a>) <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>forto min max g</code> (resp. <code>fordownto min max g</code>) returns the conjunctive iteration of goal <code>g</code> on increasing (resp. decreasing) integers from <code>min</code> (resp. <code>max</code>) to <code>max</code> (resp. <code>min</code>).</p></dd></dl><dl><dt class="spec value" id="val-once"><a href="#val-once" class="anchor"></a><code><span class="keyword">val</span> once : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>once g</code> cuts choice points left on goal <code>g</code>.</p></dd></dl><dl><dt class="spec value" id="val-sigma"><a href="#val-sigma" class="anchor"></a><code><span class="keyword">val</span> sigma : ?&#8288;domain:<a href="../Fcl_domain/index.html#type-t">Facile__.Fcl_domain.t</a> <span>&#45;&gt;</span> (<a href="../../Facile__Fcl_var/Fd/index.html#type-t">Facile__.Fcl_var.Fd.t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a>) <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>sigma ~domain:Domain.int fgoal</code> creates the goal <code>(fgoal v)</code> where <code>v</code> is a new variable of domain <code>domain</code>. Default domain is the largest one. It can be considered as an existential quantification, hence the concrete notation <code>sigma</code> of this function (because existential quantification can be seen as a generalized disjunction).</p></dd></dl><section><header><h4 id="instantiation-of-finite-domain-variables"><a href="#instantiation-of-finite-domain-variables" class="anchor"></a>Instantiation of Finite Domain Variables</h4></header><dl><dt class="spec value" id="val-unify"><a href="#val-unify" class="anchor"></a><code><span class="keyword">val</span> unify : <a href="../../Facile__Fcl_var/Fd/index.html#type-t">Facile__.Fcl_var.Fd.t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>unify var x</code> instantiates variable <code>var</code> to <code>x</code>.</p></dd></dl><dl><dt class="spec value" id="val-indomain"><a href="#val-indomain" class="anchor"></a><code><span class="keyword">val</span> indomain : <a href="../../Facile__Fcl_var/Fd/index.html#type-t">Facile__.Fcl_var.Fd.t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Non-deterministic instantiation of a variable, by labeling its domain (in increasing order).</p></dd></dl><dl><dt class="spec value" id="val-instantiate"><a href="#val-instantiate" class="anchor"></a><code><span class="keyword">val</span> instantiate : (<a href="../Fcl_domain/index.html#type-t">Facile__.Fcl_domain.t</a> <span>&#45;&gt;</span> int) <span>&#45;&gt;</span> <a href="../../Facile__Fcl_var/Fd/index.html#type-t">Facile__.Fcl_var.Fd.t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>instantiate choose var</code> Non-deterministic instantiation of a variable, by labeling its domain using the value returned by the <code>choose</code> function.</p></dd></dl><dl><dt class="spec value" id="val-dichotomic"><a href="#val-dichotomic" class="anchor"></a><code><span class="keyword">val</span> dichotomic : <a href="../../Facile__Fcl_var/Fd/index.html#type-t">Facile__.Fcl_var.Fd.t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Non-deterministic instantiation of a variable, by dichotomic recursive exploration of its domain.</p></dd></dl></section><section><header><h4 id="instantiation-of-set-variables"><a href="#instantiation-of-set-variables" class="anchor"></a>Instantiation of Set Variables</h4></header><div class="spec module" id="module-Conjunto"><a href="#module-Conjunto" class="anchor"></a><code><span class="keyword">module</span> <a href="Conjunto/index.html">Conjunto</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div></section></section><section><header><h3 id="operations-on-array-of-variables"><a href="#operations-on-array-of-variables" class="anchor"></a>Operations on Array of Variables</h3></header><div class="spec module" id="module-Array"><a href="#module-Array" class="anchor"></a><code><span class="keyword">module</span> <a href="Array/index.html">Array</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div></section><section><header><h3 id="operations-on-list-of-variables"><a href="#operations-on-list-of-variables" class="anchor"></a>Operations on List of Variables</h3></header><div class="spec module" id="module-List"><a href="#module-List" class="anchor"></a><code><span class="keyword">module</span> <a href="List/index.html">List</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div></section><section><header><h3 id="optimization"><a href="#optimization" class="anchor"></a>Optimization</h3></header><dl><dt class="spec type" id="type-bb_mode"><a href="#type-bb_mode" class="anchor"></a><code><span class="keyword">type</span> bb_mode</code><code> = </code><table class="variant"><tr id="type-bb_mode.Restart" class="anchored"><td class="def constructor"><a href="#type-bb_mode.Restart" class="anchor"></a><code>| </code><code><span class="constructor">Restart</span></code></td></tr><tr id="type-bb_mode.Continue" class="anchored"><td class="def constructor"><a href="#type-bb_mode.Continue" class="anchor"></a><code>| </code><code><span class="constructor">Continue</span></code></td><td class="doc"><p>Branch and bound mode.</p></td></tr></table></dt></dl><dl><dt class="spec value" id="val-minimize"><a href="#val-minimize" class="anchor"></a><code><span class="keyword">val</span> minimize : ?&#8288;step:int <span>&#45;&gt;</span> ?&#8288;mode:<a href="index.html#type-bb_mode">bb_mode</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../../Facile__Fcl_var/Fd/index.html#type-t">Facile__.Fcl_var.Fd.t</a> <span>&#45;&gt;</span> (int <span>&#45;&gt;</span> unit) <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>minimize ~step:1 ~mode:Continue goal cost solution</code> runs a Branch and Bound algorithm on <code>goal</code> for bound <code>cost</code>, with an improvement of at least <code>step</code> between each solution found. With <code>mode</code> equal to <code>Restart</code>, the search restarts from the beginning for every step whereas with mode <code>Continue</code> (default) the search simply carries on with an update of the cost constraint. <code>solution</code> is called with the instantiation value of <code>cost</code> (which must be instantiated by <code>goal</code>) as argument each time a solution is found; this function can therefore be used to store (e.g. in a reference) the current solution. Default <code>step</code> is 1. <code>minimize</code> <b>always fails</b>.</p></dd></dl></section><section><header><h3 id="search-strategy"><a href="#search-strategy" class="anchor"></a>Search Strategy</h3></header><dl><dt class="spec value" id="val-lds"><a href="#val-lds" class="anchor"></a><code><span class="keyword">val</span> lds : ?&#8288;step:int <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>lds ~step:1 g</code> returns a goal which will iteratively search <code>g</code> with increasing limited discrepancy (see <code> ~\cite{harvey95.lds}</code>) by increment <code>step</code>. <code>step</code> default value is 1.</p></dd></dl></section><section><header><h3 id="solving"><a href="#solving" class="anchor"></a>Solving</h3></header><dl><dt class="spec value" id="val-solve"><a href="#val-solve" class="anchor"></a><code><span class="keyword">val</span> solve : ?&#8288;control:(int <span>&#45;&gt;</span> unit) <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>solve ~control:(fun _ -&gt; ()) g</code> solves the goal <code>g</code> and returns a success (<code>true</code>) or a failure (<code>false</code>). The execution can be precisely controlled with the <code>control</code> argument whose single argument is the number of bactracks since the beginning of the search. This function is called after every local failure:</p><ul><li>it can raise <code>Stak.Fail</code> to force a failure of the search in the current branch (i.e. backtrack);</li></ul><ul><li>it can raise any other user exception to stop the search process;</li></ul><ul><li>it must return <code>unit</code> to continue the search; this is the default behavior.</li></ul></dd></dl></section></section></div></body></html>