<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Faraday (faraday.Faraday)</title><link rel="stylesheet" href="../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../index.html">faraday</a> &#x00BB; Faraday</nav><h1>Module <code>Faraday</code></h1><p>Serialization primitives built for speed an memory-efficiency.</p><p>Faraday is a library for writing fast and memory-efficient serializers. Its core type and related operation gives the user fine-grained control over copying and allocation behavior while serializing user-defined types, and presents the output in a form that makes it possible to use vectorized write operations, such as the <code>writev</code><code></code> system call, or any other platform or application-specific output APIs.</p><p>A Faraday serializer manages an internal buffer and a queue of output buffers. The output bufferes may be a sub range of the serializer's internal buffer or one that is user-provided. Buffered writes such as <a href="index.html#val-write_string"><code>write_string</code></a>, <a href="index.html#val-write_char"><code>write_char</code></a>, <a href="index.html#val-write_bigstring"><code>write_bigstring</code></a>, etc., copy the source bytes into the serializer's internal buffer. Unbuffered writes such as <code>schedule_string</code>, <a href="index.html#val-schedule_bigstring"><code>schedule_bigstring</code></a>, etc., on the other hand perform no copying. Instead, they enqueue the source bytes into the serializer's write queue directly.</p><nav class="toc"><ul><li><a href="#constructors">Constructors</a></li><li><a href="#buffered-writes">Buffered Writes</a></li><li><a href="#unbuffered-writes">Unbuffered Writes</a></li><li><a href="#querying-a-serializer's-state">Querying A Serializer's State</a></li><li><a href="#control-operations">Control Operations</a></li><li><a href="#running">Running</a></li><li><a href="#convenience-functions">Convenience Functions</a></li></ul></nav></header><dl><dt class="spec type" id="type-bigstring"><a href="#type-bigstring" class="anchor"></a><code><span class="keyword">type</span> bigstring</code><code> = (char, <a href="../../ocaml/Bigarray/index.html#type-int8_unsigned_elt">Bigarray.int8_unsigned_elt</a>, <a href="../../ocaml/Bigarray/index.html#type-c_layout">Bigarray.c_layout</a>) <a href="../../ocaml/Bigarray/Array1/index.html#type-t">Bigarray.Array1.t</a></code></dt><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> t</code></dt><dd><p>The type of a serializer.</p></dd></dl><section><header><h3 id="constructors"><a href="#constructors" class="anchor"></a>Constructors</h3></header><dl><dt class="spec value" id="val-create"><a href="#val-create" class="anchor"></a><code><span class="keyword">val</span> create : int <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>create len</code> creates a serializer with a fixed-length internal buffer of length <code>len</code>. See the Buffered writes section for details about what happens when <code>len</code> is not large enough to support a write.</p></dd></dl><dl><dt class="spec value" id="val-of_bigstring"><a href="#val-of_bigstring" class="anchor"></a><code><span class="keyword">val</span> of_bigstring : <a href="index.html#type-bigstring">bigstring</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>of_bigstring buf</code> creates a serializer, using <code>buf</code> as its internal buffer. The serializer takes ownership of <code>buf</code> until the serializer has been closed and flushed of all output.</p></dd></dl></section><section><header><h3 id="buffered-writes"><a href="#buffered-writes" class="anchor"></a>Buffered Writes</h3><p>A serializer manages an internal buffer for coalescing small writes. The size of this buffer is determined when the serializer is created. If the buffer does not contain sufficient space to service a caller's buffered write, the serializer will allocate a new buffer of the sufficient size and use it for the current and subsequent writes. The old buffer will be garbage collected once all of its contents have been <a href="index.html#val-flush"><code>flush</code></a>ed.</p></header><dl><dt class="spec value" id="val-write_string"><a href="#val-write_string" class="anchor"></a><code><span class="keyword">val</span> write_string : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> ?&#8288;off:int <span>&#45;&gt;</span> ?&#8288;len:int <span>&#45;&gt;</span> string <span>&#45;&gt;</span> unit</code></dt><dd><p><code>write_string t ?off ?len str</code> copies <code>str</code> into the serializer's internal buffer.</p></dd></dl><dl><dt class="spec value" id="val-write_bytes"><a href="#val-write_bytes" class="anchor"></a><code><span class="keyword">val</span> write_bytes : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> ?&#8288;off:int <span>&#45;&gt;</span> ?&#8288;len:int <span>&#45;&gt;</span> <a href="../../ocaml/Stdlib/Bytes/index.html#type-t">Stdlib.Bytes.t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>write_bytes t ?off ?len bytes</code> copies <code>bytes</code> into the serializer's internal buffer. It is safe to modify <code>bytes</code> after this call returns.</p></dd></dl><dl><dt class="spec value" id="val-write_bigstring"><a href="#val-write_bigstring" class="anchor"></a><code><span class="keyword">val</span> write_bigstring : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> ?&#8288;off:int <span>&#45;&gt;</span> ?&#8288;len:int <span>&#45;&gt;</span> <a href="index.html#type-bigstring">bigstring</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>write_bigstring t ?off ?len bigstring</code> copies <code>bigstring</code> into the serializer's internal buffer. It is safe to modify <code>bigstring</code> after this call returns.</p></dd></dl><dl><dt class="spec value" id="val-write_gen"><a href="#val-write_gen" class="anchor"></a><code><span class="keyword">val</span> write_gen : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> length:(<span class="type-var">'a</span> <span>&#45;&gt;</span> int) <span>&#45;&gt;</span> blit:(<span class="type-var">'a</span> <span>&#45;&gt;</span> src_off:int <span>&#45;&gt;</span> <a href="index.html#type-bigstring">bigstring</a> <span>&#45;&gt;</span> dst_off:int <span>&#45;&gt;</span> len:int <span>&#45;&gt;</span> unit) <span>&#45;&gt;</span> ?&#8288;off:int <span>&#45;&gt;</span> ?&#8288;len:int <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>write_gen t ~length ~blit ?off ?len x</code> copies <code>x</code> into the serializer's internal buffer using the provided <code>length</code> and <code>blit</code> operations. See <span class="xref-unresolved" title="unresolved reference to &quot;Bigstring.blit&quot;"><code>Bigstring</code>.blit</span> for documentation of the arguments.</p></dd></dl><dl><dt class="spec value" id="val-write_char"><a href="#val-write_char" class="anchor"></a><code><span class="keyword">val</span> write_char : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> char <span>&#45;&gt;</span> unit</code></dt><dd><p><code>write_char t char</code> copies <code>char</code> into the serializer's internal buffer.</p></dd></dl><dl><dt class="spec value" id="val-write_uint8"><a href="#val-write_uint8" class="anchor"></a><code><span class="keyword">val</span> write_uint8 : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> unit</code></dt><dd><p><code>write_uint8 t n</code> copies the lower 8 bits of <code>n</code> into the serializer's internal buffer.</p></dd></dl><dl><dt class="spec module" id="module-BE"><a href="#module-BE" class="anchor"></a><code><span class="keyword">module</span> <a href="BE/index.html">BE</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Big endian serializers</p></dd></dl><dl><dt class="spec module" id="module-LE"><a href="#module-LE" class="anchor"></a><code><span class="keyword">module</span> <a href="LE/index.html">LE</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Little endian serializers</p></dd></dl></section><section><header><h3 id="unbuffered-writes"><a href="#unbuffered-writes" class="anchor"></a>Unbuffered Writes</h3><p>Unbuffered writes do not involve copying bytes to the serializers internal buffer.</p></header><dl><dt class="spec value" id="val-schedule_bigstring"><a href="#val-schedule_bigstring" class="anchor"></a><code><span class="keyword">val</span> schedule_bigstring : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> ?&#8288;off:int <span>&#45;&gt;</span> ?&#8288;len:int <span>&#45;&gt;</span> <a href="index.html#type-bigstring">bigstring</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>schedule_bigstring t ?off ?len bigstring</code> schedules <code>bigstring</code> to be written the next time the serializer surfaces writes to the user. <code>bigstring</code> is not copied in this process, so <code>bigstring</code> should only be modified after <code>t</code> has been <a href="index.html#val-flush"><code>flush</code></a>ed.</p></dd></dl></section><section><header><h3 id="querying-a-serializer's-state"><a href="#querying-a-serializer's-state" class="anchor"></a>Querying A Serializer's State</h3></header><dl><dt class="spec value" id="val-free_bytes_in_buffer"><a href="#val-free_bytes_in_buffer" class="anchor"></a><code><span class="keyword">val</span> free_bytes_in_buffer : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int</code></dt><dd><p><code>free_bytes_in_buffer t</code> returns the free space, in bytes, of the serializer's write buffer. If a <code>write_*</code> call has a length that exceeds this value, the serializer will allocate a new buffer that will replace the serializer's internal buffer for that and subsequent calls.</p></dd></dl><dl><dt class="spec value" id="val-has_pending_output"><a href="#val-has_pending_output" class="anchor"></a><code><span class="keyword">val</span> has_pending_output : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>has_pending_output t</code> is <code>true</code> if <code>t</code>'s output queue is non-empty. It may be the case that <code>t</code>'s queued output is being serviced by some other thread of control, but has not yet completed.</p></dd></dl><dl><dt class="spec value" id="val-pending_bytes"><a href="#val-pending_bytes" class="anchor"></a><code><span class="keyword">val</span> pending_bytes : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int</code></dt><dd><p><code>pending_bytes t</code> is the size of the next write, in bytes, that <code>t</code> will surface to the caller as a <code>`Writev</code>.</p></dd></dl></section><section><header><h3 id="control-operations"><a href="#control-operations" class="anchor"></a>Control Operations</h3></header><dl><dt class="spec value" id="val-yield"><a href="#val-yield" class="anchor"></a><code><span class="keyword">val</span> yield : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>yield t</code> causes <code>t</code> to delay surfacing writes to the user, instead returning a <code>`Yield</code>. This gives the serializer an opportunity to collect additional writes before sending them to the underlying device, which will increase the write batch size.</p><p>As one example, code may want to call this function if it's about to release the OCaml lock and perform a blocking system call, but would like to batch output across that system call. To hint to the thread of control that is performing the writes on behalf of the serializer, the code might call <code>yield t</code> before releasing the lock.</p></dd></dl><dl><dt class="spec value" id="val-flush"><a href="#val-flush" class="anchor"></a><code><span class="keyword">val</span> flush : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (unit <span>&#45;&gt;</span> unit) <span>&#45;&gt;</span> unit</code></dt><dd><p><code>flush t f</code> registers <code>f</code> to be called when all prior writes have been successfully completed. If <code>t</code> has no pending writes, then <code>f</code> will be called immediately. If <a href="index.html#val-yield"><code>yield</code></a> was recently called on <code>t</code>, then the effect of the <code>yield</code> will be ignored so that client code has an opportunity to write pending output, regardless of how it handles <code>`Yield</code> operations.</p></dd></dl><dl><dt class="spec value" id="val-close"><a href="#val-close" class="anchor"></a><code><span class="keyword">val</span> close : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>close t</code> closes <code>t</code>. All subsequent write calls will raise, and any pending or subsequent <a href="index.html#val-yield"><code>yield</code></a> calls will be ignored. If the serializer has any pending writes, user code will have an opportunity to service them before it receives the <code>Close</code> operation. Flush callbacks will continue to be invoked while output is <a href="index.html#val-shift"><code>shift</code></a>ed out of <code>t</code> as needed.</p></dd></dl><dl><dt class="spec value" id="val-is_closed"><a href="#val-is_closed" class="anchor"></a><code><span class="keyword">val</span> is_closed : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>is_closed t</code> is <code>true</code> if <code>close</code> has been called on <code>t</code> and <code>false</code> otherwise. A closed <code>t</code> may still have pending output.</p></dd></dl><dl><dt class="spec value" id="val-shift"><a href="#val-shift" class="anchor"></a><code><span class="keyword">val</span> shift : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> unit</code></dt><dd><p><code>shift t n</code> removes the first <code>n</code> bytes in <code>t</code>'s write queue. Any flush callbacks registered with <code>t</code> within this span of the write queue will be called.</p></dd></dl><dl><dt class="spec value" id="val-drain"><a href="#val-drain" class="anchor"></a><code><span class="keyword">val</span> drain : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int</code></dt><dd><p><code>drain t</code> removes all pending writes from <code>t</code>, returning the number of bytes that were enqueued to be written and freeing any scheduled buffers in the process.</p></dd></dl></section><section><header><h3 id="running"><a href="#running" class="anchor"></a>Running</h3><p>Low-level operations for runing a serializer. For production use-cases, consider the Async and Lwt support that this library includes before attempting to use this these operations directly.</p></header><dl><dt class="spec type" id="type-iovec"><a href="#type-iovec" class="anchor"></a><code><span class="keyword">type</span> 'a iovec</code><code> = </code><code>{</code><table class="record"><tr id="type-iovec.buffer" class="anchored"><td class="def field"><a href="#type-iovec.buffer" class="anchor"></a><code>buffer : <span class="type-var">'a</span>;</code></td></tr><tr id="type-iovec.off" class="anchored"><td class="def field"><a href="#type-iovec.off" class="anchor"></a><code>off : int;</code></td></tr><tr id="type-iovec.len" class="anchored"><td class="def field"><a href="#type-iovec.len" class="anchor"></a><code>len : int;</code></td></tr></table><code>}</code></dt><dd><p>A view into <a href="index.html#type-iovec.buffer"><code>iovec.buffer</code></a> starting at <a href="index.html#type-iovec.off"><code>iovec.off</code></a> and with length <a href="index.html#type-iovec.len"><code>iovec.len</code></a>.</p></dd></dl><dl><dt class="spec type" id="type-operation"><a href="#type-operation" class="anchor"></a><code><span class="keyword">type</span> operation</code> = <code>[ </code><table class="variant"><tr id="type-operation.Writev" class="anchored"><td class="def constructor"><a href="#type-operation.Writev" class="anchor"></a><code>| </code><code>`Writev <span class="keyword">of</span> <a href="index.html#type-bigstring">bigstring</a> <a href="index.html#type-iovec">iovec</a> list</code></td></tr><tr id="type-operation.Yield" class="anchored"><td class="def constructor"><a href="#type-operation.Yield" class="anchor"></a><code>| </code><code>`Yield</code></td></tr><tr id="type-operation.Close" class="anchored"><td class="def constructor"><a href="#type-operation.Close" class="anchor"></a><code>| </code><code>`Close</code></td></tr></table><code> ]</code></dt><dd><p>The type of operations that the serialier may wish to perform.</p><ul><li><code>`Writev iovecs</code>: Write the bytes in <code>iovecs</code>s reporting the actual number of bytes written by calling <a href="index.html#val-shift"><code>shift</code></a>. You must accurately report the number of bytes written. Failure to do so will result in the same bytes being surfaced in a <code>`Writev</code> operation multiple times.</li><li><code>`Yield</code>: Yield to other threads of control, waiting for additional output before procedding. The method for achieving this is application-specific, but once complete, the caller can proceed with serialization by simply making another call to <a href="index.html#val-operation"><code>operation</code></a> or <a href="index.html#val-serialize"><code>serialize</code></a>.</li><li><code>`Close</code>: Serialization is complete. No further output will generated. The action to take as a result, if any, is application-specific.</li></ul></dd></dl><dl><dt class="spec value" id="val-operation"><a href="#val-operation" class="anchor"></a><code><span class="keyword">val</span> operation : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-operation">operation</a></code></dt><dd><p><code>operation t</code> is the next operation that the caller must perform on behalf of the serializer <code>t</code>. Users should consider using <a href="index.html#val-serialize"><code>serialize</code></a> before this function. See the documentation for the <a href="index.html#type-operation"><code>operation</code></a> type for details on how callers should handle these operations.</p></dd></dl><dl><dt class="spec value" id="val-serialize"><a href="#val-serialize" class="anchor"></a><code><span class="keyword">val</span> serialize : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<a href="index.html#type-bigstring">bigstring</a> <a href="index.html#type-iovec">iovec</a> list <span>&#45;&gt;</span> [ `Ok of int | `Closed ]) <span>&#45;&gt;</span> [ `Yield | `Close ]</code></dt><dd><p><code>serialize t writev</code> sufaces the next operation of <code>t</code> to the caller, handling a <code>`Writev</code> operation with <code>writev</code> function and performing an additional bookkeeping on the caller's behalf. In the event that <code>writev</code> indicates a partial write, <a href="index.html#val-serialize"><code>serialize</code></a> will call <a href="index.html#val-yield"><code>yield</code></a> on the serializer rather than attempting successive <code>writev</code> calls.</p></dd></dl></section><section><header><h3 id="convenience-functions"><a href="#convenience-functions" class="anchor"></a>Convenience Functions</h3><p>These functions are included for testing, debugging, and general development. They are not the suggested way of driving a serializer in a production setting.</p></header><dl><dt class="spec value" id="val-serialize_to_string"><a href="#val-serialize_to_string" class="anchor"></a><code><span class="keyword">val</span> serialize_to_string : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> string</code></dt><dd><p><code>serialize_to_string t</code> runs <code>t</code>, collecting the output into a string and returning it. <code>serialzie_to_string t</code> immediately closes <code>t</code> and ignores any calls to <a href="index.html#val-yield"><code>yield</code></a> on <code>t</code>.</p></dd></dl><dl><dt class="spec value" id="val-serialize_to_bigstring"><a href="#val-serialize_to_bigstring" class="anchor"></a><code><span class="keyword">val</span> serialize_to_bigstring : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-bigstring">bigstring</a></code></dt><dd><p><code>serialize_to_string t</code> runs <code>t</code>, collecting the output into a bigstring and returning it. <code>serialzie_to_bigstring t</code> immediately closes <code>t</code> and ignores any calls to <a href="index.html#val-yield"><code>yield</code></a> on <code>t</code>.</p></dd></dl></section></div></body></html>