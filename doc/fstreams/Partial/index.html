<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Partial (fstreams.Partial)</title><link rel="stylesheet" href="../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../index.html">fstreams</a> &#x00BB; Partial</nav><h1>Module <code>Partial</code></h1><p>Partial, lazy, functional streams; may terminate or may not.</p><p>Streams are lazy data structures which contain values in sequence. Due to laziness, streams may be infinite (e.g. <a href="index.html#val-ints"><code>ints</code></a> below). The streams in this module are &quot;partial&quot; referring to the fact that <a href="index.html#elimination"><span><code>eliminators</code></span></a> like <a href="index.html#val-head"><code>head</code></a>, <a href="index.html#val-tail"><code>tail</code></a>, and <a href="index.html#val-uncons"><code>uncons</code></a> return values wrapped in <code>option</code> producing <code>None</code> when if the stream contains no further values.</p><p>The streams in the <a href="../Total/index.html"><code>Total</code></a> module are a sister datatype to these streams which is &quot;total&quot;, e.g. <a href="../Total/index.html#val-uncons"><code>Total.uncons</code></a> returns pure values.</p><p>Mathematically, partial streams are the greatest fixed point of the functor <code>F X = 1 + A * X</code>.</p><nav class="toc"><ul><li><a href="#introduction">Value introduction</a></li><li><a href="#elimination">Value elimination</a></li><li><a href="#functor">Streams are <i>covariant functors</i></a></li><li><a href="#applicative">Streams are <i>applicative</i> functors</a></li><li><a href="#extras">Other operations</a></li><li><a href="#impl">Implementation</a></li></ul></nav></header><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> +'a t</code></dt><dd><p>A partial lazy stream; a potentially unbounded sequence of values of type <code>'a</code>.</p></dd></dl><section><header><h2 id="introduction"><a href="#introduction" class="anchor"></a>Value introduction</h2></header><dl><dt class="spec value" id="val-empty"><a href="#val-empty" class="anchor"></a><code><span class="keyword">val</span> empty : <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Partial streams admit an empty value.</p></dd></dl><dl><dt class="spec value" id="val-cons"><a href="#val-cons" class="anchor"></a><code><span class="keyword">val</span> cons : <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Extend a stream by prepending a value.</p></dd></dl><dl><dt class="spec value" id="val-unfold"><a href="#val-unfold" class="anchor"></a><code><span class="keyword">val</span> unfold : (<span class="type-var">'s</span> <span>&#45;&gt;</span> (<span class="type-var">'a</span> * <span class="type-var">'s</span>) option) <span>&#45;&gt;</span> <span class="type-var">'s</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Lazily unfolds a partial stream. In each step of <code>unfold build s</code>, the current seed is passed to <code>build</code> to produce either <code>None</code>, indicating the stream has now terminated, or <code>Some (a, s')</code> giving the next value of the stream and the new seed value, e.g.</p><pre><code class="ml">let ints : int t = unfold (fun n -&gt; Some (n, n+1)) 0 </code></pre></dd></dl><dl><dt class="spec value" id="val-trajectory"><a href="#val-trajectory" class="anchor"></a><code><span class="keyword">val</span> trajectory : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Generate an infinite stream from the trajectory of a endomorphism. In other words, <code>head (trajectory f a) = a</code> and <code>tail (trajectory f a) = trajectory f (f a)</code></p></dd></dl><dl><dt class="spec value" id="val-impure"><a href="#val-impure" class="anchor"></a><code><span class="keyword">val</span> impure : (unit <span>&#45;&gt;</span> <span class="type-var">'a</span> option) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Generates a list impurely. Each new value of the stream <code>impure f</code> is produced by calling <code>f ()</code> until it is <code>None</code>. See also <a href="index.html#val-tabulate"><code>tabulate</code></a>.</p></dd></dl><dl><dt class="spec value" id="val-of_list"><a href="#val-of_list" class="anchor"></a><code><span class="keyword">val</span> of_list : <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Lists can be seen as equivalent to necessarily finite streams. This function injects a list into the type of partial streams.</p><p>In particular, a linked list is the least fixed point of the functor <code>F X = 1 + A * X</code>, the same functor that partial streams are the greatest fixed point of.</p></dd></dl><dl><dt class="spec value" id="val-tabulate"><a href="#val-tabulate" class="anchor"></a><code><span class="keyword">val</span> tabulate : (int <span>&#45;&gt;</span> <span class="type-var">'a</span> option) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Generates a stream by tabulation of values. The generation proceeds sequentially such that the stream <code>tabulate f</code> is either infinite or has length equal to the <i>first</i> <code>n</code> such that <code>f n =
    None</code>.</p><p>Partial streams can be seen as memoizations of functions of type <code>int -&gt; 'a option</code> so long as the &quot;compaction&quot; property above holds. This correspondence is nicer for <a href="../Total/index.html"><code>Total</code></a> streams (see <a href="../Total/index.html#val-tabulate"><code>Total.tabulate</code></a>).</p><p>See <a href="index.html#val-nth"><code>nth</code></a>.</p></dd></dl><dl><dt class="spec value" id="val-ints"><a href="#val-ints" class="anchor"></a><code><span class="keyword">val</span> ints : int <a href="index.html#type-t">t</a></code></dt><dd><p>An infinite stream of all integers.</p></dd></dl><aside><p><i>See also</i>: <a href="index.html#val-pure"><code>pure</code></a></p></aside></section><section><header><h2 id="elimination"><a href="#elimination" class="anchor"></a>Value elimination</h2></header><dl><dt class="spec value" id="val-head"><a href="#val-head" class="anchor"></a><code><span class="keyword">val</span> head : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> option</code></dt><dt class="spec value" id="val-tail"><a href="#val-tail" class="anchor"></a><code><span class="keyword">val</span> tail : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> option</code></dt><dt class="spec value" id="val-uncons"><a href="#val-uncons" class="anchor"></a><code><span class="keyword">val</span> uncons : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span> * <span class="type-var">'a</span> <a href="index.html#type-t">t</a>) option</code></dt><dd><p>The &quot;principle eliminator&quot; for a stream. Can be used along with recursion to derive all of the others. The fact that the return value is optional indicates the potentially finite nature of partial streams.</p></dd></dl><dl><dt class="spec value" id="val-fold"><a href="#val-fold" class="anchor"></a><code><span class="keyword">val</span> fold : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'r</span> <a href="../../ocaml/Stdlib/Lazy/index.html#type-t">Stdlib.Lazy.t</a> <span>&#45;&gt;</span> <span class="type-var">'r</span>) <span>&#45;&gt;</span> <span class="type-var">'r</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'r</span></code></dt><dd><p>Non-strict right fold. If <code>f</code> is careful about forcing its second argument only as needed then <code>fold f z s</code> can return in finite time even when <code>s</code> is infinite.</p><p>This is the principle recursor of a partial stream. Essentially any function eliminating streams can be derived from <a href="index.html#val-fold"><code>fold</code></a>.</p></dd></dl><dl><dt class="spec value" id="val-fold_left"><a href="#val-fold_left" class="anchor"></a><code><span class="keyword">val</span> fold_left : (<span class="type-var">'r</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'r</span>) <span>&#45;&gt;</span> <span class="type-var">'r</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'r</span></code></dt><dd><p>Strict left fold. If <code>s</code> is infinite then <code>fold_left f z s</code> will never terminate. On the other hand, <code>fold_left</code> must be tail-recursive.</p></dd></dl><dl><dt class="spec value" id="val-iter"><a href="#val-iter" class="anchor"></a><code><span class="keyword">val</span> iter : (<span class="type-var">'a</span> <span>&#45;&gt;</span> unit) <span>&#45;&gt;</span> ?&#8288;finally:(unit <span>&#45;&gt;</span> unit) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Impure consumption of a stream. If the end of the stream is reached then the <code>finally</code> callback will be invoked. <i>This function is dangerous.</i> It may be the case that the consumed stream is infinite and therefore <code>iter f s</code> will not return. Consider calling it asynchronously.</p></dd></dl><dl><dt class="spec value" id="val-nth"><a href="#val-nth" class="anchor"></a><code><span class="keyword">val</span> nth : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <span class="type-var">'a</span> option</code></dt><dd><p>Convert a stream into an accessor function on index. See <a href="index.html#val-tabulate"><code>tabulate</code></a>.</p></dd></dl></section><section><header><h2 id="functor"><a href="#functor" class="anchor"></a>Streams are <i>covariant functors</i></h2></header><dl><dt class="spec value" id="val-map"><a href="#val-map" class="anchor"></a><code><span class="keyword">val</span> map : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Applies a function valuewise to a stream.</p></dd></dl></section><section><header><h2 id="applicative"><a href="#applicative" class="anchor"></a>Streams are <i>applicative</i> functors</h2></header><aside><p>Streams are &quot;zippy&quot; applicative functors.</p></aside><dl><dt class="spec value" id="val-pure"><a href="#val-pure" class="anchor"></a><code><span class="keyword">val</span> pure : <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Produces the infinite, constant stream of some value.</p></dd></dl><dl><dt class="spec value" id="val-ap"><a href="#val-ap" class="anchor"></a><code><span class="keyword">val</span> ap : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a></code></dt><dd><p>&quot;Zips&quot; a stream of functions with a stream of their arguments returning the resulting list. If one stream is shorter than the other then the result will be the length of the shorter stream.</p></dd></dl><dl><dt class="spec value" id="val-map2"><a href="#val-map2" class="anchor"></a><code><span class="keyword">val</span> map2 : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'c</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'c</span> <a href="index.html#type-t">t</a></code></dt><dd><p>A generalization of <a href="index.html#val-map"><code>map</code></a> afforded by <a href="index.html#val-pure"><code>pure</code></a> and <a href="index.html#val-ap"><code>ap</code></a>. This version may be more efficient than the equivalent version produced using <a href="index.html#val-pure"><code>pure</code></a> and <a href="index.html#val-ap"><code>ap</code></a>.</p><pre><code class="ml">map2 f a b = ap (ap (pure f) a) b </code></pre></dd></dl><dl><dt class="spec value" id="val-map3"><a href="#val-map3" class="anchor"></a><code><span class="keyword">val</span> map3 : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'c</span> <span>&#45;&gt;</span> <span class="type-var">'d</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'c</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'d</span> <a href="index.html#type-t">t</a></code></dt><dd><p>A generalization of <a href="index.html#val-map"><code>map</code></a> afforded by <a href="index.html#val-pure"><code>pure</code></a> and <a href="index.html#val-ap"><code>ap</code></a>. This version may be more efficient than the equivalent version produced using <a href="index.html#val-pure"><code>pure</code></a> and <a href="index.html#val-ap"><code>ap</code></a>.</p><pre><code class="ml">map3 f a b c = ap (ap (ap (pure f) a) b) c </code></pre></dd></dl></section><section><header><h2 id="extras"><a href="#extras" class="anchor"></a>Other operations</h2></header><dl><dt class="spec value" id="val-interleave"><a href="#val-interleave" class="anchor"></a><code><span class="keyword">val</span> interleave : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Interleaves two streams, non-associative. For instance, the streams <code>let x = [1;2;3;...]</code> and <code>let y = [a;b;c;...]</code> are interwoven to form <code>interleave x y = [1;a;2;b;3;c;...]</code>.</p></dd></dl><dl><dt class="spec value" id="val-concat"><a href="#val-concat" class="anchor"></a><code><span class="keyword">val</span> concat : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Concatenates finite streams, one then the next. Streams are monoidal under the <a href="index.html#val-empty"><code>empty</code></a> stream and <a href="index.html#val-concat"><code>concat</code></a>.</p></dd></dl><dl><dt class="spec value" id="val-push"><a href="#val-push" class="anchor"></a><code><span class="keyword">val</span> push : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p>If a stream <code>s</code> is interpreted as a process through time then <code>push s</code> is the same process beginning at </p><pre>t=-1</pre><p>instead of </p><pre>    t=0</pre><p>.</p></dd></dl><dl><dt class="spec value" id="val-take"><a href="#val-take" class="anchor"></a><code><span class="keyword">val</span> take : int <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> list</code></dt><dd><p>Convert a prefix of a stream into a <code>list</code>. Note that the list <code>take n s</code> is not necessarily as long as <code>n</code>.</p></dd></dl><dl><dt class="spec value" id="val-drop"><a href="#val-drop" class="anchor"></a><code><span class="keyword">val</span> drop : int <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Trim off a prefix of a stream.</p></dd></dl><dl><dt class="spec value" id="val-inits"><a href="#val-inits" class="anchor"></a><code><span class="keyword">val</span> inits : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> list <a href="index.html#type-t">t</a></code></dt><dd><p>Stream all prefixes of a stream.</p></dd></dl><dl><dt class="spec value" id="val-tails"><a href="#val-tails" class="anchor"></a><code><span class="keyword">val</span> tails : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <a href="index.html#type-t">t</a></code></dt><dd><p>Stream all suffixes of a stream.</p></dd></dl><dl><dt class="spec value" id="val-keep"><a href="#val-keep" class="anchor"></a><code><span class="keyword">val</span> keep : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> option) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Transform a stream dropping some elements. See <a href="index.html#val-map"><code>map</code></a>.</p></dd></dl><dl><dt class="spec value" id="val-filter"><a href="#val-filter" class="anchor"></a><code><span class="keyword">val</span> filter : (<span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Dropping some elements of a stream. See <a href="index.html#val-keep"><code>keep</code></a>.</p></dd></dl></section><section><header><h2 id="impl"><a href="#impl" class="anchor"></a>Implementation</h2></header><aside><p>The stream implementation is exposed to allow certain tricky definitions. <i>This will hopefully be removed in later versions, try not to depend upon it!</i></p></aside><div class="spec module" id="module-Impl"><a href="#module-Impl" class="anchor"></a><code><span class="keyword">module</span> <a href="Impl/index.html">Impl</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div></section></div></body></html>