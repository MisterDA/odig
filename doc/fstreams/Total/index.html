<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Total (fstreams.Total)</title><link rel="stylesheet" href="../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../index.html">fstreams</a> &#x00BB; Total</nav><h1>Module <code>Total</code></h1><p>Total, lazy, functional streams; guaranteed to be unending.</p><p>Streams are lazy data structures which contain values in sequence. Due to laziness, streams may be infinite (e.g. <a href="index.html#val-ints"><code>ints</code></a> below). The streams in this module are &quot;total&quot; referring to the fact that <a href="index.html#elimination"><span><code>eliminators</code></span></a> like <a href="index.html#val-head"><code>head</code></a>, <a href="index.html#val-tail"><code>tail</code></a>, and <a href="index.html#val-uncons"><code>uncons</code></a> return pure values implying that there is never an end to the sequence of contained values.</p><p>The streams in <a href="../Partial/index.html"><code>Partial</code></a> are a sister datatype to these streams which is &quot;partial&quot;, e.g. <a href="../Partial/index.html#val-uncons"><code>Partial.uncons</code></a> returns values wrapped in <code>option</code>.</p><p>Mathematically, total streams are the greatest fixed point of the functor <code>F X = A * X</code>.</p><nav class="toc"><ul><li><a href="#introduction">Value introduction</a></li><li><a href="#elimination">Value elimination</a></li><li><a href="#functor">Streams are <i>covariant functors</i></a></li><li><a href="#applicative">Streams are <i>applicative</i> functors</a></li><li><a href="#applicative">Streams are <i>comonads</i></a></li><li><a href="#extras">Other operations</a></li><li><a href="#impl">Implementation</a></li></ul></nav></header><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> +'a t</code></dt><dd><p>A total lazy stream; a necessarily unbounded sequence of values of type <code>'a</code>.</p></dd></dl><section><header><h2 id="introduction"><a href="#introduction" class="anchor"></a>Value introduction</h2></header><dl><dt class="spec value" id="val-cons"><a href="#val-cons" class="anchor"></a><code><span class="keyword">val</span> cons : <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Extend a stream by prepending a value.</p></dd></dl><dl><dt class="spec value" id="val-unfold"><a href="#val-unfold" class="anchor"></a><code><span class="keyword">val</span> unfold : (<span class="type-var">'s</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> * <span class="type-var">'s</span>) <span>&#45;&gt;</span> <span class="type-var">'s</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Lazily unfolds a total stream. In each step of <code>unfold build s</code>, the current seed is passed to <code>build</code> the next value of the stream and the new seed value, e.g.</p><pre><code class="ml">let ints : int t = unfold (fun n -&gt; (n, n+1)) 0 </code></pre></dd></dl><dl><dt class="spec value" id="val-trajectory"><a href="#val-trajectory" class="anchor"></a><code><span class="keyword">val</span> trajectory : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Generate an infinite stream from the trajectory of a endomorphism. In other words, <code>head (trajectory f a) = a</code> and <code>tail (trajectory f a) = trajectory f (f a)</code></p></dd></dl><dl><dt class="spec value" id="val-impure"><a href="#val-impure" class="anchor"></a><code><span class="keyword">val</span> impure : (unit <span>&#45;&gt;</span> <span class="type-var">'a</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Generates a list impurely. Each new value of the stream <code>impure f</code> is produced by calling <code>f ()</code>. See also <a href="index.html#val-tabulate"><code>tabulate</code></a>.</p></dd></dl><dl><dt class="spec value" id="val-tabulate"><a href="#val-tabulate" class="anchor"></a><code><span class="keyword">val</span> tabulate : (int <span>&#45;&gt;</span> <span class="type-var">'a</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Generates a stream by tabulation of values.</p><p>Total streams can be seen as memoizations of functions of type <code>int -&gt; 'a</code>, so <a href="index.html#val-tabulate"><code>tabulate</code></a> witnesses part of this isomorphism.</p><p>See <a href="index.html#val-nth"><code>nth</code></a>.</p></dd></dl><dl><dt class="spec value" id="val-ints"><a href="#val-ints" class="anchor"></a><code><span class="keyword">val</span> ints : int <a href="index.html#type-t">t</a></code></dt><dd><p>An infinite stream of all integers.</p></dd></dl><aside><p><i>See also</i>: <a href="index.html#val-pure"><code>pure</code></a></p></aside></section><section><header><h2 id="elimination"><a href="#elimination" class="anchor"></a>Value elimination</h2></header><dl><dt class="spec value" id="val-head"><a href="#val-head" class="anchor"></a><code><span class="keyword">val</span> head : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dt class="spec value" id="val-tail"><a href="#val-tail" class="anchor"></a><code><span class="keyword">val</span> tail : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-uncons"><a href="#val-uncons" class="anchor"></a><code><span class="keyword">val</span> uncons : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> * <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p>The &quot;principle eliminator&quot; for a stream. Can be used along with recursion to derive all of the others.</p></dd></dl><dl><dt class="spec value" id="val-fold"><a href="#val-fold" class="anchor"></a><code><span class="keyword">val</span> fold : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'r</span> <a href="../../ocaml/Stdlib/Lazy/index.html#type-t">Stdlib.Lazy.t</a> <span>&#45;&gt;</span> <span class="type-var">'r</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'r</span></code></dt><dd><p>Non-strict right fold. One must be careful in <code>f</code> about forcing the second argument only as needed; <code>fold f z s</code> <i>can</i> return in finite time, but won't if it is too strict.</p><p>This is the principle recursor of a total stream. Essentially any function eliminating streams can be derived from <a href="index.html#val-fold"><code>fold</code></a>.</p></dd></dl><dl><dt class="spec value" id="val-iter"><a href="#val-iter" class="anchor"></a><code><span class="keyword">val</span> iter : (<span class="type-var">'a</span> <span>&#45;&gt;</span> unit) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../Void/index.html#type-t">Void.t</a></code></dt><dd><p>Impure consumption of a stream. <i>Note</i> that this function will never return.</p></dd></dl><dl><dt class="spec value" id="val-nth"><a href="#val-nth" class="anchor"></a><code><span class="keyword">val</span> nth : int <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p>Convert a stream into an accessor function on index. See <a href="index.html#val-tabulate"><code>tabulate</code></a>.</p></dd></dl></section><section><header><h2 id="functor"><a href="#functor" class="anchor"></a>Streams are <i>covariant functors</i></h2></header><dl><dt class="spec value" id="val-map"><a href="#val-map" class="anchor"></a><code><span class="keyword">val</span> map : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Applies a function valuewise to a stream.</p></dd></dl></section><section><header><h2 id="applicative"><a href="#applicative" class="anchor"></a>Streams are <i>applicative</i> functors</h2></header><aside><p>Streams are &quot;zippy&quot; applicative functors.</p></aside><dl><dt class="spec value" id="val-pure"><a href="#val-pure" class="anchor"></a><code><span class="keyword">val</span> pure : <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Produces the infinite, constant stream of some value.</p></dd></dl><dl><dt class="spec value" id="val-ap"><a href="#val-ap" class="anchor"></a><code><span class="keyword">val</span> ap : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a></code></dt><dd><p>&quot;Zips&quot; a stream of functions with a stream of their arguments returning the resulting list.</p></dd></dl><dl><dt class="spec value" id="val-map2"><a href="#val-map2" class="anchor"></a><code><span class="keyword">val</span> map2 : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'c</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'c</span> <a href="index.html#type-t">t</a></code></dt><dd><p>A generalization of <a href="index.html#val-map"><code>map</code></a> afforded by <a href="index.html#val-pure"><code>pure</code></a> and <a href="index.html#val-ap"><code>ap</code></a>. This version may be more efficient than the equivalent version produced using <a href="index.html#val-pure"><code>pure</code></a> and <a href="index.html#val-ap"><code>ap</code></a>.</p><pre><code class="ml">map2 f a b = ap (ap (pure f) a) b </code></pre></dd></dl><dl><dt class="spec value" id="val-map3"><a href="#val-map3" class="anchor"></a><code><span class="keyword">val</span> map3 : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'c</span> <span>&#45;&gt;</span> <span class="type-var">'d</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'c</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'d</span> <a href="index.html#type-t">t</a></code></dt><dd><p>A generalization of <a href="index.html#val-map"><code>map</code></a> afforded by <a href="index.html#val-pure"><code>pure</code></a> and <a href="index.html#val-ap"><code>ap</code></a>. This version may be more efficient than the equivalent version produced using <a href="index.html#val-pure"><code>pure</code></a> and <a href="index.html#val-ap"><code>ap</code></a>.</p><pre><code class="ml">map3 f a b c = ap (ap (ap (pure f) a) b) c </code></pre></dd></dl></section><section><header><h2 id="applicative"><a href="#applicative" class="anchor"></a>Streams are <i>comonads</i></h2></header><aside><p>Streams are comonads focused on their &quot;zero&quot; element.</p></aside><dl><dt class="spec value" id="val-extract"><a href="#val-extract" class="anchor"></a><code><span class="keyword">val</span> extract : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p>Extract the focused element, e.g. <code>extract s = nth s 0</code>.</p></dd></dl><dl><dt class="spec value" id="val-extend"><a href="#val-extend" class="anchor"></a><code><span class="keyword">val</span> extend : (<span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'b</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Apply a function from streams to summary values at all points in time. In other words <code>head (extend f s) = f s</code> and <code>tail (extend f
    s) = extend f (push s)</code>.</p></dd></dl></section><section><header><h2 id="extras"><a href="#extras" class="anchor"></a>Other operations</h2></header><dl><dt class="spec value" id="val-interleave"><a href="#val-interleave" class="anchor"></a><code><span class="keyword">val</span> interleave : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Interleaves two streams</p><p>Interleaves two streams, non-associative. For instance, the streams <code>let x = [1;2;3;...]</code> and <code>let y = [a;b;c;...]</code> are interwoven to form <code>interleave x y = [1;a;2;b;3;c;...]</code>.</p></dd></dl><dl><dt class="spec value" id="val-push"><a href="#val-push" class="anchor"></a><code><span class="keyword">val</span> push : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p>If a stream <code>s</code> is interpreted as a process through time then <code>delay s</code> is the same process beginning at </p><pre>t=-1</pre><p>instead of</p><pre>t=0</pre><p>.</p><p>For total streams, <code>delay</code> is identical to <a href="index.html#val-tail"><code>tail</code></a>.</p></dd></dl><dl><dt class="spec value" id="val-take"><a href="#val-take" class="anchor"></a><code><span class="keyword">val</span> take : int <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> list</code></dt><dd><p>Convert a prefix of a stream into a <code>list</code>. Note that the list <code>take n s</code> is not necessarily as long as <code>n</code>.</p></dd></dl><dl><dt class="spec value" id="val-drop"><a href="#val-drop" class="anchor"></a><code><span class="keyword">val</span> drop : int <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Trim off a prefix of a stream.</p></dd></dl><dl><dt class="spec value" id="val-inits"><a href="#val-inits" class="anchor"></a><code><span class="keyword">val</span> inits : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> list <a href="index.html#type-t">t</a></code></dt><dd><p>Stream all prefixes of a stream.</p></dd></dl><dl><dt class="spec value" id="val-tails"><a href="#val-tails" class="anchor"></a><code><span class="keyword">val</span> tails : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <a href="index.html#type-t">t</a></code></dt><dd><p>Stream all suffixes of a stream.</p></dd></dl><dl><dt class="spec value" id="val-keep"><a href="#val-keep" class="anchor"></a><code><span class="keyword">val</span> keep : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> option) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Transform a stream dropping some elements. See <a href="index.html#val-map"><code>map</code></a>.</p></dd></dl><dl><dt class="spec value" id="val-filter"><a href="#val-filter" class="anchor"></a><code><span class="keyword">val</span> filter : (<span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Dropping some elements of a stream. See <a href="index.html#val-keep"><code>keep</code></a>.</p></dd></dl></section><section><header><h2 id="impl"><a href="#impl" class="anchor"></a>Implementation</h2></header><aside><p>The stream implementation is exposed to allow certain tricky definitions. <i>This will hopefully be removed in later versions, try not to depend upon it!</i></p></aside><div class="spec module" id="module-Impl"><a href="#module-Impl" class="anchor"></a><code><span class="keyword">module</span> <a href="Impl/index.html">Impl</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div></section></div></body></html>