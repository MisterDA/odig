<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Fut (fut.Fut)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../index.html">fut</a> &#x00BB; Fut</nav><h1>Module <code>Fut</code></h1><p>Future values for asynchronous programming.</p><p><code>Fut</code> provides support to define and combine futures. A future is an undetermined value that becomes determined at an arbitrary point in the future. The future acts as a place-holder for the value while it is undetermined.</p><p><a href="index.html#promises"><span>Promises</span></a> determine the value of futures cooperatively while <a href="index.html#queues"><span>future queues</span></a> determine the value of blocking or long running function applications with a set of concurrent workers and act as a mutual exclusion synchronization primitive. <a href="index.html#semaphores"><span>Semaphores</span></a> allow to limit the resource usage of a set of determining futures.</p><p>The separate <code>Futu</code> library exposes <code>Unix</code> system calls as futures.</p><p>Consult the <a href="index.html#basics"><span>basics</span></a>, the <a href="index.html#semantics"><span>semantics</span></a> and <a href="index.html#examples"><span>examples</span></a>.</p><p><em>v0.0.0-79-gece0e52 — <a href="UNDEFINED">homepage</a></em></p><nav class="toc"><ul><li><a href="#values">Futures</a><ul><li><a href="#applicative">Applicative combinators</a></li><li><a href="#effectful">Effectful combinators</a></li></ul></li><li><a href="#promises">Promises</a></li><li><a href="#queues">Future queues</a></li><li><a href="#timers">Timers</a></li><li><a href="#semaphores">Semaphores</a></li><li><a href="#error">Error handling</a></li><li><a href="#infix">Infix operators</a></li><li><a href="#runtime">Runtime system</a></li><li><a href="#basics">Basics</a><ul><li><a href="#semantics">Semantics</a></li><li><a href="#neverdet">Never determined futures</a></li><li><a href="#exceptions">Exceptions</a></li><li><a href="#futqueues">Future queues</a></li><li><a href="#promises">Promises</a></li><li><a href="#futandthreads">Fut and system threads</a></li><li><a href="#futandprocesses">Fut and system processes</a></li></ul></li><li><a href="#examples">Examples</a><ul><li><a href="#backend">Backends</a></li><li><a href="#the-universal-client">The universal client</a></li><li><a href="#the-echo-server">The echo server</a></li><li><a href="#promiseex">Integration with asynchronous functions</a></li><li><a href="#threadex">Integration with threads</a></li><li><a href="#multip">Integration with multiprocessing</a></li><li><a href="#signals">Integration with signals</a></li></ul></li></ul></nav></header><section><header><h2 id="values"><a href="#values" class="anchor"></a>Futures</h2></header><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type </span>'a t</code></dt><dd><p>The type for a future that determines a value of type <code>'a</code>.</p></dd></dl><dl><dt class="spec type" id="type-state"><a href="#type-state" class="anchor"></a><code><span class="keyword">type </span>'a state</code><span class="keyword"> = </span><code>[ </code><table class="variant"><tr id="type-state.Never" class="anchored"><td class="def constructor"><a href="#type-state.Never" class="anchor"></a><code><span class="keyword">| </span></code><code>`Never</code></td></tr><tr id="type-state.Undet" class="anchored"><td class="def constructor"><a href="#type-state.Undet" class="anchor"></a><code><span class="keyword">| </span></code><code>`Undet</code></td></tr><tr id="type-state.Det" class="anchored"><td class="def constructor"><a href="#type-state.Det" class="anchor"></a><code><span class="keyword">| </span></code><code>`Det<span class="keyword"> of </span><span class="type-var">'a</span></code></td></tr></table><code> ]</code></dt><dd><p>The type for future states. <code>`Det v</code> if the future determined <code>v</code>. <code>`Never</code> if the future is known to never determine. <code>`Undet</code> if the future is undetermined. If the state is different from <code>`Undet</code>, the future is <em>set</em>.</p></dd></dl><dl><dt class="spec type" id="type-set"><a href="#type-set" class="anchor"></a><code><span class="keyword">type </span>'a set</code><span class="keyword"> = </span><code>[ </code><table class="variant"><tr id="type-set.Never" class="anchored"><td class="def constructor"><a href="#type-set.Never" class="anchor"></a><code><span class="keyword">| </span></code><code>`Never</code></td></tr><tr id="type-set.Det" class="anchored"><td class="def constructor"><a href="#type-set.Det" class="anchor"></a><code><span class="keyword">| </span></code><code>`Det<span class="keyword"> of </span><span class="type-var">'a</span></code></td></tr></table><code> ]</code></dt><dd><p>The type for set future states. See <a href="index.html#type-state"><code>state</code></a>.</p></dd></dl><dl><dt class="spec value" id="val-state"><a href="#val-state" class="anchor"></a><code><span class="keyword">val </span>state : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-state">state</a></code></dt><dd><p><code>state f</code> is the current state of <code>f</code>.</p><p><b>Thread-safe.</b> This function can be called by other threads.</p></dd></dl><dl><dt class="spec value" id="val-state_set"><a href="#val-state_set" class="anchor"></a><code><span class="keyword">val </span>state_set : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-set">set</a></code></dt><dd><p><code>state_set f</code> is the set state of <code>f</code>.</p><dl><dt>raises Invalid_argument</dt><dd><p>if <code>f</code> is not <code>s</code>.</p><p><b>Thread-safe.</b> This function can be called by other threads.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-await"><a href="#val-await" class="anchor"></a><code><span class="keyword">val </span>await : ?&#8288;timeout:float <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-state">state</a></code></dt><dd><p><code>await timeout f</code>, is like <a href="index.html#type-state"><code>state</code></a> except if <code>f</code> is undetermined it waits until <code>f</code> is set or <code>timeout</code> seconds passed. If <code>timeout</code> is unspecified, <code>await</code> blocks until <code>f</code> is set.</p><dl><dt>raises Invalid_argument</dt><dd><p>if <code>timeout</code> is negative.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-sync"><a href="#val-sync" class="anchor"></a><code><span class="keyword">val </span>sync : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-set">set</a></code></dt><dd><p><code>sync f</code> is like <a href="index.html#val-await"><code>await</code></a> but blocks until <code>f</code> is set.</p></dd></dl><dl><dt class="spec value" id="val-finally"><a href="#val-finally" class="anchor"></a><code><span class="keyword">val </span>finally : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'c</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'c</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>finally fn v f</code> is <code>f</code> but <code>fn v</code> is called (and its result ignored) whenever <code>f</code> is set and immediately if <code>f</code> is already set at call time. <code>fn</code> may safely use <code>set_state</code><code> f</code> to determine how it set. If <code>fn v</code> raises an exception it is reported to the exception trap specified with <a href="Runtime/index.html#val-set_exn_trap"><code>Runtime.set_exn_trap</code></a>.</p></dd></dl><section><header><h3 id="applicative"><a href="#applicative" class="anchor"></a>Applicative combinators</h3><p>These combinators have no effects on the determination of their arguments.</p></header><dl><dt class="spec value" id="val-never"><a href="#val-never" class="anchor"></a><code><span class="keyword">val </span>never : unit <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>never ()</code> is a future that never determines a value.</p><ul><li>[<code>never ()</code>]<sub>t</sub> <code>= `Never</code></li></ul></dd></dl><dl><dt class="spec value" id="val-ret"><a href="#val-ret" class="anchor"></a><code><span class="keyword">val </span>ret : <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>ret v</code> is a future that determines the value <code>v</code> immediately.</p><ul><li>[<code>ret v</code>]<sub>t</sub> <code>= `Det v</code></li></ul></dd></dl><dl><dt class="spec value" id="val-recover"><a href="#val-recover" class="anchor"></a><code><span class="keyword">val </span>recover : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> [ `Det of <span class="type-var">'a</span><span class="keyword"> | </span>`Never ] <a href="index.html#type-t">t</a></code></dt><dd><p><code>recover f</code> is a future that determines <code>`Det v</code> if <code>f</code> determined <code>v</code> or <code>`Never</code> if <code>f</code> was set to never determine.</p><ul><li>[<code>recover f</code>]<sub>t</sub> <code>= `Det (`Det v)</code> if [<code>f</code>]<sub>t</sub> <code>= `Det v</code></li><li>[<code>recover f</code>]<sub>t</sub> <code>= `Det (`Never)</code> if [<code>f</code>]<sub>t</sub> <code>= `Never</code></li></ul></dd></dl><dl><dt class="spec value" id="val-bind"><a href="#val-bind" class="anchor"></a><code><span class="keyword">val </span>bind : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a>) <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>bind f fn</code> is the future <code>fn v</code> where <code>v</code> is the value determined by <code>f</code>.</p><ul><li>[<code>bind f fn</code>]<sub>t</sub> <code>= </code> [<code>fn v</code>]<sub>t</sub> if [<code>f</code>]<sub>t</sub> <code>= `Det v</code></li><li>[<code>bind f fn</code>]<sub>t</sub> <code>= `Never</code> if [<code>f</code>]<sub>t</sub> <code>= `Never</code></li></ul></dd></dl><dl><dt class="spec value" id="val-app"><a href="#val-app" class="anchor"></a><code><span class="keyword">val </span>app : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>app ff fv</code> is a future that determines <code>f v</code> where <code>f</code> is determined by <code>ff</code> and <code>v</code> by <code>fv</code>.</p><ul><li>[<code>app ff fv</code>]<sub>t</sub> <code>= `Det (f v)</code> if [<code>ff</code>]<sub>t</sub> <code>= `Det f</code> and [<code>fv</code>]<sub>t</sub> = <code>`Det v</code></li><li>[<code>app ff fv</code>]<sub>t</sub> <code>= `Never</code> if [<code>ff</code>]<sub>t</sub> <code>= `Never</code> or [<code>fv</code>]<sub>t</sub> <code>= `Never</code></li></ul></dd></dl><dl><dt class="spec value" id="val-map"><a href="#val-map" class="anchor"></a><code><span class="keyword">val </span>map : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>map fn f</code> is a future that determines the value <code>fn v</code> where <code>v</code> is the value determined by <code>f</code>.</p><ul><li>[<code>map fn f</code>]<sub>t</sub> <code>= `Det (fn v)</code> if [<code>f</code>]<sub>t</sub> <code>= `Det v</code></li><li>[<code>map fn f</code>]<sub>t</sub> <code>= `Never</code> if [<code>f</code>]<sub>t</sub> <code>= `Never</code>.</li></ul></dd></dl><dl><dt class="spec value" id="val-ignore"><a href="#val-ignore" class="anchor"></a><code><span class="keyword">val </span>ignore : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit <a href="index.html#type-t">t</a></code></dt><dd><p><code>ignore f</code> is <a href="index.html#val-map"><code>map</code></a> <code>(fun _ -&gt; ()) f</code>.</p></dd></dl><dl><dt class="spec value" id="val-fold"><a href="#val-fold" class="anchor"></a><code><span class="keyword">val </span>fold : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'a</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a> list <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>fold fn acc [f</code><sub>1</sub><code>; ...; f</code><sub>n</sub><code>]</code> is <code>List.fold_left fn acc [v</code><sub>1</sub><code>; ...; v</code><sub>n</sub><code>]</code> where <code>v</code><sub>i</sub> is the value determined by the future <code>f</code><sub>i</sub>.</p><ul><li>[<code>fold fn acc [f</code><sub>1</sub><code>; ...; f</code><sub>n</sub><code>]</code>]<sub>t</sub> <code>= List.fold_left fn acc [v</code><sub>1</sub><code>; ...; v</code><sub>n</sub><code>]</code> if for all <code>i</code> [<code>f</code><sub>i</sub>]<sub>t</sub> <code>= v</code><sub>i</sub></li><li>[<code>fold fn acc [f</code><sub>1</sub><code>; ...; f</code><sub>n</sub><code>]</code>]<sub>t</sub> <code>= `Never</code> if there is <code>i</code> with [<code>f</code><sub>i</sub>]<sub>t</sub> <code>= `Never</code></li></ul></dd></dl><dl><dt class="spec value" id="val-sustain"><a href="#val-sustain" class="anchor"></a><code><span class="keyword">val </span>sustain : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>sustain f f'</code> determines like <code>f</code> if it does and like <code>f'</code> if <code>f</code> never determines.</p><ul><li>[<code>sustain f f'</code>]<sub>t</sub> <code>= `Det v</code> if [<code>f</code>]<sub>t</sub> <code>= `Det v</code></li><li>[<code>sustain f f'</code>]<sub>t</sub> <code>=</code> [<code>f'</code>]<sub>t</sub> if [<code>f</code>]<sub>t</sub> <code>= `Never</code></li></ul></dd></dl><dl><dt class="spec value" id="val-first"><a href="#val-first" class="anchor"></a><code><span class="keyword">val </span>first : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span><span class="keyword"> * </span><span class="type-var">'a</span> <a href="index.html#type-t">t</a>) <a href="index.html#type-t">t</a></code></dt><dd><p><code>first f f'</code> is a future that determines <code>(v, snd)</code> where <code>v</code> is the value of the first future to determine and <code>snd</code> is the other one. If both futures are already determined the left one is taken.</p><ul><li>[<code>first f f'</code>]<sub>t</sub> <code>= `Det (v, f')</code> if [<code>f</code>]<sub>t</sub> <code>= `Det v</code> and for all <code>t' &lt; t</code> [<code>f'</code>]<sub>t'</sub> <code>&lt;&gt; `Det _</code></li><li>[<code>first f f'</code>]<sub>t</sub> <code>= `Det (v, f)</code> if [<code>f'</code>]<sub>t</sub> <code>= `Det v</code> and for all <code>t' &lt;= t</code> [<code>f</code>]<sub>t'</sub> <code>&lt;&gt; `Det _</code></li><li>[<code>first f f'</code>]<sub>t</sub> <code>= `Never</code> if [<code>f</code>]<sub>t</sub> <code>=</code> [<code>f'</code>]<sub>t</sub> <code>= `Never</code></li></ul></dd></dl><dl><dt class="spec value" id="val-firstl"><a href="#val-firstl" class="anchor"></a><code><span class="keyword">val </span>firstl : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> list <span>&#45;&gt;</span> (<span class="type-var">'a</span><span class="keyword"> * </span><span class="type-var">'a</span> <a href="index.html#type-t">t</a> list) <a href="index.html#type-t">t</a></code></dt><dd><p><code>next fs</code> is a future that determines <code>(v, fs')</code> where <code>v</code> is the first value to determine in <code>fs</code> and <code>fs'</code> are the remaining ones. If more than one future is already determined the first left one is taken.</p><ul><li>[<code>firstl [f</code><sub>1</sub><code>; ...; f</code><sub>n</sub><code>]</code>]<sub>t</sub> <code>= `Det (v, [f</code><sub>1</sub><code>; ...; f</code><sub>j-1</sub><code>; f</code><sub>j+1</sub><code>; ...;f</code><sub>n</sub><code>])</code> if [<code>f</code><sub>j</sub>]<sub>t</sub> <code>= `Det v</code> and for all t' &lt; t and i &lt; j [<code>f</code><sub>i</sub>]<sub>t'</sub> <code>&lt;&gt; `Det _</code></li><li>[<code>firstl [f</code><sub>1</sub><code>; ...; f</code><sub>n</sub><code>]</code>]<sub>t</sub> <code>= `Never</code> if for all <code>i</code> [<code>f</code><sub>i</sub>]<sub>t</sub> <code>= `Never</code></li></ul></dd></dl></section><section><header><h3 id="effectful"><a href="#effectful" class="anchor"></a>Effectful combinators</h3><p>These combinators may set their <code>`Undet</code>ermined arguments to <code>`Never</code> and abort their determination.</p><p><b>Important.</b> When a future is aborted, it is set to never determine and all the future it may be waiting on (and recursively) are also aborted, except those that are protected by <a href="index.html#val-protect"><code>protect</code></a>. Aborting a future that is set has no effect since once the future is set it never changes again.</p><p><b>Warning.</b> If the aborted future is an <code>`Undet</code>ermined future from a future queue, there's no guarantee that the corresponding application will be/has not been executed when it is set to <code>`Never</code>. In any case the semantics of futures is preserved, it will switch from <code>`Undet</code> to <code>`Never</code> and remain so forever but depending on what the function application does, the world may be affected.</p></header><dl><dt class="spec value" id="val-abort"><a href="#val-abort" class="anchor"></a><code><span class="keyword">val </span>abort : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>abort f</code> aborts the future <code>f</code>. If <code>f</code> was <code>`Undet</code>ermined at application time, it is set to never determine and all the futures it is waiting on are also aborted.</p><ul><li>[<code>f</code>]<sub>t'</sub> <code>= `Never</code> with t' &gt; ta, if [<code>f</code>]<sub>ta</sub> = <code>`Undet</code> where <code>ta</code> is <code>abort</code>'s application time.</li></ul><p>TODO semantics we need to define a waits(f) that is the set of of futures <code>f</code> waits on.</p></dd></dl><dl><dt class="spec value" id="val-protect"><a href="#val-protect" class="anchor"></a><code><span class="keyword">val </span>protect : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>protect f</code> is a future that behaves like <code>f</code> but is insensitive to <a href="index.html#val-abort"><code>abort</code></a>. It may of course still never determine because of its definition but its dependents are not able to abort it. <code>f</code> of course remains abortable.</p></dd></dl><dl><dt class="spec value" id="val-pick"><a href="#val-pick" class="anchor"></a><code><span class="keyword">val </span>pick : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>pick f f'</code> is a future that determines as the first future that does and sets the other to never determine. If both futures are already determined the left one is taken. If both futures never determine, the future never determines.</p><ul><li><p>If [<code>f</code>]<sub>t</sub> <code>= `Det v</code> then</p><ul><li>[<code>pick f f'</code>]<sub>t</sub> <code>= `Det v</code></li><li>[<code>f'</code>]<sub>t'</sub> <code>= `Never</code> with t' &gt; t, if [<code>f'</code>]<sub>t</sub> = <code>`Undet</code>.</li></ul></li><li><p>If [<code>f'</code>]<sub>t</sub> <code>= `Det v</code> and [<code>f</code>]<sub>t</sub> <code>&lt;&gt; `Det _</code> then</p><ul><li>[<code>pick f f'</code>]<sub>t</sub> <code>= `Det v</code></li><li>[<code>f</code>]<sub>t'</sub> <code>= `Never</code> with t' &gt; t, if [<code>f</code>]<sub>t</sub> = <code>`Undet</code>.</li></ul></li><li>If [<code>f</code>]<sub>t</sub> = [<code>f'</code>]<sub>t</sub> <code>= `Never</code> then [<code>pick f f'</code>]<sub>t</sub> <code>= `Never</code></li></ul><p>TODO work out the semantics to see if it is equal to</p><pre><code class="ml">first f f' &gt;&gt;= fun (v, f) -&gt; ignore (abort f); ret v</code></pre></dd></dl><dl><dt class="spec value" id="val-pickl"><a href="#val-pickl" class="anchor"></a><code><span class="keyword">val </span>pickl : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> list <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>pickl fs</code> is <code>List.fold_left Fut.pick (Fut.never ()) fs</code>.</p></dd></dl></section></section><section><header><h2 id="promises"><a href="#promises" class="anchor"></a>Promises</h2></header><dl><dt class="spec type" id="type-promise"><a href="#type-promise" class="anchor"></a><code><span class="keyword">type </span>'a promise</code></dt><dd><p>The type for promises. A promise can <a href="index.html#type-set"><code>set</code></a> the <a href="index.html#val-future"><code>future</code></a> it is associated to.</p></dd></dl><dl><dt class="spec value" id="val-promise"><a href="#val-promise" class="anchor"></a><code><span class="keyword">val </span>promise : ?&#8288;abort:(unit <span>&#45;&gt;</span> unit) <span>&#45;&gt;</span> unit <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-promise">promise</a></code></dt><dd><p><code>promise abort ()</code> is a new promise. <code>abort</code> is called if the future of the promise is set to never determine via <a href="index.html#type-set"><code>set</code></a> or an <a href="index.html#effectful"><span>effectful combinator</span></a>. Once the future is set <code>abort</code> is eventually garbage collected. If you want to call a function whenever the future of the promise is set, use <a href="index.html#val-finally"><code>finally</code></a> on the future.</p><p><b>Thread-safe.</b> This function can be called from other threads.</p></dd></dl><dl><dt class="spec value" id="val-future"><a href="#val-future" class="anchor"></a><code><span class="keyword">val </span>future : <span class="type-var">'a</span> <a href="index.html#type-promise">promise</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>future p</code> is the future set by promise <code>p</code>.</p><p><b>Thread-safe.</b> This function can be called from other threads.</p></dd></dl><dl><dt class="spec value" id="val-set"><a href="#val-set" class="anchor"></a><code><span class="keyword">val </span>set : <span class="type-var">'a</span> <a href="index.html#type-promise">promise</a> <span>&#45;&gt;</span> [ `Det of <span class="type-var">'a</span><span class="keyword"> | </span>`Never ] <span>&#45;&gt;</span> unit</code></dt><dd><p><code>set p s</code> sets <a href="index.html#val-future"><code>future</code></a> <code>p</code> to <code>s</code>. Does nothing if the future of <code>p</code> is already set.</p><p>Not thread safe, if you need to set the promise from another thread use a <a href="Runtime/index.html#val-action"><code>Runtime.action</code></a>.</p></dd></dl></section><section><header><h2 id="queues"><a href="#queues" class="anchor"></a>Future queues</h2></header><dl><dt class="spec type" id="type-queue"><a href="#type-queue" class="anchor"></a><code><span class="keyword">type </span>queue</code></dt><dd><p>The type for future queues. A future queue determines function applications sequentially in FIFO order. Applications submitted in two different queues are determined concurrently.</p></dd></dl><dl><dt class="spec module" id="module-Queue"><a href="#module-Queue" class="anchor"></a><code><span class="keyword">module </span><a href="Queue/index.html">Queue</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Future queues.</p></dd></dl><dl><dt class="spec value" id="val-apply"><a href="#val-apply" class="anchor"></a><code><span class="keyword">val </span>apply : ?&#8288;queue:<a href="index.html#type-queue">queue</a> <span>&#45;&gt;</span> ?&#8288;abort:bool Pervasives.ref <span>&#45;&gt;</span> (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>apply queue abort fn v</code> is a future that determines the value <code>fn
    v</code> on <code>queue</code> (defaults to <a href="Queue/index.html#val-concurrent"><code>Queue.concurrent</code></a>). If provided, the <code>abort</code> argument is set to <code>true</code> by the runtime system if the future is set to <code>`Never</code>, e.g. because it was <a href="index.html#val-abort"><code>abort</code></a>ed; <code>fn</code> can consult this reference cell to stop its computation or take appropriate action.</p><p><code>fn</code> can raise <a href="index.html#exception-Never"><code>Never</code></a> to silently set the future to never determine. Any uncaught exception of <code>fn v</code> also sets the future to never determine however these exceptions are reported to the exception trap specified with <a href="Runtime/index.html#val-set_exn_trap"><code>Runtime.set_exn_trap</code></a>.</p><p><b>Warning.</b></p><ul><li><code>fn</code> is executed on another thread and as such it must respect Fut's <a href="index.html#futandthreads"><span>thread safety rule</span></a>.</li><li>The future won't determine if <a href="index.html#val-await"><code>await</code></a> is not called regularly.</li><li>If your program is not multi-threaded yet, it will become at that point.</li></ul></dd></dl><dl><dt class="spec exception" id="exception-Never"><a href="#exception-Never" class="anchor"></a><code><span class="keyword">exception </span></code><code><span class="exception">Never</span></code></dt><dd><p><code>Never</code> can be raised by a function application in a queue to set its corresponding future to never determine.</p></dd></dl></section><section><header><h2 id="timers"><a href="#timers" class="anchor"></a>Timers</h2><p>Timer futures determine values after a specific amount of time has passed.</p><p><b>Warning.</b> These futures don't determine if <a href="index.html#val-await"><code>await</code></a> is not called regularly.</p></header><dl><dt class="spec value" id="val-delay"><a href="#val-delay" class="anchor"></a><code><span class="keyword">val </span>delay : float <span>&#45;&gt;</span> float <a href="index.html#type-t">t</a></code></dt><dd><p><code>delay d</code> is a value that determines <code>diff = d - d'</code> in <code>d</code> seconds where <code>d'</code> is the actual time the runtime system took to determine the timer. If <code>diff</code> is <code>0.</code> the timer was on time, if positive the delay was early and if negative it was late.</p><ul><li>[<code>delay d</code>]<sub>ta+d'</sub> <code>= `Det (d-d')</code> where <code>ta</code> is <code>delay</code>'s application time and <code>d'</code> is determined by the runtime system (but should be as near as possible from <code>d</code>).</li></ul></dd></dl><dl><dt class="spec value" id="val-tick"><a href="#val-tick" class="anchor"></a><code><span class="keyword">val </span>tick : float <span>&#45;&gt;</span> unit <a href="index.html#type-t">t</a></code></dt><dd><p><code>tick d</code> is <a href="index.html#val-ignore"><code>ignore</code></a> <code>(</code><a href="index.html#val-delay"><code>delay</code></a> <code>d)</code>.</p></dd></dl></section><section><header><h2 id="semaphores"><a href="#semaphores" class="anchor"></a>Semaphores</h2></header><dl><dt class="spec module" id="module-Sem"><a href="#module-Sem" class="anchor"></a><code><span class="keyword">module </span><a href="Sem/index.html">Sem</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Semaphores for limiting resource usage.</p></dd></dl></section><section><header><h2 id="error"><a href="#error" class="anchor"></a>Error handling</h2></header><dl><dt class="spec type" id="type-result"><a href="#type-result" class="anchor"></a><code><span class="keyword">type </span>('a, 'b) result</code><code><span class="keyword"> = </span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>) Result.result <a href="index.html#type-t">t</a></code></dt><dd><p>The type for future results. A future determining a result values.</p></dd></dl><dl><dt class="spec value" id="val-rbind"><a href="#val-rbind" class="anchor"></a><code><span class="keyword">val </span>rbind : (<span class="type-var">'a</span>, <span class="type-var">'c</span>) <a href="index.html#type-result">result</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span> <span>&#45;&gt;</span> (<span class="type-var">'b</span>, <span class="type-var">'c</span>) <a href="index.html#type-result">result</a>) <span>&#45;&gt;</span> (<span class="type-var">'b</span>, <span class="type-var">'c</span>) <a href="index.html#type-result">result</a></code></dt><dt class="spec value" id="val-ok"><a href="#val-ok" class="anchor"></a><code><span class="keyword">val </span>ok : <span class="type-var">'a</span> <span>&#45;&gt;</span> (<span class="type-var">'a</span>, <span class="type-var">'b</span>) <a href="index.html#type-result">result</a></code></dt><dt class="spec value" id="val-error"><a href="#val-error" class="anchor"></a><code><span class="keyword">val </span>error : <span class="type-var">'b</span> <span>&#45;&gt;</span> (<span class="type-var">'a</span>, <span class="type-var">'b</span>) <a href="index.html#type-result">result</a></code></dt></dl></section><section><header><h2 id="infix"><a href="#infix" class="anchor"></a>Infix operators</h2><p>Use of these operators may kill a few parentheses.</p></header><dl><dt class="spec value" id="val-(&gt;&gt;=)"><a href="#val-(&gt;&gt;=)" class="anchor"></a><code><span class="keyword">val </span>(&gt;&gt;=) : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a>) <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>f &gt;&gt;= fn</code> is <code>bind f fn</code>.</p></dd></dl><dl><dt class="spec value" id="val-(&gt;&gt;|)"><a href="#val-(&gt;&gt;|)" class="anchor"></a><code><span class="keyword">val </span>(&gt;&gt;|) : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>) <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>f &gt;&gt;| fn</code> is <code>map fn f</code>.</p></dd></dl><dl><dt class="spec value" id="val-(&gt;&gt;&amp;)"><a href="#val-(&gt;&gt;&amp;)" class="anchor"></a><code><span class="keyword">val </span>(&gt;&gt;&amp;) : (<span class="type-var">'a</span>, <span class="type-var">'c</span>) <a href="index.html#type-result">result</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span> <span>&#45;&gt;</span> (<span class="type-var">'b</span>, <span class="type-var">'c</span>) <a href="index.html#type-result">result</a>) <span>&#45;&gt;</span> (<span class="type-var">'b</span>, <span class="type-var">'c</span>) <a href="index.html#type-result">result</a></code></dt><dd><p><code>f &gt;&gt;&amp; fn</code> is <code>rbind f fn</code>.</p></dd></dl><dl><dt class="spec module" id="module-Op"><a href="#module-Op" class="anchor"></a><code><span class="keyword">module </span><a href="Op/index.html">Op</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Infix operators.</p></dd></dl></section><section><header><h2 id="runtime"><a href="#runtime" class="anchor"></a>Runtime system</h2></header><dl><dt class="spec module" id="module-Runtime"><a href="#module-Runtime" class="anchor"></a><code><span class="keyword">module </span><a href="Runtime/index.html">Runtime</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Runtime system configuration and interaction.</p></dd></dl></section><section><header><h2 id="basics"><a href="#basics" class="anchor"></a>Basics</h2><p>A future is a place-holder for a value that may become determined at an arbitrary point in the future. Futures can be combined together to define new futures that will determine whenever the underlying futures do. For example, below <code>revolt</code> determines once <code>time_to_revolt</code> does.</p><pre><code class="ml">let time_to_revolt = Fut.tick 1.871 in
let revolt =
  Fut.bind time_to_revolt
    (fun () -&gt; Fut.apply Printf.printf &quot;Revolt!&quot;)

let () = ignore (Fut.await revolt)</code></pre><p>A future can be in three different states described by the type <a href="index.html#type-state"><code>state</code></a> and returned by the (non-blocking) function <a href="index.html#type-state"><code>Fut.state</code></a>. It is:</p><ul><li><code>`Undet</code>, if the future is <code>`Undet</code>ermined and may still determine a value at some point in the future.</li><li><code>`Det v</code>, if the future <code>`Det</code>ermined the value <code>v</code>.</li><li><code>`Never</code>, if the future will never determine a value.</li></ul><p>If the state of a future <code>f</code> is <code>`Det</code> or <code>`Never</code> we say that the future is <em>set</em>.</p><p>The module <span class="xref-unresolved" title="unresolved reference to &quot;Fut.Ops&quot;"><a href="index.html"><code>Fut</code></a>.Ops</span> defines a few infix operators to make the code more readable. For example the <span class="xref-unresolved" title="unresolved reference to &quot;Ops.(&gt;&gt;=)&quot;"><code>Ops</code>.(&gt;&gt;=)</span> operator can be used for <a href="index.html#val-bind"><code>bind</code></a>. This makes it easier to sequence binds:</p><pre><code class="ml">open Fut.Ops;;

let time_to_revolt d = Fut.tick d in
let revolt =
  time_to_revolt 1.871              &gt;&gt;= fun () -&gt;
  Fut.apply Printf.printf &quot;Revolt!&quot; &gt;&gt;= fun () -&gt;
  time_to_revolt 0.72               &gt;&gt;= fun () -&gt;
  Fut.apply Printf.printf &quot;Again!&quot;

let () = ignore (Fut.await revolt)</code></pre></header><section><header><h3 id="semantics"><a href="#semantics" class="anchor"></a>Semantics</h3><p>The semantic function []<code>: 'a Fut.t -&gt; time -&gt; 'a Fut.state</code> gives meaning to a future <code>f</code> by mapping it to a function [<code>f</code>] that give its <a href="index.html#type-state"><span>state</span></a> at any point in time (after its creation). We write [<code>f</code>]<sub>t</sub> the evaluation of this <em>semantic</em> function at time <code>t</code>.</p><p>Remember that once a future is set it never changes again. This is captured by the following axiom that holds for any future <code>f</code> at any time <code>t</code>:</p><ul><li>If [<code>f</code>]<sub>t</sub> <code>&lt;&gt; `Undet</code> then for all <code>t' &gt; t</code> we have [<code>f</code>]<sub>t'</sub> = [<code>f</code>]<sub>t</sub></li></ul><p>The semantics of combinators are given in terms of [] by describing only the instants at which the resulting future is set. In the remaining undescribed instants the state of the future is implicitly taken to be unset, i.e. <code>`Undet</code>etermined. The descriptions also implicitly quantify universally over the free variable <code>t</code>.</p></header></section><section><header><h3 id="neverdet"><a href="#neverdet" class="anchor"></a>Never determined futures</h3><p><code>Fut</code> makes a distinction between a future that is undetermined and <em>may</em> remain so forever and a future that is <em>known</em> to be never determined (e.g. <a href="index.html#val-never"><code>Fut.never</code></a>), a future with state <code>`Never</code>. Futures depending on a future value that <code>`Never</code> determines also never determine. This means that most combinator whenever they are given a future that never determines return a future that never determines.</p><p>One way to get never determined futures is by using the future exclusive choice combinator <a href="index.html#val-first"><code>first</code></a> between two futures. The first one that determines makes the other become never determined. Note that for future created with <a href="index.html#val-apply"><code>Fut.apply</code></a>, the application (and its effects) may (or not) still be executed, but it's value is discarded.</p></header></section><section><header><h3 id="exceptions"><a href="#exceptions" class="anchor"></a>Exceptions</h3><p>If the computation to determine a future's value raises an exception it is set to <code>`Never</code> determine and the exception is logged by the runtime system to the handler provided by <a href="Runtime/index.html#val-set_exn_trap"><code>Runtime.set_exn_trap</code></a>. The default handler is backend dependent but usually logs the exception on <code>stderr</code>.</p><p>There is a single exception to this behaviour. If the exception <a href="index.html#exception-Never"><code>Never</code></a> is raised by an application given to <a href="index.html#val-apply"><code>Fut.apply</code></a>, the corresponding future never determines but the exception is not logged.</p><p>Do not rely on the fact that exceptions are automatically trapped by the system, this mechanism is in place so that <em>unexpected</em> exceptions do not kill the runtime system for long running programs. If you deal with a library that is designed around exceptions you should catch and handle them, if only to use <a href="index.html#val-never"><code>Fut.never</code></a> if you wish so. For example if looking up a data structure may return <code>Not_found</code> don't do that:</p><pre><code class="ml">let find k m = Fut.ret (M.find k m)</code></pre><p>This may significantly obfuscate what's happening (and won't be efficient). Explicitely handle the exception:</p><pre><code class="ml">let find k m = try Fut.ret (M.find k m) with Not_found -&gt; Fut.never ()</code></pre><p>In this example, using option types may anway be clearer:</p><pre><code class="ml">let find k m = Fut.ret (try Some (M.find k m) with Not_found -&gt; None)</code></pre></header></section><section><header><h3 id="futqueues"><a href="#futqueues" class="anchor"></a>Future queues</h3><p>Future queues determine long-running or blocking function applications with a set of concurrent workers usually implemented as system threads.</p><p>A future queue determines the applications submitted to it through the <a href="index.html#val-apply"><code>Fut.apply</code></a> function <em>sequentially</em> and in FIFO order. This property also makes them a mutual exclusion synchronization primitive. Applications submitted in two different queues are determined concurrently. In the following examples <code>f1</code> and <code>f2</code> will be set sequentially, while <code>f3</code> will do so concurrently to those.</p><pre><code class="ml">let q1 = Fut.Queue.create ()
let q2 = Fut.Queue.create ()
let f1 = Fut.apply ~queue:q1 Printf.printf &quot;first f1&quot;
let f2 = Fut.apply ~queue:q1 Printf.printf &quot;then f2&quot;
let f3 = Fut.apply ~queue:q2 Printf.printf &quot;f3 at anytime&quot;</code></pre><p>Note that the function applications are executed on another threads and as such must respect Fut's <a href="index.html#futandthreads"><span>thread safety rule</span></a>.</p><p>There is a special queue the <a href="Queue/index.html#val-concurrent"><span>concurrent</span></a> queue which is the default argument of <a href="index.html#val-apply"><code>apply</code></a>. This queue has no FIFO ordering constraint: anything submitted to it is determined concurrently. It is useful to just apply a long-running function to avoid starving the runtime system:</p><pre><code class="ml">let long_work = Fut.apply long_running_function ()</code></pre><p>It is also possible to provide a reference cell <code>abort</code> to <a href="index.html#val-apply"><code>apply</code></a>. This reference cell will be set <code>true</code> by the runtime system if the future is aborted by the runtime system. This can be used to stop the application. For example:</p><pre><code class="ml">let long_running_work abort =
  while (not !abort || !finished) do ... done

let abort = ref false
let long_work = Fut.apply ~abort long_running_work abort
let _ = Fut.abort long_work (* will set abort to [true] *)</code></pre><p>Note that the runtime system never reads abort it just sets it to <code>true</code> when appropriate.</p></header></section><section><header><h3 id="promises"><a href="#promises" class="anchor"></a>Promises</h3><p>Promises are used to expose the functionality of third-party libraries as futures. A call to <a href="index.html#type-promise"><code>promise</code></a> returns a promise that has an associated future (returned by <a href="index.html#val-future"><code>future</code></a>). The promise can be <a href="index.html#type-set"><code>set</code></a>, which sets the associated future. See <a href="index.html#promiseex"><span>this example</span></a> to see how promises can be used to expose callback based asynchronous interfaces as futures.</p><p>Note that <a href="index.html#type-set"><code>Fut.set</code></a> must be called on <code>Fut</code>'s thread. If one needs to set futures from another thread, a <a href="Runtime/index.html#val-action"><code>Runtime.action</code></a> can be used. See the next section.</p></header></section><section><header><h3 id="futandthreads"><a href="#futandthreads" class="anchor"></a>Fut and system threads</h3><p>Except for applications determined on <a href="index.html#queues"><span>future queues</span></a>, <code>Fut</code> has a single-threaded cooperative concurency model. This means that at any time there's only one future that is trying to determine its value on <code>Fut</code>'s thread.</p><p><b>Thread-safety rule.</b> The thread-safety rule of <code>Fut</code> is simple. A single thread must run <code>Fut</code>'s runtime system via a call to <a href="index.html#val-await"><code>await</code></a> and <b>no other</b> thread is allowed to use <b>any</b> function of <code>Fut</code> except, <a href="index.html#type-promise"><code>promise</code></a>, <a href="index.html#val-future"><code>future</code></a>, <a href="index.html#type-state"><code>state</code></a> and <a href="Runtime/index.html#val-action"><code>Runtime.action</code></a>.</p><p>In particular the thread-safety rule <b>does apply</b> to function applications performed with <a href="index.html#val-app"><code>Fut.app</code></a> as they are performed on other threads.</p><p><code>Fut</code> tries to abstract away all your thread needs via the concept of <a href="index.html#queues"><span>future queues</span></a>. Sometimes this is however infeasible for example because a library prevents you from sharing structures across threads and future queues provides you no support to control on which thread an application will happen. In that case you can still create your own system thread and interact with <code>Fut</code> by using <a href="index.html#type-promise"><code>promise</code></a> and a <a href="Runtime/index.html#val-action"><code>Runtime.action</code></a> to <a href="index.html#type-set"><code>Fut.set</code></a> it once it determined. See <a href="index.html#threadex"><span>this example</span></a>.</p><p>Before any call to <a href="index.html#val-apply"><code>apply</code></a> or <span class="xref-unresolved" title="unresolved reference to &quot;Runtime.set_thread_count&quot;"><a href="index.html#module-Runtime"><code>Runtime</code></a>.set_thread_count</span> the program is single threaded.</p></header></section><section><header><h3 id="futandprocesses"><a href="#futandprocesses" class="anchor"></a>Fut and system processes</h3><p>In general <code>Unix.fork</code> does not cope well with threads. The best approach is thus to fork all the processes you need before the first call to <a href="index.html#val-await"><code>await</code></a>.</p></header></section></section><section><header><h2 id="examples"><a href="#examples" class="anchor"></a>Examples</h2></header><section><header><h3 id="backend"><a href="#backend" class="anchor"></a>Backends</h3><p>TODO explain how to link against a backend.</p></header></section><section><header><h3 id="the-universal-client"><a href="#the-universal-client" class="anchor"></a>The universal client</h3></header></section><section><header><h3 id="the-echo-server"><a href="#the-echo-server" class="anchor"></a>The echo server</h3></header></section><section><header><h3 id="promiseex"><a href="#promiseex" class="anchor"></a>Integration with asynchronous functions</h3><p>Suppose we have a function to perform asynchronous reads on a regular file whose signature is as follows:</p><pre><code class="ml">type read = [ `Error | `Read of int ]
val Aio.read : Unix.file_descr -&gt; string -&gt; int -&gt; int -&gt; (read -&gt; unit) -&gt; unit</code></pre><p>where <code>read fd s j l k</code> tries to read <code>l</code> bytes from <code>fd</code> to store them in <code>s</code> starting at <code>j</code> calling <code>k</code> when it has completed.</p><p>Exposing this function call as a future is very simple. Create a promise and set it in the callback <code>k</code>:</p><pre><code class="ml">val read : Unix.file_descr -&gt; string -&gt; int -&gt; int -&gt; read Fut.t
let read fd s j l =
  let p = Fut.promise () in
  let k r = Fut.set p (`Det r) in
  Aio.read fd s j l k;
  Fut.future p</code></pre><p>It is however important to make sure that the thread that calls the continuation <code>k</code> is <code>Fut</code>'s thread. If this is not the case the callback <code>k</code> can be replaced by:</p><pre><code class="ml">let k r = Fut.Runtime.action (fun () -&gt; Fut.set p (`Det r))</code></pre></header></section><section><header><h3 id="threadex"><a href="#threadex" class="anchor"></a>Integration with threads</h3><p>If for some reason you cannot use <a href="index.html#queues"><span>future queues</span></a> and need to run a service in its own thread, the code below shows how to interact with <code>Fut</code> and respect its <a href="index.html#futandthreads"><span>thread-safety</span></a> rule.</p><pre><code class="ml">module Service : sig
  type request
  type response
  val request : request -&gt; response Fut.t
  val run : unit -&gt; unit
end = struct
  type request
  type response

  let m = Mutex.create ()
  let not_empty = Condition.create ()
  let requests = Queue.create ()

  let request req = (* executed by [Fut]'s thread. *)
    let abort' = ref false in
    let abort () = abort' := true in
    let promise = Fut.promise ~abort () in
    Mutex.lock m;
    Queue.add (req, promise, abort') requests;
    Condition.signal not_empty;
    Mutex.unlock m;
    Fut.future promise

  let rec serve () = (* executed by the service's thread. *)
    Mutex.lock m;
    while Queue.is_empty requests do Condition.wait not_empty m done;
    let (req, promise, abort) = Queue.pop requests in
    Mutex.unlock m;
    let resp = do_service req abort in
    let set () = Fut.set promise (`Det resp) in
    if not !abort then Fut.Runtime.action set;
    serve ()

    let run () = ignore (Thread.create serve ())
end</code></pre></header></section><section><header><h3 id="multip"><a href="#multip" class="anchor"></a>Integration with multiprocessing</h3><p>You may want to use futures to delegate work to other processes.</p></header></section><section><header><h3 id="signals"><a href="#signals" class="anchor"></a>Integration with signals</h3></header></section></section></div></body></html>