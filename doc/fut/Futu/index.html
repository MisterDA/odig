<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Futu (fut.Futu)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../index.html">fut</a> &#x00BB; Futu</nav><h1>Module <code>Futu</code></h1><p>Unix system calls as futures.</p><p>This module wraps <code>Unix</code> system calls that support asynchronous operation and a few other as futures abstracting away the underylying IO multiplexing mechanism.</p><p>For other blocking <code>Unix</code> system calls you can invoke them with <span class="xref-unresolved" title="unresolved reference to &quot;Unix.apply&quot;"><code>Unix</code>.apply</span> which uses <span class="xref-unresolved" title="unresolved reference to &quot;queues&quot;"><span>future queues</span></span> to perform the call, catches unix errors and automatically handles the <code>EINTR</code> error by retrying the call.</p><p><b>Important.</b> File descriptors created outside this module must be set to non-blocking mode with <span class="xref-unresolved" title="unresolved reference to &quot;Unix.set_nonblock&quot;"><code>Unix</code>.set_nonblock</span> before they are used with functions of this module.</p><p><em>v0.0.0-79-gece0e52 — <a href="UNDEFINED">homepage</a></em></p><nav class="toc"><ul><li><a href="#unix-results-and-errors">Unix results and errors</a></li><li><a href="#signals">Signals</a></li><li><a href="#file-descriptors">File descriptors</a></li><li><a href="#sockets">Sockets</a></li><li><a href="#io">IO</a></li></ul></nav></header><section><header><h2 id="unix-results-and-errors"><a href="#unix-results-and-errors" class="anchor"></a>Unix results and errors</h2></header><dl><dt class="spec type" id="type-error"><a href="#type-error" class="anchor"></a><code><span class="keyword">type </span>error</code><span class="keyword"> = </span><code>[ </code><table class="variant"><tr id="type-error.Unix" class="anchored"><td class="def constructor"><a href="#type-error.Unix" class="anchor"></a><code><span class="keyword">| </span></code><code>`Unix<span class="keyword"> of </span>Unix.error<span class="keyword"> * </span>string<span class="keyword"> * </span>string</code></td></tr></table><code> ]</code></dt><dd><p>The type for Unix errors as reported by <span class="xref-unresolved" title="unresolved reference to &quot;Unix.Unix_error&quot;"><code>Unix</code>.Unix_error</span> exceptions.</p></dd></dl><dl><dt class="spec value" id="val-apply"><a href="#val-apply" class="anchor"></a><code><span class="keyword">val </span>apply : ?&#8288;queue:Fut.queue <span>&#45;&gt;</span> (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> (<span class="type-var">'b</span>, [&gt; <a href="index.html#type-error">error</a> ]) Fut.result</code></dt><dd><p><code>apply queue f v</code> applies <code>f v</code> on <code>queue</code> and catches <span class="xref-unresolved" title="unresolved reference to &quot;Unix.Unix_error&quot;"><code>Unix</code>.Unix_error</span>. <code>EINTR</code> is handled by retrying the call.</p></dd></dl><dl><dt class="spec value" id="val-call"><a href="#val-call" class="anchor"></a><code><span class="keyword">val </span>call : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> (<span class="type-var">'b</span>, [&gt; <a href="index.html#type-error">error</a> ]) Fut.result</code></dt><dd><p><code>call f v</code> applies <code>f v</code> synchronously and catches <span class="xref-unresolved" title="unresolved reference to &quot;Unix.Unix_error&quot;"><code>Unix</code>.Unix_error</span>. <code>EINTR</code> is handled by retrying the call.</p></dd></dl></section><section><header><h2 id="signals"><a href="#signals" class="anchor"></a>Signals</h2></header><dl><dt class="spec value" id="val-signal"><a href="#val-signal" class="anchor"></a><code><span class="keyword">val </span>signal : int <span>&#45;&gt;</span> int Fut.t</code></dt><dd><p><code>signal s</code> determines with <code>s</code> the next time the signal <code>s</code> is received by the program.</p><p><b>Warning.</b> The first time <code>signal s</code> is called for a given <code>s</code> <code>Fut</code> overwrites any handler that could be already installed by <span class="xref-unresolved" title="unresolved reference to &quot;Sys.signal&quot;"><code>Sys</code>.signal</span> for that signal. Conversly if any other part of the program overwrites the handler installed by <code>Fut</code> for <code>s</code> don't expect the futures returned by <code>signal s</code> to ever determine.</p></dd></dl></section><section><header><h2 id="file-descriptors"><a href="#file-descriptors" class="anchor"></a>File descriptors</h2></header><dl><dt class="spec value" id="val-nonblock_stdio"><a href="#val-nonblock_stdio" class="anchor"></a><code><span class="keyword">val </span>nonblock_stdio : unit <span>&#45;&gt;</span> (unit, [&gt; <a href="index.html#type-error">error</a> ]) Fut.result</code></dt><dd><p><code>nonblock_stdio ()</code> sets <span class="xref-unresolved" title="unresolved reference to &quot;Unix.stdin&quot;"><code>Unix</code>.stdin</span>, <span class="xref-unresolved" title="unresolved reference to &quot;Unix.stdout&quot;"><code>Unix</code>.stdout</span>, <span class="xref-unresolved" title="unresolved reference to &quot;Unix.stderr&quot;"><code>Unix</code>.stderr</span> to non-blocking mode.</p></dd></dl><dl><dt class="spec value" id="val-close"><a href="#val-close" class="anchor"></a><code><span class="keyword">val </span>close : Unix.file_descr <span>&#45;&gt;</span> (unit, [&gt; <a href="index.html#type-error">error</a> ]) Fut.result</code></dt><dd><p><code>close fd</code> is like <code>Unix.close fd</code>, except it handles <code>EINTR</code> and sets any pending read or write on <code>fd</code> to never determine.</p></dd></dl><dl><dt class="spec value" id="val-dup2"><a href="#val-dup2" class="anchor"></a><code><span class="keyword">val </span>dup2 : Unix.file_descr <span>&#45;&gt;</span> Unix.file_descr <span>&#45;&gt;</span> (unit, [&gt; <a href="index.html#type-error">error</a> ]) Fut.result</code></dt><dd><p><code>dup2 fd1 fd2</code> is like <code>Unix.dup2 fd1 fd2</code>, except it handles <code>EINTR</code> and sets any pending read or write on <code>fd2</code> to never determine.</p></dd></dl><dl><dt class="spec value" id="val-pipe"><a href="#val-pipe" class="anchor"></a><code><span class="keyword">val </span>pipe : unit <span>&#45;&gt;</span> (Unix.file_descr<span class="keyword"> * </span>Unix.file_descr, [&gt; <a href="index.html#type-error">error</a> ]) Fut.result</code></dt><dd><p><code>pipe ()</code> is like <code>Unix.pipe ()</code>, except is sets both file descriptors to non-blocking mode with <code>Unix.set_nonblock</code>.</p></dd></dl></section><section><header><h2 id="sockets"><a href="#sockets" class="anchor"></a>Sockets</h2></header><dl><dt class="spec value" id="val-socket"><a href="#val-socket" class="anchor"></a><code><span class="keyword">val </span>socket : Unix.socket_domain <span>&#45;&gt;</span> Unix.socket_type <span>&#45;&gt;</span> int <span>&#45;&gt;</span> (Unix.file_descr, [&gt; <a href="index.html#type-error">error</a> ]) Fut.result</code></dt><dd><p><code>socket d t p</code> is like <code>Unix.socket d t p</code> except it sets the resulting file descriptor to non-blocking mode with <code>Unix.set_nonblock</code>.</p></dd></dl><dl><dt class="spec value" id="val-socketpair"><a href="#val-socketpair" class="anchor"></a><code><span class="keyword">val </span>socketpair : Unix.socket_domain <span>&#45;&gt;</span> Unix.socket_type <span>&#45;&gt;</span> int <span>&#45;&gt;</span> (Unix.file_descr<span class="keyword"> * </span>Unix.file_descr, [&gt; <a href="index.html#type-error">error</a> ]) Fut.result</code></dt><dd><p><code>socketpair d t p</code> is like <code>Unix.socketpair d t p</code> except it sets the resulting file descriptors to non-blocking mode with <code>Unix.set_nonblock</code>.</p></dd></dl><dl><dt class="spec value" id="val-accept"><a href="#val-accept" class="anchor"></a><code><span class="keyword">val </span>accept : Unix.file_descr <span>&#45;&gt;</span> Unix.file_descr<span class="keyword"> * </span>Unix.sockaddr</code></dt><dd><p><code>accept fd</code> is like <code>Unix.accept fd</code> except it handles <code>EINTR</code> and <code>EWOULDBLOCK</code> and sets the resulting file descriptor to non-blocking mode with <code>Unix.set_nonblock</code>.</p></dd></dl><dl><dt class="spec value" id="val-connect"><a href="#val-connect" class="anchor"></a><code><span class="keyword">val </span>connect : Unix.file_descr <span>&#45;&gt;</span> Unix.sockaddr <span>&#45;&gt;</span> (unit, [&gt; <a href="index.html#type-error">error</a> ]) Fut.result</code></dt><dd><p><code>connect</code> is like <span class="xref-unresolved" title="unresolved reference to &quot;Unix.connect&quot;"><code>Unix</code>.connect</span> except it handles <code>EINTR</code> and <code>EINPROGRESS</code>.</p></dd></dl><dl><dt class="spec value" id="val-bind"><a href="#val-bind" class="anchor"></a><code><span class="keyword">val </span>bind : Unix.file_descr <span>&#45;&gt;</span> Unix.sockaddr <span>&#45;&gt;</span> (unit, [&gt; <a href="index.html#type-error">error</a> ]) Fut.result</code></dt></dl></section><section><header><h2 id="io"><a href="#io" class="anchor"></a>IO</h2><p><b>Important.</b> If you use these functions on a file descriptor <code>fd</code> use <a href="index.html#val-close"><code>close</code></a> and <a href="index.html#val-dup2"><code>dup2</code></a> instead of the corresponding functions of the <code>Unix</code> module. This will prevent any <code>EBADF</code> errors if there are undetermined futures concerning <code>fd</code>.</p></header><dl><dt class="spec value" id="val-read"><a href="#val-read" class="anchor"></a><code><span class="keyword">val </span>read : Unix.file_descr <span>&#45;&gt;</span> Bytes.t <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> (int, [&gt; <a href="index.html#type-error">error</a> ]) Fut.result</code></dt><dd><p><code>read fd s j l</code> is like <code>Unix.read fd s j l</code> except it handles <code>EINTR</code>, <code>EAGAIN</code> and <code>EWOULDBLOCK</code>. It is set to never determine if <code>fd</code> is closed with <a href="index.html#val-close"><code>close</code></a> or <a href="index.html#val-dup2"><code>dup2</code></a>.</p></dd></dl><dl><dt class="spec value" id="val-write"><a href="#val-write" class="anchor"></a><code><span class="keyword">val </span>write : Unix.file_descr <span>&#45;&gt;</span> Bytes.t <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> (int, [&gt; <a href="index.html#type-error">error</a> ]) Fut.result</code></dt><dd><p><code>write fd s j l</code> is like <code>Unix.single_write fd s j l</code> except it handles <code>EINTR</code>, <code>EAGAIN</code> and <code>EWOULDBLOCK</code>. It is set to never determine if <code>fd</code> is closed with <a href="index.html#val-close"><code>close</code></a> or <a href="index.html#val-dup2"><code>dup2</code></a>.</p></dd></dl></section></div></body></html>