<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Restart (gen.GenLabels.Restart)</title><link rel="stylesheet" href="../../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../../index.html">gen</a> &#x00BB; <a href="../index.html">GenLabels</a> &#x00BB; Restart</nav><h1>Module <code>GenLabels.Restart</code></h1></header><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> 'a t</code><code> = unit <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="../index.html#type-gen">gen</a></code></dt><dt class="spec type" id="type-restartable"><a href="#type-restartable" class="anchor"></a><code><span class="keyword">type</span> 'a restartable</code><code> = <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt></dl><div><div class="spec include"><div class="doc"><details open="open"><summary><span class="def"><code><span class="keyword">include</span> <a href="../index.html#module-type-S">S</a> <span class="keyword">with</span> <span class="keyword">type</span> 'a <a href="../module-type-S/index.html#type-t">t</a> := <span class="type-var">'a</span> <a href="index.html#type-restartable">restartable</a></code></span></summary><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> 'a t</code></dt></dl><dl><dt class="spec value" id="val-empty"><a href="#val-empty" class="anchor"></a><code><span class="keyword">val</span> empty : <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Empty generator, with no elements</p></dd></dl><dl><dt class="spec value" id="val-singleton"><a href="#val-singleton" class="anchor"></a><code><span class="keyword">val</span> singleton : <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p>One-element generator</p></dd></dl><dl><dt class="spec value" id="val-return"><a href="#val-return" class="anchor"></a><code><span class="keyword">val</span> return : <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Alias to <a href="index.html#val-singleton"><code>singleton</code></a></p><dl><dt>since</dt><dd>0.3</dd></dl></dd></dl><dl><dt class="spec value" id="val-repeat"><a href="#val-repeat" class="anchor"></a><code><span class="keyword">val</span> repeat : <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Repeat same element endlessly</p></dd></dl><dl><dt class="spec value" id="val-iterate"><a href="#val-iterate" class="anchor"></a><code><span class="keyword">val</span> iterate : <span class="type-var">'a</span> <span>&#45;&gt;</span> (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>iterate x f</code> is <code>[x; f x; f (f x); f (f (f x)); ...]</code></p></dd></dl><dl><dt class="spec value" id="val-unfold"><a href="#val-unfold" class="anchor"></a><code><span class="keyword">val</span> unfold : (<span class="type-var">'b</span> <span>&#45;&gt;</span> (<span class="type-var">'a</span> * <span class="type-var">'b</span>) option) <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Dual of <a href="index.html#val-fold"><code>fold</code></a>, with a deconstructing operation. It keeps on unfolding the <code>'b</code> value into a new <code>'b</code>, and a <code>'a</code> which is yielded, until <code>None</code> is returned.</p></dd></dl><dl><dt class="spec value" id="val-init"><a href="#val-init" class="anchor"></a><code><span class="keyword">val</span> init : ?&#8288;limit:int <span>&#45;&gt;</span> (int <span>&#45;&gt;</span> <span class="type-var">'a</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Calls the function, starting from 0, on increasing indices. If <code>limit</code> is provided and is a positive int, iteration will stop at the limit (excluded). For instance <code>init ~limit:4 id</code> will yield 0, 1, 2, and 3.</p></dd></dl><section><header><h3 id="basic-combinators"><a href="#basic-combinators" class="anchor"></a>Basic combinators</h3><p><b>Note</b>: those combinators, applied to generators (not restartable generators) <i>consume</i> their argument. Sometimes they consume it lazily, sometimes eagerly, but in any case once <code>f gen</code> has been called (with <code>f</code> a combinator), <code>gen</code> shouldn't be used anymore.</p></header><dl><dt class="spec value" id="val-is_empty"><a href="#val-is_empty" class="anchor"></a><code><span class="keyword">val</span> is_empty : <span class="type-var">_</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p>Check whether the gen is empty. Pops an element, if any</p></dd></dl><dl><dt class="spec value" id="val-fold"><a href="#val-fold" class="anchor"></a><code><span class="keyword">val</span> fold : f:(<span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>) <span>&#45;&gt;</span> init:<span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'b</span></code></dt><dd><p>Fold on the generator, tail-recursively. Consumes the generator.</p></dd></dl><dl><dt class="spec value" id="val-reduce"><a href="#val-reduce" class="anchor"></a><code><span class="keyword">val</span> reduce : f:(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p>Fold on non-empty sequences. Consumes the generator.</p><dl><dt>raises Invalid_argument</dt><dd><p>on an empty gen</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-scan"><a href="#val-scan" class="anchor"></a><code><span class="keyword">val</span> scan : f:(<span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>) <span>&#45;&gt;</span> init:<span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Like <a href="index.html#val-fold"><code>fold</code></a>, but keeping successive values of the accumulator. Consumes the generator.</p></dd></dl><dl><dt class="spec value" id="val-unfold_scan"><a href="#val-unfold_scan" class="anchor"></a><code><span class="keyword">val</span> unfold_scan : (<span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> * <span class="type-var">'c</span>) <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'c</span> <a href="index.html#type-t">t</a></code></dt><dd><p>A mix of <a href="index.html#val-unfold"><code>unfold</code></a> and <a href="index.html#val-scan"><code>scan</code></a>. The current state is combined with the current element to produce a new state, and an output value of type 'c.</p><dl><dt>since</dt><dd>0.2.2</dd></dl></dd></dl><dl><dt class="spec value" id="val-iter"><a href="#val-iter" class="anchor"></a><code><span class="keyword">val</span> iter : f:(<span class="type-var">'a</span> <span>&#45;&gt;</span> unit) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Iterate on the gen, consumes it.</p></dd></dl><dl><dt class="spec value" id="val-iteri"><a href="#val-iteri" class="anchor"></a><code><span class="keyword">val</span> iteri : f:(int <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> unit) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Iterate on elements with their index in the gen, from 0, consuming it.</p></dd></dl><dl><dt class="spec value" id="val-length"><a href="#val-length" class="anchor"></a><code><span class="keyword">val</span> length : <span class="type-var">_</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int</code></dt><dd><p>Length of an gen (linear time), consuming it</p></dd></dl><dl><dt class="spec value" id="val-map"><a href="#val-map" class="anchor"></a><code><span class="keyword">val</span> map : f:(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Lazy map. No iteration is performed now, the function will be called when the result is traversed.</p></dd></dl><dl><dt class="spec value" id="val-mapi"><a href="#val-mapi" class="anchor"></a><code><span class="keyword">val</span> mapi : f:(int <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Lazy map with indexing starting from 0. No iteration is performed now, the function will be called when the result is traversed.</p><dl><dt>since</dt><dd>0.5</dd></dl></dd></dl><dl><dt class="spec value" id="val-fold_map"><a href="#val-fold_map" class="anchor"></a><code><span class="keyword">val</span> fold_map : f:(<span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>) <span>&#45;&gt;</span> init:<span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Lazy fold and map. No iteration is performed now, the function will be called when the result is traversed. The result is an iterator over the successive states of the fold.</p><dl><dt>since</dt><dd>0.2.4</dd></dl></dd></dl><dl><dt class="spec value" id="val-append"><a href="#val-append" class="anchor"></a><code><span class="keyword">val</span> append : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Append the two gens; the result contains the elements of the first, then the elements of the second gen.</p></dd></dl><dl><dt class="spec value" id="val-flatten"><a href="#val-flatten" class="anchor"></a><code><span class="keyword">val</span> flatten : <span class="type-var">'a</span> <a href="../../GenLabels_intf/index.html#type-gen">GenLabels_intf.gen</a> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Flatten the generator of generators</p></dd></dl><dl><dt class="spec value" id="val-flat_map"><a href="#val-flat_map" class="anchor"></a><code><span class="keyword">val</span> flat_map : f:(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="../../GenLabels_intf/index.html#type-gen">GenLabels_intf.gen</a>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Monadic bind; each element is transformed to a sub-gen which is then iterated on, before the next element is processed, and so on.</p></dd></dl><dl><dt class="spec value" id="val-mem"><a href="#val-mem" class="anchor"></a><code><span class="keyword">val</span> mem : ?&#8288;eq:(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> x:<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p>Is the given element, member of the gen?</p></dd></dl><dl><dt class="spec value" id="val-take"><a href="#val-take" class="anchor"></a><code><span class="keyword">val</span> take : int <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Take at most n elements</p></dd></dl><dl><dt class="spec value" id="val-drop"><a href="#val-drop" class="anchor"></a><code><span class="keyword">val</span> drop : int <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Drop n elements</p></dd></dl><dl><dt class="spec value" id="val-nth"><a href="#val-nth" class="anchor"></a><code><span class="keyword">val</span> nth : int <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p>n-th element, or Not_found</p><dl><dt>raises Not_found</dt><dd><p>if the generator contains less than <code>n</code> arguments</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-take_nth"><a href="#val-take_nth" class="anchor"></a><code><span class="keyword">val</span> take_nth : int <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>take_nth n g</code> returns every element of <code>g</code> whose index is a multiple of <code>n</code>. For instance <code>take_nth 2 (1--10) |&gt; to_list</code> will return <code>1;3;5;7;9</code></p></dd></dl><dl><dt class="spec value" id="val-filter"><a href="#val-filter" class="anchor"></a><code><span class="keyword">val</span> filter : f:(<span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Filter out elements that do not satisfy the predicate.</p></dd></dl><dl><dt class="spec value" id="val-take_while"><a href="#val-take_while" class="anchor"></a><code><span class="keyword">val</span> take_while : f:(<span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Take elements while they satisfy the predicate. The initial generator itself is not to be used anymore after this.</p></dd></dl><dl><dt class="spec value" id="val-fold_while"><a href="#val-fold_while" class="anchor"></a><code><span class="keyword">val</span> fold_while : f:(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> * [ `Stop | `Continue ]) <span>&#45;&gt;</span> init:<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p>Fold elements until (<code>'a, `Stop</code>) is indicated by the accumulator.</p><dl><dt>since</dt><dd>0.2.4</dd></dl></dd></dl><dl><dt class="spec value" id="val-drop_while"><a href="#val-drop_while" class="anchor"></a><code><span class="keyword">val</span> drop_while : f:(<span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Drop elements while they satisfy the predicate. The initial generator itself should not be used anymore, only the result of <code>drop_while</code>.</p></dd></dl><dl><dt class="spec value" id="val-filter_map"><a href="#val-filter_map" class="anchor"></a><code><span class="keyword">val</span> filter_map : f:(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> option) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Maps some elements to 'b, drop the other ones</p></dd></dl><dl><dt class="spec value" id="val-zip_index"><a href="#val-zip_index" class="anchor"></a><code><span class="keyword">val</span> zip_index : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (int * <span class="type-var">'a</span>) <a href="index.html#type-t">t</a></code></dt><dd><p>Zip elements with their index in the gen</p></dd></dl><dl><dt class="spec value" id="val-unzip"><a href="#val-unzip" class="anchor"></a><code><span class="keyword">val</span> unzip : (<span class="type-var">'a</span> * <span class="type-var">'b</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> * <span class="type-var">'b</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Unzip into two sequences, splitting each pair</p></dd></dl><dl><dt class="spec value" id="val-partition"><a href="#val-partition" class="anchor"></a><code><span class="keyword">val</span> partition : f:(<span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> * <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>partition p l</code> returns the elements that satisfy <code>p</code>, and the elements that do not satisfy <code>p</code></p></dd></dl><dl><dt class="spec value" id="val-for_all"><a href="#val-for_all" class="anchor"></a><code><span class="keyword">val</span> for_all : f:(<span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p>Is the predicate true for all elements?</p></dd></dl><dl><dt class="spec value" id="val-exists"><a href="#val-exists" class="anchor"></a><code><span class="keyword">val</span> exists : f:(<span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p>Is the predicate true for at least one element?</p></dd></dl><dl><dt class="spec value" id="val-min"><a href="#val-min" class="anchor"></a><code><span class="keyword">val</span> min : ?&#8288;lt:(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p>Minimum element, according to the given comparison function.</p><dl><dt>raises Invalid_argument</dt><dd><p>if the generator is empty</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-max"><a href="#val-max" class="anchor"></a><code><span class="keyword">val</span> max : ?&#8288;lt:(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p>Maximum element, see <a href="index.html#val-min"><code>min</code></a></p><dl><dt>raises Invalid_argument</dt><dd><p>if the generator is empty</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-eq"><a href="#val-eq" class="anchor"></a><code><span class="keyword">val</span> eq : ?&#8288;eq:(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p>Equality of generators.</p></dd></dl><dl><dt class="spec value" id="val-lexico"><a href="#val-lexico" class="anchor"></a><code><span class="keyword">val</span> lexico : ?&#8288;cmp:(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> int) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int</code></dt><dd><p>Lexicographic comparison of generators. If a generator is a prefix of the other one, it is considered smaller.</p></dd></dl><dl><dt class="spec value" id="val-compare"><a href="#val-compare" class="anchor"></a><code><span class="keyword">val</span> compare : ?&#8288;cmp:(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> int) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int</code></dt><dd><p>Synonym for <a href="index.html#val-lexico"><code>lexico</code></a></p></dd></dl><dl><dt class="spec value" id="val-find"><a href="#val-find" class="anchor"></a><code><span class="keyword">val</span> find : f:(<span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> option</code></dt><dd><p><code>find p e</code> returns the first element of <code>e</code> to satisfy <code>p</code>, or None.</p></dd></dl><dl><dt class="spec value" id="val-sum"><a href="#val-sum" class="anchor"></a><code><span class="keyword">val</span> sum : int <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int</code></dt><dd><p>Sum of all elements</p></dd></dl></section><section><header><h3 id="multiple-iterators"><a href="#multiple-iterators" class="anchor"></a>Multiple iterators</h3></header><dl><dt class="spec value" id="val-map2"><a href="#val-map2" class="anchor"></a><code><span class="keyword">val</span> map2 : f:(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'c</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'c</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Map on the two sequences. Stops once one of them is exhausted.</p></dd></dl><dl><dt class="spec value" id="val-iter2"><a href="#val-iter2" class="anchor"></a><code><span class="keyword">val</span> iter2 : f:(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> unit) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Iterate on the two sequences. Stops once one of them is exhausted.</p></dd></dl><dl><dt class="spec value" id="val-fold2"><a href="#val-fold2" class="anchor"></a><code><span class="keyword">val</span> fold2 : f:(<span class="type-var">'acc</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'acc</span>) <span>&#45;&gt;</span> init:<span class="type-var">'acc</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'acc</span></code></dt><dd><p>Fold the common prefix of the two iterators</p></dd></dl><dl><dt class="spec value" id="val-for_all2"><a href="#val-for_all2" class="anchor"></a><code><span class="keyword">val</span> for_all2 : f:(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p>Succeeds if all pairs of elements satisfy the predicate. Ignores elements of an iterator if the other runs dry.</p></dd></dl><dl><dt class="spec value" id="val-exists2"><a href="#val-exists2" class="anchor"></a><code><span class="keyword">val</span> exists2 : f:(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p>Succeeds if some pair of elements satisfy the predicate. Ignores elements of an iterator if the other runs dry.</p></dd></dl><dl><dt class="spec value" id="val-zip_with"><a href="#val-zip_with" class="anchor"></a><code><span class="keyword">val</span> zip_with : f:(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'c</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'c</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Combine common part of the gens (stops when one is exhausted)</p></dd></dl><dl><dt class="spec value" id="val-zip"><a href="#val-zip" class="anchor"></a><code><span class="keyword">val</span> zip : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span> * <span class="type-var">'b</span>) <a href="index.html#type-t">t</a></code></dt><dd><p>Zip together the common part of the gens</p></dd></dl></section><section><header><h3 id="complex-combinators"><a href="#complex-combinators" class="anchor"></a>Complex combinators</h3></header><dl><dt class="spec value" id="val-merge"><a href="#val-merge" class="anchor"></a><code><span class="keyword">val</span> merge : <span class="type-var">'a</span> <a href="../../GenLabels_intf/index.html#type-gen">GenLabels_intf.gen</a> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Pick elements fairly in each sub-generator. The merge of gens <code>e1, e2, ... </code> picks elements in <code>e1</code>, <code>e2</code>, in <code>e3</code>, <code>e1</code>, <code>e2</code> .... Once a generator is empty, it is skipped; when they are all empty, and none remains in the input, their merge is also empty. For instance, <code>merge [1;3;5] [2;4;6]</code> will be, in disorder, <code>1;2;3;4;5;6</code>.</p></dd></dl><dl><dt class="spec value" id="val-intersection"><a href="#val-intersection" class="anchor"></a><code><span class="keyword">val</span> intersection : ?&#8288;cmp:(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> int) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Intersection of two sorted sequences. Only elements that occur in both inputs appear in the output</p></dd></dl><dl><dt class="spec value" id="val-sorted_merge"><a href="#val-sorted_merge" class="anchor"></a><code><span class="keyword">val</span> sorted_merge : ?&#8288;cmp:(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> int) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Merge two sorted sequences into a sorted sequence</p></dd></dl><dl><dt class="spec value" id="val-sorted_merge_n"><a href="#val-sorted_merge_n" class="anchor"></a><code><span class="keyword">val</span> sorted_merge_n : ?&#8288;cmp:(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> int) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> list <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Sorted merge of multiple sorted sequences</p></dd></dl><dl><dt class="spec value" id="val-tee"><a href="#val-tee" class="anchor"></a><code><span class="keyword">val</span> tee : ?&#8288;n:int <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="../../GenLabels_intf/index.html#type-gen">GenLabels_intf.gen</a> list</code></dt><dd><p>Duplicate the gen into <code>n</code> generators (default 2). The generators share the same underlying instance of the gen, so the optimal case is when they are consumed evenly</p></dd></dl><dl><dt class="spec value" id="val-round_robin"><a href="#val-round_robin" class="anchor"></a><code><span class="keyword">val</span> round_robin : ?&#8288;n:int <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="../../GenLabels_intf/index.html#type-gen">GenLabels_intf.gen</a> list</code></dt><dd><p>Split the gen into <code>n</code> generators in a fair way. Elements with <code>index = k mod n</code> with go to the k-th gen. <code>n</code> default value is 2.</p></dd></dl><dl><dt class="spec value" id="val-interleave"><a href="#val-interleave" class="anchor"></a><code><span class="keyword">val</span> interleave : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>interleave a b</code> yields an element of <code>a</code>, then an element of <code>b</code>, and so on. When a generator is exhausted, this behaves like the other generator.</p></dd></dl><dl><dt class="spec value" id="val-intersperse"><a href="#val-intersperse" class="anchor"></a><code><span class="keyword">val</span> intersperse : <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Put the separator element between all elements of the given gen</p></dd></dl><dl><dt class="spec value" id="val-product"><a href="#val-product" class="anchor"></a><code><span class="keyword">val</span> product : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span> * <span class="type-var">'b</span>) <a href="index.html#type-t">t</a></code></dt><dd><p>Cartesian product, in no predictable order. Works even if some of the arguments are infinite.</p></dd></dl><dl><dt class="spec value" id="val-group"><a href="#val-group" class="anchor"></a><code><span class="keyword">val</span> group : ?&#8288;eq:(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> list <a href="index.html#type-t">t</a></code></dt><dd><p>Group equal consecutive elements together.</p></dd></dl><dl><dt class="spec value" id="val-uniq"><a href="#val-uniq" class="anchor"></a><code><span class="keyword">val</span> uniq : ?&#8288;eq:(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Remove consecutive duplicate elements. Basically this is like <code>fun e -&gt; map List.hd (group e)</code>.</p></dd></dl><dl><dt class="spec value" id="val-sort"><a href="#val-sort" class="anchor"></a><code><span class="keyword">val</span> sort : ?&#8288;cmp:(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> int) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Sort according to the given comparison function. The gen must be finite.</p></dd></dl><dl><dt class="spec value" id="val-sort_uniq"><a href="#val-sort_uniq" class="anchor"></a><code><span class="keyword">val</span> sort_uniq : ?&#8288;cmp:(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> int) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Sort and remove duplicates. The gen must be finite.</p></dd></dl><dl><dt class="spec value" id="val-chunks"><a href="#val-chunks" class="anchor"></a><code><span class="keyword">val</span> chunks : int <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> array <a href="index.html#type-t">t</a></code></dt><dd><p><code>chunks n e</code> returns a generator of arrays of length <code>n</code>, composed of successive elements of <code>e</code>. The last array may be smaller than <code>n</code></p></dd></dl><dl><dt class="spec value" id="val-permutations"><a href="#val-permutations" class="anchor"></a><code><span class="keyword">val</span> permutations : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> list <a href="index.html#type-t">t</a></code></dt><dd><p>Permutations of the gen.</p><dl><dt>since</dt><dd>0.2.2</dd></dl></dd></dl><dl><dt class="spec value" id="val-permutations_heap"><a href="#val-permutations_heap" class="anchor"></a><code><span class="keyword">val</span> permutations_heap : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> array <a href="index.html#type-t">t</a></code></dt><dd><p>Permutations of the gen, using Heap's algorithm.</p><dl><dt>since</dt><dd>0.2.3</dd></dl></dd></dl><dl><dt class="spec value" id="val-combinations"><a href="#val-combinations" class="anchor"></a><code><span class="keyword">val</span> combinations : int <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> list <a href="index.html#type-t">t</a></code></dt><dd><p>Combinations of given length. The ordering of the elements within each combination is unspecified. Example (ignoring ordering): <code>combinations 2 (1--3) |&gt; to_list = [[1;2]; [1;3]; [2;3]]</code></p><dl><dt>since</dt><dd>0.2.2</dd></dl></dd></dl><dl><dt class="spec value" id="val-power_set"><a href="#val-power_set" class="anchor"></a><code><span class="keyword">val</span> power_set : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> list <a href="index.html#type-t">t</a></code></dt><dd><p>All subsets of the gen (in no particular order). The ordering of the elements within each subset is unspecified.</p><dl><dt>since</dt><dd>0.2.2</dd></dl></dd></dl></section><section><header><h3 id="basic-conversion-functions"><a href="#basic-conversion-functions" class="anchor"></a>Basic conversion functions</h3></header><dl><dt class="spec value" id="val-of_list"><a href="#val-of_list" class="anchor"></a><code><span class="keyword">val</span> of_list : <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Enumerate elements of the list</p></dd></dl><dl><dt class="spec value" id="val-to_list"><a href="#val-to_list" class="anchor"></a><code><span class="keyword">val</span> to_list : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> list</code></dt><dd><p>non tail-call trasnformation to list, in the same order</p></dd></dl><dl><dt class="spec value" id="val-to_rev_list"><a href="#val-to_rev_list" class="anchor"></a><code><span class="keyword">val</span> to_rev_list : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> list</code></dt><dd><p>Tail call conversion to list, in reverse order (more efficient)</p></dd></dl><dl><dt class="spec value" id="val-to_array"><a href="#val-to_array" class="anchor"></a><code><span class="keyword">val</span> to_array : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> array</code></dt><dd><p>Convert the gen to an array (not very efficient)</p></dd></dl><dl><dt class="spec value" id="val-of_array"><a href="#val-of_array" class="anchor"></a><code><span class="keyword">val</span> of_array : ?&#8288;start:int <span>&#45;&gt;</span> ?&#8288;len:int <span>&#45;&gt;</span> <span class="type-var">'a</span> array <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Iterate on (a slice of) the given array</p></dd></dl><dl><dt class="spec value" id="val-of_string"><a href="#val-of_string" class="anchor"></a><code><span class="keyword">val</span> of_string : ?&#8288;start:int <span>&#45;&gt;</span> ?&#8288;len:int <span>&#45;&gt;</span> string <span>&#45;&gt;</span> char <a href="index.html#type-t">t</a></code></dt><dd><p>Iterate on bytes of the string</p></dd></dl><dl><dt class="spec value" id="val-to_string"><a href="#val-to_string" class="anchor"></a><code><span class="keyword">val</span> to_string : char <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> string</code></dt><dd><p>Convert into a string</p></dd></dl><dl><dt class="spec value" id="val-to_buffer"><a href="#val-to_buffer" class="anchor"></a><code><span class="keyword">val</span> to_buffer : <a href="../../../ocaml/Stdlib/Buffer/index.html#type-t">Stdlib.Buffer.t</a> <span>&#45;&gt;</span> char <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Consumes the iterator and writes to the buffer</p></dd></dl><dl><dt class="spec value" id="val-rand_int"><a href="#val-rand_int" class="anchor"></a><code><span class="keyword">val</span> rand_int : int <span>&#45;&gt;</span> int <a href="index.html#type-t">t</a></code></dt><dd><p>Random ints in the given range.</p></dd></dl><dl><dt class="spec value" id="val-int_range"><a href="#val-int_range" class="anchor"></a><code><span class="keyword">val</span> int_range : ?&#8288;step:int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int <a href="index.html#type-t">t</a></code></dt><dd><p><code>int_range ~step a b</code> generates integers between <code>a</code> and <code>b</code>, included, with steps of length <code>step</code> (1 if omitted). <code>a</code> is assumed to be smaller than <code>b</code>. <code>step</code> must not be null, but it can be negative for decreasing integers.</p></dd></dl><dl><dt class="spec value" id="val-lines"><a href="#val-lines" class="anchor"></a><code><span class="keyword">val</span> lines : char <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> string <a href="index.html#type-t">t</a></code></dt><dd><p>Group together chars belonging to the same line</p><dl><dt>since</dt><dd>0.3</dd></dl></dd></dl><dl><dt class="spec value" id="val-unlines"><a href="#val-unlines" class="anchor"></a><code><span class="keyword">val</span> unlines : string <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> char <a href="index.html#type-t">t</a></code></dt><dd><p>Explode lines into their chars, adding a <code>'\n'</code> after each one</p><dl><dt>since</dt><dd>0.3</dd></dl></dd></dl><div class="spec module" id="module-Infix"><a href="#module-Infix" class="anchor"></a><code><span class="keyword">module</span> <a href="Infix/index.html">Infix</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><dl><dt class="spec value" id="val-(--)"><a href="#val-(--)" class="anchor"></a><code><span class="keyword">val</span> (--) : int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int <a href="index.html#type-t">t</a></code></dt><dd><p>Synonym for <code> int_range ~by:1</code></p></dd></dl><dl><dt class="spec value" id="val-(&gt;&gt;=)"><a href="#val-(&gt;&gt;=)" class="anchor"></a><code><span class="keyword">val</span> (&gt;&gt;=) : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="../../GenLabels_intf/index.html#type-gen">GenLabels_intf.gen</a>) <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Monadic bind operator</p></dd></dl><dl><dt class="spec value" id="val-(&gt;&gt;|)"><a href="#val-(&gt;&gt;|)" class="anchor"></a><code><span class="keyword">val</span> (&gt;&gt;|) : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>) <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Infix map operator</p><dl><dt>since</dt><dd>0.2.3</dd></dl></dd></dl><dl><dt class="spec value" id="val-(&gt;|=)"><a href="#val-(&gt;|=)" class="anchor"></a><code><span class="keyword">val</span> (&gt;|=) : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>) <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Infix map operator</p><dl><dt>since</dt><dd>0.2.3</dd></dl></dd></dl><dl><dt class="spec value" id="val-pp"><a href="#val-pp" class="anchor"></a><code><span class="keyword">val</span> pp : ?&#8288;start:string <span>&#45;&gt;</span> ?&#8288;stop:string <span>&#45;&gt;</span> ?&#8288;sep:string <span>&#45;&gt;</span> ?&#8288;horizontal:bool <span>&#45;&gt;</span> (<a href="../../../ocaml/Stdlib/Format/index.html#type-formatter">Stdlib.Format.formatter</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> unit) <span>&#45;&gt;</span> <a href="../../../ocaml/Stdlib/Format/index.html#type-formatter">Stdlib.Format.formatter</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Pretty print the content of the generator on a formatter.</p></dd></dl></section></details></div></div></div><dl><dt class="spec value" id="val-cycle"><a href="#val-cycle" class="anchor"></a><code><span class="keyword">val</span> cycle : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Cycle through the enum, endlessly. The enum must not be empty.</p></dd></dl><dl><dt class="spec value" id="val-lift"><a href="#val-lift" class="anchor"></a><code><span class="keyword">val</span> lift : (<span class="type-var">'a</span> <a href="../index.html#type-gen">gen</a> <span>&#45;&gt;</span> <span class="type-var">'b</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'b</span></code></dt><dt class="spec value" id="val-lift2"><a href="#val-lift2" class="anchor"></a><code><span class="keyword">val</span> lift2 : (<span class="type-var">'a</span> <a href="../index.html#type-gen">gen</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="../index.html#type-gen">gen</a> <span>&#45;&gt;</span> <span class="type-var">'c</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'c</span></code></dt></dl></div></body></html>