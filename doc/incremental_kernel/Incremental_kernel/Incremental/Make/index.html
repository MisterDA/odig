<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Make (incremental_kernel.Incremental_kernel.Incremental.Make)</title><link rel="stylesheet" href="../../../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../../../index.html">incremental_kernel</a> &#x00BB; <a href="../../index.html">Incremental_kernel</a> &#x00BB; <a href="../index.html">Incremental</a> &#x00BB; Make</nav><h1>Module <code>Incremental.Make</code></h1><nav class="toc"><ul><li><a href="#time">Time</a></li></ul></nav></header><h3 class="heading">Parameters</h3><ul></ul><h3 class="heading">Signature</h3><div><div class="spec include"><div class="doc"><details open="open"><summary><span class="def"><code><span class="keyword">include</span> <a href="../../Incremental_intf/index.html#module-type-S_without_times">Incremental_intf.S_without_times</a></code></span></summary><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> 'a t</code></dt><dd><p><code>type 'a t</code> is the type of incrementals that have a value of type <code>'a</code>.</p><p>Incrementals are not covariant, i.e. we do not have <code>+'a t</code> -- consider, e.g. <code>set_cutoff</code> and <code>get_cutoff</code>. However, if you have types <code>a1</code> and <code>a2</code> where <code>a1</code> is a subtype of <code>a2</code>, and a value <code>t1 : a1 t</code>, then the following builds an incremental value of type <code>a2 t</code>:</p><pre><code class="ml">let t2 : a2 t = t1 &gt;&gt;| fun a1 -&gt; (a1 : a1 :&gt; a2)</code></pre></dd></dl><div><div class="spec include"><div class="doc"><details open="open"><summary><span class="def"><code><span class="keyword">include</span> <span class="keyword">sig</span> ... <span class="keyword">end</span></code></span></summary><dl><dt class="spec value" id="val-sexp_of_t"><a href="#val-sexp_of_t" class="anchor"></a><code><span class="keyword">val</span> sexp_of_t : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <a href="../../../../sexplib0/Sexplib0/Sexp/index.html#type-t">Ppx_sexp_conv_lib.Sexp.t</a>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../../../../sexplib0/Sexplib0/Sexp/index.html#type-t">Ppx_sexp_conv_lib.Sexp.t</a></code></dt></dl></details></div></div></div><dl><dt class="spec type" id="type-incremental"><a href="#type-incremental" class="anchor"></a><code><span class="keyword">type</span> 'a incremental</code><code> = <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt></dl><div><div class="spec include"><div class="doc"><details open="open"><summary><span class="def"><code><span class="keyword">include</span> <a href="../../../../base/Base/Invariant/index.html#module-type-S1">Core_kernel.Invariant.S1</a> <span class="keyword">with</span> <span class="keyword">type</span> 'a <a href="../../../../base/Base/Invariant/module-type-S1/index.html#type-t">t</a> := <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></span></summary><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> 'a t</code></dt></dl><dl><dt class="spec value" id="val-invariant"><a href="#val-invariant" class="anchor"></a><code><span class="keyword">val</span> invariant : <span class="type-var">'a</span> <a href="../../../../base/Base__/Invariant_intf/index.html#type-inv">Base__.Invariant_intf.inv</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <a href="../../../../base/Base__/Invariant_intf/index.html#type-inv">Base__.Invariant_intf.inv</a></code></dt></dl></details></div></div></div><dl><dt class="spec value" id="val-is_const"><a href="#val-is_const" class="anchor"></a><code><span class="keyword">val</span> is_const : <span class="type-var">_</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p>If <code>is_const t</code> then <code>t</code> is a constant-valued incremental. <code>is_const (const a)</code> is true.</p></dd></dl><dl><dt class="spec value" id="val-is_valid"><a href="#val-is_valid" class="anchor"></a><code><span class="keyword">val</span> is_valid : <span class="type-var">_</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dt class="spec value" id="val-is_necessary"><a href="#val-is_necessary" class="anchor"></a><code><span class="keyword">val</span> is_necessary : <span class="type-var">_</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt></dl><section><header><h2 id="creating-incrementals"><a href="#creating-incrementals" class="anchor"></a>Creating incrementals</h2></header><dl><dt class="spec value" id="val-const"><a href="#val-const" class="anchor"></a><code><span class="keyword">val</span> const : <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>const v</code> returns an incremental whose value never changes. It is the same as <code>return</code>, but reads more clearly in many situations because it serves as a nice reminder that the incremental won't change (except possibly be invalidated).</p></dd></dl><dl><dt class="spec value" id="val-return"><a href="#val-return" class="anchor"></a><code><span class="keyword">val</span> return : <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-map"><a href="#val-map" class="anchor"></a><code><span class="keyword">val</span> map : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> f:(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>) <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>map t1 ~f</code> returns an incremental <code>t</code> that maintains its value as <code>f a</code>, where <code>a</code> is the value of <code>t1</code>. <code>map2</code>, <code>map3</code>, ..., <code>map9</code> are the generalizations to more arguments. If you need map&lt;N&gt; for some N &gt; 9, it can easily be added, but also see <code>array_fold</code> and <code>unordered_array_fold</code>.</p><p><code>f</code> should not create incremental nodes but this behavior is not checked; if you want to create incremental nodes, use <code>bind</code>. The invalidation machinery that is used with <code>bind</code> is not used with <code>map</code>.</p></dd></dl><dl><dt class="spec value" id="val-(&gt;&gt;|)"><a href="#val-(&gt;&gt;|)" class="anchor"></a><code><span class="keyword">val</span> (&gt;&gt;|) : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>) <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-map2"><a href="#val-map2" class="anchor"></a><code><span class="keyword">val</span> map2 : <span class="type-var">'a1</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a2</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> f:(<span class="type-var">'a1</span> <span>&#45;&gt;</span> <span class="type-var">'a2</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>) <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-map3"><a href="#val-map3" class="anchor"></a><code><span class="keyword">val</span> map3 : <span class="type-var">'a1</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a2</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a3</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> f:(<span class="type-var">'a1</span> <span>&#45;&gt;</span> <span class="type-var">'a2</span> <span>&#45;&gt;</span> <span class="type-var">'a3</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>) <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-map4"><a href="#val-map4" class="anchor"></a><code><span class="keyword">val</span> map4 : <span class="type-var">'a1</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a2</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a3</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a4</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> f:(<span class="type-var">'a1</span> <span>&#45;&gt;</span> <span class="type-var">'a2</span> <span>&#45;&gt;</span> <span class="type-var">'a3</span> <span>&#45;&gt;</span> <span class="type-var">'a4</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>) <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-map5"><a href="#val-map5" class="anchor"></a><code><span class="keyword">val</span> map5 : <span class="type-var">'a1</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a2</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a3</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a4</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a5</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> f:(<span class="type-var">'a1</span> <span>&#45;&gt;</span> <span class="type-var">'a2</span> <span>&#45;&gt;</span> <span class="type-var">'a3</span> <span>&#45;&gt;</span> <span class="type-var">'a4</span> <span>&#45;&gt;</span> <span class="type-var">'a5</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>) <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-map6"><a href="#val-map6" class="anchor"></a><code><span class="keyword">val</span> map6 : <span class="type-var">'a1</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a2</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a3</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a4</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a5</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a6</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> f:(<span class="type-var">'a1</span> <span>&#45;&gt;</span> <span class="type-var">'a2</span> <span>&#45;&gt;</span> <span class="type-var">'a3</span> <span>&#45;&gt;</span> <span class="type-var">'a4</span> <span>&#45;&gt;</span> <span class="type-var">'a5</span> <span>&#45;&gt;</span> <span class="type-var">'a6</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>) <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-map7"><a href="#val-map7" class="anchor"></a><code><span class="keyword">val</span> map7 : <span class="type-var">'a1</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a2</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a3</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a4</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a5</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a6</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a7</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> f:(<span class="type-var">'a1</span> <span>&#45;&gt;</span> <span class="type-var">'a2</span> <span>&#45;&gt;</span> <span class="type-var">'a3</span> <span>&#45;&gt;</span> <span class="type-var">'a4</span> <span>&#45;&gt;</span> <span class="type-var">'a5</span> <span>&#45;&gt;</span> <span class="type-var">'a6</span> <span>&#45;&gt;</span> <span class="type-var">'a7</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>) <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-map8"><a href="#val-map8" class="anchor"></a><code><span class="keyword">val</span> map8 : <span class="type-var">'a1</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a2</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a3</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a4</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a5</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a6</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a7</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a8</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> f:(<span class="type-var">'a1</span> <span>&#45;&gt;</span> <span class="type-var">'a2</span> <span>&#45;&gt;</span> <span class="type-var">'a3</span> <span>&#45;&gt;</span> <span class="type-var">'a4</span> <span>&#45;&gt;</span> <span class="type-var">'a5</span> <span>&#45;&gt;</span> <span class="type-var">'a6</span> <span>&#45;&gt;</span> <span class="type-var">'a7</span> <span>&#45;&gt;</span> <span class="type-var">'a8</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>) <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-map9"><a href="#val-map9" class="anchor"></a><code><span class="keyword">val</span> map9 : <span class="type-var">'a1</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a2</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a3</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a4</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a5</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a6</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a7</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a8</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a9</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> f:(<span class="type-var">'a1</span> <span>&#45;&gt;</span> <span class="type-var">'a2</span> <span>&#45;&gt;</span> <span class="type-var">'a3</span> <span>&#45;&gt;</span> <span class="type-var">'a4</span> <span>&#45;&gt;</span> <span class="type-var">'a5</span> <span>&#45;&gt;</span> <span class="type-var">'a6</span> <span>&#45;&gt;</span> <span class="type-var">'a7</span> <span>&#45;&gt;</span> <span class="type-var">'a8</span> <span>&#45;&gt;</span> <span class="type-var">'a9</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>) <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-bind"><a href="#val-bind" class="anchor"></a><code><span class="keyword">val</span> bind : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> f:(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a>) <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>bind t1 ~f</code> returns an incremental <code>t2</code> that behaves like <code>f v</code>, where <code>v</code> is the value of <code>t1</code>. If <code>t1</code>'s value changes, then incremental applies <code>f</code> to that new value and <code>t2</code> behaves like the resulting incremental.</p><p><code>bind</code> can be significantly more expensive than <code>map</code> during stabilization, because, when its left-hand side changes, it requires modification of the incremental DAG, while <code>map</code> simply flows values along the DAG. Thus it is preferable to use <code>map</code> (and its n-ary variants above) instead of <code>bind</code> unless one actually needs <code>bind</code>'s power.</p><p><code>bind2 t1 t2 ~f</code> is:</p><pre><code class="ml">bind (map2 t1 t2 ~f:(fun v1 v2 -&gt; (v1, v2)))
  ~f:(fun (v1, v2) -&gt; f v1 v2)</code></pre><p>This is equivalent to <code>bind t1 ~f:(fun v1 -&gt; bind t2 ~f:(fun v2 -&gt; f v1 v2))</code> but more efficient due to using one bind node rather than two. The other <code>bind&lt;N&gt;</code> functions are generalize to more arguments.</p></dd></dl><dl><dt class="spec value" id="val-(&gt;&gt;=)"><a href="#val-(&gt;&gt;=)" class="anchor"></a><code><span class="keyword">val</span> (&gt;&gt;=) : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a>) <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-bind2"><a href="#val-bind2" class="anchor"></a><code><span class="keyword">val</span> bind2 : <span class="type-var">'a1</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a2</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> f:(<span class="type-var">'a1</span> <span>&#45;&gt;</span> <span class="type-var">'a2</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a>) <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-bind3"><a href="#val-bind3" class="anchor"></a><code><span class="keyword">val</span> bind3 : <span class="type-var">'a1</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a2</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a3</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> f:(<span class="type-var">'a1</span> <span>&#45;&gt;</span> <span class="type-var">'a2</span> <span>&#45;&gt;</span> <span class="type-var">'a3</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a>) <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-bind4"><a href="#val-bind4" class="anchor"></a><code><span class="keyword">val</span> bind4 : <span class="type-var">'a1</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a2</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a3</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a4</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> f:(<span class="type-var">'a1</span> <span>&#45;&gt;</span> <span class="type-var">'a2</span> <span>&#45;&gt;</span> <span class="type-var">'a3</span> <span>&#45;&gt;</span> <span class="type-var">'a4</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a>) <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a></code></dt></dl><div class="spec module" id="module-Infix"><a href="#module-Infix" class="anchor"></a><code><span class="keyword">module</span> <a href="Infix/index.html">Infix</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><dl><dt class="spec value" id="val-join"><a href="#val-join" class="anchor"></a><code><span class="keyword">val</span> join : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>join t</code> returns an incremental that behaves like the incremental that <code>t</code> currently holds.</p></dd></dl><dl><dt class="spec value" id="val-if_"><a href="#val-if_" class="anchor"></a><code><span class="keyword">val</span> if_ : bool <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> then_:<span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> else_:<span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>if_ tb ~then_ ~else_</code> returns an incremental <code>t</code> that holds the value of <code>then_</code> if <code>tb</code> is true, the value of <code>else_</code> if <code>tb</code> is false. Note that <code>t</code> only depends on one of <code>then_</code> or <code>else_</code> at a time, i.e. <code>if_ tb ~then_ ~else</code> is like:</p><pre><code class="ml">bind b ~f:(fun b -&gt; if b then then_ else else_)</code></pre><p>which is not the same as:</p><pre><code class="ml">map3 b then_ else_ ~f:(fun b then_ else_ -&gt; if b then then_ else else_)</code></pre></dd></dl><dl><dt class="spec value" id="val-freeze"><a href="#val-freeze" class="anchor"></a><code><span class="keyword">val</span> freeze : ?&#8288;when_:(<span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>freeze ?when_ t</code> returns an incremental whose value is <code>t</code>'s value <code>v</code> until the first stabilization in which <code>when_ v</code> holds, at which point the freeze node's value becomes constant and never changes again. Calling <code>freeze t</code> forces <code>t</code> to be necessary until it freezes regardless of whether the freeze node is necessary, but not thereafter (although of course <code>t</code> could remain necessary for other reasons). The result of <code>freeze t</code>, once frozen, will never be invalidated, even if <code>t</code> is invalidated, and even if the scope in which the freeze is created is invalidated. However, prior to <code>when_ v</code> becoming true, <code>freeze t</code> can be invalidated.</p></dd></dl><dl><dt class="spec value" id="val-depend_on"><a href="#val-depend_on" class="anchor"></a><code><span class="keyword">val</span> depend_on : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> depend_on:<span class="type-var">_</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>depend_on input ~depend_on</code> returns an <code>output</code> whose value is the same as <code>input</code>'s value, such that <code>depend_on</code> is necessary so long as <code>output</code> is necessary. It is like:</p><pre><code class="ml">map2 input depend_on ~f:(fun a _ -&gt; a)</code></pre><p>but with a cutoff such that <code>output</code>'s value only changes when <code>input</code>'s value changes.</p></dd></dl><dl><dt class="spec value" id="val-necessary_if_alive"><a href="#val-necessary_if_alive" class="anchor"></a><code><span class="keyword">val</span> necessary_if_alive : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>necessary_if_alive input</code> returns <code>output</code> that has the same value and cutoff as <code>input</code>, such that as long as <code>output</code> is alive, <code>input</code> is necessary.</p></dd></dl><dl><dt class="spec value" id="val-for_all"><a href="#val-for_all" class="anchor"></a><code><span class="keyword">val</span> for_all : bool <a href="index.html#type-t">t</a> array <span>&#45;&gt;</span> bool <a href="index.html#type-t">t</a></code></dt><dd><p><code>for_all ts</code> returns an incremental that is <code>true</code> iff all <code>ts</code> are <code>true</code>.</p></dd></dl><dl><dt class="spec value" id="val-exists"><a href="#val-exists" class="anchor"></a><code><span class="keyword">val</span> exists : bool <a href="index.html#type-t">t</a> array <span>&#45;&gt;</span> bool <a href="index.html#type-t">t</a></code></dt><dd><p><code>exists ts</code> returns an incremental that is <code>true</code> iff at least one of the <code>ts</code> is <code>true</code>.</p></dd></dl><dl><dt class="spec value" id="val-all"><a href="#val-all" class="anchor"></a><code><span class="keyword">val</span> all : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> list <span>&#45;&gt;</span> <span class="type-var">'a</span> list <a href="index.html#type-t">t</a></code></dt><dd><p><code>all ts</code> returns an incremental whose value is a list of the values of all of the <code>ts</code>. In any stabilization where any of the <code>ts</code> changes, the entire list is recreated (once all of the <code>ts</code> have stabilized). This essentially an <code>array_fold</code> over the <code>ts</code>.</p></dd></dl></section><section><header><h2 id="array-folds-and-sums"><a href="#array-folds-and-sums" class="anchor"></a>Array folds and sums</h2></header><dl><dt class="spec value" id="val-array_fold"><a href="#val-array_fold" class="anchor"></a><code><span class="keyword">val</span> array_fold : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> array <span>&#45;&gt;</span> init:<span class="type-var">'b</span> <span>&#45;&gt;</span> f:(<span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>) <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>array_fold ts ~init ~f</code> creates an incremental <code>t</code> whose value is:</p><pre><code class="ml">Array.fold ts ~init ~f:(fun ac t -&gt; f ac (value t))</code></pre><p>In a stabilization during which any of the <code>ts</code> changes, the entire fold will be computed once all of the <code>ts</code> have been computed.</p></dd></dl><dl><dt class="spec value" id="val-reduce_balanced"><a href="#val-reduce_balanced" class="anchor"></a><code><span class="keyword">val</span> reduce_balanced : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> array <span>&#45;&gt;</span> f:(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>) <span>&#45;&gt;</span> reduce:(<span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>) <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a> option</code></dt><dd><p><code>reduce_balanced ts ~f ~reduce</code> does a fold-like operation over <code>ts</code>. Unlike <code>array_fold</code>, the operation will be computed in <code>O(min(n, k * log(n)))</code> time, where <code>n</code> is the size of <code>ts</code> and <code>k</code> is the number of elements of <code>ts</code> that have changed since the last stabilization.</p><p>Generally, if most or all of <code>ts</code> are changing between stabilizations, using <code>array_fold</code> will have better constant factors.</p><p>The <code>reduce</code> argument must be an associative operation: <code>reduce a (reduce b c) = (reduce (reduce a b) c)</code>.</p><p><code>None</code> is returned upon supplying an empty array.</p></dd></dl><dl><dt class="spec value" id="val-unordered_array_fold"><a href="#val-unordered_array_fold" class="anchor"></a><code><span class="keyword">val</span> unordered_array_fold : ?&#8288;full_compute_every_n_changes:int <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> array <span>&#45;&gt;</span> init:<span class="type-var">'b</span> <span>&#45;&gt;</span> f:(<span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>) <span>&#45;&gt;</span> f_inverse:(<span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>) <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>unordered_array_fold ts ~init ~f ~f_inverse</code> folds over the <code>ts</code>. Unlike <code>array_fold</code>, the fold will be computed in time proportional to the number of <code>ts</code> that change rather than the number of <code>ts</code>. In a stabilization, for each <code>t</code> in <code>ts</code> that changes from <code>old_value</code> to <code>new_value</code>, the value of the unordered-array fold will change from <code>b</code> to <code>f (f_inverse b old_value) new_value</code>. The <code>t</code>'s that change may take effect in any order.</p><p>If repeated changes might accumulate error, one can cause the fold to be fully computed after every <code>full_compute_every_n_changes</code> changes. If you do not supply <code>full_compute_every_n_changes</code>, then full computes will never happen after the initial one.</p><p><code>opt_unordered_array_fold</code> is like <code>unordered_array_fold</code>, except that its result is <code>Some</code> iff all its inputs are <code>Some</code>.</p></dd></dl><dl><dt class="spec value" id="val-opt_unordered_array_fold"><a href="#val-opt_unordered_array_fold" class="anchor"></a><code><span class="keyword">val</span> opt_unordered_array_fold : ?&#8288;full_compute_every_n_changes:int <span>&#45;&gt;</span> <span class="type-var">'a</span> option <a href="index.html#type-t">t</a> array <span>&#45;&gt;</span> init:<span class="type-var">'b</span> <span>&#45;&gt;</span> f:(<span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>) <span>&#45;&gt;</span> f_inverse:(<span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>) <span>&#45;&gt;</span> <span class="type-var">'b</span> option <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-sum"><a href="#val-sum" class="anchor"></a><code><span class="keyword">val</span> sum : ?&#8288;full_compute_every_n_changes:int <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> array <span>&#45;&gt;</span> zero:<span class="type-var">'a</span> <span>&#45;&gt;</span> add:(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span>) <span>&#45;&gt;</span> sub:(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>sum ts ~zero ~add ~sub ?full_compute_every_n_changes</code> returns an incremental that maintains the sum of the <code>ts</code>. It uses <code>unordered_array_fold</code> so that the work required to maintain the sum is proportional to the number of <code>ts</code> that change (i.e. one <code>sub</code> and one <code>add</code> per change).</p><p><code>opt_sum</code> is like <code>sum</code>, except that its result is <code>Some</code> iff all its inputs are <code>Some</code>.</p></dd></dl><dl><dt class="spec value" id="val-opt_sum"><a href="#val-opt_sum" class="anchor"></a><code><span class="keyword">val</span> opt_sum : ?&#8288;full_compute_every_n_changes:int <span>&#45;&gt;</span> <span class="type-var">'a</span> option <a href="index.html#type-t">t</a> array <span>&#45;&gt;</span> zero:<span class="type-var">'a</span> <span>&#45;&gt;</span> add:(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span>) <span>&#45;&gt;</span> sub:(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span> option <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-sum_int"><a href="#val-sum_int" class="anchor"></a><code><span class="keyword">val</span> sum_int : int <a href="index.html#type-t">t</a> array <span>&#45;&gt;</span> int <a href="index.html#type-t">t</a></code></dt><dd><p><code>sum_int ts</code> = <code>sum ts ~zero:0 ~add:(+) ~sub:(-)</code></p></dd></dl><dl><dt class="spec value" id="val-sum_float"><a href="#val-sum_float" class="anchor"></a><code><span class="keyword">val</span> sum_float : float <a href="index.html#type-t">t</a> array <span>&#45;&gt;</span> float <a href="index.html#type-t">t</a></code></dt><dd><p><code>sum_float ts</code> is:</p><pre><code class="ml">sum ts ~zero:0.0 ~add:(+.) ~sub:(-.)
  ~full_compute_every_n_changes:(Array.length ts)</code></pre><p>This uses <code>sum</code> for fast update, with a full recompute every <code>length ts</code> changes to cut down on floating-point error.</p></dd></dl></section><section><header><h2 id="variables"><a href="#variables" class="anchor"></a>Variables</h2></header><div class="spec module" id="module-Var"><a href="#module-Var" class="anchor"></a><code><span class="keyword">module</span> <a href="Var/index.html">Var</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div></section><section><header><h2 id="observers"><a href="#observers" class="anchor"></a>Observers</h2></header><dl><dt class="spec module" id="module-Observer"><a href="#module-Observer" class="anchor"></a><code><span class="keyword">module</span> <a href="Observer/index.html">Observer</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>An observer lets one get the value of an incremental, either by asking directly for the value or installing an on-update handler to run when the incremental's value changes.</p></dd></dl><dl><dt class="spec value" id="val-observe"><a href="#val-observe" class="anchor"></a><code><span class="keyword">val</span> observe : ?&#8288;should_finalize:bool <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="Observer/index.html#type-t">Observer.t</a></code></dt><dd><p><code>observe t</code> returns a new observer for <code>t</code>. <code>observe</code> raises if called during stabilization.</p><p>By default, an observer has a finalizer that calls <code>disallow_future_use</code> when the observer is no longer referenced. One can use <code>~should_finalize:false</code> to cause the finalizer to not be created, in which case the observer will live until <code>disallow_future_use</code> is explicitly called.</p></dd></dl><dl><dt class="spec module" id="module-Update"><a href="#module-Update" class="anchor"></a><code><span class="keyword">module</span> <a href="Update/index.html">Update</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p><code>on_update t ~f</code> is similar to <code>Observer.on_update_exn</code>, but it does not cause <code>t</code> to be necessary. Instead of the <code>Initialized</code> update, there are updates for when a node becomes <code>Necessary</code> or <code>Unnecessary</code>. Here is a state diagram for the allowable sequences of <code>Update.t</code>'s that can be supplied to a particular <code>f</code>:</p></dd></dl><dl><dt class="spec value" id="val-on_update"><a href="#val-on_update" class="anchor"></a><code><span class="keyword">val</span> on_update : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> f:(<span class="type-var">'a</span> <a href="Update/index.html#type-t">Update.t</a> <span>&#45;&gt;</span> unit) <span>&#45;&gt;</span> unit</code></dt></dl></section><section><header><h2 id="stabilization"><a href="#stabilization" class="anchor"></a>Stabilization</h2></header><dl><dt class="spec value" id="val-stabilize"><a href="#val-stabilize" class="anchor"></a><code><span class="keyword">val</span> stabilize : unit <span>&#45;&gt;</span> unit</code></dt><dd><p><code>stabilize ()</code> recomputes all incrementals that are necessary and stale. I.e. it propagates changes from variables that have been set to the necessary incrementals that depend on them, stopping propagation as per cutoffs.</p></dd></dl><dl><dt class="spec value" id="val-am_stabilizing"><a href="#val-am_stabilizing" class="anchor"></a><code><span class="keyword">val</span> am_stabilizing : unit <span>&#45;&gt;</span> bool</code></dt></dl></section><section><header><h2 id="cutoffs"><a href="#cutoffs" class="anchor"></a>Cutoffs</h2></header><dl><dt class="spec module" id="module-Cutoff"><a href="#module-Cutoff" class="anchor"></a><code><span class="keyword">module</span> <a href="Cutoff/index.html">Cutoff</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>An <code>'a Cutoff.t</code> is a function that returns <code>true</code> if propagation of changes should be cutoff at a node based on the old value and the (possible) new value of the node.</p></dd></dl><dl><dt class="spec value" id="val-set_cutoff"><a href="#val-set_cutoff" class="anchor"></a><code><span class="keyword">val</span> set_cutoff : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="Cutoff/index.html#type-t">Cutoff.t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>set_cutoff t cutoff</code> replaces the current cutoff function for <code>t</code> with <code>cutoff</code>. <code>cutoff</code> will be called any time <code>t</code> is recomputed, with <code>old_value</code> being the value of <code>t</code> before the recomputation and <code>new_value</code> being the value that just recomputed. If <code>cutoff ~old_value ~new_value</code>, then <code>t</code>'s value will remain as <code>old_value</code> (<code>new_value</code> is discarded) and anything depending on <code>t</code> will not be recomputed (at least not because of <code>t</code>). If <code>not (cutoff ~old_value ~new_value)</code>, then <code>t</code>'s value will become <code>new_value</code>, and all nodes depending on <code>t</code> will recomputed.</p><p>A reasonable choice for <code>cutoff</code> is an equality function on <code>'a</code>.</p><p>The default cutoff for every node is <code>phys_equal</code>. For example, this means that a <code>unit incremental</code> would only fire once; to disable this, use <code>set_cutoff t
      Cutoff.never</code>.</p></dd></dl><dl><dt class="spec value" id="val-get_cutoff"><a href="#val-get_cutoff" class="anchor"></a><code><span class="keyword">val</span> get_cutoff : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="Cutoff/index.html#type-t">Cutoff.t</a></code></dt></dl><dl><dt class="spec module" id="module-Scope"><a href="#module-Scope" class="anchor"></a><code><span class="keyword">module</span> <a href="Scope/index.html">Scope</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd></dd></dl><dl><dt class="spec value" id="val-lazy_from_fun"><a href="#val-lazy_from_fun" class="anchor"></a><code><span class="keyword">val</span> lazy_from_fun : (unit <span>&#45;&gt;</span> <span class="type-var">'a</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="../../../../core_kernel/Core_kernel/Lazy/index.html#type-t">Core_kernel.Lazy.t</a></code></dt><dd><p><code>lazy_from_fun f</code> is like <code>Lazy.from_fun f</code>, except that the nodes created by <code>f</code> will be created in the scope in which <code>lazy_from_fun</code> was called, rather than in the scope of the piece of code that first forces the resulting lazy. Not using this function when defining lazy values is likely to result in exceptions being thrown by incremental. As a rule of thumb, all <code>lazy e</code> that might create incremental nodes should be replaced by <code>lazy_from_fun (fun () -&gt; e)</code>.</p><p>As usual with <code>Lazy</code>, if <code>f</code> raises, then that exception will be raised when calling <code>Lazy.force</code>.</p></dd></dl><dl><dt class="spec value" id="val-default_hash_table_initial_size"><a href="#val-default_hash_table_initial_size" class="anchor"></a><code><span class="keyword">val</span> default_hash_table_initial_size : int</code></dt><dd><p><code>memoize_fun f hashable</code> returns a function <code>m</code> that is a memoized version of <code>f</code> that will run <code>f a</code> on each distinct <code>a</code> that <code>m</code> is applied to, memoize the result (in a hash table), and thereafter for <code>a</code>, <code>m</code> will return the memoized result.</p><p>When <code>m</code> is called, it uses <code>Scope.within</code> to run <code>f</code> in the scope that was in effect when <code>memoize_fun f</code> was called. This is essential to correctly capture the dependence of nodes that <code>f</code> creates on values that <code>f</code> is closed over, which may in turn depend on the left-hand sides of binds in the scope in effect when <code>memoize_fun
      f</code> was called. Furthermore, nodes that <code>f</code> creates do not depend on the scope in effect when <code>m</code> is called.</p><p><code>memoize_fun_by_key</code> is a generalization that allows one to memoize over values that contain a uniquely identifying key, but also have other data.</p></dd></dl><dl><dt class="spec value" id="val-memoize_fun"><a href="#val-memoize_fun" class="anchor"></a><code><span class="keyword">val</span> memoize_fun : ?&#8288;initial_size:int <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="../../../../base/Base/Hashable/index.html#type-t">Core_kernel.Hashtbl.Hashable.t</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>) <span>&#45;&gt;</span> (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>) <a href="../../../../base/Base/Staged/index.html#type-t">Core_kernel.Staged.t</a></code></dt><dt class="spec value" id="val-memoize_fun_by_key"><a href="#val-memoize_fun_by_key" class="anchor"></a><code><span class="keyword">val</span> memoize_fun_by_key : ?&#8288;initial_size:int <span>&#45;&gt;</span> <span class="type-var">'key</span> <a href="../../../../base/Base/Hashable/index.html#type-t">Core_kernel.Hashtbl.Hashable.t</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'key</span>) <span>&#45;&gt;</span> (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>) <span>&#45;&gt;</span> (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>) <a href="../../../../base/Base/Staged/index.html#type-t">Core_kernel.Staged.t</a></code></dt><dt class="spec value" id="val-user_info"><a href="#val-user_info" class="anchor"></a><code><span class="keyword">val</span> user_info : <span class="type-var">_</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../../../../core_kernel/Core_kernel/Info/index.html#type-t">Core_kernel.Info.t</a> option</code></dt><dd><p>For debugging purposes, one can store an arbitrary <code>Info.t</code> in a node. This will be displayed as part of a node in error messages.</p></dd></dl><dl><dt class="spec value" id="val-set_user_info"><a href="#val-set_user_info" class="anchor"></a><code><span class="keyword">val</span> set_user_info : <span class="type-var">_</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../../../../core_kernel/Core_kernel/Info/index.html#type-t">Core_kernel.Info.t</a> option <span>&#45;&gt;</span> unit</code></dt></dl><dl><dt class="spec module" id="module-Expert"><a href="#module-Expert" class="anchor"></a><code><span class="keyword">module</span> <a href="Expert/index.html">Expert</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>A low-level, experimental interface to incremental. This is useful when you need more control over the dependency graph, for performance reasons. It comes at the cost that it's much harder to use right. Specifically, here is what you can do with an expert node:</p></dd></dl><dl><dt class="spec module" id="module-State"><a href="#module-State" class="anchor"></a><code><span class="keyword">module</span> <a href="State/index.html">State</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd></dd></dl><div class="spec module" id="module-Packed"><a href="#module-Packed" class="anchor"></a><code><span class="keyword">module</span> <a href="Packed/index.html">Packed</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><dl><dt class="spec value" id="val-pack"><a href="#val-pack" class="anchor"></a><code><span class="keyword">val</span> pack : <span class="type-var">_</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="Packed/index.html#type-t">Packed.t</a></code></dt><dt class="spec value" id="val-save_dot"><a href="#val-save_dot" class="anchor"></a><code><span class="keyword">val</span> save_dot : string <span>&#45;&gt;</span> unit</code></dt><dd><p><code>save_dot file</code> outputs to <code>file</code> the DAG of all necessary nodes, in dot format.</p></dd></dl><dl><dt class="spec value" id="val-keep_node_creation_backtrace"><a href="#val-keep_node_creation_backtrace" class="anchor"></a><code><span class="keyword">val</span> keep_node_creation_backtrace : bool <a href="../../../../core_kernel/Core_kernel/index.html#type-ref">Core_kernel.ref</a></code></dt><dd><p>If <code>keep_node_creation_backtrace</code>, then whenever a new node is created, incremental will call <code>Backtrace.get</code> and store the result in the node. The backtrace will then appear in subsequent error messages when the node is pretty printed.</p></dd></dl><dl><dt class="spec module" id="module-Let_syntax"><a href="#module-Let_syntax" class="anchor"></a><code><span class="keyword">module</span> <a href="Let_syntax/index.html">Let_syntax</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>This <code>Let_syntax</code> allows you to write expressions like</p></dd></dl></section></details></div></div></div><section><header><h2 id="time"><a href="#time" class="anchor"></a>Time</h2><p>Incremental has a timing-wheel-based clock, and lets one build incremental values that change as its time passes. One must explicitly call <code>advance_clock</code> to change incremental's clock; there is no implicit call based on the passage of time.</p></header><dl><dt class="spec module" id="module-Time"><a href="#module-Time" class="anchor"></a><code><span class="keyword">module</span> <a href="Time/index.html">Time</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>A given incremental functor may use either <code>Time_ns</code> or <code>Time</code>.</p></dd></dl><dl><dt class="spec value" id="val-alarm_precision"><a href="#val-alarm_precision" class="anchor"></a><code><span class="keyword">val</span> alarm_precision : <a href="../../../Incremental_kernel__Import/Time_ns/Span/index.html#type-t">Incremental_kernel__.Import.Time_ns.Span.t</a></code></dt><dd><p>The <code>alarm_precision</code> of the underlying timing wheel.</p></dd></dl><dl><dt class="spec value" id="val-now"><a href="#val-now" class="anchor"></a><code><span class="keyword">val</span> now : unit <span>&#45;&gt;</span> <a href="Time/index.html#type-t">Time.t</a></code></dt><dd><p><code>now t</code> returns the current time of incremental's clock.</p></dd></dl><dl><dt class="spec value" id="val-watch_now"><a href="#val-watch_now" class="anchor"></a><code><span class="keyword">val</span> watch_now : unit <span>&#45;&gt;</span> <a href="Time/index.html#type-t">Time.t</a> <a href="index.html#type-t">t</a></code></dt><dd><p><code>watch_now t</code> returns an incremental that tracks the current time.</p></dd></dl><dl><dt class="spec value" id="val-advance_clock"><a href="#val-advance_clock" class="anchor"></a><code><span class="keyword">val</span> advance_clock : to_:<a href="Time/index.html#type-t">Time.t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>advance_clock t ~to_</code> moves incremental's clock forward to <code>to_</code>. <code>advance_clock</code> raises if <code>to_ &lt; now t</code>. As with <code>Var.set</code>, the effect of <code>advance_clock</code> is not seen on incremental values until the next stabilization. Unlike <code>Var.set</code>, calling <code>advance_clock</code> during stabilization raises.</p><p>In certain pathological cases, <code>advance_clock</code> can raise due to it detecting a cycle in the incremental graph.</p></dd></dl><dl><dt class="spec module" id="module-Before_or_after"><a href="#module-Before_or_after" class="anchor"></a><code><span class="keyword">module</span> <a href="Before_or_after/index.html">Before_or_after</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p><code>at time</code> returns an incremental that is <code>Before</code> when <code>now () &lt;= time</code> and <code>After</code> when <code>now () &gt;= time + alarm_precision</code>. When <code>now ()</code> is between <code>time</code> and <code>time + alarm_precision</code>, <code>at time</code> might be <code>Before</code> or <code>After</code>, due to the fundamental imprecision of the timing wheel. One is guaranteed that an <code>at</code> never becomes <code>After</code> too early, but it may become <code>After</code> up to <code>alarm_precision</code> late.</p></dd></dl><dl><dt class="spec value" id="val-at"><a href="#val-at" class="anchor"></a><code><span class="keyword">val</span> at : <a href="Time/index.html#type-t">Time.t</a> <span>&#45;&gt;</span> <a href="Before_or_after/index.html#type-t">Before_or_after.t</a> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-after"><a href="#val-after" class="anchor"></a><code><span class="keyword">val</span> after : <a href="Time/Span/index.html#type-t">Time.Span.t</a> <span>&#45;&gt;</span> <a href="Before_or_after/index.html#type-t">Before_or_after.t</a> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-at_intervals"><a href="#val-at_intervals" class="anchor"></a><code><span class="keyword">val</span> at_intervals : <a href="Time/Span/index.html#type-t">Time.Span.t</a> <span>&#45;&gt;</span> unit <a href="index.html#type-t">t</a></code></dt><dd><p><code>at_intervals interval</code> returns an incremental whose value changes at time intervals of the form:</p><pre><code class="ml">Time.next_multiple ~base ~after ~interval</code></pre><p>where <code>base</code> is <code>now ()</code> when <code>at_intervals</code> was called and <code>after</code> is the current <code>now ()</code>. As with <code>at</code>, <code>at_intervals</code> might fire up to <code>alarm_precision</code> late.</p><p><code>at_intervals</code> raises if <code>interval &lt; alarm_precision</code>. The <code>unit t</code> that <code>at_intervals</code> returns has its cutoff set to <code>Cutoff.never</code>, so that although its value is always <code>()</code>, incrementals that depend on it will refire each time it is set. The result of <code>at_intervals</code> remains alive and is updated until the left-hand side of its defining bind changes, at which point it becomes invalid.</p></dd></dl><dl><dt class="spec value" id="val-step_function"><a href="#val-step_function" class="anchor"></a><code><span class="keyword">val</span> step_function : init:<span class="type-var">'a</span> <span>&#45;&gt;</span> (<a href="Time/index.html#type-t">Time.t</a> * <span class="type-var">'a</span>) list <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>step_function ~init [(t1, v1); ...; (tn, vn)]</code> returns an incremental whose initial value is <code>init</code> and takes on the values <code>v1</code>, ..., <code>vn</code> in sequence taking on the value <code>vi</code> when the clock's time passes <code>ti</code>. As with <code>at</code>, the steps might take effect up to <code>alarm_precision</code> late.</p><p>It is possible for <code>vi</code> to be skipped if time advances from <code>t(i-1)</code> to some time greater than <code>t(i+1)</code>.</p><p>The times must be in nondecreasing order, i.e. <code>step_function</code> raises if for some <code>i
      &lt; j</code>, <code>ti &gt; tj</code>.</p></dd></dl><dl><dt class="spec value" id="val-snapshot"><a href="#val-snapshot" class="anchor"></a><code><span class="keyword">val</span> snapshot : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> at:<a href="Time/index.html#type-t">Time.t</a> <span>&#45;&gt;</span> before:<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <a href="../../../../core_kernel/Core_kernel/Or_error/index.html#type-t">Core_kernel.Or_error.t</a></code></dt><dd><p><code>snapshot value_at ~at ~before</code> returns an incremental whose value is <code>before</code> before <code>at</code> and whose value is frozen to the value of <code>value_at</code> during the first stabilization after which the time passes <code>at</code>. <code>snapshot</code> causes <code>value_at</code> to be necessary during the first stabilization after which time passes <code>at</code> even if the <code>snapshot</code> node itself is not necessary, but not thereafter (although of course <code>value_at</code> could remain necessary for other reasons). The result of <code>snapshot</code> will only be invalidated if <code>value_at</code> is invalid at the moment of the snapshot.</p><p><code>snapshot</code> returns <code>Error</code> if <code>at &lt; now ()</code>, because it is impossible to take the snapshot because the time has already passed.</p></dd></dl></section></div></body></html>