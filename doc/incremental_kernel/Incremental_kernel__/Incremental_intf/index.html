<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Incremental_intf (incremental_kernel.Incremental_kernel__.Incremental_intf)</title><link rel="stylesheet" href="../../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../../index.html">incremental_kernel</a> &#x00BB; <a href="../index.html">Incremental_kernel__</a> &#x00BB; Incremental_intf</nav><h1>Module <code>Incremental_kernel__.Incremental_intf</code></h1><nav class="toc"><ul><li><a href="#incremental-in-a-nutshell">Incremental in a nutshell</a></li><li><a href="#the-incremental-dag">The incremental DAG</a></li><li><a href="#stabilization">Stabilization</a></li><li><a href="#bind">Bind</a></li><li><a href="#garbage-collection">Garbage collection</a></li><li><a href="#the-implementation">The implementation</a></li><li><a href="#maintaining-the-parent-invariant">Maintaining the parent invariant</a></li><li><a href="#maintaining-the-height-invariant-and-checking-for-cycles">Maintaining the height invariant and checking for cycles</a></li><li><a href="#bind,-scopes,-and-invalidation">Bind, scopes, and invalidation</a></li><li><a href="#debugging">Debugging</a></li><li><a href="#reading-guide">Reading guide</a></li></ul></nav></header><aside><p>For expressing a computation that depends on variables and that can automatically incrementally recompute after the values of some of the variables change.</p></aside><section><header><h2 id="incremental-in-a-nutshell"><a href="#incremental-in-a-nutshell" class="anchor"></a>Incremental in a nutshell</h2><p>Incremental is used to define a collection of interdependent values, some of which are &quot;variables&quot; set by user code and others that are defined via functions (in the mathematical and programming senses) of other incremental values. Incremental automatically tracks all the dependencies between incremental values and can, on demand, propagate changed variables and recompute the incremental values that depend on them.</p><p>To use incremental, one first creates a new instance via:</p><pre><code class="ml">module Inc : Incremental.S = Incremental.Make ()</code></pre><p>The functor application creates data structures that will be shared throughout the lifetime of all incremental values used with this instance. Since <code>Incremental.Make</code> is a generative functor, the type system enforces that different applications of the functor deal with disjoint sets of incrementals.</p><p>For the remainder of this comment, we assume a particular <code>Inc</code> is <code>open</code>:</p><pre><code class="ml">open Inc</code></pre><p>As an example of a simple computation, suppose we have integer variables <code>x</code> and <code>y</code> and want to keep an incremental value <code>z</code> defined by <code>z = x + y</code>. We could do this with:</p><pre><code class="ml">let x = Var.create 13
let y = Var.create 17
let z = map2 (Var.watch x) (Var.watch y) ~f:(fun x y -&gt; x + y)</code></pre><p>With this, as <code>x</code> and <code>y</code> change, incremental can recompute <code>z = x + y</code> on demand. Incremental only recomputes values that are being &quot;observed&quot;, which one indicates by calling the <code>observe</code> function to get an &quot;observer&quot;, e.g.:</p><pre><code class="ml">let z_o = observe z</code></pre><p>Incremental doesn't compute <code>z</code> every time <code>x</code> and <code>y</code> change. Rather, one must explicitly tell incremental when one wants <code>z</code> (and all other observed values) to be brought up to date, by calling <code>stabilize</code>:</p><pre><code class="ml">stabilize ();</code></pre><p>At this point, the value of <code>z</code> is <code>30</code>, which we can verify by:</p><pre><code class="ml">assert (Observer.value_exn z_o = 30);</code></pre><p>If we change the value of <code>x</code> and then tell incremental to recompute observed values, then the value of <code>z</code> will change appropriately:</p><pre><code class="ml">Var.set x 19;
stabilize ();
assert (Observer.value_exn z_o = 36);</code></pre><p>Another way to observe values is to use <code>Observer.on_update_exn</code>, which attaches an &quot;on-update handler&quot; to an observer -- the handler will be run after each stabilization in which the observer's value changed (or was initialized) during stabilization.</p><p>User functions given to incremental should never raise any exceptions: doing so will cause all future calls to <code>stabilize</code> to raise.</p></header></section><section><header><h2 id="the-incremental-dag"><a href="#the-incremental-dag" class="anchor"></a>The incremental DAG</h2><p>One can think of incrementals as forming a directed acyclic graph (DAG), where nodes correspond to incremental values and there is an edge from node <code>n1</code> to node <code>n2</code> if the value of <code>n2</code> depends on the value of <code>n1</code>. For example, the DAG for the above example has an edge from <code>x</code> to <code>z</code> and from <code>y</code> to <code>z</code>. The graph must be acyclic in order for the computation to be well defined. The graph is a DAG rather than a tree because incremental values can be shared. Extending the above example, we might have:</p><pre><code class="ml">let w = map2 (Var.watch y) z ~f:(fun y z -&gt; y - z)</code></pre><p>Both the node for <code>y</code> and the node for <code>z</code> are shared.</p><p>We will use &quot;node&quot; to mean &quot;incremental value&quot; when we want to emphasize some aspect of the DAG.</p><p>Say that a node is &quot;observed&quot; if there is an observer for it (created via <code>observe</code>). Say that a node is &quot;necessary&quot; if there is a path from that node to an observed node. <code>stabilize</code> ensures that all necessary nodes have correct values; it will not compute unnecessary nodes. An unobserved node becomes necessary by a call to <code>observe</code> or by being used to compute an observed node; this will cause the appropriate DAG edges to be added. A necessary node will become unnecessary if its observer (if any) becomes unused and if the node is no longer used to compute any observed nodes. This will cause the appropriate DAG edges to be removed.</p><p>Incremental does not know whether user-supplied functions (e.g. functions supplied to <code>bind</code> or <code>map</code>) are side effecting, and will not evaluate them for side effect. If the resulting incrementals are not necessary then the function will not be called.</p></header></section><section><header><h2 id="stabilization"><a href="#stabilization" class="anchor"></a>Stabilization</h2><p><code>stabilize</code> traverses the DAG in topological order starting at variables that changed since the last stabilization and recomputing their dependents. This is done by using a &quot;recompute heap&quot; to visit the nodes in non-decreasing order of &quot;height&quot;, which is a over-approximation of the longest path from a variable to that node. To ensure that each node is computed at most once and that its children are stabilized before it is computed, nodes satisfy the property that if there is an edge from n1 to n2, then the height of n1 is less than the height of n2.</p><p><code>stabilize</code> repeats the following steps until the heap becomes empty:</p><p>1. remove from the recompute heap a node with the smallest height 2. recompute that node 3. if the node's value changes, then add its parents to the heap.</p><p>The definition of &quot;changes&quot; in step (3) is configurable by user code. By default, a node is considered to change if its new value is not <code>phys_equal</code> to the previous value. One can use <code>set_cutoff</code> on a node to change its cutoff function, e.g. for <code>floats</code> one could cutoff propagation if the old value and new value are closer than some threshold.</p><p>If <code>stabilize</code> ever raises due to an error, then the incremental system becomes unusable, and all future calls to <code>stabilize</code> will immediately raise.</p><p>Stabilization uses a heap implemented with an array whose length is the max height, so for good performance, the height of nodes must be small. There is an upper bound on the height of nodes, <code>max_height_allowed</code>, which defaults to 128. An attempt to create a node with larger height will raise. One can dynamically increase <code>max_height_allowed</code>; however, one should be wary of doing so, for performance reasons.</p></header></section><section><header><h2 id="bind"><a href="#bind" class="anchor"></a>Bind</h2><p>Much of the power of incremental comes from <code>bind</code>, also written <code>&gt;&gt;=</code>. As a reminder, <code>bind</code> has this type:</p><pre><code class="ml">val bind : 'a t -&gt; f:('a -&gt; 'b t) -&gt; 'b t</code></pre><p><code>bind ta ~f</code> returns an incremental <code>tb</code> that behaves like <code>f a</code>, where <code>a</code> is the most recent value of <code>ta</code>. The implementation only calls <code>f</code> when the value of <code>ta</code> changes. Thinking in terms of the DAG, <code>bind ta ~f</code> returns a node <code>tb</code> such that whenever the value of <code>ta</code> changes, the implementation calls <code>f</code> to obtain a node (possibly with an arbitrary DAG below it) that defines the value of <code>tb</code>.</p><p><code>bind</code> can be used to transition existing parts of the graph between necessary and unnecessary. E.g.:</p><pre><code class="ml">val if_ : bool t -&gt; a t -&gt; a t -&gt; a t
let if_ a b c = bind a ~f:(fun a -&gt; if a then b else c)</code></pre><p>With <code>let t = if_ a b c</code>, when <code>a</code> is <code>true</code>, if <code>t</code> is necessary, then <code>b</code> will be necessary, but <code>c</code> will not. And vice-versa when <code>a</code> is <code>false</code>.</p><p>Even more, <code>bind</code> allows one to dynamically create an arbitrary graph based on the value of some other incremental, and to &quot;hide&quot; that dynamism behind an ordinary incremental value. One common way to use this is for dynamic reconfiguration, e.g.:</p><pre><code class="ml">let config_var = Var.create config in
bind (Var.watch config_var) ~f:(fun config -&gt; ... )</code></pre><p>Then, whenever one wants to reconfigure the system, one does <code>Var.set config_var</code> and then <code>stabilize</code>, which will construct a new DAG according to the new config.</p><p>Bind nodes introduce special height constraints, so that stabilization is guaranteed to recompute the left-hand side of a bind before recomputing any node created by the right-hand side <code>f</code>. This avoids recomputing nodes created on the right-hand side that would then become unnecessary when the left-hand side changes. More precisely, in <code>t &gt;&gt;= f</code>, any node created by <code>f</code> is made to have a height larger than <code>t</code>. This rule applies also to bind nodes created by <code>f</code>, so that ultimately the height of every node is greater than the height of all the left-hand sides of the binds that were involved in its creation. The height requirement does not apply to nodes returned by <code>f</code> but not created by <code>f</code> -- such nodes depend on the bind in effect when they were created, but have no dependence on <code>t</code>.</p><p>When the left-hand side of a bind node changes, stabilization &quot;invalidates&quot; all the nodes that depend on it (because they may use an old value of the left-hand side).</p><p>For example, consider:</p><pre><code class="ml">let t1 = map ... in
bind t2 ~f:(fun _ -&gt;
  let t3 = map ... in
  map2 t1 t3 ~f:(...))</code></pre><p>In this example, <code>t1</code> is created outside of <code>bind t2</code>, whereas <code>t3</code> is created by the right-hand side of <code>bind t2</code>. So, <code>t3</code> depends on <code>t2</code> (and has a greater height), whereas <code>t1</code> does not. And, in a stabilization in which <code>t2</code> changes, we are guaranteed to not recompute the old <code>t3</code>, but we have no such guarantee about <code>t1</code>. Furthermore, when <code>t2</code> changes, the old <code>t3</code> will be invalidated, whereas <code>t1</code> will not.</p><p>Since <code>bind</code> essentially allows one to add arbitrary edges to the DAG, one can use it to construct a cycle. <code>stabilize</code> will detect such cycles and raise.</p></header></section><section><header><h2 id="garbage-collection"><a href="#garbage-collection" class="anchor"></a>Garbage collection</h2><p>Incremental maintains three kinds of pointers:</p><ul><li>from nodes to their children (nodes they depend on).</li><li>from necessary nodes to their necessary parents (nodes that depend on them).</li><li>from observers to the nodes they observe.</li></ul><p>So, all necessary nodes are kept alive, from the perspective of the garbage collector.</p><p>If an observer has no on-update handlers and user code no longer holds on to it, incremental (via a finalizer on the observer), detects this and disallows future use of the observer, making the node it observed unnecessary if it is not necessary for another reason. One can eagerly remove an observer by calling <code>disallow_future_use</code>. Because finalizers may be called much later than when an observer actually becomes unreachable, it is preferable to disable observers using <code>disallow_future_use</code> to avoid useless propagation during stabilizations.</p><p>If an observer has on-update handlers, calling <code>disallow_future_use</code> is the only way to have it removed.</p></header></section><section><header><h2 id="the-implementation"><a href="#the-implementation" class="anchor"></a>The implementation</h2><p>The key type in the implementation is <code>Node.t</code>, which represents one node in the incremental DAG. The node type is in fact the same as <code>Incremental.t</code>, although this type equivalence is not exposed. A node is a record with many fields (&gt; 20). In particular a node holds:</p><ul><li>kind -- the kind of node it is (const, var, map, bind, snapshot, etc.).</li><li>value -- the node's current value.</li><li>recompute id -- the stabilization number at which it was last recomputed.</li><li>change id -- the stabilization number at which its value last changed.</li><li>height -- the height of the node in the DAG.</li><li>parents -- the necessary nodes that depend on it.</li><li>children -- the nodes that it depends on.</li><li>created_in -- the scope in which it was created.</li></ul><p>Say that a node is &quot;stale&quot; if it has never been computed or if its recompute id is less than the change id of one of its children. A node should be recomputed if it is both necessary and stale.</p><p>The <code>State.t</code> type holds all the mutable data used to implement stabilization. In particular, the incremental state contains:</p><ul><li>the current stabilization number</li><li>the set of observers</li><li>a recompute heap -- nodes that need to be recomputed, ordered by height.</li><li>an adjust-heights heap -- nodes whose height needs increasing, ordered by height.</li><li>a timing wheel -- used to implement time-based operations.</li></ul><p>The goals of stabilization are to:</p><ul><li>compute all necessary nodes that need to be recomputed.</li><li>only compute necessary nodes.</li><li>compute each node at most once.</li><li>only compute a node after ensuring its children are up to date.</li></ul><p>To do this, incremental maintains the following invariants:</p><ul><li><code>p</code> is in <code>c</code>'s parents iff (<code>c</code> is in <code>p</code>'s children &amp;&amp; <code>p</code> is necessary)</li><li><code>p</code> is in the recompute heap iff <code>p</code> is necessary and stale.</li><li>if <code>p</code> is a parent of <code>c</code>, then <code>p</code>'s height is greater than <code>c</code>'s height.</li></ul><p>The first invariant ensures that when a node's value changes, we can reach from it all necessary nodes (and only the necessary nodes) that depend on it. The second invariant ensures that that stabilization only computes necessary nodes. The third invariant, combined with the fact that stabilization always recomputes a node from the recompute-heap that has minimum height, ensures that we only compute a node after all its children are stable, and that we compute each node at most once.</p><p>Finally, at the end of stabilization, the recompute heap is empty, so the invariant implies that there are no necessary nodes that are stale, i.e. stabilization has computed all necessary nodes that need to be recomputed.</p></header></section><section><header><h2 id="maintaining-the-parent-invariant"><a href="#maintaining-the-parent-invariant" class="anchor"></a>Maintaining the parent invariant</h2><p>Maintaining the invariant that a node has edges only to necessary parents requires traversing a node's descendants when it transitions between necessary and unnecessary, in order to add or remove parents as appropriate. For example, when an observer is first added to an unnecessary node, the implementation visits all its descendants to add parents. This is essentially a form of ref-counting, in which the counter is the number of parents that a node has. There is no problem with cycles because the DAG requirement on the graph is enforced.</p></header></section><section><header><h2 id="maintaining-the-height-invariant-and-checking-for-cycles"><a href="#maintaining-the-height-invariant-and-checking-for-cycles" class="anchor"></a>Maintaining the height invariant and checking for cycles</h2><p>Maintaining the invariant that a necessary node's height is larger than all of its children requires adjusting heights when an edge is added to the DAG (e.g. when a bind left-hand side changes). This is done using the &quot;adjust-heights&quot; heap. When an edge is added, if the child's height is greater than or equal to the parent's height, then the adjust-heights heap increases the height of the parent and all of the parent's ancestors as necessary in order to restore the height invariant. This is done by visiting ancestors in topological order, in increasing order of pre-adjusted height. If during that traversal, the child of the original edge is visited, then there is a cycle in the graph, and stabilization raises.</p><p>In pathological situations, the implementation will raise due to a cyclic graph even though subsequent graph operations would eliminate the cycle. This is because the cyclicity check happens after each edge is added, rather than waiting until a batch of graph changes.</p></header></section><section><header><h2 id="bind,-scopes,-and-invalidation"><a href="#bind,-scopes,-and-invalidation" class="anchor"></a>Bind, scopes, and invalidation</h2><p>Much of the complexity of the implementation comes from <code>bind</code>. In <code>t &gt;&gt;= f</code>, when <code>f</code> is applied to the value of <code>t</code>, all of the nodes that are created depend on that value. If the value of <code>t</code> changes, then those nodes no longer make sense because they depend on a stale value. It would be both wasteful and wrong to recompute any of those &quot;invalid&quot; nodes. So, the implementation maintains the invariant that the height of a necessary node is greater than the height of the left-hand side of the nearest enclosing bind. That guarantees that stabilization will stabilize the left-hand side before recomputing any nodes created on the right-hand side. Furthermore, if the left-hand side's value changes, stabilization marks all the nodes on the right-hand side as invalid. Such invalid nodes will typically be unnecessary, but there are pathological cases where they remain necessary.</p><p>The bind height invariant is accomplished using a special &quot;bind-lhs-change&quot; node, which is a parent of the bind-lhs and a child of the bind result. The incremental state maintains the &quot;current scope&quot;, which is the bind whose right-hand side is currently being evaluated, or a special &quot;top&quot; scope if there is no bind in effect. Each node has a <code>created_in</code> field set to the scope in effect when the node is created. The implementation keeps for each scope, a singly-linked list of all nodes created in that scope. Invalidation traverses this list, and recurs on bind nodes in it to traverse their scopes as well.</p><p><code>if_</code> and <code>join</code> are special cases of <code>bind</code> that manipulate the graph; however they do not create new scopes. They use a similar lhs-change node to detect changes and perform graph manipulation.</p></header></section><section><header><h2 id="debugging"><a href="#debugging" class="anchor"></a>Debugging</h2><p>For performance reasons, <code>Incremental_lib</code> is built with debugging asserts disabled. <code>Incremental_debug</code> is a library that uses the same code as <code>Incremental_lib</code>, but has debugging asserts enabled (via an <code>IFDEF</code>). <code>Incremental_debug</code> is significantly slower than <code>Incremental_lib</code>, but may detect a bug in the Incremental library that would otherwise remain undetected by <code>Incremental_lib</code>.</p></header></section><section><header><h2 id="reading-guide"><a href="#reading-guide" class="anchor"></a>Reading guide</h2><p>Here's a breakdown of the modules in roughly dependency order.</p><ul><li><code>Import</code> -- imports from other libraries, and commonly used functions</li><li><p>Basic types.</p><ul><li><code>Cutoff</code> -- a cutoff function</li><li><code>On_update_handler</code> -- a function to run when a node's value changes</li><li><code>Node_id</code> -- an integer unique id for nodes</li><li><code>Raised_exn</code> -- a wrapper around <code>exn</code> that keeps a backtrace.</li><li><code>Sexp_of</code> -- interfaces for types that have <code>with sexp_of</code>.</li><li><code>Should_not_use</code> -- a type used for lightweight existentials.</li><li><code>Stabilization_num</code> -- an abstract <code>int option</code>, used to express the stabilization cycle when something happens.</li><li><code>Uopt</code> -- an unboxed option type.</li></ul></li><li><code>Types</code> -- mutually recursive types. Many of the types used in the implementation are mutually recursive. They are all defined in <code>Types</code>. Each type is then later defined in its own module, along with <code>with fields, sexp</code>.</li><li><p><code>Kind</code> -- the variant with one constructor for each kind of node, plus a special constructor for invalidated nodes. Many of the value-carrying variants also have a module for its argument type:</p><ul><li><code>Array_fold</code></li><li><code>At</code></li><li><code>At_intervals</code></li><li><code>Bind</code></li><li><code>Freeze</code></li><li><code>If_then_else</code></li><li><code>Join</code></li><li><code>Snapshot</code></li><li><code>Step_function</code></li><li><code>Unordered_array_fold</code></li><li><code>Var</code></li></ul></li><li><code>Scope</code> -- a packed bind.</li><li><code>Node</code> -- the main node type.</li><li><code>Internal_observer</code></li><li><code>Observer</code> -- a <code>ref</code> wrapper around <code>Internal_observer</code>, used so a finalizer can detect when user code is done with an observer.</li><li><code>Recompute_heap</code></li><li><code>Adjust_heights_heap</code></li><li><code>Alarm_value</code> -- values stored in the timing wheel, for time-based nodes.</li><li><code>State</code> -- the record type will all data structures used for stabilization, and the implementation of all the <code>Incremental</code> functions.</li><li><code>Incremental</code>, the main functor, mostly a wrapper around <code>State</code>.</li><li><code>Incremental_unit_tests</code>.</li></ul></header><div class="spec module-type" id="module-type-S_without_times"><a href="#module-type-S_without_times" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-S_without_times/index.html">S_without_times</a> = <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><div class="spec module-type" id="module-type-S_abstract_times"><a href="#module-type-S_abstract_times" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-S_abstract_times/index.html">S_abstract_times</a> = <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><div class="spec module-type" id="module-type-S"><a href="#module-type-S" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-S/index.html">S</a> : <a href="index.html#module-type-S_abstract_times">S_abstract_times</a> <span class="keyword">with</span> <span class="keyword">module</span> <a href="module-type-S/Time/index.html">Time</a> := <a href="../Import/index.html#module-Time_ns">Incremental_kernel__.Import.Time_ns</a></code></div><div class="spec module-type" id="module-type-Incremental"><a href="#module-type-Incremental" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-Incremental/index.html">Incremental</a> = <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div></section></div></body></html>