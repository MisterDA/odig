<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Irmin (irmin.Irmin)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../index.html">irmin</a> &#x00BB; Irmin</nav><h1>Module <code>Irmin</code></h1><p>Irmin public API.</p><p><code>Irmin</code> is a library to design and use persistent stores with built-in snapshot, branching and reverting mechanisms. Irmin uses concepts similar to <a href="http://git-scm.com/">Git</a> but it exposes them as a high level library instead of a complex command-line frontend. It features a <em>bidirectional</em> Git backend, where an application can read and persist its state using the Git format, fully-compatible with the usual Git tools and workflows.</p><p>Irmin is designed to use a large variety of backends. It is written in pure OCaml and does not depend on external C stubs; it is thus very portable and aims to run everywhere, from Linux to browser and MirageOS unikernels.</p><p>Consult the <code>basics</code> and <a href="index.html#examples"><span>Examples</span></a> of use for a quick start. See also the <span class="xref-unresolved" title="unresolved reference to &quot;Irmin_unix&quot;"><span>documentation</span></span> for the unix backends.</p><p><em>Release 1.4.0 - %%HOMEPAGE%%</em></p><nav class="toc"><ul><li><a href="#preliminaries">Preliminaries</a></li><li><a href="#stores">Stores</a></li><li><a href="#user-defined-contents">User-Defined Contents</a></li><li><a href="#high-level-stores">High-level Stores</a><ul><li><a href="#synchronization">Synchronization</a></li></ul></li><li><a href="#examples">Examples</a><ul><li><a href="#synchronization">Synchronization</a></li><li><a href="#mergeable-logs">Mergeable logs</a></li></ul></li><li><a href="#helpers">Helpers</a></li><li><a href="#backend">Backends</a></li></ul></nav></header><dl><dt class="spec value" id="val-version"><a href="#val-version" class="anchor"></a><code><span class="keyword">val </span>version : string</code></dt><dd><p>The version of the library.</p></dd></dl><section><header><h2 id="preliminaries"><a href="#preliminaries" class="anchor"></a>Preliminaries</h2></header><dl><dt class="spec module" id="module-Type"><a href="#module-Type" class="anchor"></a><code><span class="keyword">module </span><a href="Type/index.html">Type</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Dynamic types for Irmin values.</p></dd></dl><dl><dt class="spec module" id="module-Info"><a href="#module-Info" class="anchor"></a><code><span class="keyword">module </span><a href="Info/index.html">Info</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Commit info are used to keep track of the origin of write operations in the stores. <code>Info</code> model the metadata associated with commit objects in Git.</p></dd></dl><dl><dt class="spec module" id="module-Merge"><a href="#module-Merge" class="anchor"></a><code><span class="keyword">module </span><a href="Merge/index.html">Merge</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p><code>Merge</code> provides functions to build custom 3-way merge operators for various user-defined contents.</p></dd></dl><dl><dt class="spec module" id="module-Diff"><a href="#module-Diff" class="anchor"></a><code><span class="keyword">module </span><a href="Diff/index.html">Diff</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Differences between values.</p></dd></dl></section><section><header><h2 id="stores"><a href="#stores" class="anchor"></a>Stores</h2></header><dl><dt class="spec type" id="type-config"><a href="#type-config" class="anchor"></a><code><span class="keyword">type </span>config</code></dt><dd><p>The type for backend-specific configuration values.</p><p>Every backend has different configuration options, which are kept abstract to the user.</p></dd></dl><dl><dt class="spec type" id="type-diff"><a href="#type-diff" class="anchor"></a><code><span class="keyword">type </span>'a diff</code><code><span class="keyword"> = </span><span class="type-var">'a</span> <a href="Diff/index.html#type-t">Diff.t</a></code></dt><dd><p>The type for representing differences betwen values.</p></dd></dl><aside><p>An Irmin store is automatically built from a number of lower-level stores, implementing fewer operations, such as <a href="module-type-AO/index.html"><span>append-only</span></a> and <a href="module-type-RW/index.html"><span>read-write</span></a> stores. These low-level stores are provided by various backends.</p></aside><dl><dt class="spec module-type" id="module-type-RO"><a href="#module-type-RO" class="anchor"></a><code><span class="keyword">module type </span><a href="module-type-RO/index.html">RO</a> = <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Read-only backend stores.</p></dd></dl><dl><dt class="spec module-type" id="module-type-AO"><a href="#module-type-AO" class="anchor"></a><code><span class="keyword">module type </span><a href="module-type-AO/index.html">AO</a> = <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Append-only backend store.</p></dd></dl><dl><dt class="spec module-type" id="module-type-LINK"><a href="#module-type-LINK" class="anchor"></a><code><span class="keyword">module type </span><a href="module-type-LINK/index.html">LINK</a> = <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Immutable Link store.</p></dd></dl><dl><dt class="spec module-type" id="module-type-RW"><a href="#module-type-RW" class="anchor"></a><code><span class="keyword">module type </span><a href="module-type-RW/index.html">RW</a> = <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Read-write stores.</p></dd></dl></section><section><header><h2 id="user-defined-contents"><a href="#user-defined-contents" class="anchor"></a>User-Defined Contents</h2></header><dl><dt class="spec module" id="module-Path"><a href="#module-Path" class="anchor"></a><code><span class="keyword">module </span><a href="Path/index.html">Path</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Store paths.</p></dd></dl><dl><dt class="spec module" id="module-Hash"><a href="#module-Hash" class="anchor"></a><code><span class="keyword">module </span><a href="Hash/index.html">Hash</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Hashing functions.</p></dd></dl><dl><dt class="spec module" id="module-Contents"><a href="#module-Contents" class="anchor"></a><code><span class="keyword">module </span><a href="Contents/index.html">Contents</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p><code>Contents</code> specifies how user-defined contents need to be <em>serializable</em> and <em>mergeable</em>.</p></dd></dl><dl><dt class="spec module" id="module-Branch"><a href="#module-Branch" class="anchor"></a><code><span class="keyword">module </span><a href="Branch/index.html">Branch</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>User-defined branches.</p></dd></dl><dl><dt class="spec module" id="module-Metadata"><a href="#module-Metadata" class="anchor"></a><code><span class="keyword">module </span><a href="Metadata/index.html">Metadata</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p><code>Metadata</code> defines metadata that is attached to contents but stored in nodes. The Git backend uses this to indicate the type of file (normal, executable or symlink).</p></dd></dl><dl><dt class="spec module" id="module-Private"><a href="#module-Private" class="anchor"></a><code><span class="keyword">module </span><a href="Private/index.html">Private</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p><code>Private</code> defines functions only useful for creating new backends. If you are just using the library (and not developing a new backend), you should not use this module.</p></dd></dl></section><section><header><h2 id="high-level-stores"><a href="#high-level-stores" class="anchor"></a>High-level Stores</h2><p>An Irmin store is a branch-consistent store where keys are lists of steps.</p><p>An example is a Git repository where keys are filenames, <em>i.e.</em> list of <code>'/'</code>-separated strings. More complex examples are structured values, where steps might contain first-class field accessors and array offsets.</p><p>Irmin provides the following features:</p><ul><li>Support for fast clones, branches and merges, in a fashion very similar to Git.</li><li>Efficient taging areas for fast, transient, in-memory operations.</li><li>Fast <a href="Sync/index.html"><span>synchronization</span></a> primitives between remote stores, using native backend protocols (as the Git protocol) when available.</li></ul></header><dl><dt class="spec module-type" id="module-type-S"><a href="#module-type-S" class="anchor"></a><code><span class="keyword">module type </span><a href="module-type-S/index.html">S</a> = <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Irmin stores.</p></dd></dl><dl><dt class="spec module-type" id="module-type-S_MAKER"><a href="#module-type-S_MAKER" class="anchor"></a><code><span class="keyword">module type </span><a href="module-type-S_MAKER/index.html">S_MAKER</a> : <span class="keyword">functor</span> (<a href="module-type-S_MAKER/argument-1-M/index.html">M</a> : <a href="Metadata/index.html#module-type-S">Metadata.S</a>) <span>&#45;&gt;</span> <span class="keyword">functor</span> (<a href="module-type-S_MAKER/argument-2-C/index.html">C</a> : <a href="Contents/index.html#module-type-S">Contents.S</a>) <span>&#45;&gt;</span> <span class="keyword">functor</span> (<a href="module-type-S_MAKER/argument-3-P/index.html">P</a> : <a href="Path/index.html#module-type-S">Path.S</a>) <span>&#45;&gt;</span> <span class="keyword">functor</span> (<a href="module-type-S_MAKER/argument-4-B/index.html">B</a> : <a href="Branch/index.html#module-type-S">Branch.S</a>) <span>&#45;&gt;</span> <span class="keyword">functor</span> (<a href="module-type-S_MAKER/argument-5-H/index.html">H</a> : <a href="Hash/index.html#module-type-S">Hash.S</a>) <span>&#45;&gt;</span> <a href="index.html#module-type-S">S</a><span class="keyword"> with </span><span class="keyword">type </span><a href="module-type-S_MAKER/index.html#type-key">key</a><span class="keyword"> = </span><a href="module-type-S_MAKER/argument-3-P/index.html#type-t">P.t</a><span class="keyword"> and </span><span class="keyword">type </span><a href="module-type-S_MAKER/index.html#type-step">step</a><span class="keyword"> = </span><a href="module-type-S_MAKER/argument-3-P/index.html#type-step">P.step</a><span class="keyword"> and </span><span class="keyword">type </span><a href="module-type-S_MAKER/index.html#type-metadata">metadata</a><span class="keyword"> = </span><a href="module-type-S_MAKER/argument-1-M/index.html#type-t">M.t</a><span class="keyword"> and </span><span class="keyword">type </span><a href="module-type-S_MAKER/index.html#type-contents">contents</a><span class="keyword"> = </span><a href="module-type-S_MAKER/argument-2-C/index.html#type-t">C.t</a><span class="keyword"> and </span><span class="keyword">type </span><a href="module-type-S_MAKER/index.html#type-branch">branch</a><span class="keyword"> = </span><a href="module-type-S_MAKER/argument-4-B/index.html#type-t">B.t</a><span class="keyword"> and </span><span class="keyword">type </span><a href="module-type-S_MAKER/Commit/Hash/index.html#type-t">Commit.Hash.t</a><span class="keyword"> = </span><a href="module-type-S_MAKER/argument-5-H/index.html#type-t">H.t</a><span class="keyword"> and </span><span class="keyword">type </span><a href="module-type-S_MAKER/Tree/Hash/index.html#type-t">Tree.Hash.t</a><span class="keyword"> = </span><a href="module-type-S_MAKER/argument-5-H/index.html#type-t">H.t</a><span class="keyword"> and </span><span class="keyword">type </span><a href="module-type-S_MAKER/Contents/Hash/index.html#type-t">Contents.Hash.t</a><span class="keyword"> = </span><a href="module-type-S_MAKER/argument-5-H/index.html#type-t">H.t</a></code></dt><dd><p><code>S_MAKER</code> is the signature exposed by any backend providing <a href="module-type-S/index.html"><code>S</code></a> implementations. <code>M</code> is the implementation of user-defined metadata, <code>C</code> is the one for user-defined contents, <code>B</code> is the implementation for branches and <code>H</code> is the implementation for object (blobs, trees, commits) hashes. It does not use any native synchronization primitives.</p></dd></dl><dl><dt class="spec module-type" id="module-type-KV"><a href="#module-type-KV" class="anchor"></a><code><span class="keyword">module type </span><a href="module-type-KV/index.html">KV</a> : <a href="index.html#module-type-S">S</a><span class="keyword"> with </span><span class="keyword">type </span><a href="module-type-KV/index.html#type-key">key</a><span class="keyword"> = </span>string list<span class="keyword"> and </span><span class="keyword">type </span><a href="module-type-KV/index.html#type-step">step</a><span class="keyword"> = </span>string<span class="keyword"> and </span><span class="keyword">type </span><a href="module-type-KV/index.html#type-branch">branch</a><span class="keyword"> = </span>string</code></dt><dd><p><code>KV</code> is similar to <a href="module-type-S/index.html"><code>S</code></a> but choose sensible implementations for path and branch.</p></dd></dl><dl><dt class="spec module-type" id="module-type-KV_MAKER"><a href="#module-type-KV_MAKER" class="anchor"></a><code><span class="keyword">module type </span><a href="module-type-KV_MAKER/index.html">KV_MAKER</a> : <span class="keyword">functor</span> (<a href="module-type-KV_MAKER/argument-1-C/index.html">C</a> : <a href="Contents/index.html#module-type-S">Contents.S</a>) <span>&#45;&gt;</span> <a href="index.html#module-type-KV">KV</a><span class="keyword"> with </span><span class="keyword">type </span><a href="module-type-KV_MAKER/index.html#type-contents">contents</a><span class="keyword"> = </span><a href="module-type-KV_MAKER/argument-1-C/index.html#type-t">C.t</a></code></dt><dd><p><code>KV_MAKER</code> is like <a href="module-type-S_MAKER/index.html"><code>S_MAKER</code></a> but where everything except the contents is replaced by sensible default implementations.</p></dd></dl><section><header><h3 id="synchronization"><a href="#synchronization" class="anchor"></a>Synchronization</h3></header><dl><dt class="spec type" id="type-remote"><a href="#type-remote" class="anchor"></a><code><span class="keyword">type </span>remote</code></dt><dd><p>The type for remote stores.</p></dd></dl><dl><dt class="spec value" id="val-remote_uri"><a href="#val-remote_uri" class="anchor"></a><code><span class="keyword">val </span>remote_uri : string <span>&#45;&gt;</span> <a href="index.html#type-remote">remote</a></code></dt><dd><p><code>remote_uri s</code> is the remote store located at <code>uri</code>. Use the optimized native synchronization protocol when available for the given backend.</p></dd></dl></section></section><section><header><h2 id="examples"><a href="#examples" class="anchor"></a>Examples</h2><p>These examples are in the <code>examples</code> directory of the distribution.</p></header><section><header><h4 id="synchronization"><a href="#synchronization" class="anchor"></a>Synchronization</h4><p>A simple synchronization example, using the <span class="xref-unresolved" title="unresolved reference to &quot;Irmin_unix.Git&quot;"><span>Git</span></span> backend and the <a href="Sync/index.html"><code>Sync</code></a> helpers. The code clones a fresh repository if the repository does not exist locally, otherwise it performs a fetch: in this case, only the missing contents is downloaded.</p><pre><code class="ml">open Lwt.Infix

module S = Irmin_unix.Git.FS.KV(Irmin.Contents.String)
module Sync = Irmin.Sync(S)
let config = Irmin_git.config &quot;/tmp/test&quot;

let upstream =
  if Array.length Sys.argv = 2 then (Irmin.remote_uri Sys.argv.(1))
  else (Printf.eprintf &quot;Usage: sync [uri]\n%!&quot;; exit 1)

let test () =
  S.Repo.v config &gt;&gt;= S.master
  &gt;&gt;= fun t  -&gt; Sync.pull_exn t upstream `Set
  &gt;&gt;= fun () -&gt; S.get t [&quot;README.md&quot;]
  &gt;|= fun r  -&gt; Printf.printf &quot;%s\n%!&quot; r

let () = Lwt_main.run (test ())</code></pre></header></section><section><header><h4 id="mergeable-logs"><a href="#mergeable-logs" class="anchor"></a>Mergeable logs</h4><p>We will demonstrate the use of custom merge operators by defining mergeable debug log files. We first define a log entry as a pair of a timestamp and a message, using the combinator exposed by <a href="https://github.com/mirage/mirage-tc">mirage-tc</a>:</p><pre><code class="ml">module Entry = sig
  include Irmin.Contents.Conv
  val v: string -&gt; t
  val compare: t -&gt; t -&gt; int
  val timestamp: t -&gt; int
end = struct

  type t = { timestamp: int; message : string; }

  let compare x y = compare x.timestamp y.timestamp

  let v message =
    incr time;
    { timestamp = !time; message }

  let t =
    let open Irmin.Type in
    record &quot;entry&quot; (fun timestamp message -&gt; { timestamp; message })
    |+ field &quot;timestamp&quot; int    (fun t -&gt; t.timestamp)
    |+ field &quot;message&quot;   string (fun t -&gt; t.message)
    |&gt; sealr

  let timestamp t = t.timestamp

  let pp ppf { timestamp; message } =
    Fmt.pf ppf  &quot;%04d: %s\n&quot; timestamp message

  let of_string str =
    match String.cut ~sep:&quot;: &quot; str with
    | None -&gt; Error (`Msg (&quot;invalid entry: &quot; ^ str))
    | Some (x, message) -&gt;
      try Ok { timestamp = int_of_string x; message }
      with Failure e -&gt; Error (`Msg e)
end</code></pre><p>A log file is a list of entries (one per line), ordered by decreasing order of timestamps. The 3-way <code>merge</code> operator for log files concatenates and sorts the new entries and prepend them to the common ancestor's ones.</p><pre><code class="ml">(* A log file *)
module Log: sig
  include Irmin.Contents.S
  val add: t -&gt; Entry.t -&gt; t
  val empty: t
end = struct

  type t = Entry.t list
  let t = Irmin.Type.(list Entry.t)

  let empty = []

  let pp ppf l = List.iter (Fmt.pf ppf &quot;%a\n&quot; Entry.pp ) (List.rev l)

  let of_string str =
    let lines = String.cuts ~sep:&quot;\n&quot; str in
    try
      List.fold_left (fun acc l -&gt;
          match Entry.of_string l with
          | Ok x           -&gt; x :: acc
          | Error (`Msg e) -&gt; failwith e
        ) [] lines
      |&gt; fun l -&gt; Ok l
    with Failure e -&gt;
      Error (`Msg e)

  let timestamp = function
    | [] -&gt; 0
    | e :: _ -&gt; Entry.timestamp e

  let newer_than timestamp file =
    let rec aux acc = function
      | [] -&gt; List.rev acc
      | h:: _ when Entry.timestamp h &lt;= timestamp -&gt; List.rev acc
      | h::t -&gt; aux (h::acc) t
    in
    aux [] file

  let merge ~old t1 t2 =
    let open Irmin.Merge.Infix in
    old () &gt;&gt;=* fun old -&gt;
    let old = match old with None -&gt; [] | Some o -&gt; o in
    let ts = timestamp old in
    let t1 = newer_than ts t1 in
    let t2 = newer_than ts t2 in
    let t3 = List.sort Entry.compare (List.rev_append t1 t2) in
    Irmin.Merge.ok (List.rev_append t3 old)

  let merge = Irmin.Merge.(option (v t merge))

  let add t e = e :: t

end </code></pre><p><b>Note:</b> The serialisation primitives used in that example are not very efficient in this case as they parse the file every-time. For real usage, you would write buffered versions of <code>Log.pp</code> and <code>Log.of_string</code>.</p><p>To persist the log file on disk, we need to choose a backend. We show here how to use the on-disk <code>Git</code> backend on Unix.</p><pre><code class="ml">(* Build an Irmin store containing log files. *)
module S = Irmin_unix.Git.FS.KV(Log)

(* Set-up the local configuration of the Git repository. *)
let config = Irmin_git.config ~bare:true &quot;/tmp/irmin/test&quot;

(* Set-up the commit info function *)
let info fmt = Irmin_unix.info ~author:&quot;logger&quot; fmt</code></pre><p>We can now define a toy example to use our mergeable log files.</p><pre><code class="ml">open Lwt.Infix

(* Name of the log file. *)
let file = [ &quot;local&quot;; &quot;debug&quot; ]

(* Read the entire log file. *)
let read_file t =
  S.find t file &gt;|= function
  | None   -&gt; []
  | Some l -&gt; l

(* Persist a new entry in the log. *)
let log t fmt =
  Fmt.kstrf (fun message -&gt;
      read_file t &gt;&gt;= fun logs -&gt;
      let logs = Log.add logs (Entry.v message) in
      S.set t (info &quot;Adding a new entry&quot;) file logs
    ) fmt

let () =
  Lwt_main.run begin
    S.Repo.v config &gt;&gt;= S.master
    &gt;&gt;= fun t  -&gt; log t &quot;Adding a new log entry&quot;
    &gt;&gt;= fun () -&gt; Irmin.clone_force ~src:t ~dst:&quot;x&quot;
    &gt;&gt;= fun x  -&gt; log x &quot;Adding new stuff to x&quot;
    &gt;&gt;= fun () -&gt; log x &quot;Adding more stuff to x&quot;
    &gt;&gt;= fun () -&gt; log x &quot;More. Stuff. To x.&quot;
    &gt;&gt;= fun () -&gt; log t &quot;I can add stuff on t also&quot;
    &gt;&gt;= fun () -&gt; log t &quot;Yes. On t!&quot;
    &gt;&gt;= fun () -&gt; S.merge (info &quot;Merging x into t&quot;) x ~into:t
    &gt;|= function Ok () -&gt; () | Errror _ -&gt; failwith &quot;merge conflict!&quot;
  end</code></pre></header></section></section><section><header><h2 id="helpers"><a href="#helpers" class="anchor"></a>Helpers</h2></header><dl><dt class="spec value" id="val-remote_store"><a href="#val-remote_store" class="anchor"></a><code><span class="keyword">val </span>remote_store : (<span class="keyword">module </span><a href="module-type-S/index.html">S</a> <span class="keyword">with</span> <span class="keyword">type </span><a href="module-type-S/index.html#type-t">t</a> <span class="keyword">=</span> <span class="type-var">'a</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <a href="index.html#type-remote">remote</a></code></dt><dd><p><code>remote_store t</code> is the remote corresponding to the local store <code>t</code>. Synchronization is done by importing and exporting store <span class="xref-unresolved" title="unresolved reference to &quot;BC.slice&quot;"><span>slices</span></span>, so this is usually much slower than native synchronization using <a href="index.html#val-remote_uri"><code>remote_uri</code></a> but it works for all backends.</p></dd></dl><dl><dt class="spec module-type" id="module-type-SYNC"><a href="#module-type-SYNC" class="anchor"></a><code><span class="keyword">module type </span><a href="module-type-SYNC/index.html">SYNC</a> = <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p><code>SYNC</code> provides functions to synchronization an Irmin store with local and remote Irmin stores.</p></dd></dl><dl><dt class="spec module" id="module-Sync"><a href="#module-Sync" class="anchor"></a><code><span class="keyword">module </span><a href="Sync/index.html">Sync</a> : <span class="keyword">functor</span> (<a href="Sync/argument-1-S/index.html">S</a> : <a href="index.html#module-type-S">S</a>) <span>&#45;&gt;</span> <a href="index.html#module-type-SYNC">SYNC</a><span class="keyword"> with </span><span class="keyword">type </span><a href="Sync/index.html#type-db">db</a><span class="keyword"> = </span><a href="Sync/argument-1-S/index.html#type-t">S.t</a><span class="keyword"> and </span><span class="keyword">type </span><a href="Sync/index.html#type-commit">commit</a><span class="keyword"> = </span><a href="Sync/argument-1-S/index.html#type-commit">S.commit</a></code></dt><dd><p>The default <code>Sync</code> implementation.</p></dd></dl><dl><dt class="spec module" id="module-Dot"><a href="#module-Dot" class="anchor"></a><code><span class="keyword">module </span><a href="Dot/index.html">Dot</a> : <span class="keyword">functor</span> (<a href="Dot/argument-1-S/index.html">S</a> : <a href="index.html#module-type-S">S</a>) <span>&#45;&gt;</span> <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p><code>Dot</code> provides functions to export a store to the Graphviz `dot` format.</p></dd></dl></section><section><header><h2 id="backend"><a href="#backend" class="anchor"></a>Backends</h2><p>API to create new Irmin backends. A backend is an implementation exposing either a concrete implementation of <a href="module-type-S/index.html"><code>S</code></a> or a functor providing <a href="module-type-S/index.html"><code>S</code></a> once applied.</p><p>There are two ways to create a concrete <a href="module-type-S/index.html"><code>Irmin.S</code></a> implementation:</p><ul><li><a href="Make/index.html"><code>Make</code></a> creates a store where all the objects are stored in the same store, using the same internal keys format and a custom binary format based on <a href="https://github.com/janestreet/bin_prot">bin_prot</a>, with no native synchronization primitives: it is usually what is needed to quickly create a new backend.</li><li><a href="Make_ext/index.html"><code>Make_ext</code></a> creates a store with a <em>deep</em> embedding of each of the internal stores into separate store, with a total control over the binary format and using the native synchronization protocols when available.</li></ul></header><dl><dt class="spec module-type" id="module-type-AO_MAKER"><a href="#module-type-AO_MAKER" class="anchor"></a><code><span class="keyword">module type </span><a href="module-type-AO_MAKER/index.html">AO_MAKER</a> : <span class="keyword">functor</span> (<a href="module-type-AO_MAKER/argument-1-K/index.html">K</a> : <a href="Hash/index.html#module-type-S">Hash.S</a>) <span>&#45;&gt;</span> <span class="keyword">functor</span> (<a href="module-type-AO_MAKER/argument-2-V/index.html">V</a> : <a href="Contents/index.html#module-type-Conv">Contents.Conv</a>) <span>&#45;&gt;</span> <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p><code>AO_MAKER</code> is the signature exposed by append-only store backends. <code>K</code> is the implementation of keys and <code>V</code> is the implementation of values.</p></dd></dl><dl><dt class="spec module-type" id="module-type-LINK_MAKER"><a href="#module-type-LINK_MAKER" class="anchor"></a><code><span class="keyword">module type </span><a href="module-type-LINK_MAKER/index.html">LINK_MAKER</a> : <span class="keyword">functor</span> (<a href="module-type-LINK_MAKER/argument-1-K/index.html">K</a> : <a href="Hash/index.html#module-type-S">Hash.S</a>) <span>&#45;&gt;</span> <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p><code>LINK_MAKER</code> is the signature exposed by store which enable adding relation between keys. This is used to decouple the way keys are manipulated by the Irmin runtime and the keys used for storage. This is useful when trying to optimize storage for random-access file operations or for encryption.</p></dd></dl><dl><dt class="spec module-type" id="module-type-RW_MAKER"><a href="#module-type-RW_MAKER" class="anchor"></a><code><span class="keyword">module type </span><a href="module-type-RW_MAKER/index.html">RW_MAKER</a> : <span class="keyword">functor</span> (<a href="module-type-RW_MAKER/argument-1-K/index.html">K</a> : <a href="Contents/index.html#module-type-Conv">Contents.Conv</a>) <span>&#45;&gt;</span> <span class="keyword">functor</span> (<a href="module-type-RW_MAKER/argument-2-V/index.html">V</a> : <a href="Contents/index.html#module-type-Conv">Contents.Conv</a>) <span>&#45;&gt;</span> <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p><code>RW_MAKER</code> is the signature exposed by read-write store backends. <code>K</code> is the implementation of keys and <code>V</code> is the implementation of values.</p></dd></dl><dl><dt class="spec module" id="module-Make"><a href="#module-Make" class="anchor"></a><code><span class="keyword">module </span><a href="Make/index.html">Make</a> : <span class="keyword">functor</span> (<a href="Make/argument-1-AO/index.html">AO</a> : <a href="index.html#module-type-AO_MAKER">AO_MAKER</a>) <span>&#45;&gt;</span> <span class="keyword">functor</span> (<a href="Make/argument-2-RW/index.html">RW</a> : <a href="index.html#module-type-RW_MAKER">RW_MAKER</a>) <span>&#45;&gt;</span> <a href="index.html#module-type-S_MAKER">S_MAKER</a></code></dt><dd><p>Simple store creator. Use the same type of all of the internal keys and store all the values in the same store.</p></dd></dl><dl><dt class="spec module" id="module-Make_ext"><a href="#module-Make_ext" class="anchor"></a><code><span class="keyword">module </span><a href="Make_ext/index.html">Make_ext</a> : <span class="keyword">functor</span> (<a href="Make_ext/argument-1-P/index.html">P</a> : <a href="Private/index.html#module-type-S">Private.S</a>) <span>&#45;&gt;</span> <a href="index.html#module-type-S">S</a><span class="keyword"> with </span><span class="keyword">type </span><a href="Make_ext/index.html#type-key">key</a><span class="keyword"> = </span><a href="Make_ext/argument-1-P/Node/Path/index.html#type-t">P.Node.Path.t</a><span class="keyword"> and </span><span class="keyword">type </span><a href="Make_ext/index.html#type-contents">contents</a><span class="keyword"> = </span><a href="Make_ext/argument-1-P/Contents/index.html#type-value">P.Contents.value</a><span class="keyword"> and </span><span class="keyword">type </span><a href="Make_ext/index.html#type-branch">branch</a><span class="keyword"> = </span><a href="Make_ext/argument-1-P/Branch/index.html#type-key">P.Branch.key</a><span class="keyword"> and </span><span class="keyword">type </span><a href="Make_ext/Commit/Hash/index.html#type-t">Commit.Hash.t</a><span class="keyword"> = </span><a href="Make_ext/argument-1-P/Commit/index.html#type-key">P.Commit.key</a><span class="keyword"> and </span><span class="keyword">type </span><a href="Make_ext/Tree/Hash/index.html#type-t">Tree.Hash.t</a><span class="keyword"> = </span><a href="Make_ext/argument-1-P/Node/index.html#type-key">P.Node.key</a><span class="keyword"> and </span><span class="keyword">type </span><a href="Make_ext/Contents/Hash/index.html#type-t">Contents.Hash.t</a><span class="keyword"> = </span><a href="Make_ext/argument-1-P/Contents/index.html#type-key">P.Contents.key</a><span class="keyword"> and </span><span class="keyword">type </span><a href="Make_ext/index.html#type-step">step</a><span class="keyword"> = </span><a href="Make_ext/argument-1-P/Node/Path/index.html#type-step">P.Node.Path.step</a><span class="keyword"> and </span><span class="keyword">type </span><a href="Make_ext/index.html#type-metadata">metadata</a><span class="keyword"> = </span><a href="Make_ext/argument-1-P/Node/Val/index.html#type-metadata">P.Node.Val.metadata</a><span class="keyword"> and </span><span class="keyword">type </span><a href="Make_ext/Key/index.html#type-step">Key.step</a><span class="keyword"> = </span><a href="Make_ext/argument-1-P/Node/Path/index.html#type-step">P.Node.Path.step</a><span class="keyword"> and </span><span class="keyword">type </span><a href="Make_ext/index.html#type-repo">repo</a><span class="keyword"> = </span><a href="Make_ext/argument-1-P/Repo/index.html#type-t">P.Repo.t</a></code></dt><dd><p>Advanced store creator.</p></dd></dl></section></div></body></html>