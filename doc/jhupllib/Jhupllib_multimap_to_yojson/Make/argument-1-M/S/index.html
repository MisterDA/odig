<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>S (jhupllib.Jhupllib_multimap_to_yojson.Make.1-M.S)</title><link rel="stylesheet" href="../../../../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../../../../index.html">jhupllib</a> &#x00BB; <a href="../../../index.html">Jhupllib_multimap_to_yojson</a> &#x00BB; <a href="../../index.html">Make</a> &#x00BB; <a href="../index.html">1-M</a> &#x00BB; S</nav><h1>Module <code>1-M.S</code></h1><nav class="toc"><ul><li><a href="#boilerplate-code">Boilerplate code</a></li><li><a href="#printing">Printing</a></li><li><a href="#infix-operators">Infix operators</a></li><li><a href="#override-modules">Override modules</a></li></ul></nav></header><dl><dt class="spec type" id="type-elt"><a href="#type-elt" class="anchor"></a><code><span class="keyword">type</span> elt</code><code> = <a href="../index.html#type-value">value</a></code></dt><dd><p>The type of the set elements.</p></dd></dl><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> t</code></dt><dd><p>The type of sets.</p></dd></dl><dl><dt class="spec value" id="val-empty"><a href="#val-empty" class="anchor"></a><code><span class="keyword">val</span> empty : <a href="index.html#type-t">t</a></code></dt><dd><p>The empty set.</p></dd></dl><dl><dt class="spec value" id="val-is_empty"><a href="#val-is_empty" class="anchor"></a><code><span class="keyword">val</span> is_empty : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p>Test whether a set is empty or not.</p></dd></dl><dl><dt class="spec value" id="val-singleton"><a href="#val-singleton" class="anchor"></a><code><span class="keyword">val</span> singleton : <a href="index.html#type-elt">elt</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>singleton x</code> returns the one-element set containing only <code>x</code>.</p></dd></dl><dl><dt class="spec value" id="val-mem"><a href="#val-mem" class="anchor"></a><code><span class="keyword">val</span> mem : <a href="index.html#type-elt">elt</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>mem x s</code> tests whether <code>x</code> belongs to the set <code>s</code>.</p></dd></dl><dl><dt class="spec value" id="val-find"><a href="#val-find" class="anchor"></a><code><span class="keyword">val</span> find : <a href="index.html#type-elt">elt</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-elt">elt</a></code></dt><dd><p><code>find x s</code> returns the element in s that tests equal to <code>x</code> under its comparison function.</p><dl><dt>raises Not_found</dt><dd><p>if no element is equal</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-add"><a href="#val-add" class="anchor"></a><code><span class="keyword">val</span> add : <a href="index.html#type-elt">elt</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>add x s</code> returns a set containing all elements of <code>s</code>, plus <code>x</code>. If <code>x</code> was already in <code>s</code>, <code>s</code> is returned unchanged.</p></dd></dl><dl><dt class="spec value" id="val-remove"><a href="#val-remove" class="anchor"></a><code><span class="keyword">val</span> remove : <a href="index.html#type-elt">elt</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>remove x s</code> returns a set containing all elements of <code>s</code>, except <code>x</code>. If <code>x</code> was not in <code>s</code>, <code>s</code> is returned unchanged.</p></dd></dl><dl><dt class="spec value" id="val-update"><a href="#val-update" class="anchor"></a><code><span class="keyword">val</span> update : <a href="index.html#type-elt">elt</a> <span>&#45;&gt;</span> <a href="index.html#type-elt">elt</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>update x y s</code> replace <code>x</code> by <code>y</code> in <code>s</code>. <code>update</code> is faster when <code>x</code> compares equal to <code>y</code> according to the comparison function used by your set.</p><dl><dt>raises Not_found</dt><dd><p>if <code>x</code> is not in <code>s</code>.</p></dd></dl><dl><dt>since</dt><dd>2.4</dd></dl></dd></dl><dl><dt class="spec value" id="val-union"><a href="#val-union" class="anchor"></a><code><span class="keyword">val</span> union : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Set union.</p></dd></dl><dl><dt class="spec value" id="val-inter"><a href="#val-inter" class="anchor"></a><code><span class="keyword">val</span> inter : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Set intersection.</p></dd></dl><dl><dt class="spec value" id="val-diff"><a href="#val-diff" class="anchor"></a><code><span class="keyword">val</span> diff : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Set difference.</p></dd></dl><dl><dt class="spec value" id="val-sym_diff"><a href="#val-sym_diff" class="anchor"></a><code><span class="keyword">val</span> sym_diff : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>sym_diff s t</code> returns the set of all elements in <code>s</code> or <code>t</code> but not both. This is the same as <code>diff (union s t) (inter s
    t)</code>.</p></dd></dl><dl><dt class="spec value" id="val-compare"><a href="#val-compare" class="anchor"></a><code><span class="keyword">val</span> compare : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int</code></dt><dd><p>Total ordering between sets. Can be used as the ordering function for doing sets of sets.</p></dd></dl><dl><dt class="spec value" id="val-equal"><a href="#val-equal" class="anchor"></a><code><span class="keyword">val</span> equal : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>equal s1 s2</code> tests whether the sets <code>s1</code> and <code>s2</code> are equal, that is, contain equal elements.</p></dd></dl><dl><dt class="spec value" id="val-subset"><a href="#val-subset" class="anchor"></a><code><span class="keyword">val</span> subset : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>subset s1 s2</code> tests whether the set <code>s1</code> is a subset of the set <code>s2</code>.</p></dd></dl><dl><dt class="spec value" id="val-disjoint"><a href="#val-disjoint" class="anchor"></a><code><span class="keyword">val</span> disjoint : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>disjoint s1 s2</code> tests whether the sets <code>s1</code> and <code>s2</code> contain no shared elements. (i.e. <code>inter s1 s2</code> is empty.)</p></dd></dl><dl><dt class="spec value" id="val-compare_subset"><a href="#val-compare_subset" class="anchor"></a><code><span class="keyword">val</span> compare_subset : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int</code></dt><dd><p>Partial ordering between sets as generated by <code>subset</code></p></dd></dl><dl><dt class="spec value" id="val-iter"><a href="#val-iter" class="anchor"></a><code><span class="keyword">val</span> iter : (<a href="index.html#type-elt">elt</a> <span>&#45;&gt;</span> unit) <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>iter f s</code> applies <code>f</code> in turn to all elements of <code>s</code>. The elements of <code>s</code> are presented to <code>f</code> in increasing order with respect to the ordering over the type of the elements.</p></dd></dl><dl><dt class="spec value" id="val-at_rank_exn"><a href="#val-at_rank_exn" class="anchor"></a><code><span class="keyword">val</span> at_rank_exn : int <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-elt">elt</a></code></dt><dd><p><code>at_rank_exn i s</code> returns element at rank <code>i</code> in <code>s</code>, that is the <code>i</code>-th element in increasing order (the <code>0</code>-th element being the smallest element of <code>s</code>).</p><dl><dt>raises Not_found</dt><dd><p>if <code>s = empty</code>.</p></dd></dl><dl><dt>raises Invalid_argument</dt><dd><p>error_message if <code>i &lt; 0 || i &gt;= cardinal s</code></p></dd></dl><dl><dt>since</dt><dd>2.4</dd></dl></dd></dl><dl><dt class="spec value" id="val-map"><a href="#val-map" class="anchor"></a><code><span class="keyword">val</span> map : (<a href="index.html#type-elt">elt</a> <span>&#45;&gt;</span> <a href="index.html#type-elt">elt</a>) <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>map f x</code> creates a new set with elements <code>f a0</code>, <code>f a1</code>... <code>f aN</code>, where <code>a0</code>,<code>a1</code>..<code>aN</code> are the values contained in <code>x</code></p></dd></dl><dl><dt class="spec value" id="val-filter"><a href="#val-filter" class="anchor"></a><code><span class="keyword">val</span> filter : (<a href="index.html#type-elt">elt</a> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>filter p s</code> returns the set of all elements in <code>s</code> that satisfy predicate <code>p</code>.</p></dd></dl><dl><dt class="spec value" id="val-filter_map"><a href="#val-filter_map" class="anchor"></a><code><span class="keyword">val</span> filter_map : (<a href="index.html#type-elt">elt</a> <span>&#45;&gt;</span> <a href="index.html#type-elt">elt</a> option) <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>filter_map f m</code> combines the features of <code>filter</code> and <code>map</code>. It calls calls <code>f a0</code>, <code>f a1</code>, <code>f aN</code> where <code>a0</code>,<code>a1</code>..<code>aN</code> are the elements of <code>m</code> and returns the set of pairs <code>bi</code> such as <code>f ai = Some bi</code> (when <code>f</code> returns <code>None</code>, the corresponding element of <code>m</code> is discarded).</p></dd></dl><dl><dt class="spec value" id="val-fold"><a href="#val-fold" class="anchor"></a><code><span class="keyword">val</span> fold : (<a href="index.html#type-elt">elt</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span>) <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p><code>fold f s a</code> computes <code>(f xN ... (f x1 (f x0 a))...)</code>, where <code>x0</code>,<code>x1</code>..<code>xN</code> are the elements of <code>s</code>, in increasing order.</p></dd></dl><dl><dt class="spec value" id="val-for_all"><a href="#val-for_all" class="anchor"></a><code><span class="keyword">val</span> for_all : (<a href="index.html#type-elt">elt</a> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>for_all p s</code> checks if all elements of the set satisfy the predicate <code>p</code>.</p></dd></dl><dl><dt class="spec value" id="val-exists"><a href="#val-exists" class="anchor"></a><code><span class="keyword">val</span> exists : (<a href="index.html#type-elt">elt</a> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>exists p s</code> checks if at least one element of the set satisfies the predicate <code>p</code>.</p></dd></dl><dl><dt class="spec value" id="val-partition"><a href="#val-partition" class="anchor"></a><code><span class="keyword">val</span> partition : (<a href="index.html#type-elt">elt</a> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> * <a href="index.html#type-t">t</a></code></dt><dd><p><code>partition p s</code> returns a pair of sets <code>(s1, s2)</code>, where <code>s1</code> is the set of all the elements of <code>s</code> that satisfy the predicate <code>p</code>, and <code>s2</code> is the set of all the elements of <code>s</code> that do not satisfy <code>p</code>.</p></dd></dl><dl><dt class="spec value" id="val-split"><a href="#val-split" class="anchor"></a><code><span class="keyword">val</span> split : <a href="index.html#type-elt">elt</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> * bool * <a href="index.html#type-t">t</a></code></dt><dd><p><code>split x s</code> returns a triple <code>(l, present, r)</code>, where <code>l</code> is the set of elements of <code>s</code> that are strictly less than <code>x</code>; <code>r</code> is the set of elements of <code>s</code> that are strictly greater than <code>x</code>; <code>present</code> is <code>false</code> if <code>s</code> contains no element equal to <code>x</code>, or <code>true</code> if <code>s</code> contains an element equal to <code>x</code>.</p></dd></dl><dl><dt class="spec value" id="val-split_opt"><a href="#val-split_opt" class="anchor"></a><code><span class="keyword">val</span> split_opt : <a href="index.html#type-elt">elt</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> * <a href="index.html#type-elt">elt</a> option * <a href="index.html#type-t">t</a></code></dt><dd><p><code>split_opt x s</code> returns a triple <code>(l, maybe_v, r)</code>, where <code>l</code> is the set of elements of <code>s</code> that are strictly less than <code>x</code>; <code>r</code> is the set of elements of <code>s</code> that are strictly greater than <code>x</code>; <code>maybe_v</code> is <code>None</code> if <code>s</code> contains no element equal to <code>x</code>, or <code>Some v</code> if <code>s</code> contains an element <code>v</code> that compares equal to <code>x</code>.</p><dl><dt>since</dt><dd>2.2.0</dd></dl></dd></dl><dl><dt class="spec value" id="val-split_lt"><a href="#val-split_lt" class="anchor"></a><code><span class="keyword">val</span> split_lt : <a href="index.html#type-elt">elt</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> * <a href="index.html#type-t">t</a></code></dt><dd><p><code>split_lt x s</code> returns a pair of sets <code>(l, r)</code>, such that <code>l</code> is the subset of <code>s</code> with elements &lt; <code>x</code>; <code>r</code> is the subset of <code>s</code> with elements &gt;= <code>x</code>.</p><dl><dt>since</dt><dd>2.2.0</dd></dl></dd></dl><dl><dt class="spec value" id="val-split_le"><a href="#val-split_le" class="anchor"></a><code><span class="keyword">val</span> split_le : <a href="index.html#type-elt">elt</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> * <a href="index.html#type-t">t</a></code></dt><dd><p><code>split_le x s</code> returns a pair of sets <code>(l, r)</code>, such that <code>l</code> is the subset of <code>s</code> with elements &lt;= <code>x</code>; <code>r</code> is the subset of <code>s</code> with elements &gt; <code>x</code>.</p><dl><dt>since</dt><dd>2.2.0</dd></dl></dd></dl><dl><dt class="spec value" id="val-cardinal"><a href="#val-cardinal" class="anchor"></a><code><span class="keyword">val</span> cardinal : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int</code></dt><dd><p>Return the number of elements of a set.</p></dd></dl><dl><dt class="spec value" id="val-elements"><a href="#val-elements" class="anchor"></a><code><span class="keyword">val</span> elements : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-elt">elt</a> list</code></dt><dd><p>Return the list of all elements of the given set. The returned list is sorted in increasing order with respect to the ordering <code>Ord.compare</code>, where <code>Ord</code> is the argument given to <span class="xref-unresolved" title="unresolved reference to &quot;Set.Make&quot;"><code>Set</code>.Make</span>.</p></dd></dl><dl><dt class="spec value" id="val-to_list"><a href="#val-to_list" class="anchor"></a><code><span class="keyword">val</span> to_list : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-elt">elt</a> list</code></dt><dd><p>Alias for <code>elements</code>.</p><dl><dt>since</dt><dd>2.2.0</dd></dl></dd></dl><dl><dt class="spec value" id="val-to_array"><a href="#val-to_array" class="anchor"></a><code><span class="keyword">val</span> to_array : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-elt">elt</a> array</code></dt><dd><p>Same as <code>to_list</code> but with an array instead of a list.</p><dl><dt>since</dt><dd>2.4</dd></dl></dd></dl><dl><dt class="spec value" id="val-min_elt"><a href="#val-min_elt" class="anchor"></a><code><span class="keyword">val</span> min_elt : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-elt">elt</a></code></dt><dd><p>Return the smallest element of the given set (with respect to the <code>Ord.compare</code> ordering).</p><dl><dt>raises Not_found</dt><dd><p>if the set is empty.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-pop_min"><a href="#val-pop_min" class="anchor"></a><code><span class="keyword">val</span> pop_min : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-elt">elt</a> * <a href="index.html#type-t">t</a></code></dt><dd><p>Returns the smallest element of the given set along with the rest of the set. Semantically equivalent and faster than</p><p><code>let mini = min_elt s in (mini, remove mini s)</code></p><dl><dt>raises Not_found</dt><dd><p>if the set is empty.</p></dd></dl><dl><dt>since</dt><dd>2.4</dd></dl></dd></dl><dl><dt class="spec value" id="val-pop_max"><a href="#val-pop_max" class="anchor"></a><code><span class="keyword">val</span> pop_max : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-elt">elt</a> * <a href="index.html#type-t">t</a></code></dt><dd><p>Returns the biggest element of the given set along with the rest of the set. Semantically equivalent and faster than</p><p><code>let maxi = max_elt s in (maxi, remove maxi s)</code></p><dl><dt>raises Not_found</dt><dd><p>if the set is empty.</p></dd></dl><dl><dt>since</dt><dd>2.4</dd></dl></dd></dl><dl><dt class="spec value" id="val-max_elt"><a href="#val-max_elt" class="anchor"></a><code><span class="keyword">val</span> max_elt : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-elt">elt</a></code></dt><dd><p>Same as <span class="xref-unresolved" title="unresolved reference to &quot;Set.S.min_elt&quot;"><span class="xref-unresolved" title="unresolved reference to &quot;Set.S&quot;"><code>Set</code>.S</span>.min_elt</span>, but returns the largest element of the given set.</p></dd></dl><dl><dt class="spec value" id="val-choose"><a href="#val-choose" class="anchor"></a><code><span class="keyword">val</span> choose : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-elt">elt</a></code></dt><dd><p>Return one element of the given set. Which element is chosen is unspecified, but equal elements will be chosen for equal sets.</p><dl><dt>raises Not_found</dt><dd><p>if the set is empty.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-any"><a href="#val-any" class="anchor"></a><code><span class="keyword">val</span> any : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-elt">elt</a></code></dt><dd><p>Return one element of the given set. The difference with choose is that there is no guarantee that equals elements will be picked for equal sets. This merely returns the quickest element to get (O(1)).</p><dl><dt>raises Not_found</dt><dd><p>if the set is empty.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-pop"><a href="#val-pop" class="anchor"></a><code><span class="keyword">val</span> pop : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-elt">elt</a> * <a href="index.html#type-t">t</a></code></dt><dd><p>returns one element of the set and the set without that element.</p><dl><dt>raises Not_found</dt><dd><p>if given an empty set</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-enum"><a href="#val-enum" class="anchor"></a><code><span class="keyword">val</span> enum : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-elt">elt</a> <a href="../../../../../batteries/BatEnum/index.html#type-t">BatEnum.t</a></code></dt><dd><p>Return an enumeration of all elements of the given set. The returned enumeration is sorted in increasing order with respect to the ordering <code>Ord.compare</code>, where <code>Ord</code> is the argument given to <span class="xref-unresolved" title="unresolved reference to &quot;Set.Make&quot;"><code>Set</code>.Make</span>.</p></dd></dl><dl><dt class="spec value" id="val-backwards"><a href="#val-backwards" class="anchor"></a><code><span class="keyword">val</span> backwards : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-elt">elt</a> <a href="../../../../../batteries/BatEnum/index.html#type-t">BatEnum.t</a></code></dt><dd><p>Return an enumeration of all elements of the given set. The returned enumeration is sorted in decreasing order with respect to the ordering <code>Ord.compare</code>, where <code>Ord</code> is the argument given to <span class="xref-unresolved" title="unresolved reference to &quot;Set.Make&quot;"><code>Set</code>.Make</span>.</p></dd></dl><dl><dt class="spec value" id="val-of_enum"><a href="#val-of_enum" class="anchor"></a><code><span class="keyword">val</span> of_enum : <a href="index.html#type-elt">elt</a> <a href="../../../../../batteries/BatEnum/index.html#type-t">BatEnum.t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-of_list"><a href="#val-of_list" class="anchor"></a><code><span class="keyword">val</span> of_list : <a href="index.html#type-elt">elt</a> list <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>builds a set from the given list.</p><dl><dt>since</dt><dd>2.3.0</dd></dl></dd></dl><dl><dt class="spec value" id="val-of_array"><a href="#val-of_array" class="anchor"></a><code><span class="keyword">val</span> of_array : <a href="index.html#type-elt">elt</a> array <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>builds a set from the given array.</p><dl><dt>since</dt><dd>2.4</dd></dl></dd></dl><section><header><h6 id="boilerplate-code"><a href="#boilerplate-code" class="anchor"></a>Boilerplate code</h6></header></section><section><header><h6 id="printing"><a href="#printing" class="anchor"></a>Printing</h6></header><dl><dt class="spec value" id="val-print"><a href="#val-print" class="anchor"></a><code><span class="keyword">val</span> print : ?&#8288;first:string <span>&#45;&gt;</span> ?&#8288;last:string <span>&#45;&gt;</span> ?&#8288;sep:string <span>&#45;&gt;</span> (<span class="type-var">'a</span> <a href="../../../../../batteries/BatInnerIO/index.html#type-output">BatInnerIO.output</a> <span>&#45;&gt;</span> <a href="index.html#type-elt">elt</a> <span>&#45;&gt;</span> unit) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="../../../../../batteries/BatInnerIO/index.html#type-output">BatInnerIO.output</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt></dl></section><section><header><h6 id="infix-operators"><a href="#infix-operators" class="anchor"></a>Infix operators</h6></header><div class="spec module" id="module-Infix"><a href="#module-Infix" class="anchor"></a><code><span class="keyword">module</span> <a href="Infix/index.html">Infix</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div></section><section><header><h6 id="override-modules"><a href="#override-modules" class="anchor"></a>Override modules</h6></header><aside><p>The following modules replace functions defined in <code>Set</code> with functions behaving slightly differently but having the same name. This is by design: the functions meant to override the corresponding functions of <code>Set</code>.</p></aside><dl><dt class="spec module" id="module-Exceptionless"><a href="#module-Exceptionless" class="anchor"></a><code><span class="keyword">module</span> <a href="Exceptionless/index.html">Exceptionless</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Operations on <code>Set</code> without exceptions.</p></dd></dl><dl><dt class="spec module" id="module-Labels"><a href="#module-Labels" class="anchor"></a><code><span class="keyword">module</span> <a href="Labels/index.html">Labels</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Operations on <code>Set</code> with labels.</p></dd></dl></section></div></body></html>