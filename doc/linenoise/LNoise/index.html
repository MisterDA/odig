<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>LNoise (linenoise.LNoise)</title><link rel="stylesheet" href="../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../index.html">linenoise</a> &#x00BB; LNoise</nav><h1>Module <code>LNoise</code></h1><p>OCaml bindings to linenoise, functions that can fail use result type</p></header><dl><dt class="spec type" id="type-completions"><a href="#type-completions" class="anchor"></a><code><span class="keyword">type</span> completions</code></dt><dd><p>Abstract type of completions, given to your completion callback</p></dd></dl><dl><dt class="spec value" id="val-add_completion"><a href="#val-add_completion" class="anchor"></a><code><span class="keyword">val</span> add_completion : <a href="index.html#type-completions">completions</a> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> unit</code></dt><dd><p>This function is used by the callback function registered by the user in order to add completion options given the input string when the user typed &lt;TAB&gt;.</p></dd></dl><dl><dt class="spec value" id="val-set_completion_callback"><a href="#val-set_completion_callback" class="anchor"></a><code><span class="keyword">val</span> set_completion_callback : (string <span>&#45;&gt;</span> <a href="index.html#type-completions">completions</a> <span>&#45;&gt;</span> unit) <span>&#45;&gt;</span> unit</code></dt><dd><p>Register the callback function that is called for upon tab-completion, aka when &lt;TAB&gt; is hit in the terminal</p></dd></dl><dl><dt class="spec value" id="val-linenoise"><a href="#val-linenoise" class="anchor"></a><code><span class="keyword">val</span> linenoise : string <span>&#45;&gt;</span> string option</code></dt><dd><p>The high level function that is the main API of the linenoise library. This function checks if the terminal has basic capabilities, just checking for a blacklist of stupid terminals, and later either calls the line editing function or uses dummy fgets() so that you will be able to type something even in the most desperate of the conditions.</p></dd></dl><dl><dt class="spec value" id="val-history_add"><a href="#val-history_add" class="anchor"></a><code><span class="keyword">val</span> history_add : string <span>&#45;&gt;</span> (unit, string) <a href="../../result/Result/index.html#type-result">Result.result</a></code></dt><dd><p>Add a string to the history</p></dd></dl><dl><dt class="spec value" id="val-history_set"><a href="#val-history_set" class="anchor"></a><code><span class="keyword">val</span> history_set : max_length:int <span>&#45;&gt;</span> (unit, string) <a href="../../result/Result/index.html#type-result">Result.result</a></code></dt><dd><p>Set the maximum length for the history. This function can be called even if there is already some history, the function will make sure to retain just the latest 'len' elements if the new history length value is smaller than the amount of items already inside the history.</p></dd></dl><dl><dt class="spec value" id="val-history_save"><a href="#val-history_save" class="anchor"></a><code><span class="keyword">val</span> history_save : filename:string <span>&#45;&gt;</span> (unit, string) <a href="../../result/Result/index.html#type-result">Result.result</a></code></dt><dd><p>Save the history in the specified file</p></dd></dl><dl><dt class="spec value" id="val-history_load"><a href="#val-history_load" class="anchor"></a><code><span class="keyword">val</span> history_load : filename:string <span>&#45;&gt;</span> (unit, string) <a href="../../result/Result/index.html#type-result">Result.result</a></code></dt><dd><p>Load the history from the specified file.</p></dd></dl><dl><dt class="spec value" id="val-clear_screen"><a href="#val-clear_screen" class="anchor"></a><code><span class="keyword">val</span> clear_screen : unit <span>&#45;&gt;</span> unit</code></dt><dd><p>Clear the screen; used to handle CTRL+L</p></dd></dl><dl><dt class="spec value" id="val-catch_break"><a href="#val-catch_break" class="anchor"></a><code><span class="keyword">val</span> catch_break : bool <span>&#45;&gt;</span> unit</code></dt><dd><p>If <code>true</code>, <code>ctrl-c</code> during a call to <a href="index.html#val-linenoise"><code>linenoise</code></a> will raise <code>Sys.Break</code> instead of returning an empty string.</p><dl><dt>since</dt><dd>1.1</dd></dl></dd></dl><dl><dt class="spec value" id="val-set_multiline"><a href="#val-set_multiline" class="anchor"></a><code><span class="keyword">val</span> set_multiline : bool <span>&#45;&gt;</span> unit</code></dt><dd><p>Set if to use or not use the multi line mode.</p></dd></dl><dl><dt class="spec value" id="val-print_keycodes"><a href="#val-print_keycodes" class="anchor"></a><code><span class="keyword">val</span> print_keycodes : unit <span>&#45;&gt;</span> unit</code></dt><dd><p>This special mode is used by linenoise in order to print scan codes on screen for debugging / development purposes.</p></dd></dl><dl><dt class="spec type" id="type-hint_color"><a href="#type-hint_color" class="anchor"></a><code><span class="keyword">type</span> hint_color</code><code> = </code><table class="variant"><tr id="type-hint_color.Red" class="anchored"><td class="def constructor"><a href="#type-hint_color.Red" class="anchor"></a><code>| </code><code><span class="constructor">Red</span></code></td></tr><tr id="type-hint_color.Green" class="anchored"><td class="def constructor"><a href="#type-hint_color.Green" class="anchor"></a><code>| </code><code><span class="constructor">Green</span></code></td></tr><tr id="type-hint_color.Yellow" class="anchored"><td class="def constructor"><a href="#type-hint_color.Yellow" class="anchor"></a><code>| </code><code><span class="constructor">Yellow</span></code></td></tr><tr id="type-hint_color.Blue" class="anchored"><td class="def constructor"><a href="#type-hint_color.Blue" class="anchor"></a><code>| </code><code><span class="constructor">Blue</span></code></td></tr><tr id="type-hint_color.Magenta" class="anchored"><td class="def constructor"><a href="#type-hint_color.Magenta" class="anchor"></a><code>| </code><code><span class="constructor">Magenta</span></code></td></tr><tr id="type-hint_color.Cyan" class="anchored"><td class="def constructor"><a href="#type-hint_color.Cyan" class="anchor"></a><code>| </code><code><span class="constructor">Cyan</span></code></td></tr><tr id="type-hint_color.White" class="anchored"><td class="def constructor"><a href="#type-hint_color.White" class="anchor"></a><code>| </code><code><span class="constructor">White</span></code></td></tr></table></dt><dd><p>What color you want the hints to be.</p></dd></dl><dl><dt class="spec value" id="val-set_hints_callback"><a href="#val-set_hints_callback" class="anchor"></a><code><span class="keyword">val</span> set_hints_callback : (string <span>&#45;&gt;</span> (string * <a href="index.html#type-hint_color">hint_color</a> * bool) option) <span>&#45;&gt;</span> unit</code></dt><dd><p>Set a hints callback, callback gets a string, aka the line input, and you get a chance to give a hint to the user. Example, imagine if user types git remote add, then you can give a hint of &lt;this is where you add a remote name&gt; &lt;this is where you add the remote's URL&gt;, see animated gif in source repo for clear example. Returned tuple represents the hint message, color, and whether it ought to be bold.</p></dd></dl></div></body></html>