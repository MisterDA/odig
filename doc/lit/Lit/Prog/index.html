<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Prog (lit.Lit.Prog)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../../index.html">lit</a> &#x00BB; <a href="../index.html">Lit</a> &#x00BB; Prog</nav><h1>Module <code>Lit.Prog</code></h1><p>GPU programs</p><p>A GPU program is a set of linked <a href="index.html#shaders"><span>shaders</span></a>. Each shader defines a transformation that is applied on the rendering pipeline that transforms the vertex stream to fragments. Programs can be shared among effects.</p></header><section><header><h2 id="locs"><a href="#locs" class="anchor"></a>Source locations</h2><p>Depending on the GPU driver a renderer <em>should</em> be able to report precise source file locations on compilation errors.</p><p>If shader sources are loaded from external sources, specify their provenance with the <code>loc</code> argument of <a href="index.html#type-insert"><code>insert</code></a> and <a href="index.html#type-shader"><code>shader</code></a>.</p><p>If they are written directly in the OCaml source code files, compile them with <code>-g</code>. For errors to be reported without offset miscalculations you need to open the source string on the line of the call to <a href="index.html#type-insert"><code>insert</code></a> or <a href="index.html#type-shader"><code>shader</code></a>. For example:</p><pre>Prog.shader `Vertex &quot; &lt;--- This is important
  ... &quot;</pre><p>otherwise the reported lines may be off.</p></header><dl><dt class="spec type" id="type-loc"><a href="#type-loc" class="anchor"></a><code><span class="keyword">type </span>loc</code><span class="keyword"> = </span><code>[ </code><table class="variant"><tr id="type-loc.Loc" class="anchored"><td class="def constructor"><a href="#type-loc.Loc" class="anchor"></a><code><span class="keyword">| </span></code><code>`Loc<span class="keyword"> of </span>string<span class="keyword"> * </span>int</code></td></tr><tr id="type-loc.Unknown" class="anchored"><td class="def constructor"><a href="#type-loc.Unknown" class="anchor"></a><code><span class="keyword">| </span></code><code>`Unknown</code></td></tr></table><code> ]</code></dt><dd><p>The type for source locations. File name and one-based line number or unknown.</p></dd></dl><dl><dt class="spec value" id="val-pp_loc"><a href="#val-pp_loc" class="anchor"></a><code><span class="keyword">val </span>pp_loc : Format.formatter <span>&#45;&gt;</span> <a href="index.html#type-loc">loc</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>pp_loc ppf loc</code> prints an unspecified representation of <code>loc</code> on <code>ppf</code>.</p></dd></dl></section><section><header><h2 id="inserts"><a href="#inserts" class="anchor"></a>Inserts</h2><p>Inserts can be used for source level, verbatim, textual inclusion (they want to be called <em>includes</em> but that's an OCaml keyword). They are a very primitive form of code reuse.</p></header><dl><dt class="spec type" id="type-insert"><a href="#type-insert" class="anchor"></a><code><span class="keyword">type </span>insert</code></dt><dd><p>The type for textual source inserts.</p></dd></dl><dl><dt class="spec value" id="val-insert"><a href="#val-insert" class="anchor"></a><code><span class="keyword">val </span>insert : ?&#8288;loc:<a href="index.html#type-loc">loc</a> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <a href="index.html#type-insert">insert</a></code></dt><dd><p><code>insert ~loc:(`Loc (f, l)) src</code> is the insert made of <code>src</code> located in file <code>f</code> at line <code>l</code>. If <code>loc</code> is unspecified the location of the function call is used provided the program is compiled with <code>-g</code>.</p></dd></dl></section><section><header><h2 id="shaders"><a href="#shaders" class="anchor"></a>Shaders</h2></header><dl><dt class="spec type" id="type-lang"><a href="#type-lang" class="anchor"></a><code><span class="keyword">type </span>lang</code><span class="keyword"> = </span><code>[ </code><table class="variant"><tr id="type-lang.GLSL" class="anchored"><td class="def constructor"><a href="#type-lang.GLSL" class="anchor"></a><code><span class="keyword">| </span></code><code>`GLSL<span class="keyword"> of </span>int</code></td></tr><tr id="type-lang.GLSL_ES" class="anchored"><td class="def constructor"><a href="#type-lang.GLSL_ES" class="anchor"></a><code><span class="keyword">| </span></code><code>`GLSL_ES<span class="keyword"> of </span>int</code></td></tr></table><code> ]</code></dt><dd><p>The type for shading language version and dialects. Use <code>150</code> for 1.50.</p></dd></dl><dl><dt class="spec type" id="type-shader_stage"><a href="#type-shader_stage" class="anchor"></a><code><span class="keyword">type </span>shader_stage</code><span class="keyword"> = </span><code>[ </code><table class="variant"><tr id="type-shader_stage.Vertex" class="anchored"><td class="def constructor"><a href="#type-shader_stage.Vertex" class="anchor"></a><code><span class="keyword">| </span></code><code>`Vertex</code></td></tr><tr id="type-shader_stage.Tess_control" class="anchored"><td class="def constructor"><a href="#type-shader_stage.Tess_control" class="anchor"></a><code><span class="keyword">| </span></code><code>`Tess_control</code></td></tr><tr id="type-shader_stage.Tess_evaluation" class="anchored"><td class="def constructor"><a href="#type-shader_stage.Tess_evaluation" class="anchor"></a><code><span class="keyword">| </span></code><code>`Tess_evaluation</code></td></tr><tr id="type-shader_stage.Geometry" class="anchored"><td class="def constructor"><a href="#type-shader_stage.Geometry" class="anchor"></a><code><span class="keyword">| </span></code><code>`Geometry</code></td></tr><tr id="type-shader_stage.Fragment" class="anchored"><td class="def constructor"><a href="#type-shader_stage.Fragment" class="anchor"></a><code><span class="keyword">| </span></code><code>`Fragment</code></td></tr><tr id="type-shader_stage.Compute" class="anchored"><td class="def constructor"><a href="#type-shader_stage.Compute" class="anchor"></a><code><span class="keyword">| </span></code><code>`Compute</code></td></tr></table><code> ]</code></dt><dd><p>Shader stages. Note that not all renderers support all shaders stages, see <a href="../Renderer/Cap/index.html#val-shader_stages"><code>Renderer.Cap.shader_stages</code></a>.</p></dd></dl><dl><dt class="spec value" id="val-pp_shader_stage"><a href="#val-pp_shader_stage" class="anchor"></a><code><span class="keyword">val </span>pp_shader_stage : Format.formatter <span>&#45;&gt;</span> <a href="index.html#type-shader_stage">shader_stage</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>pp_shader_stage ppf stage</code> prints an unspecified representatino of <code>stage</code> on <code>ppf</code>.</p></dd></dl><dl><dt class="spec type" id="type-shader"><a href="#type-shader" class="anchor"></a><code><span class="keyword">type </span>shader</code></dt><dd><p>The type for shaders.</p></dd></dl><dl><dt class="spec value" id="val-shader"><a href="#val-shader" class="anchor"></a><code><span class="keyword">val </span>shader : ?&#8288;lang:<a href="index.html#type-lang">lang</a> <span>&#45;&gt;</span> ?&#8288;loc:<a href="index.html#type-loc">loc</a> <span>&#45;&gt;</span> ?&#8288;inserts:<a href="index.html#type-insert">insert</a> list <span>&#45;&gt;</span> <a href="index.html#type-shader_stage">shader_stage</a> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <a href="index.html#type-shader">shader</a></code></dt><dd><p><code>shader ~loc:(`Loc (f, l)) ~inserts stage src</code> is the shader for stage <code>stage</code> made by pre-concatening the inserts <code>inserts</code> to <code>src</code> located in file <code>f</code> at line <code>l</code>. If <code>loc</code> is unspecified the location of the function call is used provided the program is compiled with <code>-g</code>.</p></dd></dl><dl><dt class="spec value" id="val-stage"><a href="#val-stage" class="anchor"></a><code><span class="keyword">val </span>stage : <a href="index.html#type-shader">shader</a> <span>&#45;&gt;</span> <a href="index.html#type-shader_stage">shader_stage</a></code></dt><dd><p><code>stage s</code> is the shader stage of <code>s</code>.</p></dd></dl><dl><dt class="spec value" id="val-loc"><a href="#val-loc" class="anchor"></a><code><span class="keyword">val </span>loc : <a href="index.html#type-shader">shader</a> <span>&#45;&gt;</span> <a href="index.html#type-loc">loc</a></code></dt><dd><p><code>loc s</code> is the location of shader <code>s</code>.</p></dd></dl><dl><dt class="spec value" id="val-lang"><a href="#val-lang" class="anchor"></a><code><span class="keyword">val </span>lang : <a href="index.html#type-shader">shader</a> <span>&#45;&gt;</span> <a href="index.html#type-lang">lang</a> option</code></dt><dd><p><code>lang s</code> is the shading language for shader <code>s</code>.</p></dd></dl><dl><dt class="spec type" id="type-source"><a href="#type-source" class="anchor"></a><code><span class="keyword">type </span>source</code><code><span class="keyword"> = </span>string<span class="keyword"> * </span>(int<span class="keyword"> * </span>string) list</code></dt><dd><p>The type for sources. The actual source and a map from file ids to file names to recognize the #line directives in the source.</p></dd></dl><dl><dt class="spec value" id="val-source"><a href="#val-source" class="anchor"></a><code><span class="keyword">val </span>source : ?&#8288;lang:<a href="index.html#type-lang">lang</a> <span>&#45;&gt;</span> <a href="index.html#type-shader">shader</a> <span>&#45;&gt;</span> <a href="index.html#type-source">source</a></code></dt><dd><p><code>source ?lang s</code> is the source of shader <code>s</code> as will be given to the GPU.</p></dd></dl></section><section><header><h2 id="programs"><a href="#programs" class="anchor"></a>Programs</h2></header><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type </span>t</code><code><span class="keyword"> = </span><a href="../index.html#type-prog">prog</a></code></dt><dd><p>The type for programs.</p></dd></dl><dl><dt class="spec value" id="val-create"><a href="#val-create" class="anchor"></a><code><span class="keyword">val </span>create : ?&#8288;name:string <span>&#45;&gt;</span> ?&#8288;uset:<a href="../Uniform/index.html#type-set">Uniform.set</a> <span>&#45;&gt;</span> <a href="index.html#type-shader">shader</a> list <span>&#45;&gt;</span> <a href="../index.html#type-prog">prog</a></code></dt><dd><p><code>create uset shaders</code> is the program made up of <code>shaders</code>, a list in which each <code>shader_kind</code> should appear at most once. <code>uset</code> define default uniform values (defaults to <a href="../Uniform/index.html#val-empty"><code>Uniform.empty</code></a>).</p></dd></dl><dl><dt class="spec value" id="val-name"><a href="#val-name" class="anchor"></a><code><span class="keyword">val </span>name : <a href="../index.html#type-prog">prog</a> <span>&#45;&gt;</span> string</code></dt><dd><p><code>name p</code> is the program name.</p></dd></dl><dl><dt class="spec value" id="val-uniforms"><a href="#val-uniforms" class="anchor"></a><code><span class="keyword">val </span>uniforms : <a href="../index.html#type-prog">prog</a> <span>&#45;&gt;</span> <a href="../Uniform/index.html#type-set">Uniform.set</a></code></dt><dd><p><code>uniforms p</code> are the default uniforms of <code>p</code>.</p></dd></dl><dl><dt class="spec value" id="val-shaders"><a href="#val-shaders" class="anchor"></a><code><span class="keyword">val </span>shaders : <a href="../index.html#type-prog">prog</a> <span>&#45;&gt;</span> <a href="index.html#type-shader">shader</a> list</code></dt><dd><p><code>shaders p</code> is the shaders of <code>p</code>.</p></dd></dl></section></div></body></html>