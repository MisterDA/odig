<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Tex (lit.Lit.Tex)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../../index.html">lit</a> &#x00BB; <a href="../index.html">Lit</a> &#x00BB; Tex</nav><h1>Module <code>Lit.Tex</code></h1><p>Textures.</p><p><b>TODO</b> We need to introduce Tex.sampler which will map to GL's 3.3 sampler objects. A tex uniform will then be a pair Tex.t * Tex.sampler (mmh except for Buffer textures...). The fallback should simply set the parameters and we should say that in renderers that don't support rendering a tex with different Tex.sampler won't work.</p><nav class="toc"><ul><li><a href="#textures">Textures</a></li></ul></nav></header><section><header><h2 id="textures"><a href="#textures" class="anchor"></a>Textures</h2></header><dl><dt class="spec type" id="type-wrap"><a href="#type-wrap" class="anchor"></a><code><span class="keyword">type </span>wrap</code><span class="keyword"> = </span><code>[ </code><table class="variant"><tr id="type-wrap.Repeat" class="anchored"><td class="def constructor"><a href="#type-wrap.Repeat" class="anchor"></a><code><span class="keyword">| </span></code><code>`Repeat</code></td></tr><tr id="type-wrap.Mirrored_repeat" class="anchored"><td class="def constructor"><a href="#type-wrap.Mirrored_repeat" class="anchor"></a><code><span class="keyword">| </span></code><code>`Mirrored_repeat</code></td></tr><tr id="type-wrap.Clamp_to_edge" class="anchored"><td class="def constructor"><a href="#type-wrap.Clamp_to_edge" class="anchor"></a><code><span class="keyword">| </span></code><code>`Clamp_to_edge</code></td></tr></table><code> ]</code></dt><dd><p>The type for texture wraps</p></dd></dl><dl><dt class="spec value" id="val-pp_wrap"><a href="#val-pp_wrap" class="anchor"></a><code><span class="keyword">val </span>pp_wrap : Format.formatter <span>&#45;&gt;</span> <a href="index.html#type-wrap">wrap</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>pp_wrap ppf w</code> prints a textual representation of <code>w</code> on <code>ppf</code></p></dd></dl><dl><dt class="spec type" id="type-mag_filter"><a href="#type-mag_filter" class="anchor"></a><code><span class="keyword">type </span>mag_filter</code><span class="keyword"> = </span><code>[ </code><table class="variant"><tr id="type-mag_filter.Linear" class="anchored"><td class="def constructor"><a href="#type-mag_filter.Linear" class="anchor"></a><code><span class="keyword">| </span></code><code>`Linear</code></td></tr><tr id="type-mag_filter.Nearest" class="anchored"><td class="def constructor"><a href="#type-mag_filter.Nearest" class="anchor"></a><code><span class="keyword">| </span></code><code>`Nearest</code></td></tr></table><code> ]</code></dt><dd><p>The type for magnification filters.</p></dd></dl><dl><dt class="spec value" id="val-pp_mag_filter"><a href="#val-pp_mag_filter" class="anchor"></a><code><span class="keyword">val </span>pp_mag_filter : Format.formatter <span>&#45;&gt;</span> <a href="index.html#type-mag_filter">mag_filter</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>pp_mag_filter ppf m</code> prints a textual representation of <code>m</code> on <code>ppf</code></p></dd></dl><dl><dt class="spec type" id="type-min_filter"><a href="#type-min_filter" class="anchor"></a><code><span class="keyword">type </span>min_filter</code><span class="keyword"> = </span><code>[ </code><table class="variant"><tr id="type-min_filter.Linear" class="anchored"><td class="def constructor"><a href="#type-min_filter.Linear" class="anchor"></a><code><span class="keyword">| </span></code><code>`Linear</code></td></tr><tr id="type-min_filter.Linear_mipmap_linear" class="anchored"><td class="def constructor"><a href="#type-min_filter.Linear_mipmap_linear" class="anchor"></a><code><span class="keyword">| </span></code><code>`Linear_mipmap_linear</code></td></tr><tr id="type-min_filter.Linear_mipmap_nearest" class="anchored"><td class="def constructor"><a href="#type-min_filter.Linear_mipmap_nearest" class="anchor"></a><code><span class="keyword">| </span></code><code>`Linear_mipmap_nearest</code></td></tr><tr id="type-min_filter.Nearest" class="anchored"><td class="def constructor"><a href="#type-min_filter.Nearest" class="anchor"></a><code><span class="keyword">| </span></code><code>`Nearest</code></td></tr><tr id="type-min_filter.Nearest_mipmap_linear" class="anchored"><td class="def constructor"><a href="#type-min_filter.Nearest_mipmap_linear" class="anchor"></a><code><span class="keyword">| </span></code><code>`Nearest_mipmap_linear</code></td></tr><tr id="type-min_filter.Nearest_mipmap_nearest" class="anchored"><td class="def constructor"><a href="#type-min_filter.Nearest_mipmap_nearest" class="anchor"></a><code><span class="keyword">| </span></code><code>`Nearest_mipmap_nearest</code></td></tr></table><code> ]</code></dt><dd><p>The type for minification filters.</p></dd></dl><dl><dt class="spec value" id="val-pp_min_filter"><a href="#val-pp_min_filter" class="anchor"></a><code><span class="keyword">val </span>pp_min_filter : Format.formatter <span>&#45;&gt;</span> <a href="index.html#type-min_filter">min_filter</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>pp_mag_filter ppf m</code> prints a textual representation of <code>m</code> on <code>ppf</code></p></dd></dl><dl><dt class="spec type" id="type-kind"><a href="#type-kind" class="anchor"></a><code><span class="keyword">type </span>kind</code><span class="keyword"> = </span><code>[ </code><table class="variant"><tr id="type-kind.D1" class="anchored"><td class="def constructor"><a href="#type-kind.D1" class="anchor"></a><code><span class="keyword">| </span></code><code>`D1</code></td></tr><tr id="type-kind.D2" class="anchored"><td class="def constructor"><a href="#type-kind.D2" class="anchor"></a><code><span class="keyword">| </span></code><code>`D2</code></td></tr><tr id="type-kind.D3" class="anchored"><td class="def constructor"><a href="#type-kind.D3" class="anchor"></a><code><span class="keyword">| </span></code><code>`D3</code></td></tr><tr id="type-kind.D2_ms" class="anchored"><td class="def constructor"><a href="#type-kind.D2_ms" class="anchor"></a><code><span class="keyword">| </span></code><code>`D2_ms</code></td></tr><tr id="type-kind.D3_ms" class="anchored"><td class="def constructor"><a href="#type-kind.D3_ms" class="anchor"></a><code><span class="keyword">| </span></code><code>`D3_ms</code></td></tr><tr id="type-kind.Buffer" class="anchored"><td class="def constructor"><a href="#type-kind.Buffer" class="anchor"></a><code><span class="keyword">| </span></code><code>`Buffer</code></td></tr></table><code> ]</code></dt><dd><p>The type for kinds of textures. TODO add `Cube_map</p></dd></dl><dl><dt class="spec value" id="val-pp_kind"><a href="#val-pp_kind" class="anchor"></a><code><span class="keyword">val </span>pp_kind : Format.formatter <span>&#45;&gt;</span> <a href="index.html#type-kind">kind</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>pp_kind ppf k</code> prints a textual representation of <code>k</code> on <code>ppf</code></p></dd></dl><dl><dt class="spec type" id="type-sample_format"><a href="#type-sample_format" class="anchor"></a><code><span class="keyword">type </span>sample_format</code><span class="keyword"> = </span><code>[ </code><table class="variant"><tr id="type-sample_format.D1" class="anchored"><td class="def constructor"><a href="#type-sample_format.D1" class="anchor"></a><code><span class="keyword">| </span></code><code>`D1<span class="keyword"> of </span>Gg.Ba.scalar_type<span class="keyword"> * </span>bool</code></td></tr><tr id="type-sample_format.D2" class="anchored"><td class="def constructor"><a href="#type-sample_format.D2" class="anchor"></a><code><span class="keyword">| </span></code><code>`D2<span class="keyword"> of </span>Gg.Ba.scalar_type<span class="keyword"> * </span>bool</code></td></tr><tr id="type-sample_format.D3" class="anchored"><td class="def constructor"><a href="#type-sample_format.D3" class="anchor"></a><code><span class="keyword">| </span></code><code>`D3<span class="keyword"> of </span>Gg.Ba.scalar_type<span class="keyword"> * </span>bool</code></td></tr><tr id="type-sample_format.D4" class="anchored"><td class="def constructor"><a href="#type-sample_format.D4" class="anchor"></a><code><span class="keyword">| </span></code><code>`D4<span class="keyword"> of </span>Gg.Ba.scalar_type<span class="keyword"> * </span>bool</code></td></tr><tr id="type-sample_format.SRGB" class="anchored"><td class="def constructor"><a href="#type-sample_format.SRGB" class="anchor"></a><code><span class="keyword">| </span></code><code>`SRGB<span class="keyword"> of </span>[ `UInt8 ]</code></td></tr><tr id="type-sample_format.SRGBA" class="anchored"><td class="def constructor"><a href="#type-sample_format.SRGBA" class="anchor"></a><code><span class="keyword">| </span></code><code>`SRGBA<span class="keyword"> of </span>[ `UInt8 ]</code></td></tr><tr id="type-sample_format.Depth" class="anchored"><td class="def constructor"><a href="#type-sample_format.Depth" class="anchor"></a><code><span class="keyword">| </span></code><code>`Depth<span class="keyword"> of </span>[ `UInt16<span class="keyword"> | </span>`UInt24<span class="keyword"> | </span>`Float32 ]</code></td></tr><tr id="type-sample_format.Stencil" class="anchored"><td class="def constructor"><a href="#type-sample_format.Stencil" class="anchor"></a><code><span class="keyword">| </span></code><code>`Stencil<span class="keyword"> of </span>[ `UInt8 ]</code></td></tr><tr id="type-sample_format.Depth_stencil" class="anchored"><td class="def constructor"><a href="#type-sample_format.Depth_stencil" class="anchor"></a><code><span class="keyword">| </span></code><code>`Depth_stencil<span class="keyword"> of </span>[ `UInt24_UInt8<span class="keyword"> | </span>`Float32_UInt8 ]</code></td></tr></table><code> ]</code></dt><dd><p>The type for texture sample formats. This defines the internal texture format and how <a href="index.html#type-init"><code>init</code></a> buffers are read (dimension). For <code>`D1</code> to <code>`D4</code> the boolean indicates if normalization should be performed for signed and unsigned integers scalar types.</p><p><b>Note.</b> Renderers may not support all sample formats. This can by testing membership in <span class="xref-unresolved" title="unresolved reference to &quot;Renderer.Tex.sample_formats&quot;"><span class="xref-unresolved" title="unresolved reference to &quot;Renderer.Tex&quot;"><a href="../index.html#module-Renderer"><code>Renderer</code></a>.Tex</span>.sample_formats</span>.</p></dd></dl><dl><dt class="spec value" id="val-pp_sample_format"><a href="#val-pp_sample_format" class="anchor"></a><code><span class="keyword">val </span>pp_sample_format : Format.formatter <span>&#45;&gt;</span> <a href="index.html#type-sample_format">sample_format</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>pp_sample_format ppf sf</code> prints a textual representation of <code>sp</code> on <code>ppf</code>.</p></dd></dl><dl><dt class="spec type" id="type-init"><a href="#type-init" class="anchor"></a><code><span class="keyword">type </span>init</code><span class="keyword"> = </span><code>[ </code><table class="variant"><tr id="type-init.D1" class="anchored"><td class="def constructor"><a href="#type-init.D1" class="anchor"></a><code><span class="keyword">| </span></code><code>`D1<span class="keyword"> of </span><a href="index.html#type-sample_format">sample_format</a><span class="keyword"> * </span>float<span class="keyword"> * </span><a href="../Buf/index.html#type-t">Buf.t</a> option</code></td></tr><tr id="type-init.D2" class="anchored"><td class="def constructor"><a href="#type-init.D2" class="anchor"></a><code><span class="keyword">| </span></code><code>`D2<span class="keyword"> of </span><a href="index.html#type-sample_format">sample_format</a><span class="keyword"> * </span>Gg.size2<span class="keyword"> * </span><a href="../Buf/index.html#type-t">Buf.t</a> option</code></td></tr><tr id="type-init.D3" class="anchored"><td class="def constructor"><a href="#type-init.D3" class="anchor"></a><code><span class="keyword">| </span></code><code>`D3<span class="keyword"> of </span><a href="index.html#type-sample_format">sample_format</a><span class="keyword"> * </span>Gg.size3<span class="keyword"> * </span><a href="../Buf/index.html#type-t">Buf.t</a> option</code></td></tr><tr id="type-init.D2_ms" class="anchored"><td class="def constructor"><a href="#type-init.D2_ms" class="anchor"></a><code><span class="keyword">| </span></code><code>`D2_ms<span class="keyword"> of </span><a href="index.html#type-sample_format">sample_format</a><span class="keyword"> * </span>Gg.size2<span class="keyword"> * </span>int<span class="keyword"> * </span>bool</code></td></tr><tr id="type-init.D3_ms" class="anchored"><td class="def constructor"><a href="#type-init.D3_ms" class="anchor"></a><code><span class="keyword">| </span></code><code>`D3_ms<span class="keyword"> of </span><a href="index.html#type-sample_format">sample_format</a><span class="keyword"> * </span>Gg.size3<span class="keyword"> * </span>int<span class="keyword"> * </span>bool</code></td></tr><tr id="type-init.Buffer" class="anchored"><td class="def constructor"><a href="#type-init.Buffer" class="anchor"></a><code><span class="keyword">| </span></code><code>`Buffer<span class="keyword"> of </span><a href="index.html#type-sample_format">sample_format</a><span class="keyword"> * </span><a href="../Buf/index.html#type-t">Buf.t</a></code></td></tr></table><code> ]</code></dt><dd><p>The type for texture initialisation, determines the kind of the the texture.</p><p>Buffers image data pixel by pixel in row order then layer order, the first pixel of the buffer is the image's lower left frontmost pixel.</p></dd></dl><dl><dt class="spec value" id="val-pp_init"><a href="#val-pp_init" class="anchor"></a><code><span class="keyword">val </span>pp_init : Format.formatter <span>&#45;&gt;</span> <a href="index.html#type-init">init</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>pp_init ppf init</code> prints a textual representation of <code>init</code> on <code>ppf</code>.</p></dd></dl><dl><dt class="spec value" id="val-init_of_raster"><a href="#val-init_of_raster" class="anchor"></a><code><span class="keyword">val </span>init_of_raster : ?&#8288;buf:bool <span>&#45;&gt;</span> ?&#8288;cpu_autorelease:bool <span>&#45;&gt;</span> ?&#8288;usage:<a href="../Buf/index.html#type-usage">Buf.usage</a> <span>&#45;&gt;</span> ?&#8288;kind:<a href="index.html#type-kind">kind</a> <span>&#45;&gt;</span> ?&#8288;sample_format:<a href="index.html#type-sample_format">sample_format</a> <span>&#45;&gt;</span> ?&#8288;norm:bool <span>&#45;&gt;</span> Gg.raster <span>&#45;&gt;</span> <a href="index.html#type-init">init</a></code></dt><dd><p><code>init_of_raster r</code> is a texture init value derived from <code>raster</code>.</p><ul><li><code>buf</code>, if <code>true</code> (default) or <code>kind</code> is <code>`Buffer</code>, a Lit buffer value is created for the raster's buffer value. <code>cpu_autorelease</code> and <code>usage</code> are passed to <a href="../Buf/index.html#val-create"><code>Buf.create</code></a>.</li><li><code>sample_format</code>, if unspecified it has <code>r</code>'s sample format scalar type and dimension. Packed raster sample formats are mapped to <code>`D1</code> texture sample format. <code>norm</code> determines the normalization if <code>sample_format</code> is unspecified (see <a href="index.html#type-sample_format"><code>sample_format</code></a>, defaults to <code>true</code>).</li><li><code>kind</code>, if unspecified it is automatically derived to <code>`D1</code>, <code>`D2</code> or <code>`D3</code> according to the raster's dimension.</li></ul><dl><dt>raises Invalid_argument</dt><dd><p>If the raster's sample format dimension is greater than 4 or if <code>kind</code> specifies a multisample texture.</p></dd></dl></dd></dl><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type </span>t</code><code><span class="keyword"> = </span><a href="../index.html#type-tex">tex</a></code></dt><dd><p>The type for textures.</p></dd></dl><dl><dt class="spec value" id="val-nil"><a href="#val-nil" class="anchor"></a><code><span class="keyword">val </span>nil : <a href="../index.html#type-tex">tex</a></code></dt><dd><p><code>nil</code> is a stub texture that can be used for example to initialize texture uniforms. Trying to render the nil texture results in an error.</p></dd></dl><dl><dt class="spec value" id="val-create"><a href="#val-create" class="anchor"></a><code><span class="keyword">val </span>create : ?&#8288;wrap_s:<a href="index.html#type-wrap">wrap</a> <span>&#45;&gt;</span> ?&#8288;wrap_t:<a href="index.html#type-wrap">wrap</a> <span>&#45;&gt;</span> ?&#8288;wrap_r:<a href="index.html#type-wrap">wrap</a> <span>&#45;&gt;</span> ?&#8288;mipmaps:bool <span>&#45;&gt;</span> ?&#8288;min_filter:<a href="index.html#type-min_filter">min_filter</a> <span>&#45;&gt;</span> ?&#8288;mag_filter:<a href="index.html#type-mag_filter">mag_filter</a> <span>&#45;&gt;</span> ?&#8288;buf_autorelease:bool <span>&#45;&gt;</span> <a href="index.html#type-init">init</a> <span>&#45;&gt;</span> <a href="../index.html#type-tex">tex</a></code></dt><dd><ul><li><code>wrap_s, wrap_t, wrap_r</code>, wrapping behaviour, if applicable, along <code>s</code>, <code>t</code> and <code>r</code> dimensions. Defaults to `Repeat.</li><li><code>mipmaps</code>, if <code>true</code> generates mipmaps. Defaults to <code>false</code>.</li><li><code>min_filter</code>, if applicable, minification filter. Defaults to <code>`Nearest_mipmap_linear</code>.</li><li><code>mag_filter</code>, if applicable, magnification filter. Defaults to <code>`Nearest</code>.</li><li><code>buf_autorelease</code>, doesn't keep a reference on buf once texture has been uploaded to gpu. Defaults to <code>true</code> for `D1 to `D3 but false on `Buffer.</li></ul><dl><dt>raises Invalid_argumnet</dt><dd><p>if the <code>init</code> spec is inconsistent.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-sample_format"><a href="#val-sample_format" class="anchor"></a><code><span class="keyword">val </span>sample_format : <a href="../index.html#type-tex">tex</a> <span>&#45;&gt;</span> <a href="index.html#type-sample_format">sample_format</a></code></dt><dd><p><code>sample_format t</code> is <code>t</code>'s sample format.</p></dd></dl><dl><dt class="spec value" id="val-kind"><a href="#val-kind" class="anchor"></a><code><span class="keyword">val </span>kind : <a href="../index.html#type-tex">tex</a> <span>&#45;&gt;</span> <a href="index.html#type-kind">kind</a></code></dt><dd><p><code>kind t</code> is <code>t</code>'s texture kind.</p></dd></dl><dl><dt class="spec value" id="val-size2"><a href="#val-size2" class="anchor"></a><code><span class="keyword">val </span>size2 : <a href="../index.html#type-tex">tex</a> <span>&#45;&gt;</span> Gg.size2</code></dt><dd><p><code>size2 t</code> is <code>t</code>'s width and height.</p></dd></dl><dl><dt class="spec value" id="val-size3"><a href="#val-size3" class="anchor"></a><code><span class="keyword">val </span>size3 : <a href="../index.html#type-tex">tex</a> <span>&#45;&gt;</span> Gg.size3</code></dt><dd><p><code>size3 t</code> is <code>t</code>'s width and height in samples.</p></dd></dl><dl><dt class="spec value" id="val-buf"><a href="#val-buf" class="anchor"></a><code><span class="keyword">val </span>buf : <a href="../index.html#type-tex">tex</a> <span>&#45;&gt;</span> <a href="../Buf/index.html#type-t">Buf.t</a> option</code></dt><dd><p><code>buf</code> is <code>t</code>'s buffer if any.</p></dd></dl><dl><dt class="spec value" id="val-set_buf"><a href="#val-set_buf" class="anchor"></a><code><span class="keyword">val </span>set_buf : <a href="../index.html#type-tex">tex</a> <span>&#45;&gt;</span> <a href="../Buf/index.html#type-t">Buf.t</a> option <span>&#45;&gt;</span> unit</code></dt><dd><p><code>set_buf t b</code> sets <code>t</code>'s buffer to b.</p></dd></dl><dl><dt class="spec value" id="val-buf_autorelease"><a href="#val-buf_autorelease" class="anchor"></a><code><span class="keyword">val </span>buf_autorelease : <a href="../index.html#type-tex">tex</a> <span>&#45;&gt;</span> bool</code></dt><dt class="spec value" id="val-set_buf_autorelease"><a href="#val-set_buf_autorelease" class="anchor"></a><code><span class="keyword">val </span>set_buf_autorelease : <a href="../index.html#type-tex">tex</a> <span>&#45;&gt;</span> bool <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-gpu_update"><a href="#val-gpu_update" class="anchor"></a><code><span class="keyword">val </span>gpu_update : <a href="../index.html#type-tex">tex</a> <span>&#45;&gt;</span> bool</code></dt><dt class="spec value" id="val-set_gpu_update"><a href="#val-set_gpu_update" class="anchor"></a><code><span class="keyword">val </span>set_gpu_update : <a href="../index.html#type-tex">tex</a> <span>&#45;&gt;</span> bool <span>&#45;&gt;</span> unit</code></dt><dd><p>Needs to be called if you change the underlying buffer and want buffer changes to be picked up.</p></dd></dl><dl><dt class="spec value" id="val-wrap_s"><a href="#val-wrap_s" class="anchor"></a><code><span class="keyword">val </span>wrap_s : <a href="../index.html#type-tex">tex</a> <span>&#45;&gt;</span> <a href="index.html#type-wrap">wrap</a></code></dt><dd><p><code>wrap_s t</code> is <code>t</code>'s texturing wrapping mode in the s dimension.</p></dd></dl><dl><dt class="spec value" id="val-wrap_t"><a href="#val-wrap_t" class="anchor"></a><code><span class="keyword">val </span>wrap_t : <a href="../index.html#type-tex">tex</a> <span>&#45;&gt;</span> <a href="index.html#type-wrap">wrap</a></code></dt><dd><p><code>wrap_t t</code> is <code>t</code>'s texturing wrapping mode in the t dimension.</p></dd></dl><dl><dt class="spec value" id="val-wrap_r"><a href="#val-wrap_r" class="anchor"></a><code><span class="keyword">val </span>wrap_r : <a href="../index.html#type-tex">tex</a> <span>&#45;&gt;</span> <a href="index.html#type-wrap">wrap</a></code></dt><dd><p><code>wrap_r t</code> is <code>t</code>'s texturing wrapping mode in the r dimension.</p></dd></dl><dl><dt class="spec value" id="val-mipmaps"><a href="#val-mipmaps" class="anchor"></a><code><span class="keyword">val </span>mipmaps : <a href="../index.html#type-tex">tex</a> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>mipmaps t</code> is <code>true</code> if mipmaps are generated for texture.</p></dd></dl><dl><dt class="spec value" id="val-min_filter"><a href="#val-min_filter" class="anchor"></a><code><span class="keyword">val </span>min_filter : <a href="../index.html#type-tex">tex</a> <span>&#45;&gt;</span> <a href="index.html#type-min_filter">min_filter</a></code></dt><dd><p><code>min_filter t</code> is <code>t</code>'s minification filter.</p></dd></dl><dl><dt class="spec value" id="val-mag_filter"><a href="#val-mag_filter" class="anchor"></a><code><span class="keyword">val </span>mag_filter : <a href="../index.html#type-tex">tex</a> <span>&#45;&gt;</span> <a href="index.html#type-mag_filter">mag_filter</a></code></dt><dd><p><code>min_filter t</code> is <code>t</code>'s magnification filter.</p></dd></dl><dl><dt class="spec value" id="val-multisample"><a href="#val-multisample" class="anchor"></a><code><span class="keyword">val </span>multisample : <a href="../index.html#type-tex">tex</a> <span>&#45;&gt;</span> int<span class="keyword"> * </span>bool</code></dt><dd><p><code>multisample t</code> is <code>t</code>'s multisample parameters.</p><dl><dt>raises Invalid_argument</dt><dd><p>if <code>t</code>'s kind is not <code>`D{2,3}_ms</code>.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-pp"><a href="#val-pp" class="anchor"></a><code><span class="keyword">val </span>pp : Format.formatter <span>&#45;&gt;</span> <a href="../index.html#type-tex">tex</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>pp ppf t</code> is a textual represenation of <code>t</code> on <code>ppf</code>.</p></dd></dl></section></div></body></html>