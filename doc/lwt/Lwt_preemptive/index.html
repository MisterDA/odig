<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Lwt_preemptive (lwt.Lwt_preemptive)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../index.html">lwt</a> &#x00BB; Lwt_preemptive</nav><h1>Module <code>Lwt_preemptive</code></h1><p>This module allows to mix preemptive threads with <code>Lwt</code> cooperative threads. It maintains an extensible pool of preemptive threads to which you can detach computations.</p><p>When compiling or linking programs that use <code>Lwt_preemptive</code>, you should pass the <code>-thread</code> or <code>-vmthread</code> option. This depends on your build system. For OCamlbuild, add <code>true: thread</code> to <code>_tags</code>. For OASIS, add <code>threads</code> to <code>BuildDepends</code> in <code>_oasis</code>.</p></header><dl><dt class="spec value" id="val-detach"><a href="#val-detach" class="anchor"></a><code><span class="keyword">val </span>detach : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> Lwt.t</code></dt><dd><p><code>detach f x</code> runs the computation <code>f x</code> in a separate preemptive thread. <code>detach</code> evaluates to an Lwt promise, which is pending until the preemptive thread completes.</p><p><code>detach</code> calls <a href="index.html#val-simple_init"><code>simple_init</code></a> internally, which means that the number of preemptive threads is capped by default at four. If you would like a higher limit, call <a href="index.html#val-init"><code>init</code></a> or <a href="index.html#val-set_bounds"><code>set_bounds</code></a> directly.</p><p>Note that Lwt thread-local storage (i.e., <span class="xref-unresolved" title="unresolved reference to &quot;Lwt.with_value&quot;"><code>Lwt</code>.with_value</span>) cannot be safely used from within <code>f</code>. The same goes for most of the rest of Lwt. If you need to run an Lwt thread in <code>f</code>, use <a href="index.html#val-run_in_main"><code>run_in_main</code></a>.</p></dd></dl><dl><dt class="spec value" id="val-run_in_main"><a href="#val-run_in_main" class="anchor"></a><code><span class="keyword">val </span>run_in_main : (unit <span>&#45;&gt;</span> <span class="type-var">'a</span> Lwt.t) <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p><code>run_in_main f</code> can be called from a detached computation to execute <code>f ()</code> in the main preemptive thread, i.e. the one executing <span class="xref-unresolved" title="unresolved reference to &quot;Lwt_main.run&quot;"><code>Lwt_main</code>.run</span>. <code>run_in_main f</code> blocks until <code>f ()</code> completes, then returns its result. If <code>f ()</code> raises an exception, <code>run_in_main f</code> raises the same exception.</p><p><span class="xref-unresolved" title="unresolved reference to &quot;Lwt.with_value&quot;"><code>Lwt</code>.with_value</span> may be used inside <code>f ()</code>. <span class="xref-unresolved" title="unresolved reference to &quot;Lwt.get&quot;"><code>Lwt</code>.get</span> can correctly retrieve values set this way inside <code>f ()</code>, but not values set using <span class="xref-unresolved" title="unresolved reference to &quot;Lwt.with_value&quot;"><code>Lwt</code>.with_value</span> outside <code>f ()</code>.</p></dd></dl><dl><dt class="spec value" id="val-init"><a href="#val-init" class="anchor"></a><code><span class="keyword">val </span>init : int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> (string <span>&#45;&gt;</span> unit) <span>&#45;&gt;</span> unit</code></dt><dd><p><code>init min max log</code> initialises this module. i.e. it launches the minimum number of preemptive threads and starts the <b>dispatcher</b>.</p><dl><dt>parameter min</dt><dd><p>is the minimum number of threads</p></dd></dl><dl><dt>parameter max</dt><dd><p>is the maximum number of threads</p></dd></dl><dl><dt>parameter log</dt><dd><p>is used to log error messages</p><p>If <a href="index.html"><code>Lwt_preemptive</code></a> has already been initialised, this call only modify bounds and the log function.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-simple_init"><a href="#val-simple_init" class="anchor"></a><code><span class="keyword">val </span>simple_init : unit <span>&#45;&gt;</span> unit</code></dt><dd><p><code>simple_init ()</code> checks if the library is not yet initialized, and if not, does a <i>simple initialization</i>. The minimum number of threads is set to zero, maximum to four, and the log function is left unchanged, i.e. the default built-in logging function is used. See <a href="index.html#val-init"><code>Lwt_preemptive.init</code></a>.</p><p>Note: this function is automatically called by <a href="index.html#val-detach"><code>detach</code></a>.</p></dd></dl><dl><dt class="spec value" id="val-get_bounds"><a href="#val-get_bounds" class="anchor"></a><code><span class="keyword">val </span>get_bounds : unit <span>&#45;&gt;</span> int<span class="keyword"> * </span>int</code></dt><dd><p><code>get_bounds ()</code> returns the minimum and the maximum number of preemptive threads.</p></dd></dl><dl><dt class="spec value" id="val-set_bounds"><a href="#val-set_bounds" class="anchor"></a><code><span class="keyword">val </span>set_bounds : (int<span class="keyword"> * </span>int) <span>&#45;&gt;</span> unit</code></dt><dd><p><code>set_bounds (min, max)</code> set the minimum and the maximum number of preemptive threads.</p></dd></dl><dl><dt class="spec value" id="val-set_max_number_of_threads_queued"><a href="#val-set_max_number_of_threads_queued" class="anchor"></a><code><span class="keyword">val </span>set_max_number_of_threads_queued : int <span>&#45;&gt;</span> unit</code></dt><dd><p>Sets the size of the waiting queue, if no more preemptive threads are available. When the queue is full, <a href="index.html#val-detach"><code>detach</code></a> will sleep until a thread is available.</p></dd></dl><dl><dt class="spec value" id="val-get_max_number_of_threads_queued"><a href="#val-get_max_number_of_threads_queued" class="anchor"></a><code><span class="keyword">val </span>get_max_number_of_threads_queued : unit <span>&#45;&gt;</span> int</code></dt><dd><p>Returns the size of the waiting queue, if no more threads are available</p></dd></dl><dl><dt class="spec value" id="val-nbthreads"><a href="#val-nbthreads" class="anchor"></a><code><span class="keyword">val </span>nbthreads : unit <span>&#45;&gt;</span> int</code></dt><dd><p>/*</p></dd></dl><dl><dt class="spec value" id="val-nbthreadsbusy"><a href="#val-nbthreadsbusy" class="anchor"></a><code><span class="keyword">val </span>nbthreadsbusy : unit <span>&#45;&gt;</span> int</code></dt><dt class="spec value" id="val-nbthreadsqueued"><a href="#val-nbthreadsqueued" class="anchor"></a><code><span class="keyword">val </span>nbthreadsqueued : unit <span>&#45;&gt;</span> int</code></dt></dl></div></body></html>