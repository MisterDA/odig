<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Mlt_parser (mlt_parser.Mlt_parser)</title><link rel="stylesheet" href="../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../index.html">mlt_parser</a> &#x00BB; Mlt_parser</nav><h1>Module <code>Mlt_parser</code></h1><p>Code for parsing toplevel expect test files</p></header><dl><dt class="spec type" id="type-chunk"><a href="#type-chunk" class="anchor"></a><code><span class="keyword">type</span> chunk</code><code> = </code><code>{</code><table class="record"><tr id="type-chunk.part" class="anchored"><td class="def field"><a href="#type-chunk.part" class="anchor"></a><code>part : string option;</code></td><td class="doc"><p>The part the chunk is in, None if it's not in any part.</p></td></tr><tr id="type-chunk.phrases" class="anchored"><td class="def field"><a href="#type-chunk.phrases" class="anchor"></a><code>phrases : <a href="../../ppxlib/Ppxlib/index.html#type-toplevel_phrase">Ppxlib.toplevel_phrase</a> list;</code></td></tr><tr id="type-chunk.expectation" class="anchored"><td class="def field"><a href="#type-chunk.expectation" class="anchor"></a><code>expectation : <a href="../../ppx_expect/Expect_test_matcher/Fmt/index.html#type-t">Expect_test_matcher.Std.Fmt.t</a> <a href="../../ppx_expect/Expect_test_matcher/Cst/index.html#type-t">Expect_test_matcher.Std.Cst.t</a> <a href="../../ppx_expect/Expect_test_common/Expectation/index.html#type-t">Expect_test_common.Std.Expectation.t</a>;</code></td></tr><tr id="type-chunk.phrases_loc" class="anchored"><td class="def field"><a href="#type-chunk.phrases_loc" class="anchor"></a><code>phrases_loc : <a href="../../ppxlib/Ppxlib/Location/index.html#type-t">Ppxlib.Location.t</a>;</code></td></tr></table><code>}</code></dt></dl><dl><dt class="spec value" id="val-split_chunks"><a href="#val-split_chunks" class="anchor"></a><code><span class="keyword">val</span> split_chunks : fname:string <span>&#45;&gt;</span> allow_output_patterns:bool <span>&#45;&gt;</span> <a href="../../ppxlib/Ppxlib/index.html#type-toplevel_phrase">Ppxlib.toplevel_phrase</a> list <span>&#45;&gt;</span> <a href="index.html#type-chunk">chunk</a> list * (<a href="../../ppxlib/Ppxlib/index.html#type-toplevel_phrase">Ppxlib.toplevel_phrase</a> list * <a href="../../ppxlib/Ppxlib/index.html#type-position">Ppxlib.position</a> * string option) option</code></dt><dd><p>Recursively parses toplevel phrases (i.e., contiguous units of code separated by <code>;;</code>) into &quot;chunks&quot;, one chunk per <code>%%expect</code> statement.</p><p>For example if the mlt contents are:</p><pre><code class="ml"> let x = 1 + 1;;

 printf &quot;%d&quot; x + 2;;

 [%%expect {|
- : int: 4
|}];;

 print_string &quot;f&quot; ^ &quot;o&quot; ^ &quot;o&quot;;;

 [%%expect {|
- : string: &quot;foo&quot;
|}];;

 print_string 3 + 3 + 3;;</code></pre><p>then you'd have two chunks, where the first has two phrases (<code>&quot;x = 1 + 1&quot;</code> and <code>&quot;printf &quot;%d&quot; x + 2&quot;</code>) and an <code>expectation.body</code> of <code>&quot;: int 4&quot;</code>. The second chunk would have just the one phrase.</p><p><code>&quot;print_line 3 + 3 + 3&quot;</code> is not part of a chunk because there is no expectation following it, so instead it is returned as <code>trailing_code</code>, which is just a list of toplevel phrases with some position metadata.</p><p>&quot;part&quot; refers to <code>@@@part &quot;foo&quot;</code> statements, which are arbitrary section breaks. Each chunk, and the trailing code, belongs to a part (which is just the empty string <code>&quot;&quot;</code> if none has been specified).</p></dd></dl><dl><dt class="spec type" id="type-mlt_block"><a href="#type-mlt_block" class="anchor"></a><code><span class="keyword">type</span> mlt_block</code><code> = </code><table class="variant"><tr id="type-mlt_block.Org" class="anchored"><td class="def constructor"><a href="#type-mlt_block.Org" class="anchor"></a><code>| </code><code><span class="constructor">Org</span> <span class="keyword">of</span> string</code></td></tr><tr id="type-mlt_block.Expect" class="anchored"><td class="def constructor"><a href="#type-mlt_block.Expect" class="anchor"></a><code>| </code><code><span class="constructor">Expect</span> <span class="keyword">of</span> string</code></td></tr><tr id="type-mlt_block.Code" class="anchored"><td class="def constructor"><a href="#type-mlt_block.Code" class="anchor"></a><code>| </code><code><span class="constructor">Code</span> <span class="keyword">of</span> string</code></td></tr></table></dt></dl><div><div class="spec include"><div class="doc"><details open="open"><summary><span class="def"><code><span class="keyword">include</span> <span class="keyword">sig</span> ... <span class="keyword">end</span></code></span></summary><dl><dt class="spec value" id="val-mlt_block_of_sexp"><a href="#val-mlt_block_of_sexp" class="anchor"></a><code><span class="keyword">val</span> mlt_block_of_sexp : <a href="../../sexplib0/Sexplib0/Sexp/index.html#type-t">Ppx_sexp_conv_lib.Sexp.t</a> <span>&#45;&gt;</span> <a href="index.html#type-mlt_block">mlt_block</a></code></dt><dt class="spec value" id="val-sexp_of_mlt_block"><a href="#val-sexp_of_mlt_block" class="anchor"></a><code><span class="keyword">val</span> sexp_of_mlt_block : <a href="index.html#type-mlt_block">mlt_block</a> <span>&#45;&gt;</span> <a href="../../sexplib0/Sexplib0/Sexp/index.html#type-t">Ppx_sexp_conv_lib.Sexp.t</a></code></dt></dl></details></div></div></div><dl><dt class="spec value" id="val-parse"><a href="#val-parse" class="anchor"></a><code><span class="keyword">val</span> parse : <a href="../../ppxlib/Ppxlib/index.html#type-toplevel_phrase">Ppxlib.toplevel_phrase</a> list <span>&#45;&gt;</span> contents:string <span>&#45;&gt;</span> <a href="index.html#type-mlt_block">mlt_block</a> list</code></dt><dd><p>Takes a list of toplevel phrases and the raw string they're embedded in and returns a list of labeled blocks, so that for instance the following raw toplevel code:</p><pre><code class="ml">[%%org {|
  Here comes a very /simple/ example.
|}];;

1 + 1;;
[%%expect {|
- : int: 2
|}];;</code></pre><p>is parsed into its constituent parts:</p><pre><code class="ml">[
  (Org &quot;Here comes a very /simple/ example.&quot;);
  (Code &quot;1 + 1&quot;);
  (Expect &quot;- : int: 2&quot;)
]</code></pre><p>Note that we only care about these three kinds of element (org blocks, expect blocks, and regular OCaml code blocks); everything else -- including toplevel comments -- is silently discarded.</p></dd></dl></div></body></html>