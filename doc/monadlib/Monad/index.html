<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Monad (monadlib.Monad)</title><link rel="stylesheet" href="../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../index.html">monadlib</a> &#x00BB; Monad</nav><h1>Module <code>Monad</code></h1><p>The monad library.</p><p><b>Introduction</b></p><p>Monads in ocaml, as defined in the batteries library and lwt, are defined narrowly in terms of a type constructor, and two functions, <code>return</code> and <code>bind</code>. This misses the <code>i abstraction</code>, which lies in the ability to write functions that apply generally to <code>i all</code> monads. This library defines modules for such functions.</p><dl><dt>author</dt><dd>Phil Scott</dd></dl><nav class="toc"><ul><li><a href="#base-modules">Base Modules</a></li><li><a href="#library-types">Library Types</a></li><li><a href="#transformers">Transformers</a></li><li><a href="#transformers-on-collections">Transformers on Collections</a></li></ul></nav></header><section><header><h6 id="base-modules"><a href="#base-modules" class="anchor"></a>Base Modules</h6></header><div class="spec module-type" id="module-type-Monoid"><a href="#module-type-Monoid" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-Monoid/index.html">Monoid</a> = <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><dl><dt class="spec module-type" id="module-type-BasePlus"><a href="#module-type-BasePlus" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-BasePlus/index.html">BasePlus</a> = <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Monads with additional monoid structure.</p></dd></dl><dl><dt class="spec module-type" id="module-type-BaseLazyPlus"><a href="#module-type-BaseLazyPlus" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-BaseLazyPlus/index.html">BaseLazyPlus</a> = <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>LazyPlus is another base module useful when the monad is a lazy data structure. We then allow the plus operation to be non-strict in its second argument, which makes it possible to use functions such as <span class="xref-unresolved" title="unresolved reference to &quot;Monad.lsum&quot;"><a href="index.html#module-type-Monad"><code>Monad</code></a>.lsum</span> lazily. This is what you want for lazy lists.</p></dd></dl></section><section><header><h6 id="library-types"><a href="#library-types" class="anchor"></a>Library Types</h6></header><dl><dt class="spec module-type" id="module-type-Monad"><a href="#module-type-Monad" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-Monad/index.html">Monad</a> = <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Your basic library functions for monads.</p></dd></dl><dl><dt class="spec module-type" id="module-type-MonadPlus"><a href="#module-type-MonadPlus" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-MonadPlus/index.html">MonadPlus</a> = <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Library functions for monads with additional monoid structure.</p></dd></dl><dl><dt class="spec module-type" id="module-type-LazyPlus"><a href="#module-type-LazyPlus" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-LazyPlus/index.html">LazyPlus</a> = <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>This is the counterpart for the lazy version of <a href="module-type-BasePlus/index.html"><code>BasePlus</code></a>.</p></dd></dl><dl><dt class="spec module" id="module-Make"><a href="#module-Make" class="anchor"></a><code><span class="keyword">module</span> <a href="Make/index.html">Make</a> : <span class="keyword">functor</span> (<a href="Make/argument-1-M/index.html">M</a> : <a href="../../batteries/BatInterfaces/index.html#module-type-Monad">BatInterfaces.Monad</a>) <span>&#45;&gt;</span> <a href="index.html#module-type-Monad">Monad</a> <span class="keyword">with</span> <span class="keyword">type</span> 'a <a href="Make/index.html#type-m">m</a> = <span class="type-var">'a</span> <a href="Make/argument-1-M/index.html#type-m">M.m</a></code></dt><dd></dd></dl><div class="spec module" id="module-MakePlus"><a href="#module-MakePlus" class="anchor"></a><code><span class="keyword">module</span> <a href="MakePlus/index.html">MakePlus</a> : <span class="keyword">functor</span> (<a href="MakePlus/argument-1-M/index.html">M</a> : <a href="index.html#module-type-BasePlus">BasePlus</a>) <span>&#45;&gt;</span> <a href="index.html#module-type-MonadPlus">MonadPlus</a> <span class="keyword">with</span> <span class="keyword">type</span> 'a <a href="MakePlus/index.html#type-m">m</a> = <span class="type-var">'a</span> <a href="MakePlus/argument-1-M/index.html#type-m">M.m</a></code></div><div class="spec module" id="module-MakeLazyPlus"><a href="#module-MakeLazyPlus" class="anchor"></a><code><span class="keyword">module</span> <a href="MakeLazyPlus/index.html">MakeLazyPlus</a> : <span class="keyword">functor</span> (<a href="MakeLazyPlus/argument-1-M/index.html">M</a> : <a href="index.html#module-type-BaseLazyPlus">BaseLazyPlus</a>) <span>&#45;&gt;</span> <a href="index.html#module-type-LazyPlus">LazyPlus</a> <span class="keyword">with</span> <span class="keyword">type</span> 'a <a href="MakeLazyPlus/index.html#type-m">m</a> = <span class="type-var">'a</span> <a href="MakeLazyPlus/argument-1-M/index.html#type-m">M.m</a></code></div><dl><dt class="spec module" id="module-LazyM"><a href="#module-LazyM" class="anchor"></a><code><span class="keyword">module</span> <a href="LazyM/index.html">LazyM</a> : <a href="index.html#module-type-Monad">Monad</a> <span class="keyword">with</span> <span class="keyword">type</span> 'a <a href="module-type-Monad/index.html#type-m">m</a> = <span class="type-var">'a</span> <a href="../../ocaml/Stdlib/Lazy/index.html#type-t">Stdlib.Lazy.t</a></code></dt><dd><p>The lazy monad. Automatically wraps calls lazily and forces as needed.</p></dd></dl><div class="spec module" id="module-List"><a href="#module-List" class="anchor"></a><code><span class="keyword">module</span> <a href="List/index.html">List</a> : <a href="index.html#module-type-MonadPlus">MonadPlus</a> <span class="keyword">with</span> <span class="keyword">type</span> 'a <a href="module-type-MonadPlus/index.html#type-m">m</a> = <span class="type-var">'a</span> list</code></div><div class="spec module" id="module-LazyListM"><a href="#module-LazyListM" class="anchor"></a><code><span class="keyword">module</span> <a href="LazyListM/index.html">LazyListM</a> : <a href="index.html#module-type-LazyPlus">LazyPlus</a> <span class="keyword">with</span> <span class="keyword">type</span> 'a <a href="module-type-LazyPlus/index.html#type-m">m</a> = <span class="type-var">'a</span> <a href="../LazyList/index.html#type-t">LazyList.t</a></code></div><div class="spec module" id="module-Option"><a href="#module-Option" class="anchor"></a><code><span class="keyword">module</span> <a href="Option/index.html">Option</a> : <a href="index.html#module-type-MonadPlus">MonadPlus</a> <span class="keyword">with</span> <span class="keyword">type</span> 'a <a href="module-type-MonadPlus/index.html#type-m">m</a> = <span class="type-var">'a</span> option</code></div><dl><dt class="spec module" id="module-Continuation"><a href="#module-Continuation" class="anchor"></a><code><span class="keyword">module</span> <a href="Continuation/index.html">Continuation</a> : <span class="keyword">functor</span> (<a href="Continuation/argument-1-T/index.html">T</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span>) <span>&#45;&gt;</span> <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>For the incorruptible programmer:</p></dd></dl><div class="spec module" id="module-Reader"><a href="#module-Reader" class="anchor"></a><code><span class="keyword">module</span> <a href="Reader/index.html">Reader</a> : <span class="keyword">functor</span> (<a href="Reader/argument-1-T/index.html">T</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span>) <span>&#45;&gt;</span> <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><div class="spec module" id="module-Writer"><a href="#module-Writer" class="anchor"></a><code><span class="keyword">module</span> <a href="Writer/index.html">Writer</a> : <span class="keyword">functor</span> (<a href="Writer/argument-1-M/index.html">M</a> : <a href="index.html#module-type-Monoid">Monoid</a>) <span>&#45;&gt;</span> <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><div class="spec module" id="module-State"><a href="#module-State" class="anchor"></a><code><span class="keyword">module</span> <a href="State/index.html">State</a> : <span class="keyword">functor</span> (<a href="State/argument-1-T/index.html">T</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span>) <span>&#45;&gt;</span> <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><div class="spec module" id="module-Error"><a href="#module-Error" class="anchor"></a><code><span class="keyword">module</span> <a href="Error/index.html">Error</a> : <span class="keyword">functor</span> (<a href="Error/argument-1-E/index.html">E</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span>) <span>&#45;&gt;</span> <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><dl><dt class="spec module-type" id="module-type-BaseCollectionM"><a href="#module-type-BaseCollectionM" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-BaseCollectionM/index.html">BaseCollectionM</a> = <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Monads for collections. Stream is the current use-case for this, since it is parameterised on a collection monad (like <code>list</code>).</p></dd></dl><dl><dt class="spec module-type" id="module-type-Stream"><a href="#module-type-Stream" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-Stream/index.html">Stream</a> = <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Streams supporting fair and unbounded search.</p></dd></dl><dl><dt class="spec module-type" id="module-type-StreamC"><a href="#module-type-StreamC" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-StreamC/index.html">StreamC</a> = <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>The union of streams and collections.</p></dd></dl></section><section><header><h6 id="transformers"><a href="#transformers" class="anchor"></a>Transformers</h6></header><div class="spec module" id="module-LazyT"><a href="#module-LazyT" class="anchor"></a><code><span class="keyword">module</span> <a href="LazyT/index.html">LazyT</a> : <span class="keyword">functor</span> (<a href="LazyT/argument-1-M/index.html">M</a> : <a href="../../batteries/BatInterfaces/index.html#module-type-Monad">BatInterfaces.Monad</a>) <span>&#45;&gt;</span> <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><dl><dt class="spec module" id="module-ListT"><a href="#module-ListT" class="anchor"></a><code><span class="keyword">module</span> <a href="ListT/index.html">ListT</a> : <span class="keyword">functor</span> (<a href="ListT/argument-1-M/index.html">M</a> : <a href="../../batteries/BatInterfaces/index.html#module-type-Monad">BatInterfaces.Monad</a>) <span>&#45;&gt;</span> <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>The list monad transformer will add non-determinism to computations. I have not provided a transformer for lazy lists, since I'm not yet sure how to implement it. It would probably need a lazy version of map_m, but it's not clear to me how to write this, since whether the computations are strict will determine whether the argument has to be completely forced.</p></dd></dl><div class="spec module" id="module-OptionT"><a href="#module-OptionT" class="anchor"></a><code><span class="keyword">module</span> <a href="OptionT/index.html">OptionT</a> : <span class="keyword">functor</span> (<a href="OptionT/argument-1-M/index.html">M</a> : <a href="../../batteries/BatInterfaces/index.html#module-type-Monad">BatInterfaces.Monad</a>) <span>&#45;&gt;</span> <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><div class="spec module" id="module-StateT"><a href="#module-StateT" class="anchor"></a><code><span class="keyword">module</span> <a href="StateT/index.html">StateT</a> : <span class="keyword">functor</span> (<a href="StateT/argument-1-T/index.html">T</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span>) <span>&#45;&gt;</span> <span class="keyword">functor</span> (<a href="StateT/argument-2-M/index.html">M</a> : <a href="../../batteries/BatInterfaces/index.html#module-type-Monad">BatInterfaces.Monad</a>) <span>&#45;&gt;</span> <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><div class="spec module" id="module-WriterT"><a href="#module-WriterT" class="anchor"></a><code><span class="keyword">module</span> <a href="WriterT/index.html">WriterT</a> : <span class="keyword">functor</span> (<a href="WriterT/argument-1-Mon/index.html">Mon</a> : <a href="index.html#module-type-Monoid">Monoid</a>) <span>&#45;&gt;</span> <span class="keyword">functor</span> (<a href="WriterT/argument-2-M/index.html">M</a> : <a href="../../batteries/BatInterfaces/index.html#module-type-Monad">BatInterfaces.Monad</a>) <span>&#45;&gt;</span> <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div></section><section><header><h6 id="transformers-on-collections"><a href="#transformers-on-collections" class="anchor"></a>Transformers on Collections</h6></header><aside><p>Sometimes, you might want to transform a collection monad, in such a way that functions such as <a href="module-type-BaseCollectionM/index.html#val-unique"><code>BaseCollectionM.unique</code></a> behave in a sensible way by regarding None as smaller than any Some. Each transformer provides a function <code>cmp_on</code> with which the collection functions such as <code>BaseCollectionM.difference</code> are implemented. We also provide the <code>list</code> function for transformers.</p></aside><div class="spec module" id="module-CollectionOpt"><a href="#module-CollectionOpt" class="anchor"></a><code><span class="keyword">module</span> <a href="CollectionOpt/index.html">CollectionOpt</a> : <span class="keyword">functor</span> (<a href="CollectionOpt/argument-1-C/index.html">C</a> : <a href="index.html#module-type-BaseCollectionM">BaseCollectionM</a>) <span>&#45;&gt;</span> <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><div class="spec module" id="module-CollectionWriter"><a href="#module-CollectionWriter" class="anchor"></a><code><span class="keyword">module</span> <a href="CollectionWriter/index.html">CollectionWriter</a> : <span class="keyword">functor</span> (<a href="CollectionWriter/argument-1-Mon/index.html">Mon</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span>) <span>&#45;&gt;</span> <span class="keyword">functor</span> (<a href="CollectionWriter/argument-2-C/index.html">C</a> : <a href="index.html#module-type-BaseCollectionM">BaseCollectionM</a>) <span>&#45;&gt;</span> <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><div class="spec module" id="module-CollectionState"><a href="#module-CollectionState" class="anchor"></a><code><span class="keyword">module</span> <a href="CollectionState/index.html">CollectionState</a> : <span class="keyword">functor</span> (<a href="CollectionState/argument-1-T/index.html">T</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span>) <span>&#45;&gt;</span> <span class="keyword">functor</span> (<a href="CollectionState/argument-2-C/index.html">C</a> : <a href="index.html#module-type-BaseCollectionM">BaseCollectionM</a>) <span>&#45;&gt;</span> <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><dl><dt class="spec module" id="module-MakeStream"><a href="#module-MakeStream" class="anchor"></a><code><span class="keyword">module</span> <a href="MakeStream/index.html">MakeStream</a> : <span class="keyword">functor</span> (<a href="MakeStream/argument-1-M/index.html">M</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span>) <span>&#45;&gt;</span> <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Create a stream monad from an arbitrary inner monad, which computes the values discovered in each generation. This is pretty abstract, since we're not requiring that the inner monad is a <i>collection</i>. There is a constraint here, since we're strictly supposed to disallow a monad collection where order of elements matters. I think we can characterise this abstractly by saying that the plus operation on the inner monad must be commutative, but don't take my word for it!</p></dd></dl><dl><dt class="spec module" id="module-MakeStreamC"><a href="#module-MakeStreamC" class="anchor"></a><code><span class="keyword">module</span> <a href="MakeStreamC/index.html">MakeStreamC</a> : <span class="keyword">functor</span> (<a href="MakeStreamC/argument-1-M/index.html">M</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span>) <span>&#45;&gt;</span> <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Here, we create a stream monad from a definite collection monad <span class="xref-unresolved" title="unresolved reference to &quot;Monad.BaseCollectionM&quot;"><a href="index.html#module-type-Monad"><code>Monad</code></a>.BaseCollectionM</span>. The inner monad will be used to represent the generations in the stream. The order of elements in each generation should not matter, so you might want to use a set or a bag. If you want to live life on the edge, just remember that your code should not depend on the order of elements within generations (you can, of course, depend on the order that generations appear in the stream). You can enforce this constraint by performing, say, a sort on each generation.</p></dd></dl></section></div></body></html>