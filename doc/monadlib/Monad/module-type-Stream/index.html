<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Stream (monadlib.Monad.Stream)</title><link rel="stylesheet" href="../../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../../index.html">monadlib</a> &#x00BB; <a href="../index.html">Monad</a> &#x00BB; Stream</nav><h1>Module type <code>Monad.Stream</code></h1><p>Streams supporting fair and unbounded search.</p><p>Spivey has a nice and authoratitive paper on this, understanding streams as a breadth-first search. If that description appeals to you, I recommend his paper. Personally, I found it helpful to understand streams a bit differently, as concurrent processes that go off and discover data.</p><p>First, we have <i>generations</i>, which are collections of zero or more data. The data in each generation is discovered simultaneously, and therefore, it doesn't make much sense to have any ordering imposed on the generations. In fact, the lack of an ordering is essential for getting the associativity laws of the monad, and is why Spivey's paper works with bags.</p><p>Now a stream is just a lazy list of generations. We want to think of the indices into these streams as temporal indices. So the first generation in the lazy list was discovered at time 0. The second was discovered at time 1. The third was discovered at time 2. And so on.</p><p>Thinking this way helped me figure out <code>return</code> and <code>join</code>. Here, <code>return x</code> gives you the process which immediately discovers <code>x</code> and then terminates.</p><p>With <code>join xss</code>, we should interpret the <code>xss</code> as a process which discovers <i>other processes</i>. When we join them, we ask the outer process to fork each inner process as soon as it is discovered, and then merge in all the values found by the forked processes. For instance, if <code>xs</code> discovers a process <code>p</code> at time 5, and in turn, <code>p</code> discovers the string &quot;hello world!&quot; at time 13, then <code>join xs</code> discovers &quot;hello world!&quot; at time 5 + 13 = 18.</p><p>Now we can understand <code>bind</code>, realising that it is just the result of doing a <code>map</code> and then a <code>join</code>. The expression <code>bind xs f</code> forks processes <code>f</code> which depend on a discovered value <code>x</code>, and then merges back all their values.</p><p>Technically, all our streams should be infinite, and the processes should run forever, but this gave me sad performance in my theorem proving code. So for efficiency, our streams can be truncated, which represents a process that terminates.</p><p>Note that it is impossible to define a general <a href="../module-type-BaseLazyPlus/index.html#val-null"><code>BaseLazyPlus.null</code></a> predicate for streams, because we would have to be able to decide whether an infinite stream of values consists entirely of the empty generation. Turing says that's impossible, and I believe him. As a crude approximation, then, we have it that <a href="../module-type-BaseLazyPlus/index.html#val-null"><code>BaseLazyPlus.null</code></a> returns <code>true</code> just for the special case that its input is an empty lazy list.</p></header><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> 'a t</code></dt></dl><div><div class="spec include"><div class="doc"><details open="open"><summary><span class="def"><code><span class="keyword">include</span> <a href="../index.html#module-type-LazyPlus">LazyPlus</a> <span class="keyword">with</span> <span class="keyword">type</span> 'a <a href="../module-type-LazyPlus/index.html#type-m">m</a> = <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <a href="../../../ocaml/Stdlib/Lazy/index.html#type-t">Stdlib.Lazy.t</a></code></span></summary><div><div class="spec include"><div class="doc"><details open="open"><summary><span class="def"><code><span class="keyword">include</span> <a href="../index.html#module-type-BaseLazyPlus">BaseLazyPlus</a></code></span></summary><div><div class="spec include"><div class="doc"><details open="open"><summary><span class="def"><code><span class="keyword">include</span> <a href="../../../batteries/BatInterfaces/index.html#module-type-Monad">BatInterfaces.Monad</a></code></span></summary><dl><dt class="spec type" id="type-m"><a href="#type-m" class="anchor"></a><code><span class="keyword">type</span> 'a m</code></dt><dd><p>The type of a monad producing values of type <code>'a</code>.</p></dd></dl><dl><dt class="spec value" id="val-bind"><a href="#val-bind" class="anchor"></a><code><span class="keyword">val</span> bind : <span class="type-var">'a</span> <a href="index.html#type-m">m</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-m">m</a>) <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-m">m</a></code></dt><dd><p>Monadic binding.</p><p><code>bind m f</code> executes first <code>m</code> then <code>f</code>, using the result of <code>m</code>.</p></dd></dl><dl><dt class="spec value" id="val-return"><a href="#val-return" class="anchor"></a><code><span class="keyword">val</span> return : <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-m">m</a></code></dt><dd><p>Return a value, that is, put a value in the monad.</p></dd></dl></details></div></div></div><dl><dt class="spec value" id="val-zero"><a href="#val-zero" class="anchor"></a><code><span class="keyword">val</span> zero : unit <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-m">m</a></code></dt><dt class="spec value" id="val-lplus"><a href="#val-lplus" class="anchor"></a><code><span class="keyword">val</span> lplus : <span class="type-var">'a</span> <a href="index.html#type-m">m</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-m">m</a> <a href="../../../ocaml/Stdlib/Lazy/index.html#type-t">Stdlib.Lazy.t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-m">m</a></code></dt><dt class="spec value" id="val-null"><a href="#val-null" class="anchor"></a><code><span class="keyword">val</span> null : <span class="type-var">'a</span> <a href="index.html#type-m">m</a> <span>&#45;&gt;</span> bool</code></dt><dd><p>null x implies that x is zero. If you do not want to or cannot answer whether a given x is zero, then null x should be false.</p></dd></dl></details></div></div></div><div><div class="spec include"><div class="doc"><details open="open"><summary><span class="def"><code><span class="keyword">include</span> <a href="../index.html#module-type-MonadPlus">MonadPlus</a> <span class="keyword">with</span> <span class="keyword">type</span> 'a <a href="../module-type-MonadPlus/index.html#type-m">m</a> := <span class="type-var">'a</span> <a href="index.html#type-m">m</a></code></span></summary><div><div class="spec include"><div class="doc"><details open="open"><summary><span class="def"><code><span class="keyword">include</span> <a href="../index.html#module-type-BasePlus">BasePlus</a></code></span></summary><div><div class="spec include"><div class="doc"><details open="open"><summary><span class="def"><code><span class="keyword">include</span> <a href="../../../batteries/BatInterfaces/index.html#module-type-Monad">BatInterfaces.Monad</a></code></span></summary><dl><dt class="spec type" id="type-m"><a href="#type-m" class="anchor"></a><code><span class="keyword">type</span> 'a m</code></dt><dd><p>The type of a monad producing values of type <code>'a</code>.</p></dd></dl><dl><dt class="spec value" id="val-bind"><a href="#val-bind" class="anchor"></a><code><span class="keyword">val</span> bind : <span class="type-var">'a</span> <a href="index.html#type-m">m</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-m">m</a>) <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-m">m</a></code></dt><dd><p>Monadic binding.</p><p><code>bind m f</code> executes first <code>m</code> then <code>f</code>, using the result of <code>m</code>.</p></dd></dl><dl><dt class="spec value" id="val-return"><a href="#val-return" class="anchor"></a><code><span class="keyword">val</span> return : <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-m">m</a></code></dt><dd><p>Return a value, that is, put a value in the monad.</p></dd></dl></details></div></div></div><dl><dt class="spec value" id="val-zero"><a href="#val-zero" class="anchor"></a><code><span class="keyword">val</span> zero : unit <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-m">m</a></code></dt><dt class="spec value" id="val-plus"><a href="#val-plus" class="anchor"></a><code><span class="keyword">val</span> plus : <span class="type-var">'a</span> <a href="index.html#type-m">m</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-m">m</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-m">m</a></code></dt><dt class="spec value" id="val-null"><a href="#val-null" class="anchor"></a><code><span class="keyword">val</span> null : <span class="type-var">'a</span> <a href="index.html#type-m">m</a> <span>&#45;&gt;</span> bool</code></dt><dd><p>null x implies that x is zero. If you do not want to or cannot answer whether a given x is zero, then null x should be false. I have provided this so that streams can be implemented more efficiently.</p></dd></dl></details></div></div></div><div><div class="spec include"><div class="doc"><details open="open"><summary><span class="def"><code><span class="keyword">include</span> <a href="../index.html#module-type-Monad">Monad</a> <span class="keyword">with</span> <span class="keyword">type</span> 'a <a href="../module-type-Monad/index.html#type-m">m</a> := <span class="type-var">'a</span> <a href="index.html#type-m">m</a></code></span></summary><div><div class="spec include"><div class="doc"><details open="open"><summary><span class="def"><code><span class="keyword">include</span> <a href="../../../batteries/BatInterfaces/index.html#module-type-Monad">BatInterfaces.Monad</a></code></span></summary><dl><dt class="spec type" id="type-m"><a href="#type-m" class="anchor"></a><code><span class="keyword">type</span> 'a m</code></dt><dd><p>The type of a monad producing values of type <code>'a</code>.</p></dd></dl><dl><dt class="spec value" id="val-bind"><a href="#val-bind" class="anchor"></a><code><span class="keyword">val</span> bind : <span class="type-var">'a</span> <a href="index.html#type-m">m</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-m">m</a>) <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-m">m</a></code></dt><dd><p>Monadic binding.</p><p><code>bind m f</code> executes first <code>m</code> then <code>f</code>, using the result of <code>m</code>.</p></dd></dl><dl><dt class="spec value" id="val-return"><a href="#val-return" class="anchor"></a><code><span class="keyword">val</span> return : <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-m">m</a></code></dt><dd><p>Return a value, that is, put a value in the monad.</p></dd></dl></details></div></div></div><div><div class="spec include"><div class="doc"><details open="open"><summary><span class="def"><code><span class="keyword">include</span> <a href="../../Applicative/index.html#module-type-Applicative">Applicative.Applicative</a> <span class="keyword">with</span> <span class="keyword">type</span> 'a <a href="../../Applicative/module-type-Applicative/index.html#type-m">m</a> := <span class="type-var">'a</span> <a href="index.html#type-m">m</a></code></span></summary><div><div class="spec include"><div class="doc"><details open="open"><summary><span class="def"><code><span class="keyword">include</span> <a href="../../Applicative/index.html#module-type-Base">Applicative.Base</a></code></span></summary><dl><dt class="spec type" id="type-m"><a href="#type-m" class="anchor"></a><code><span class="keyword">type</span> 'a m</code></dt></dl><dl><dt class="spec value" id="val-return"><a href="#val-return" class="anchor"></a><code><span class="keyword">val</span> return : <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-m">m</a></code></dt><dt class="spec value" id="val-(&lt;*&gt;)"><a href="#val-(&lt;*&gt;)" class="anchor"></a><code><span class="keyword">val</span> (&lt;*&gt;) : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>) <a href="index.html#type-m">m</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-m">m</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-m">m</a></code></dt></dl></details></div></div></div><dl><dt class="spec value" id="val-lift1"><a href="#val-lift1" class="anchor"></a><code><span class="keyword">val</span> lift1 : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-m">m</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-m">m</a></code></dt><dt class="spec value" id="val-lift2"><a href="#val-lift2" class="anchor"></a><code><span class="keyword">val</span> lift2 : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'c</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-m">m</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-m">m</a> <span>&#45;&gt;</span> <span class="type-var">'c</span> <a href="index.html#type-m">m</a></code></dt><dt class="spec value" id="val-lift3"><a href="#val-lift3" class="anchor"></a><code><span class="keyword">val</span> lift3 : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'c</span> <span>&#45;&gt;</span> <span class="type-var">'d</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-m">m</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-m">m</a> <span>&#45;&gt;</span> <span class="type-var">'c</span> <a href="index.html#type-m">m</a> <span>&#45;&gt;</span> <span class="type-var">'d</span> <a href="index.html#type-m">m</a></code></dt><dt class="spec value" id="val-lift4"><a href="#val-lift4" class="anchor"></a><code><span class="keyword">val</span> lift4 : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'c</span> <span>&#45;&gt;</span> <span class="type-var">'d</span> <span>&#45;&gt;</span> <span class="type-var">'e</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-m">m</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-m">m</a> <span>&#45;&gt;</span> <span class="type-var">'c</span> <a href="index.html#type-m">m</a> <span>&#45;&gt;</span> <span class="type-var">'d</span> <a href="index.html#type-m">m</a> <span>&#45;&gt;</span> <span class="type-var">'e</span> <a href="index.html#type-m">m</a></code></dt><dt class="spec value" id="val-(&lt;$&gt;)"><a href="#val-(&lt;$&gt;)" class="anchor"></a><code><span class="keyword">val</span> (&lt;$&gt;) : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-m">m</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-m">m</a></code></dt><dd><p>Alias for lift1.</p></dd></dl><dl><dt class="spec value" id="val-sequence"><a href="#val-sequence" class="anchor"></a><code><span class="keyword">val</span> sequence : <span class="type-var">'a</span> <a href="index.html#type-m">m</a> list <span>&#45;&gt;</span> <span class="type-var">'a</span> list <a href="index.html#type-m">m</a></code></dt><dt class="spec value" id="val-map_a"><a href="#val-map_a" class="anchor"></a><code><span class="keyword">val</span> map_a : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-m">m</a>) <span>&#45;&gt;</span> <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'b</span> list <a href="index.html#type-m">m</a></code></dt><dt class="spec value" id="val-(&lt;*)"><a href="#val-(&lt;*)" class="anchor"></a><code><span class="keyword">val</span> (&lt;*) : <span class="type-var">'a</span> <a href="index.html#type-m">m</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-m">m</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-m">m</a></code></dt><dt class="spec value" id="val-(&gt;*)"><a href="#val-(&gt;*)" class="anchor"></a><code><span class="keyword">val</span> (&gt;*) : <span class="type-var">'a</span> <a href="index.html#type-m">m</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-m">m</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-m">m</a></code></dt></dl></details></div></div></div><dl><dt class="spec value" id="val-(&gt;&gt;=)"><a href="#val-(&gt;&gt;=)" class="anchor"></a><code><span class="keyword">val</span> (&gt;&gt;=) : <span class="type-var">'a</span> <a href="index.html#type-m">m</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-m">m</a>) <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-m">m</a></code></dt><dt class="spec value" id="val-join"><a href="#val-join" class="anchor"></a><code><span class="keyword">val</span> join : <span class="type-var">'a</span> <a href="index.html#type-m">m</a> <a href="index.html#type-m">m</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-m">m</a></code></dt><dt class="spec value" id="val-filter_m"><a href="#val-filter_m" class="anchor"></a><code><span class="keyword">val</span> filter_m : (<span class="type-var">'a</span> <span>&#45;&gt;</span> bool <a href="index.html#type-m">m</a>) <span>&#45;&gt;</span> <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'a</span> list <a href="index.html#type-m">m</a></code></dt><dt class="spec value" id="val-onlyif"><a href="#val-onlyif" class="anchor"></a><code><span class="keyword">val</span> onlyif : bool <span>&#45;&gt;</span> unit <a href="index.html#type-m">m</a> <span>&#45;&gt;</span> unit <a href="index.html#type-m">m</a></code></dt><dt class="spec value" id="val-unless"><a href="#val-unless" class="anchor"></a><code><span class="keyword">val</span> unless : bool <span>&#45;&gt;</span> unit <a href="index.html#type-m">m</a> <span>&#45;&gt;</span> unit <a href="index.html#type-m">m</a></code></dt><dt class="spec value" id="val-ignore"><a href="#val-ignore" class="anchor"></a><code><span class="keyword">val</span> ignore : <span class="type-var">'a</span> <a href="index.html#type-m">m</a> <span>&#45;&gt;</span> unit <a href="index.html#type-m">m</a></code></dt></dl></details></div></div></div><dl><dt class="spec value" id="val-filter"><a href="#val-filter" class="anchor"></a><code><span class="keyword">val</span> filter : (<span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-m">m</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-m">m</a></code></dt><dt class="spec value" id="val-of_list"><a href="#val-of_list" class="anchor"></a><code><span class="keyword">val</span> of_list : <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-m">m</a></code></dt><dt class="spec value" id="val-sum"><a href="#val-sum" class="anchor"></a><code><span class="keyword">val</span> sum : <span class="type-var">'a</span> list <a href="index.html#type-m">m</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-m">m</a></code></dt><dt class="spec value" id="val-msum"><a href="#val-msum" class="anchor"></a><code><span class="keyword">val</span> msum : <span class="type-var">'a</span> <a href="index.html#type-m">m</a> list <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-m">m</a></code></dt><dt class="spec value" id="val-guard"><a href="#val-guard" class="anchor"></a><code><span class="keyword">val</span> guard : bool <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-m">m</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-m">m</a></code></dt><dt class="spec value" id="val-transpose"><a href="#val-transpose" class="anchor"></a><code><span class="keyword">val</span> transpose : <span class="type-var">'a</span> list <a href="index.html#type-m">m</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-m">m</a> list</code></dt><dd><p>Generalises matrix transposition. This will loop infinitely if <a href="../module-type-BasePlus/index.html#val-null"><code>BasePlus.null</code></a> cannot answer <code>true</code> for <code>zero</code>es.</p></dd></dl></details></div></div></div><dl><dt class="spec value" id="val-of_llist"><a href="#val-of_llist" class="anchor"></a><code><span class="keyword">val</span> of_llist : <span class="type-var">'a</span> <a href="../../LazyList/index.html#type-t">LazyList.t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-m">m</a></code></dt><dt class="spec value" id="val-lsum"><a href="#val-lsum" class="anchor"></a><code><span class="keyword">val</span> lsum : <span class="type-var">'a</span> <a href="../../LazyList/index.html#type-t">LazyList.t</a> <a href="index.html#type-m">m</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-m">m</a></code></dt><dt class="spec value" id="val-lmsum"><a href="#val-lmsum" class="anchor"></a><code><span class="keyword">val</span> lmsum : <span class="type-var">'a</span> <a href="index.html#type-m">m</a> <a href="../../LazyList/index.html#type-t">LazyList.t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-m">m</a></code></dt><dt class="spec value" id="val-ltranspose"><a href="#val-ltranspose" class="anchor"></a><code><span class="keyword">val</span> ltranspose : <span class="type-var">'a</span> <a href="../../LazyList/index.html#type-t">LazyList.t</a> <a href="index.html#type-m">m</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-m">m</a> <a href="../../LazyList/index.html#type-t">LazyList.t</a></code></dt><dd><p>Generalises matrix transposition. You don't necessarily have to worry about correctly implementing <a href="../module-type-BaseLazyPlus/index.html#val-null"><code>BaseLazyPlus.null</code></a> for this function, since the return value can happily be infinite.</p></dd></dl></details></div></div></div><dl><dt class="spec value" id="val-iterate"><a href="#val-iterate" class="anchor"></a><code><span class="keyword">val</span> iterate : (<span class="type-var">'a</span> <a href="index.html#type-m">m</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-m">m</a>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-m">m</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-m">m</a></code></dt><dd><p>The sum of the stream <code>[f x, f (f x), f (f (f x)),...]</code></p></dd></dl><dl><dt class="spec value" id="val-delay"><a href="#val-delay" class="anchor"></a><code><span class="keyword">val</span> delay : <span class="type-var">'a</span> <a href="index.html#type-m">m</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-m">m</a></code></dt><dd><p>Delay a stream by one time step. This is needed when you write recursive streams and you have to avoid deadlock. The nice thing about Ocaml here is that it will generally detect deadlock for you, announcing to you that you're writing viciously circular lists!</p></dd></dl><dl><dt class="spec value" id="val-to_depth"><a href="#val-to_depth" class="anchor"></a><code><span class="keyword">val</span> to_depth : int <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-m">m</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-m">m</a></code></dt><dd><p>Terminate discovery at some depth.</p></dd></dl></div></body></html>