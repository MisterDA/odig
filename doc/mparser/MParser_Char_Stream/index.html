<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>MParser_Char_Stream (mparser.MParser_Char_Stream)</title><link rel="stylesheet" href="../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../index.html">mparser</a> &#x00BB; MParser_Char_Stream</nav><h1>Module <code>MParser_Char_Stream</code></h1><p>A position-based interface to character streams.</p><nav class="toc"><ul><li><a href="#regexp-related-features">Regexp-related features</a></li></ul></nav></header><aside><p>The streams are optimized for applications that mostly read a stream sequentially and occasionally backtrack over a bounded distance, which is a common usage pattern of backtracking parsers.</p><p>The characters in a character stream provided by this module are accessed based on their position in the stream. A position <code>pos</code> is valid in the stream <code>s</code> if it satisfies <code>0 &lt;= pos &lt; length s</code>. Character streams can be created from input channels and from strings.</p></aside><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> t</code></dt><dd><p>A character stream.</p></dd></dl><dl><dt class="spec value" id="val-from_string"><a href="#val-from_string" class="anchor"></a><code><span class="keyword">val</span> from_string : string <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>from_string s</code> creates a character stream that contains the characters of the string <code>s</code>.</p></dd></dl><dl><dt class="spec value" id="val-from_channel"><a href="#val-from_channel" class="anchor"></a><code><span class="keyword">val</span> from_channel : ?&#8288;block_size:int <span>&#45;&gt;</span> ?&#8288;block_overlap:int <span>&#45;&gt;</span> ?&#8288;min_rspace:int <span>&#45;&gt;</span> <a href="../../ocaml/Stdlib/index.html#type-in_channel">Stdlib.in_channel</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>from_channel ?block_size ?block_overlap ?min_rspace chn</code> creates a character stream that contains the characters of the input channel <code>chn</code>. The behavior of the stream is undefined if the channel is modified subsequently.</p><p>When a character stream is created from an input channel, the characters in this channel are read in overlapping blocks, where <code>block_size</code> and <code>block_overlap</code> determine the size of a block and the amount of overlap. If the length of the channel is not greater than the block size, the whole channel is read at once. Otherwise, only a single block of the channel is kept in memory at a time. Whenever the current stream position leaves the part that is currently kept in memory, a new block is read from the channel. The channel must support seeking (i.e., must be created from a regular file) to enable this. If possible, blocks are read with the specified amount of overlap to minimize the re-reading of blocks due to backtracking. <code>min_rspace</code> specifies the minimum number of characters a regular expression is matched against (if possible) by <code>match_regexp</code>.</p><dl><dt>parameter block_size</dt><dd><p>default: <code>1048576</code> characters, valid range: <code>1 &lt;=
    block_size &lt;= Sys.max_string_length</code>.</p></dd></dl><dl><dt>parameter block_overlap</dt><dd><p>default: <code>block_size / 16</code>, valid range: <code>1 &lt;=
    block_overlap &lt;= block_size / 2</code>.</p></dd></dl><dl><dt>parameter min_rspace</dt><dd><p>default: <code>block_size / 64</code>, valid range: <code>1 &lt;=
    min_rspace &lt;= block_overlap</code>.</p></dd></dl><dl><dt>raises Invalid_argument</dt><dd><p>if the arguments are invalid.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-length"><a href="#val-length" class="anchor"></a><code><span class="keyword">val</span> length : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int</code></dt><dd><p><code>length s</code> returns the number of characters in the stream <code>s</code>.</p></dd></dl><dl><dt class="spec value" id="val-seek"><a href="#val-seek" class="anchor"></a><code><span class="keyword">val</span> seek : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> unit</code></dt><dd><p><code>seek s pos</code> prepares the stream for reading from position <code>pos</code>. If <code>pos</code> is outside the block currently held in memory, a block containing <code>pos</code> is read, replacing the old block.</p><dl><dt>raises Invalid_argument</dt><dd><p>if <code>pos</code> is not a valid stream position.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-read_char"><a href="#val-read_char" class="anchor"></a><code><span class="keyword">val</span> read_char : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> char option</code></dt><dd><p><code>read_char s pos</code> returns <code>Some c</code> if <code>c</code> is the character at position <code>pos</code> in <code>s</code>, or <code>None</code> if this position is not a valid position in <code>s</code>.</p></dd></dl><dl><dt class="spec value" id="val-read_string"><a href="#val-read_string" class="anchor"></a><code><span class="keyword">val</span> read_string : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> string</code></dt><dd><p><code>read_string s pos maxlen</code> returns a string containing the next <code>n</code> characters in <code>s</code>, where <code>n</code> is the minimum of <code>maxlen</code> and the number of characters remaining from position <code>pos</code>. If <code>pos</code> is not a valid position in <code>s</code>, the empty string is returned.</p></dd></dl><dl><dt class="spec value" id="val-match_char"><a href="#val-match_char" class="anchor"></a><code><span class="keyword">val</span> match_char : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> char <span>&#45;&gt;</span> bool</code></dt><dd><p><code>match_char s pos c</code> is equivalent to <code>read_char s pos = Some c</code>.</p></dd></dl><dl><dt class="spec value" id="val-match_string"><a href="#val-match_string" class="anchor"></a><code><span class="keyword">val</span> match_string : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> string <span>&#45;&gt;</span> bool</code></dt><dd><p><code>match_string s pos str</code> is equivalent to <code>read_string s pos
    (String.length str) = str</code>.</p></dd></dl><section><header><h3 id="regexp-related-features"><a href="#regexp-related-features" class="anchor"></a>Regexp-related features</h3></header><div class="spec module" id="module-MakeRegexp"><a href="#module-MakeRegexp" class="anchor"></a><code><span class="keyword">module</span> <a href="MakeRegexp/index.html">MakeRegexp</a> : <span class="keyword">functor</span> (<a href="MakeRegexp/argument-1-Regexp/index.html">Regexp</a> : <a href="../MParser_Sig/index.html#module-type-Regexp">MParser_Sig.Regexp</a>) <span>&#45;&gt;</span> <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div></section></div></body></html>