<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Namespaces (namespaces.Namespaces)</title><link rel="stylesheet" href="../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../index.html">namespaces</a> &#x00BB; Namespaces</nav><h1>Module <code>Namespaces</code></h1><p><code>ocamlbuild</code> namespaces plugin. This plugin turns directories in the source tree into namespace modules. For example:</p><p>The directory tree</p><pre>    main.ml
    foo/
      bar/
        some.ml</pre><p>results in modules <code>Main</code>, <code>Foo</code>, <code>Foo.Bar</code>, and <code>Foo.Bar.Some</code>, provided the directories <code>foo/</code> and <code>bar/</code> are tagged with <code>namespace</code>. The easiest way to do this is to add <code>&lt;**/*&gt;: namespace</code> to your <code>_tags</code> file.</p><p>To include this plugin in your build process, call <code>Namespaces.handler</code> from your <code>myocamlbuild.ml</code> file, and invoke ocamlbuild using <code>ocamlbuild -use-ocamlfind -plugin-tag &quot;package(namespaces)&quot; [your_target]</code>. A minimal <code>myocamlbuild.ml</code> file using this plugin looks like this:</p><pre>    open Ocamlbuild_plugin
    let () = dispatch Namespaces.handler</pre><p>For more information on <code>ocamlbuild</code>, <code>_tags</code>, and <code>myocamlbuild.ml</code>, see the <a href="http://caml.inria.fr/pub/docs/manual-ocaml/ocamlbuild.html">ocamlbuild manual</a>.</p><nav class="toc"><ul><li><a href="#generated-files">Generated files</a></li><li><a href="#plugin">Plugin</a></li><li><a href="#debugging">Debugging</a></li></ul></nav></header><section><header><h2 id="generated-files"><a href="#generated-files" class="anchor"></a>Generated files</h2></header><dl><dt class="spec type" id="type-generator"><a href="#type-generator" class="anchor"></a><code><span class="keyword">type</span> generator</code><code> = string * string list</code></dt><dd><p>The plugin does not automatically detect generated <code>.ml</code> and <code>.mli</code> files in namespaces. If some of your files are generated, you must describe the generator to the plugin. The syntax is the same as for <code>ocamlbuild</code> rule dependencies and products. For example, the description of <code>ocamllex</code> is <code>&quot;%.mll&quot;, [&quot;%.ml&quot;]</code>. Note that the outer brackets are part of `ocamldoc` code style syntax, not OCaml list syntax!</p></dd></dl><dl><dt class="spec value" id="val-ocamllex"><a href="#val-ocamllex" class="anchor"></a><code><span class="keyword">val</span> ocamllex : <a href="index.html#type-generator">generator</a></code></dt><dd><p><code>&quot;%.mll&quot;, [&quot;%.ml&quot;]</code>.</p></dd></dl><dl><dt class="spec value" id="val-ocamlyacc"><a href="#val-ocamlyacc" class="anchor"></a><code><span class="keyword">val</span> ocamlyacc : <a href="index.html#type-generator">generator</a></code></dt><dd><p><code>&quot;%.mly&quot;, [&quot;%.ml&quot;]</code>.</p></dd></dl><dl><dt class="spec value" id="val-builtin_generators"><a href="#val-builtin_generators" class="anchor"></a><code><span class="keyword">val</span> builtin_generators : <a href="index.html#type-generator">generator</a> list</code></dt><dd><p>The list <code>[ocamllex; ocamlyacc]</code>.</p></dd></dl></section><section><header><h2 id="plugin"><a href="#plugin" class="anchor"></a>Plugin</h2></header><dl><dt class="spec value" id="val-handler"><a href="#val-handler" class="anchor"></a><code><span class="keyword">val</span> handler : ?&#8288;generators:<a href="index.html#type-generator">generator</a> list <span>&#45;&gt;</span> ?&#8288;filter:(string <span>&#45;&gt;</span> string option) <span>&#45;&gt;</span> <a href="../../ocamlbuild/Ocamlbuild_plugin/index.html#type-hook">Ocamlbuild_plugin.hook</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Scans the source tree and creates namespaces, as described above. If the <code>generators</code> parameter is not specified, it is equal to <code>builtin_generators</code>. The <code>filter</code> parameter allows transformation of the detected filenames or the omission of the files.</p></dd></dl><dl><dt class="spec value" id="val-delete_mllib_files"><a href="#val-delete_mllib_files" class="anchor"></a><code><span class="keyword">val</span> delete_mllib_files : unit <span>&#45;&gt;</span> unit</code></dt><dd><p>Deletes all <code>.mllib</code> files in the source tree. This function is a workaround for building libraries with OASIS. OASIS generates its own <code>.mllib</code> files. To prevent them from being used, they should be deleted on each build by calling this function in `myocamlbuild.ml`, e.g.:</p><pre>    let () = Namespaces.delete_mllib_files ()</pre></dd></dl></section><section><header><h2 id="debugging"><a href="#debugging" class="anchor"></a>Debugging</h2></header><dl><dt class="spec type" id="type-file"><a href="#type-file" class="anchor"></a><code><span class="keyword">type</span> file</code><code> = </code><code>{</code><table class="record"><tr id="type-file.original_name" class="anchored"><td class="def field"><a href="#type-file.original_name" class="anchor"></a><code>original_name : string;</code></td><td class="doc"><p>File or directory name as it appears in the source tree.</p></td></tr><tr id="type-file.renamed_name" class="anchored"><td class="def field"><a href="#type-file.renamed_name" class="anchor"></a><code>renamed_name : string;</code></td><td class="doc"><p>If the file is a namespace tagged with <code>namespace_with_name(n)</code>, this is <code>n</code>. Otherwise, it is equal to <code>original_name</code>.</p></td></tr><tr id="type-file.prefixed_name" class="anchored"><td class="def field"><a href="#type-file.prefixed_name" class="anchor"></a><code>prefixed_name : string;</code></td><td class="doc"><p>File or directory name after prefixing with its namespace path.</p></td></tr><tr id="type-file.directory" class="anchored"><td class="def field"><a href="#type-file.directory" class="anchor"></a><code>directory : string list;</code></td><td class="doc"><p>List of path components giving the directory containing the file.</p></td></tr><tr id="type-file.namespace" class="anchored"><td class="def field"><a href="#type-file.namespace" class="anchor"></a><code>namespace : string list;</code></td><td class="doc"><p>Module path of the namespace containing the module resulting from the file.</p></td></tr></table><code>}</code></dt><dd><p>Type of a file that has been indexed by the plugin during its scan of the source tree. <code>file</code> can represent a module, interface, or namespace. In the first two cases, <code>original_name</code> and <code>prefixed_name</code> end with <code>.ml</code> or <code>.mli</code>, respectively. If the file is a namespace, <code>original_name</code> and <code>prefixed_name</code> are directory names without suffix.</p></dd></dl><dl><dt class="spec value" id="val-iter"><a href="#val-iter" class="anchor"></a><code><span class="keyword">val</span> iter : (([ `Module | `Interface | `Namespace ] * <a href="index.html#type-file">file</a>) <span>&#45;&gt;</span> unit) <span>&#45;&gt;</span> unit</code></dt><dd><p>Calls the given function for each <code>.ml</code> file, <code>.mli</code> file, and namespace in the source tree. Must be called in the <code>After_rules</code> hook.</p></dd></dl></section></div></body></html>