<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>BytesLabels (ocaml.BytesLabels)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../index.html">ocaml</a> &#x00BB; BytesLabels</nav><h1>Module <code>BytesLabels</code></h1><p>Byte sequence operations.</p><dl><dt>since</dt><dd>4.02.0</dd></dl></header><dl><dt class="spec external" id="val-length"><a href="#val-length" class="anchor"></a><code><span class="keyword">val </span>length : bytes <span>&#45;&gt;</span> int</code></dt><dd><p>Return the length (number of bytes) of the argument.</p></dd></dl><dl><dt class="spec external" id="val-get"><a href="#val-get" class="anchor"></a><code><span class="keyword">val </span>get : bytes <span>&#45;&gt;</span> int <span>&#45;&gt;</span> char</code></dt><dd><p><code>get s n</code> returns the byte at index <code>n</code> in argument <code>s</code>.</p><p>Raise <code>Invalid_argument</code> if <code>n</code> not a valid index in <code>s</code>.</p></dd></dl><dl><dt class="spec external" id="val-set"><a href="#val-set" class="anchor"></a><code><span class="keyword">val </span>set : bytes <span>&#45;&gt;</span> int <span>&#45;&gt;</span> char <span>&#45;&gt;</span> unit</code></dt><dd><p><code>set s n c</code> modifies <code>s</code> in place, replacing the byte at index <code>n</code> with <code>c</code>.</p><p>Raise <code>Invalid_argument</code> if <code>n</code> is not a valid index in <code>s</code>.</p></dd></dl><dl><dt class="spec external" id="val-create"><a href="#val-create" class="anchor"></a><code><span class="keyword">val </span>create : int <span>&#45;&gt;</span> bytes</code></dt><dd><p><code>create n</code> returns a new byte sequence of length <code>n</code>. The sequence is uninitialized and contains arbitrary bytes.</p><p>Raise <code>Invalid_argument</code> if <code>n &lt; 0</code> or <code>n &gt; </code><span class="xref-unresolved" title="unresolved reference to &quot;Sys.max_string_length&quot;"><code>Sys</code>.max_string_length</span>.</p></dd></dl><dl><dt class="spec value" id="val-make"><a href="#val-make" class="anchor"></a><code><span class="keyword">val </span>make : int <span>&#45;&gt;</span> char <span>&#45;&gt;</span> bytes</code></dt><dd><p><code>make n c</code> returns a new byte sequence of length <code>n</code>, filled with the byte <code>c</code>.</p><p>Raise <code>Invalid_argument</code> if <code>n &lt; 0</code> or <code>n &gt; </code><span class="xref-unresolved" title="unresolved reference to &quot;Sys.max_string_length&quot;"><code>Sys</code>.max_string_length</span>.</p></dd></dl><dl><dt class="spec value" id="val-init"><a href="#val-init" class="anchor"></a><code><span class="keyword">val </span>init : int <span>&#45;&gt;</span> f:(int <span>&#45;&gt;</span> char) <span>&#45;&gt;</span> bytes</code></dt><dd><p><code>init n f</code> returns a fresh byte sequence of length <code>n</code>, with character <code>i</code> initialized to the result of <code>f i</code>.</p><p>Raise <code>Invalid_argument</code> if <code>n &lt; 0</code> or <code>n &gt; </code><span class="xref-unresolved" title="unresolved reference to &quot;Sys.max_string_length&quot;"><code>Sys</code>.max_string_length</span>.</p></dd></dl><dl><dt class="spec value" id="val-empty"><a href="#val-empty" class="anchor"></a><code><span class="keyword">val </span>empty : bytes</code></dt><dd><p>A byte sequence of size 0.</p></dd></dl><dl><dt class="spec value" id="val-copy"><a href="#val-copy" class="anchor"></a><code><span class="keyword">val </span>copy : bytes <span>&#45;&gt;</span> bytes</code></dt><dd><p>Return a new byte sequence that contains the same bytes as the argument.</p></dd></dl><dl><dt class="spec value" id="val-of_string"><a href="#val-of_string" class="anchor"></a><code><span class="keyword">val </span>of_string : string <span>&#45;&gt;</span> bytes</code></dt><dd><p>Return a new byte sequence that contains the same bytes as the given string.</p></dd></dl><dl><dt class="spec value" id="val-to_string"><a href="#val-to_string" class="anchor"></a><code><span class="keyword">val </span>to_string : bytes <span>&#45;&gt;</span> string</code></dt><dd><p>Return a new string that contains the same bytes as the given byte sequence.</p></dd></dl><dl><dt class="spec value" id="val-sub"><a href="#val-sub" class="anchor"></a><code><span class="keyword">val </span>sub : bytes <span>&#45;&gt;</span> pos:int <span>&#45;&gt;</span> len:int <span>&#45;&gt;</span> bytes</code></dt><dd><p><code>sub s start len</code> returns a new byte sequence of length <code>len</code>, containing the subsequence of <code>s</code> that starts at position <code>start</code> and has length <code>len</code>.</p><p>Raise <code>Invalid_argument</code> if <code>start</code> and <code>len</code> do not designate a valid range of <code>s</code>.</p></dd></dl><dl><dt class="spec value" id="val-sub_string"><a href="#val-sub_string" class="anchor"></a><code><span class="keyword">val </span>sub_string : bytes <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> string</code></dt><dd><p>Same as <code>sub</code> but return a string instead of a byte sequence.</p></dd></dl><dl><dt class="spec value" id="val-fill"><a href="#val-fill" class="anchor"></a><code><span class="keyword">val </span>fill : bytes <span>&#45;&gt;</span> pos:int <span>&#45;&gt;</span> len:int <span>&#45;&gt;</span> char <span>&#45;&gt;</span> unit</code></dt><dd><p><code>fill s start len c</code> modifies <code>s</code> in place, replacing <code>len</code> characters with <code>c</code>, starting at <code>start</code>.</p><p>Raise <code>Invalid_argument</code> if <code>start</code> and <code>len</code> do not designate a valid range of <code>s</code>.</p></dd></dl><dl><dt class="spec value" id="val-blit"><a href="#val-blit" class="anchor"></a><code><span class="keyword">val </span>blit : src:bytes <span>&#45;&gt;</span> src_pos:int <span>&#45;&gt;</span> dst:bytes <span>&#45;&gt;</span> dst_pos:int <span>&#45;&gt;</span> len:int <span>&#45;&gt;</span> unit</code></dt><dd><p><code>blit src srcoff dst dstoff len</code> copies <code>len</code> bytes from sequence <code>src</code>, starting at index <code>srcoff</code>, to sequence <code>dst</code>, starting at index <code>dstoff</code>. It works correctly even if <code>src</code> and <code>dst</code> are the same byte sequence, and the source and destination intervals overlap.</p><p>Raise <code>Invalid_argument</code> if <code>srcoff</code> and <code>len</code> do not designate a valid range of <code>src</code>, or if <code>dstoff</code> and <code>len</code> do not designate a valid range of <code>dst</code>.</p></dd></dl><dl><dt class="spec value" id="val-concat"><a href="#val-concat" class="anchor"></a><code><span class="keyword">val </span>concat : sep:bytes <span>&#45;&gt;</span> bytes list <span>&#45;&gt;</span> bytes</code></dt><dd><p><code>concat sep sl</code> concatenates the list of byte sequences <code>sl</code>, inserting the separator byte sequence <code>sep</code> between each, and returns the result as a new byte sequence.</p></dd></dl><dl><dt class="spec value" id="val-iter"><a href="#val-iter" class="anchor"></a><code><span class="keyword">val </span>iter : f:(char <span>&#45;&gt;</span> unit) <span>&#45;&gt;</span> bytes <span>&#45;&gt;</span> unit</code></dt><dd><p><code>iter f s</code> applies function <code>f</code> in turn to all the bytes of <code>s</code>. It is equivalent to <code>f (get s 0); f (get s 1); ...; f (get s
    (length s - 1)); ()</code>.</p></dd></dl><dl><dt class="spec value" id="val-iteri"><a href="#val-iteri" class="anchor"></a><code><span class="keyword">val </span>iteri : f:(int <span>&#45;&gt;</span> char <span>&#45;&gt;</span> unit) <span>&#45;&gt;</span> bytes <span>&#45;&gt;</span> unit</code></dt><dd><p>Same as <span class="xref-unresolved" title="unresolved reference to &quot;Bytes.iter&quot;"><code>Bytes</code>.iter</span>, but the function is applied to the index of the byte as first argument and the byte itself as second argument.</p></dd></dl><dl><dt class="spec value" id="val-map"><a href="#val-map" class="anchor"></a><code><span class="keyword">val </span>map : f:(char <span>&#45;&gt;</span> char) <span>&#45;&gt;</span> bytes <span>&#45;&gt;</span> bytes</code></dt><dd><p><code>map f s</code> applies function <code>f</code> in turn to all the bytes of <code>s</code> and stores the resulting bytes in a new sequence that is returned as the result.</p></dd></dl><dl><dt class="spec value" id="val-mapi"><a href="#val-mapi" class="anchor"></a><code><span class="keyword">val </span>mapi : f:(int <span>&#45;&gt;</span> char <span>&#45;&gt;</span> char) <span>&#45;&gt;</span> bytes <span>&#45;&gt;</span> bytes</code></dt><dd><p><code>mapi f s</code> calls <code>f</code> with each character of <code>s</code> and its index (in increasing index order) and stores the resulting bytes in a new sequence that is returned as the result.</p></dd></dl><dl><dt class="spec value" id="val-trim"><a href="#val-trim" class="anchor"></a><code><span class="keyword">val </span>trim : bytes <span>&#45;&gt;</span> bytes</code></dt><dd><p>Return a copy of the argument, without leading and trailing whitespace. The bytes regarded as whitespace are the ASCII characters <code>' '</code>, <code>'\012'</code>, <code>'\n'</code>, <code>'\r'</code>, and <code>'\t'</code>.</p></dd></dl><dl><dt class="spec value" id="val-escaped"><a href="#val-escaped" class="anchor"></a><code><span class="keyword">val </span>escaped : bytes <span>&#45;&gt;</span> bytes</code></dt><dd><p>Return a copy of the argument, with special characters represented by escape sequences, following the lexical conventions of OCaml.</p></dd></dl><dl><dt class="spec value" id="val-index"><a href="#val-index" class="anchor"></a><code><span class="keyword">val </span>index : bytes <span>&#45;&gt;</span> char <span>&#45;&gt;</span> int</code></dt><dd><p><code>index s c</code> returns the index of the first occurrence of byte <code>c</code> in <code>s</code>.</p><p>Raise <code>Not_found</code> if <code>c</code> does not occur in <code>s</code>.</p></dd></dl><dl><dt class="spec value" id="val-rindex"><a href="#val-rindex" class="anchor"></a><code><span class="keyword">val </span>rindex : bytes <span>&#45;&gt;</span> char <span>&#45;&gt;</span> int</code></dt><dd><p><code>rindex s c</code> returns the index of the last occurrence of byte <code>c</code> in <code>s</code>.</p><p>Raise <code>Not_found</code> if <code>c</code> does not occur in <code>s</code>.</p></dd></dl><dl><dt class="spec value" id="val-index_from"><a href="#val-index_from" class="anchor"></a><code><span class="keyword">val </span>index_from : bytes <span>&#45;&gt;</span> int <span>&#45;&gt;</span> char <span>&#45;&gt;</span> int</code></dt><dd><p><code>index_from s i c</code> returns the index of the first occurrence of byte <code>c</code> in <code>s</code> after position <code>i</code>. <code>Bytes.index s c</code> is equivalent to <code>Bytes.index_from s 0 c</code>.</p><p>Raise <code>Invalid_argument</code> if <code>i</code> is not a valid position in <code>s</code>. Raise <code>Not_found</code> if <code>c</code> does not occur in <code>s</code> after position <code>i</code>.</p></dd></dl><dl><dt class="spec value" id="val-rindex_from"><a href="#val-rindex_from" class="anchor"></a><code><span class="keyword">val </span>rindex_from : bytes <span>&#45;&gt;</span> int <span>&#45;&gt;</span> char <span>&#45;&gt;</span> int</code></dt><dd><p><code>rindex_from s i c</code> returns the index of the last occurrence of byte <code>c</code> in <code>s</code> before position <code>i+1</code>. <code>rindex s c</code> is equivalent to <code>rindex_from s (Bytes.length s - 1) c</code>.</p><p>Raise <code>Invalid_argument</code> if <code>i+1</code> is not a valid position in <code>s</code>. Raise <code>Not_found</code> if <code>c</code> does not occur in <code>s</code> before position <code>i+1</code>.</p></dd></dl><dl><dt class="spec value" id="val-contains"><a href="#val-contains" class="anchor"></a><code><span class="keyword">val </span>contains : bytes <span>&#45;&gt;</span> char <span>&#45;&gt;</span> bool</code></dt><dd><p><code>contains s c</code> tests if byte <code>c</code> appears in <code>s</code>.</p></dd></dl><dl><dt class="spec value" id="val-contains_from"><a href="#val-contains_from" class="anchor"></a><code><span class="keyword">val </span>contains_from : bytes <span>&#45;&gt;</span> int <span>&#45;&gt;</span> char <span>&#45;&gt;</span> bool</code></dt><dd><p><code>contains_from s start c</code> tests if byte <code>c</code> appears in <code>s</code> after position <code>start</code>. <code>contains s c</code> is equivalent to <code>contains_from
    s 0 c</code>.</p><p>Raise <code>Invalid_argument</code> if <code>start</code> is not a valid position in <code>s</code>.</p></dd></dl><dl><dt class="spec value" id="val-rcontains_from"><a href="#val-rcontains_from" class="anchor"></a><code><span class="keyword">val </span>rcontains_from : bytes <span>&#45;&gt;</span> int <span>&#45;&gt;</span> char <span>&#45;&gt;</span> bool</code></dt><dd><p><code>rcontains_from s stop c</code> tests if byte <code>c</code> appears in <code>s</code> before position <code>stop+1</code>.</p><p>Raise <code>Invalid_argument</code> if <code>stop &lt; 0</code> or <code>stop+1</code> is not a valid position in <code>s</code>.</p></dd></dl><dl><dt class="spec value" id="val-uppercase"><a href="#val-uppercase" class="anchor"></a><code><span class="keyword">val </span>uppercase : bytes <span>&#45;&gt;</span> bytes</code></dt><dd><p>Return a copy of the argument, with all lowercase letters translated to uppercase, including accented letters of the ISO Latin-1 (8859-1) character set.</p></dd></dl><dl><dt class="spec value" id="val-lowercase"><a href="#val-lowercase" class="anchor"></a><code><span class="keyword">val </span>lowercase : bytes <span>&#45;&gt;</span> bytes</code></dt><dd><p>Return a copy of the argument, with all uppercase letters translated to lowercase, including accented letters of the ISO Latin-1 (8859-1) character set.</p></dd></dl><dl><dt class="spec value" id="val-capitalize"><a href="#val-capitalize" class="anchor"></a><code><span class="keyword">val </span>capitalize : bytes <span>&#45;&gt;</span> bytes</code></dt><dd><p>Return a copy of the argument, with the first byte set to uppercase.</p></dd></dl><dl><dt class="spec value" id="val-uncapitalize"><a href="#val-uncapitalize" class="anchor"></a><code><span class="keyword">val </span>uncapitalize : bytes <span>&#45;&gt;</span> bytes</code></dt><dd><p>Return a copy of the argument, with the first byte set to lowercase.</p></dd></dl><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type </span>t</code><code><span class="keyword"> = </span>bytes</code></dt><dd><p>An alias for the type of byte sequences.</p></dd></dl><dl><dt class="spec value" id="val-compare"><a href="#val-compare" class="anchor"></a><code><span class="keyword">val </span>compare : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int</code></dt><dd><p>The comparison function for byte sequences, with the same specification as <span class="xref-unresolved" title="unresolved reference to &quot;Pervasives.compare&quot;"><code>Pervasives</code>.compare</span>. Along with the type <code>t</code>, this function <code>compare</code> allows the module <code>Bytes</code> to be passed as argument to the functors <span class="xref-unresolved" title="unresolved reference to &quot;Set.Make&quot;"><code>Set</code>.Make</span> and <span class="xref-unresolved" title="unresolved reference to &quot;Map.Make&quot;"><code>Map</code>.Make</span>.</p></dd></dl></div></body></html>