<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Flambda_utils (ocaml.Flambda_utils)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../index.html">ocaml</a> &#x00BB; Flambda_utils</nav><h1>Module <code>Flambda_utils</code></h1><p>Utility functions for the Flambda intermediate language.</p></header><aside><p>Access functions</p></aside><dl><dt class="spec value" id="val-find_declaration"><a href="#val-find_declaration" class="anchor"></a><code><span class="keyword">val </span>find_declaration : Closure_id.t <span>&#45;&gt;</span> Flambda.function_declarations <span>&#45;&gt;</span> Flambda.function_declaration</code></dt><dd><p><code>find_declaration f decl</code> raises <code>Not_found</code> if <code>f</code> is not in <code>decl</code>.</p></dd></dl><dl><dt class="spec value" id="val-find_declaration_variable"><a href="#val-find_declaration_variable" class="anchor"></a><code><span class="keyword">val </span>find_declaration_variable : Closure_id.t <span>&#45;&gt;</span> Flambda.function_declarations <span>&#45;&gt;</span> Variable.t</code></dt><dd><p><code>find_declaration_variable f decl</code> raises <code>Not_found</code> if <code>f</code> is not in <code>decl</code>.</p></dd></dl><dl><dt class="spec value" id="val-find_free_variable"><a href="#val-find_free_variable" class="anchor"></a><code><span class="keyword">val </span>find_free_variable : Var_within_closure.t <span>&#45;&gt;</span> Flambda.set_of_closures <span>&#45;&gt;</span> Variable.t</code></dt><dd><p><code>find_free_variable v clos</code> raises <code>Not_found</code> if <code>c</code> is not in <code>clos</code>.</p></dd></dl><aside><p>Utility functions</p></aside><dl><dt class="spec value" id="val-function_arity"><a href="#val-function_arity" class="anchor"></a><code><span class="keyword">val </span>function_arity : Flambda.function_declaration <span>&#45;&gt;</span> int</code></dt><dt class="spec value" id="val-variables_bound_by_the_closure"><a href="#val-variables_bound_by_the_closure" class="anchor"></a><code><span class="keyword">val </span>variables_bound_by_the_closure : Closure_id.t <span>&#45;&gt;</span> Flambda.function_declarations <span>&#45;&gt;</span> Variable.Set.t</code></dt><dd><p>Variables &quot;bound by a closure&quot; are those variables free in the corresponding function's body that are neither:</p><ul><li>bound as parameters of that function; nor</li><li>bound by the <code>let</code> binding that introduces the function declaration(s). In particular, if <code>f</code>, <code>g</code> and <code>h</code> are being introduced by a simultaneous, possibly mutually-recursive <code>let</code> binding then none of <code>f</code>, <code>g</code> or <code>h</code> are bound in any of the closures for <code>f</code>, <code>g</code> and <code>h</code>.</li></ul></dd></dl><dl><dt class="spec value" id="val-can_be_merged"><a href="#val-can_be_merged" class="anchor"></a><code><span class="keyword">val </span>can_be_merged : Flambda.t <span>&#45;&gt;</span> Flambda.t <span>&#45;&gt;</span> bool</code></dt><dd><p>If <code>can_be_merged f1 f2</code> is <code>true</code>, it is safe to merge switch branches containing <code>f1</code> and <code>f2</code>.</p></dd></dl><dl><dt class="spec value" id="val-description_of_toplevel_node"><a href="#val-description_of_toplevel_node" class="anchor"></a><code><span class="keyword">val </span>description_of_toplevel_node : Flambda.t <span>&#45;&gt;</span> string</code></dt></dl><dl><dt class="spec type" id="type-sharing_key"><a href="#type-sharing_key" class="anchor"></a><code><span class="keyword">type </span>sharing_key</code></dt><dd><p>Sharing key, used for coalescing switch cases.</p></dd></dl><dl><dt class="spec value" id="val-make_key"><a href="#val-make_key" class="anchor"></a><code><span class="keyword">val </span>make_key : Flambda.t <span>&#45;&gt;</span> <a href="index.html#type-sharing_key">sharing_key</a> option</code></dt><dt class="spec value" id="val-make_closure_declaration"><a href="#val-make_closure_declaration" class="anchor"></a><code><span class="keyword">val </span>make_closure_declaration : id:Variable.t <span>&#45;&gt;</span> body:Flambda.t <span>&#45;&gt;</span> params:Variable.t list <span>&#45;&gt;</span> stub:bool <span>&#45;&gt;</span> Flambda.t</code></dt><dt class="spec value" id="val-toplevel_substitution"><a href="#val-toplevel_substitution" class="anchor"></a><code><span class="keyword">val </span>toplevel_substitution : Variable.t Variable.Map.t <span>&#45;&gt;</span> Flambda.expr <span>&#45;&gt;</span> Flambda.expr</code></dt><dt class="spec value" id="val-toplevel_substitution_named"><a href="#val-toplevel_substitution_named" class="anchor"></a><code><span class="keyword">val </span>toplevel_substitution_named : Variable.t Variable.Map.t <span>&#45;&gt;</span> Flambda.named <span>&#45;&gt;</span> Flambda.named</code></dt><dt class="spec value" id="val-bind"><a href="#val-bind" class="anchor"></a><code><span class="keyword">val </span>bind : bindings:(Variable.t<span class="keyword"> * </span>Flambda.named) list <span>&#45;&gt;</span> body:Flambda.t <span>&#45;&gt;</span> Flambda.t</code></dt><dd><p><code>bind [var1, expr1; ...; varN, exprN] body</code> binds using <code>Immutable</code> <code>Let</code> expressions the given <code>(var, expr)</code> pairs around the body.</p></dd></dl><dl><dt class="spec value" id="val-name_expr"><a href="#val-name_expr" class="anchor"></a><code><span class="keyword">val </span>name_expr : Flambda.named <span>&#45;&gt;</span> name:string <span>&#45;&gt;</span> Flambda.t</code></dt><dt class="spec value" id="val-compare_const"><a href="#val-compare_const" class="anchor"></a><code><span class="keyword">val </span>compare_const : Flambda.const <span>&#45;&gt;</span> Flambda.const <span>&#45;&gt;</span> int</code></dt><dt class="spec value" id="val-initialize_symbols"><a href="#val-initialize_symbols" class="anchor"></a><code><span class="keyword">val </span>initialize_symbols : Flambda.program <span>&#45;&gt;</span> (Symbol.t<span class="keyword"> * </span>Tag.t<span class="keyword"> * </span>Flambda.t list) list</code></dt><dt class="spec value" id="val-imported_symbols"><a href="#val-imported_symbols" class="anchor"></a><code><span class="keyword">val </span>imported_symbols : Flambda.program <span>&#45;&gt;</span> Symbol.Set.t</code></dt><dt class="spec value" id="val-needed_import_symbols"><a href="#val-needed_import_symbols" class="anchor"></a><code><span class="keyword">val </span>needed_import_symbols : Flambda.program <span>&#45;&gt;</span> Symbol.Set.t</code></dt><dt class="spec value" id="val-introduce_needed_import_symbols"><a href="#val-introduce_needed_import_symbols" class="anchor"></a><code><span class="keyword">val </span>introduce_needed_import_symbols : Flambda.program <span>&#45;&gt;</span> Flambda.program</code></dt><dt class="spec value" id="val-root_symbol"><a href="#val-root_symbol" class="anchor"></a><code><span class="keyword">val </span>root_symbol : Flambda.program <span>&#45;&gt;</span> Symbol.t</code></dt><dt class="spec value" id="val-might_raise_static_exn"><a href="#val-might_raise_static_exn" class="anchor"></a><code><span class="keyword">val </span>might_raise_static_exn : Flambda.named <span>&#45;&gt;</span> Static_exception.t <span>&#45;&gt;</span> bool</code></dt><dd><p>Returns <code>true</code> iff the given term might raise the given static exception.</p></dd></dl><dl><dt class="spec value" id="val-make_closure_map"><a href="#val-make_closure_map" class="anchor"></a><code><span class="keyword">val </span>make_closure_map : Flambda.program <span>&#45;&gt;</span> Flambda.function_declarations Closure_id.Map.t</code></dt><dd><p>Creates a map from closure IDs to function declarations by iterating over all sets of closures in the given program.</p></dd></dl><dl><dt class="spec value" id="val-make_closure_map'"><a href="#val-make_closure_map'" class="anchor"></a><code><span class="keyword">val </span>make_closure_map' : Flambda.function_declarations Set_of_closures_id.Map.t <span>&#45;&gt;</span> Flambda.function_declarations Closure_id.Map.t</code></dt><dd><p>Like <code>make_closure_map</code>, but takes a mapping from set of closures IDs to function declarations, instead of a <code>program</code>.</p></dd></dl><dl><dt class="spec value" id="val-all_lifted_constants"><a href="#val-all_lifted_constants" class="anchor"></a><code><span class="keyword">val </span>all_lifted_constants : Flambda.program <span>&#45;&gt;</span> (Symbol.t<span class="keyword"> * </span>Flambda.constant_defining_value) list</code></dt><dd><p>The definitions of all constants that have been lifted out to <code>Let_symbol</code> or <code>Let_rec_symbol</code> constructions.</p></dd></dl><dl><dt class="spec value" id="val-all_lifted_constants_as_map"><a href="#val-all_lifted_constants_as_map" class="anchor"></a><code><span class="keyword">val </span>all_lifted_constants_as_map : Flambda.program <span>&#45;&gt;</span> Flambda.constant_defining_value Symbol.Map.t</code></dt><dd><p>Like <code>all_lifted_constant_symbols</code>, but returns a map instead of a list.</p></dd></dl><dl><dt class="spec value" id="val-all_lifted_constant_sets_of_closures"><a href="#val-all_lifted_constant_sets_of_closures" class="anchor"></a><code><span class="keyword">val </span>all_lifted_constant_sets_of_closures : Flambda.program <span>&#45;&gt;</span> Set_of_closures_id.Set.t</code></dt><dd><p>The identifiers of all constant sets of closures that have been lifted out to <code>Let_symbol</code> or <code>Let_rec_symbol</code> constructions.</p></dd></dl><dl><dt class="spec value" id="val-all_sets_of_closures"><a href="#val-all_sets_of_closures" class="anchor"></a><code><span class="keyword">val </span>all_sets_of_closures : Flambda.program <span>&#45;&gt;</span> Flambda.set_of_closures list</code></dt><dd><p>All sets of closures in the given program (whether or not bound to a symbol.)</p></dd></dl><dl><dt class="spec value" id="val-all_sets_of_closures_map"><a href="#val-all_sets_of_closures_map" class="anchor"></a><code><span class="keyword">val </span>all_sets_of_closures_map : Flambda.program <span>&#45;&gt;</span> Flambda.set_of_closures Set_of_closures_id.Map.t</code></dt><dt class="spec value" id="val-all_function_decls_indexed_by_set_of_closures_id"><a href="#val-all_function_decls_indexed_by_set_of_closures_id" class="anchor"></a><code><span class="keyword">val </span>all_function_decls_indexed_by_set_of_closures_id : Flambda.program <span>&#45;&gt;</span> Flambda.function_declarations Set_of_closures_id.Map.t</code></dt><dt class="spec value" id="val-all_function_decls_indexed_by_closure_id"><a href="#val-all_function_decls_indexed_by_closure_id" class="anchor"></a><code><span class="keyword">val </span>all_function_decls_indexed_by_closure_id : Flambda.program <span>&#45;&gt;</span> Flambda.function_declarations Closure_id.Map.t</code></dt><dt class="spec value" id="val-make_variable_symbol"><a href="#val-make_variable_symbol" class="anchor"></a><code><span class="keyword">val </span>make_variable_symbol : Variable.t <span>&#45;&gt;</span> Symbol.t</code></dt><dt class="spec value" id="val-make_variables_symbol"><a href="#val-make_variables_symbol" class="anchor"></a><code><span class="keyword">val </span>make_variables_symbol : Variable.t list <span>&#45;&gt;</span> Symbol.t</code></dt><dt class="spec value" id="val-substitute_read_symbol_field_for_variables"><a href="#val-substitute_read_symbol_field_for_variables" class="anchor"></a><code><span class="keyword">val </span>substitute_read_symbol_field_for_variables : (Symbol.t<span class="keyword"> * </span>int list) Variable.Map.t <span>&#45;&gt;</span> Flambda.t <span>&#45;&gt;</span> Flambda.t</code></dt></dl><dl><dt class="spec module" id="module-Switch_storer"><a href="#module-Switch_storer" class="anchor"></a><code><span class="keyword">module </span><a href="Switch_storer/index.html">Switch_storer</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>For the compilation of switch statements.</p></dd></dl><dl><dt class="spec value" id="val-fun_vars_referenced_in_decls"><a href="#val-fun_vars_referenced_in_decls" class="anchor"></a><code><span class="keyword">val </span>fun_vars_referenced_in_decls : Flambda.function_declarations <span>&#45;&gt;</span> backend:(<span class="keyword">module </span>Backend_intf.S) <span>&#45;&gt;</span> Variable.Set.t Variable.Map.t</code></dt><dd><p>Within a set of function declarations there is a set of function bodies, each of which may (or may not) reference one of the other functions in the same set. Initially such intra-set references are by <code>Var</code>s (known as &quot;fun_var&quot;s) but if the function is lifted by <code>Lift_constants</code> then the references will be translated to <code>Symbol</code>s. This means that optimization passes that need to identify whether a given &quot;fun_var&quot; (i.e. a key in the <code>funs</code> map in a value of type <code>function_declarations</code>) is used in one of the function bodies need to examine the <code>free_symbols</code> as well as the <code>free_variables</code> members of <code>function_declarations</code>. This function makes that process easier by computing all used &quot;fun_var&quot;s in the bodies of the given set of function declarations, including the cases where the references are <code>Symbol</code>s. The returned value is a map from &quot;fun_var&quot;s to the &quot;fun_var&quot;s (if any) used in the body of the function associated with that &quot;fun_var&quot;.</p></dd></dl><dl><dt class="spec value" id="val-closures_required_by_entry_point"><a href="#val-closures_required_by_entry_point" class="anchor"></a><code><span class="keyword">val </span>closures_required_by_entry_point : entry_point:Closure_id.t <span>&#45;&gt;</span> backend:(<span class="keyword">module </span>Backend_intf.S) <span>&#45;&gt;</span> Flambda.function_declarations <span>&#45;&gt;</span> Variable.Set.t</code></dt><dd><p>Computes the set of closure_id in the set of closures that are required used (transitively) the entry_point</p></dd></dl><dl><dt class="spec value" id="val-all_functions_parameters"><a href="#val-all_functions_parameters" class="anchor"></a><code><span class="keyword">val </span>all_functions_parameters : Flambda.function_declarations <span>&#45;&gt;</span> Variable.Set.t</code></dt><dt class="spec value" id="val-all_free_symbols"><a href="#val-all_free_symbols" class="anchor"></a><code><span class="keyword">val </span>all_free_symbols : Flambda.function_declarations <span>&#45;&gt;</span> Symbol.Set.t</code></dt><dt class="spec value" id="val-contains_stub"><a href="#val-contains_stub" class="anchor"></a><code><span class="keyword">val </span>contains_stub : Flambda.function_declarations <span>&#45;&gt;</span> bool</code></dt><dt class="spec value" id="val-clean_projections"><a href="#val-clean_projections" class="anchor"></a><code><span class="keyword">val </span>clean_projections : which_variables:Flambda.specialised_to Variable.Map.t <span>&#45;&gt;</span> Flambda.specialised_to Variable.Map.t</code></dt><dt class="spec value" id="val-projection_to_named"><a href="#val-projection_to_named" class="anchor"></a><code><span class="keyword">val </span>projection_to_named : Projection.t <span>&#45;&gt;</span> Flambda.named</code></dt></dl></div></body></html>