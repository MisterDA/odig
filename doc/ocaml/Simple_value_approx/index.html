<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Simple_value_approx (ocaml.Simple_value_approx)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../index.html">ocaml</a> &#x00BB; Simple_value_approx</nav><h1>Module <code>Simple_value_approx</code></h1><p>Simple approximations to the runtime results of computations. This pass is designed for speed rather than accuracy; the performance is important since it is used heavily during inlining.</p></header><dl><dt class="spec type" id="type-boxed_int"><a href="#type-boxed_int" class="anchor"></a><code><span class="keyword">type </span>'a boxed_int</code><code><span class="keyword"> = </span></code><table class="variant"><tr id="type-boxed_int.Int32" class="anchored"><td class="def constructor"><a href="#type-boxed_int.Int32" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Int32</span> <span class="keyword">:</span> int32 <a href="index.html#type-boxed_int">boxed_int</a></code></td></tr><tr id="type-boxed_int.Int64" class="anchored"><td class="def constructor"><a href="#type-boxed_int.Int64" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Int64</span> <span class="keyword">:</span> int64 <a href="index.html#type-boxed_int">boxed_int</a></code></td></tr><tr id="type-boxed_int.Nativeint" class="anchored"><td class="def constructor"><a href="#type-boxed_int.Nativeint" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Nativeint</span> <span class="keyword">:</span> nativeint <a href="index.html#type-boxed_int">boxed_int</a></code></td></tr></table></dt><dt class="spec type" id="type-value_string"><a href="#type-value_string" class="anchor"></a><code><span class="keyword">type </span>value_string</code><code><span class="keyword"> = </span></code><code>{</code><table class="record"><tr id="type-value_string.contents" class="anchored"><td class="def field"><a href="#type-value_string.contents" class="anchor"></a><code>contents : string option;</code></td></tr><tr id="type-value_string.size" class="anchored"><td class="def field"><a href="#type-value_string.size" class="anchor"></a><code>size : int;</code></td></tr></table><code>}</code></dt><dt class="spec type" id="type-value_float_array_contents"><a href="#type-value_float_array_contents" class="anchor"></a><code><span class="keyword">type </span>value_float_array_contents</code><code><span class="keyword"> = </span></code><table class="variant"><tr id="type-value_float_array_contents.Contents" class="anchored"><td class="def constructor"><a href="#type-value_float_array_contents.Contents" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Contents</span><span class="keyword"> of </span>float option array</code></td></tr><tr id="type-value_float_array_contents.Unknown_or_mutable" class="anchored"><td class="def constructor"><a href="#type-value_float_array_contents.Unknown_or_mutable" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Unknown_or_mutable</span></code></td></tr></table></dt><dt class="spec type" id="type-value_float_array"><a href="#type-value_float_array" class="anchor"></a><code><span class="keyword">type </span>value_float_array</code><code><span class="keyword"> = </span></code><code>{</code><table class="record"><tr id="type-value_float_array.contents" class="anchored"><td class="def field"><a href="#type-value_float_array.contents" class="anchor"></a><code>contents : <a href="index.html#type-value_float_array_contents">value_float_array_contents</a>;</code></td></tr><tr id="type-value_float_array.size" class="anchored"><td class="def field"><a href="#type-value_float_array.size" class="anchor"></a><code>size : int;</code></td></tr></table><code>}</code></dt><dt class="spec type" id="type-unknown_because_of"><a href="#type-unknown_because_of" class="anchor"></a><code><span class="keyword">type </span>unknown_because_of</code><code><span class="keyword"> = </span></code><table class="variant"><tr id="type-unknown_because_of.Unresolved_symbol" class="anchored"><td class="def constructor"><a href="#type-unknown_because_of.Unresolved_symbol" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Unresolved_symbol</span><span class="keyword"> of </span>Symbol.t</code></td></tr><tr id="type-unknown_because_of.Other" class="anchored"><td class="def constructor"><a href="#type-unknown_because_of.Other" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Other</span></code></td></tr></table></dt><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type </span>t</code><code><span class="keyword"> = </span><span class="keyword">private </span></code><code>{</code><table class="record"><tr id="type-t.descr" class="anchored"><td class="def field"><a href="#type-t.descr" class="anchor"></a><code>descr : <a href="index.html#type-descr">descr</a>;</code></td></tr><tr id="type-t.var" class="anchored"><td class="def field"><a href="#type-t.var" class="anchor"></a><code>var : Variable.t option;</code></td></tr><tr id="type-t.symbol" class="anchored"><td class="def field"><a href="#type-t.symbol" class="anchor"></a><code>symbol : (Symbol.t<span class="keyword"> * </span>int option) option;</code></td></tr></table><code>}</code></dt><dd><p>A value of type <code>t</code> corresponds to an &quot;approximation&quot; of the result of a computation in the program being compiled. That is to say, it represents what knowledge we have about such a result at compile time. The simplification pass exploits this information to partially evaluate computations.</p><p>At a high level, an approximation for a value <code>v</code> has three parts:</p><ul><li>the &quot;description&quot; (for example, &quot;the constant integer 42&quot;);</li><li>an optional variable;</li><li>an optional symbol or symbol field. If the variable (resp. symbol) is present then that variable (resp. symbol) may be used to obtain the value <code>v</code>.</li></ul><p>The exact semantics of the variable and symbol fields follows.</p><p>Approximations are deduced at particular points in an expression tree, but may subsequently be propagated to other locations.</p><p>At the point at which an approximation is built for some value <code>v</code>, we can construct a set of variables (call the set <code>S</code>) that are known to alias the same value <code>v</code>. Each member of <code>S</code> will have the same or a more precise <code>descr</code> field in its approximation relative to the approximation for <code>v</code>. (An increase in precision may currently be introduced for pattern matches.) If <code>S</code> is non-empty then it is guaranteed that there is a unique member of <code>S</code> that was declared in a scope further out (&quot;earlier&quot;) than all other members of <code>S</code>. If such a member exists then it is recorded in the <code>var</code> field. Otherwise <code>var</code> is <code>None</code>.</p><p>Analogous to the construction of the set <code>S</code>, we can construct a set <code>T</code> consisting of all symbols that are known to alias the value whose approximation is being constructed. If <code>T</code> is non-empty then the <code>symbol</code> field is set to some member of <code>T</code>; it does not matter which one. (There is no notion of scope for symbols.)</p><p>Note about mutable blocks:</p><p>Mutable blocks are always represented by <code>Value_unknown</code> or <code>Value_bottom</code>. Any other approximation could leave the door open to a miscompilation. Such bad scenarios are most likely a user using <code>Obj.magic</code> or <code>Obj.set_field</code> in an inappropriate situation. Such a situation might be: <code>let x = (1, 1) in
     Obj.set_field (Obj.repr x) 0 (Obj.repr 2);
     assert(fst x = 2)</code> The user would probably expect the assertion to be true, but the compiler could in fact propagate the value of <code>x</code> across the <code>Obj.set_field</code>.</p><p>Insisting that mutable blocks have <code>Value_unknown</code> or <code>Value_bottom</code> approximations certainly won't always prevent this kind of error, but should help catch many of them.</p><p>It is possible that there may be some false positives, with correct but unreachable code causing this check to fail. However the likelihood of this seems sufficiently low, especially compared to the advantages gained by performing the check, that we include it.</p><p>An example of a pattern that might trigger a false positive is: <code>type a = { a : int }
     type b = { mutable b : int }
     type _ t =
       | A : a t
       | B : b t
     let f (type x) (v:x t) (r:x) =
       match v with
       | A -&gt; r.a
       | B -&gt; r.b &lt;- 2; 3
    let v =
    let r =
      ref A in
      r := A; (* Some pattern that the compiler can't understand *)
      f !r { a = 1 }</code> When inlining <code>f</code>, the B branch is unreachable, yet the compiler cannot prove it and must therefore keep it.</p></dd></dl><dl><dt class="spec type" id="type-descr"><a href="#type-descr" class="anchor"></a><code><span class="keyword">and </span>descr</code><code><span class="keyword"> = </span><span class="keyword">private </span></code><table class="variant"><tr id="type-descr.Value_block" class="anchored"><td class="def constructor"><a href="#type-descr.Value_block" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Value_block</span><span class="keyword"> of </span>Tag.t<span class="keyword"> * </span><a href="index.html#type-t">t</a> array</code></td></tr><tr id="type-descr.Value_int" class="anchored"><td class="def constructor"><a href="#type-descr.Value_int" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Value_int</span><span class="keyword"> of </span>int</code></td></tr><tr id="type-descr.Value_char" class="anchored"><td class="def constructor"><a href="#type-descr.Value_char" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Value_char</span><span class="keyword"> of </span>char</code></td></tr><tr id="type-descr.Value_constptr" class="anchored"><td class="def constructor"><a href="#type-descr.Value_constptr" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Value_constptr</span><span class="keyword"> of </span>int</code></td></tr><tr id="type-descr.Value_float" class="anchored"><td class="def constructor"><a href="#type-descr.Value_float" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Value_float</span><span class="keyword"> of </span>float</code></td></tr><tr id="type-descr.Value_boxed_int" class="anchored"><td class="def constructor"><a href="#type-descr.Value_boxed_int" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Value_boxed_int</span><span class="keyword"> : </span><span class="type-var">'a</span> <a href="index.html#type-boxed_int">boxed_int</a><span class="keyword"> * </span><span class="type-var">'a</span> <span>&#45;&gt;</span> <a href="index.html#type-descr">descr</a></code></td></tr><tr id="type-descr.Value_set_of_closures" class="anchored"><td class="def constructor"><a href="#type-descr.Value_set_of_closures" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Value_set_of_closures</span><span class="keyword"> of </span><a href="index.html#type-value_set_of_closures">value_set_of_closures</a></code></td></tr><tr id="type-descr.Value_closure" class="anchored"><td class="def constructor"><a href="#type-descr.Value_closure" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Value_closure</span><span class="keyword"> of </span><a href="index.html#type-value_closure">value_closure</a></code></td></tr><tr id="type-descr.Value_string" class="anchored"><td class="def constructor"><a href="#type-descr.Value_string" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Value_string</span><span class="keyword"> of </span><a href="index.html#type-value_string">value_string</a></code></td></tr><tr id="type-descr.Value_float_array" class="anchored"><td class="def constructor"><a href="#type-descr.Value_float_array" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Value_float_array</span><span class="keyword"> of </span><a href="index.html#type-value_float_array">value_float_array</a></code></td></tr><tr id="type-descr.Value_unknown" class="anchored"><td class="def constructor"><a href="#type-descr.Value_unknown" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Value_unknown</span><span class="keyword"> of </span><a href="index.html#type-unknown_because_of">unknown_because_of</a></code></td></tr><tr id="type-descr.Value_bottom" class="anchored"><td class="def constructor"><a href="#type-descr.Value_bottom" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Value_bottom</span></code></td></tr><tr id="type-descr.Value_extern" class="anchored"><td class="def constructor"><a href="#type-descr.Value_extern" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Value_extern</span><span class="keyword"> of </span>Export_id.t</code></td></tr><tr id="type-descr.Value_symbol" class="anchored"><td class="def constructor"><a href="#type-descr.Value_symbol" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Value_symbol</span><span class="keyword"> of </span>Symbol.t</code></td></tr><tr id="type-descr.Value_unresolved" class="anchored"><td class="def constructor"><a href="#type-descr.Value_unresolved" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Value_unresolved</span><span class="keyword"> of </span>Symbol.t</code></td></tr></table></dt><dt class="spec type" id="type-value_closure"><a href="#type-value_closure" class="anchor"></a><code><span class="keyword">and </span>value_closure</code><code><span class="keyword"> = </span></code><code>{</code><table class="record"><tr id="type-value_closure.set_of_closures" class="anchored"><td class="def field"><a href="#type-value_closure.set_of_closures" class="anchor"></a><code>set_of_closures : <a href="index.html#type-t">t</a>;</code></td></tr><tr id="type-value_closure.closure_id" class="anchored"><td class="def field"><a href="#type-value_closure.closure_id" class="anchor"></a><code>closure_id : Closure_id.t;</code></td></tr></table><code>}</code></dt><dt class="spec type" id="type-value_set_of_closures"><a href="#type-value_set_of_closures" class="anchor"></a><code><span class="keyword">and </span>value_set_of_closures</code><code><span class="keyword"> = </span><span class="keyword">private </span></code><code>{</code><table class="record"><tr id="type-value_set_of_closures.function_decls" class="anchored"><td class="def field"><a href="#type-value_set_of_closures.function_decls" class="anchor"></a><code>function_decls : Flambda.function_declarations;</code></td></tr><tr id="type-value_set_of_closures.bound_vars" class="anchored"><td class="def field"><a href="#type-value_set_of_closures.bound_vars" class="anchor"></a><code>bound_vars : <a href="index.html#type-t">t</a> Var_within_closure.Map.t;</code></td></tr><tr id="type-value_set_of_closures.invariant_params" class="anchored"><td class="def field"><a href="#type-value_set_of_closures.invariant_params" class="anchor"></a><code>invariant_params : Variable.Set.t Variable.Map.t lazy_t;</code></td></tr><tr id="type-value_set_of_closures.size" class="anchored"><td class="def field"><a href="#type-value_set_of_closures.size" class="anchor"></a><code>size : int option Variable.Map.t lazy_t;</code></td><td class="doc"><p>For functions that are very likely to be inlined, the size of the function's body.</p></td></tr><tr id="type-value_set_of_closures.specialised_args" class="anchored"><td class="def field"><a href="#type-value_set_of_closures.specialised_args" class="anchor"></a><code>specialised_args : Flambda.specialised_to Variable.Map.t;</code></td></tr><tr id="type-value_set_of_closures.freshening" class="anchored"><td class="def field"><a href="#type-value_set_of_closures.freshening" class="anchor"></a><code>freshening : Freshening.Project_var.t;</code></td></tr><tr id="type-value_set_of_closures.direct_call_surrogates" class="anchored"><td class="def field"><a href="#type-value_set_of_closures.direct_call_surrogates" class="anchor"></a><code>direct_call_surrogates : Closure_id.t Closure_id.Map.t;</code></td></tr></table><code>}</code></dt></dl><dl><dt class="spec value" id="val-descr"><a href="#val-descr" class="anchor"></a><code><span class="keyword">val </span>descr : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-descr">descr</a></code></dt><dd><p>Extraction of the description of approximation(s).</p></dd></dl><dl><dt class="spec value" id="val-descrs"><a href="#val-descrs" class="anchor"></a><code><span class="keyword">val </span>descrs : <a href="index.html#type-t">t</a> list <span>&#45;&gt;</span> <a href="index.html#type-descr">descr</a> list</code></dt><dt class="spec value" id="val-print"><a href="#val-print" class="anchor"></a><code><span class="keyword">val </span>print : Format.formatter <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Pretty-printing of approximations to a formatter.</p></dd></dl><dl><dt class="spec value" id="val-print_descr"><a href="#val-print_descr" class="anchor"></a><code><span class="keyword">val </span>print_descr : Format.formatter <span>&#45;&gt;</span> <a href="index.html#type-descr">descr</a> <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-print_value_set_of_closures"><a href="#val-print_value_set_of_closures" class="anchor"></a><code><span class="keyword">val </span>print_value_set_of_closures : Format.formatter <span>&#45;&gt;</span> <a href="index.html#type-value_set_of_closures">value_set_of_closures</a> <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-create_value_set_of_closures"><a href="#val-create_value_set_of_closures" class="anchor"></a><code><span class="keyword">val </span>create_value_set_of_closures : function_decls:Flambda.function_declarations <span>&#45;&gt;</span> bound_vars:<a href="index.html#type-t">t</a> Var_within_closure.Map.t <span>&#45;&gt;</span> invariant_params:Variable.Set.t Variable.Map.t lazy_t <span>&#45;&gt;</span> specialised_args:Flambda.specialised_to Variable.Map.t <span>&#45;&gt;</span> freshening:Freshening.Project_var.t <span>&#45;&gt;</span> direct_call_surrogates:Closure_id.t Closure_id.Map.t <span>&#45;&gt;</span> <a href="index.html#type-value_set_of_closures">value_set_of_closures</a></code></dt><dt class="spec value" id="val-update_freshening_of_value_set_of_closures"><a href="#val-update_freshening_of_value_set_of_closures" class="anchor"></a><code><span class="keyword">val </span>update_freshening_of_value_set_of_closures : <a href="index.html#type-value_set_of_closures">value_set_of_closures</a> <span>&#45;&gt;</span> freshening:Freshening.Project_var.t <span>&#45;&gt;</span> <a href="index.html#type-value_set_of_closures">value_set_of_closures</a></code></dt><dt class="spec value" id="val-value_unknown"><a href="#val-value_unknown" class="anchor"></a><code><span class="keyword">val </span>value_unknown : <a href="index.html#type-unknown_because_of">unknown_because_of</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Basic construction of approximations.</p></dd></dl><dl><dt class="spec value" id="val-value_int"><a href="#val-value_int" class="anchor"></a><code><span class="keyword">val </span>value_int : int <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-value_char"><a href="#val-value_char" class="anchor"></a><code><span class="keyword">val </span>value_char : char <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-value_float"><a href="#val-value_float" class="anchor"></a><code><span class="keyword">val </span>value_float : float <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-value_mutable_float_array"><a href="#val-value_mutable_float_array" class="anchor"></a><code><span class="keyword">val </span>value_mutable_float_array : size:int <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-value_immutable_float_array"><a href="#val-value_immutable_float_array" class="anchor"></a><code><span class="keyword">val </span>value_immutable_float_array : float option array <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-value_string"><a href="#val-value_string" class="anchor"></a><code><span class="keyword">val </span>value_string : int <span>&#45;&gt;</span> string option <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-value_boxed_int"><a href="#val-value_boxed_int" class="anchor"></a><code><span class="keyword">val </span>value_boxed_int : <span class="type-var">'i</span> <a href="index.html#type-boxed_int">boxed_int</a> <span>&#45;&gt;</span> <span class="type-var">'i</span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-value_constptr"><a href="#val-value_constptr" class="anchor"></a><code><span class="keyword">val </span>value_constptr : int <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-value_block"><a href="#val-value_block" class="anchor"></a><code><span class="keyword">val </span>value_block : Tag.t <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> array <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-value_extern"><a href="#val-value_extern" class="anchor"></a><code><span class="keyword">val </span>value_extern : Export_id.t <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-value_symbol"><a href="#val-value_symbol" class="anchor"></a><code><span class="keyword">val </span>value_symbol : Symbol.t <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-value_bottom"><a href="#val-value_bottom" class="anchor"></a><code><span class="keyword">val </span>value_bottom : <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-value_unresolved"><a href="#val-value_unresolved" class="anchor"></a><code><span class="keyword">val </span>value_unresolved : Symbol.t <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-value_closure"><a href="#val-value_closure" class="anchor"></a><code><span class="keyword">val </span>value_closure : ?&#8288;closure_var:Variable.t <span>&#45;&gt;</span> ?&#8288;set_of_closures_var:Variable.t <span>&#45;&gt;</span> ?&#8288;set_of_closures_symbol:Symbol.t <span>&#45;&gt;</span> <a href="index.html#type-value_set_of_closures">value_set_of_closures</a> <span>&#45;&gt;</span> Closure_id.t <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Construct a closure approximation given the approximation of the corresponding set of closures and the closure ID of the closure to be projected from such set. <code>closure_var</code> and/or <code>set_of_closures_var</code> may be specified to augment the approximation with variables that may be used to access the closure value itself, so long as they are in scope at the proposed point of use.</p></dd></dl><dl><dt class="spec value" id="val-value_set_of_closures"><a href="#val-value_set_of_closures" class="anchor"></a><code><span class="keyword">val </span>value_set_of_closures : ?&#8288;set_of_closures_var:Variable.t <span>&#45;&gt;</span> <a href="index.html#type-value_set_of_closures">value_set_of_closures</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Construct a set of closures approximation. <code>set_of_closures_var</code> is as for the parameter of the same name in <code>value_closure</code>, above.</p></dd></dl><dl><dt class="spec value" id="val-make_const_int"><a href="#val-make_const_int" class="anchor"></a><code><span class="keyword">val </span>make_const_int : int <span>&#45;&gt;</span> Flambda.t<span class="keyword"> * </span><a href="index.html#type-t">t</a></code></dt><dd><p>Take the given constant and produce an appropriate approximation for it together with an Flambda expression representing it.</p></dd></dl><dl><dt class="spec value" id="val-make_const_char"><a href="#val-make_const_char" class="anchor"></a><code><span class="keyword">val </span>make_const_char : char <span>&#45;&gt;</span> Flambda.t<span class="keyword"> * </span><a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-make_const_ptr"><a href="#val-make_const_ptr" class="anchor"></a><code><span class="keyword">val </span>make_const_ptr : int <span>&#45;&gt;</span> Flambda.t<span class="keyword"> * </span><a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-make_const_bool"><a href="#val-make_const_bool" class="anchor"></a><code><span class="keyword">val </span>make_const_bool : bool <span>&#45;&gt;</span> Flambda.t<span class="keyword"> * </span><a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-make_const_float"><a href="#val-make_const_float" class="anchor"></a><code><span class="keyword">val </span>make_const_float : float <span>&#45;&gt;</span> Flambda.t<span class="keyword"> * </span><a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-make_const_boxed_int"><a href="#val-make_const_boxed_int" class="anchor"></a><code><span class="keyword">val </span>make_const_boxed_int : <span class="type-var">'i</span> <a href="index.html#type-boxed_int">boxed_int</a> <span>&#45;&gt;</span> <span class="type-var">'i</span> <span>&#45;&gt;</span> Flambda.t<span class="keyword"> * </span><a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-make_const_int_named"><a href="#val-make_const_int_named" class="anchor"></a><code><span class="keyword">val </span>make_const_int_named : int <span>&#45;&gt;</span> Flambda.named<span class="keyword"> * </span><a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-make_const_char_named"><a href="#val-make_const_char_named" class="anchor"></a><code><span class="keyword">val </span>make_const_char_named : char <span>&#45;&gt;</span> Flambda.named<span class="keyword"> * </span><a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-make_const_ptr_named"><a href="#val-make_const_ptr_named" class="anchor"></a><code><span class="keyword">val </span>make_const_ptr_named : int <span>&#45;&gt;</span> Flambda.named<span class="keyword"> * </span><a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-make_const_bool_named"><a href="#val-make_const_bool_named" class="anchor"></a><code><span class="keyword">val </span>make_const_bool_named : bool <span>&#45;&gt;</span> Flambda.named<span class="keyword"> * </span><a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-make_const_float_named"><a href="#val-make_const_float_named" class="anchor"></a><code><span class="keyword">val </span>make_const_float_named : float <span>&#45;&gt;</span> Flambda.named<span class="keyword"> * </span><a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-make_const_boxed_int_named"><a href="#val-make_const_boxed_int_named" class="anchor"></a><code><span class="keyword">val </span>make_const_boxed_int_named : <span class="type-var">'i</span> <a href="index.html#type-boxed_int">boxed_int</a> <span>&#45;&gt;</span> <span class="type-var">'i</span> <span>&#45;&gt;</span> Flambda.named<span class="keyword"> * </span><a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-augment_with_variable"><a href="#val-augment_with_variable" class="anchor"></a><code><span class="keyword">val </span>augment_with_variable : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> Variable.t <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Augment an approximation with a given variable (see comment above). If the approximation was already augmented with a variable, the one passed to this function replaces it within the approximation.</p></dd></dl><dl><dt class="spec value" id="val-augment_with_symbol"><a href="#val-augment_with_symbol" class="anchor"></a><code><span class="keyword">val </span>augment_with_symbol : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> Symbol.t <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Like <code>augment_with_variable</code>, but for symbol information.</p></dd></dl><dl><dt class="spec value" id="val-augment_with_symbol_field"><a href="#val-augment_with_symbol_field" class="anchor"></a><code><span class="keyword">val </span>augment_with_symbol_field : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> Symbol.t <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Like <code>augment_with_symbol</code>, but for symbol field information.</p></dd></dl><dl><dt class="spec value" id="val-replace_description"><a href="#val-replace_description" class="anchor"></a><code><span class="keyword">val </span>replace_description : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-descr">descr</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Replace the description within an approximation.</p></dd></dl><dl><dt class="spec value" id="val-equal_boxed_int"><a href="#val-equal_boxed_int" class="anchor"></a><code><span class="keyword">val </span>equal_boxed_int : <span class="type-var">'a</span> <a href="index.html#type-boxed_int">boxed_int</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-boxed_int">boxed_int</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> bool</code></dt><dt class="spec value" id="val-meet"><a href="#val-meet" class="anchor"></a><code><span class="keyword">val </span>meet : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-known"><a href="#val-known" class="anchor"></a><code><span class="keyword">val </span>known : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p>An approximation is &quot;known&quot; iff it is not <code>Value_unknown</code>.</p></dd></dl><dl><dt class="spec value" id="val-useful"><a href="#val-useful" class="anchor"></a><code><span class="keyword">val </span>useful : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p>An approximation is &quot;useful&quot; iff it is neither unknown nor bottom.</p></dd></dl><dl><dt class="spec value" id="val-all_not_useful"><a href="#val-all_not_useful" class="anchor"></a><code><span class="keyword">val </span>all_not_useful : <a href="index.html#type-t">t</a> list <span>&#45;&gt;</span> bool</code></dt><dd><p>Whether all approximations in the given list do *not* satisfy <code>useful</code>.</p></dd></dl><dl><dt class="spec value" id="val-is_definitely_immutable"><a href="#val-is_definitely_immutable" class="anchor"></a><code><span class="keyword">val </span>is_definitely_immutable : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p>A value is certainly immutable if its approximation is known and not bottom. It must have been resolved (it cannot be <code>Value_extern</code> or <code>Value_symbol</code>). (See comment above for further explanation.)</p></dd></dl><dl><dt class="spec type" id="type-simplification_summary"><a href="#type-simplification_summary" class="anchor"></a><code><span class="keyword">type </span>simplification_summary</code><code><span class="keyword"> = </span></code><table class="variant"><tr id="type-simplification_summary.Nothing_done" class="anchored"><td class="def constructor"><a href="#type-simplification_summary.Nothing_done" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Nothing_done</span></code></td></tr><tr id="type-simplification_summary.Replaced_term" class="anchored"><td class="def constructor"><a href="#type-simplification_summary.Replaced_term" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Replaced_term</span></code></td></tr></table></dt><dt class="spec type" id="type-simplification_result"><a href="#type-simplification_result" class="anchor"></a><code><span class="keyword">type </span>simplification_result</code><code><span class="keyword"> = </span>Flambda.t<span class="keyword"> * </span><a href="index.html#type-simplification_summary">simplification_summary</a><span class="keyword"> * </span><a href="index.html#type-t">t</a></code></dt><dt class="spec type" id="type-simplification_result_named"><a href="#type-simplification_result_named" class="anchor"></a><code><span class="keyword">type </span>simplification_result_named</code><code><span class="keyword"> = </span>Flambda.named<span class="keyword"> * </span><a href="index.html#type-simplification_summary">simplification_summary</a><span class="keyword"> * </span><a href="index.html#type-t">t</a></code></dt></dl><dl><dt class="spec value" id="val-simplify"><a href="#val-simplify" class="anchor"></a><code><span class="keyword">val </span>simplify : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> Flambda.t <span>&#45;&gt;</span> <a href="index.html#type-simplification_result">simplification_result</a></code></dt><dd><p>Given an expression and its approximation, attempt to simplify the expression to a constant (with associated approximation), taking into account whether the expression has any side effects.</p></dd></dl><dl><dt class="spec value" id="val-simplify_using_env"><a href="#val-simplify_using_env" class="anchor"></a><code><span class="keyword">val </span>simplify_using_env : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> is_present_in_env:(Variable.t <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> Flambda.t <span>&#45;&gt;</span> <a href="index.html#type-simplification_result">simplification_result</a></code></dt><dd><p>As for <code>simplify</code>, but also enables us to simplify based on equalities between variables. The caller must provide a function that tells us whether, if we simplify to a given variable, the value of that variable will be accessible in the current environment.</p></dd></dl><dl><dt class="spec value" id="val-simplify_named"><a href="#val-simplify_named" class="anchor"></a><code><span class="keyword">val </span>simplify_named : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> Flambda.named <span>&#45;&gt;</span> <a href="index.html#type-simplification_result_named">simplification_result_named</a></code></dt><dt class="spec value" id="val-simplify_named_using_env"><a href="#val-simplify_named_using_env" class="anchor"></a><code><span class="keyword">val </span>simplify_named_using_env : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> is_present_in_env:(Variable.t <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> Flambda.named <span>&#45;&gt;</span> <a href="index.html#type-simplification_result_named">simplification_result_named</a></code></dt><dt class="spec value" id="val-simplify_var_to_var_using_env"><a href="#val-simplify_var_to_var_using_env" class="anchor"></a><code><span class="keyword">val </span>simplify_var_to_var_using_env : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> is_present_in_env:(Variable.t <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> Variable.t option</code></dt><dd><p>If the given approximation identifies another variable and <code>is_present_in_env</code> deems it to be in scope, return that variable (wrapped in a <code>Some</code>), otherwise return <code>None</code>.</p></dd></dl><dl><dt class="spec value" id="val-simplify_var"><a href="#val-simplify_var" class="anchor"></a><code><span class="keyword">val </span>simplify_var : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (Flambda.named<span class="keyword"> * </span><a href="index.html#type-t">t</a>) option</code></dt></dl><dl><dt class="spec type" id="type-get_field_result"><a href="#type-get_field_result" class="anchor"></a><code><span class="keyword">type </span>get_field_result</code><code><span class="keyword"> = </span></code><table class="variant"><tr id="type-get_field_result.Ok" class="anchored"><td class="def constructor"><a href="#type-get_field_result.Ok" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Ok</span><span class="keyword"> of </span><a href="index.html#type-t">t</a></code></td></tr><tr id="type-get_field_result.Unreachable" class="anchored"><td class="def constructor"><a href="#type-get_field_result.Unreachable" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Unreachable</span></code></td></tr></table></dt></dl><dl><dt class="spec value" id="val-get_field"><a href="#val-get_field" class="anchor"></a><code><span class="keyword">val </span>get_field : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> field_index:int <span>&#45;&gt;</span> <a href="index.html#type-get_field_result">get_field_result</a></code></dt><dd><p>Given the approximation <code>t</code> of a value, expected to correspond to a block (in the <code>Pmakeblock</code> sense of the word), and a field index then return an appropriate approximation for that field of the block (or <code>Unreachable</code> if the code with the approximation <code>t</code> is unreachable). N.B. Not all cases of unreachable code are returned as <code>Unreachable</code>.</p></dd></dl><dl><dt class="spec type" id="type-checked_approx_for_block"><a href="#type-checked_approx_for_block" class="anchor"></a><code><span class="keyword">type </span>checked_approx_for_block</code><code><span class="keyword"> = </span></code><table class="variant"><tr id="type-checked_approx_for_block.Wrong" class="anchored"><td class="def constructor"><a href="#type-checked_approx_for_block.Wrong" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Wrong</span></code></td></tr><tr id="type-checked_approx_for_block.Ok" class="anchored"><td class="def constructor"><a href="#type-checked_approx_for_block.Ok" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Ok</span><span class="keyword"> of </span>Tag.t<span class="keyword"> * </span><a href="index.html#type-t">t</a> array</code></td></tr></table></dt></dl><dl><dt class="spec value" id="val-check_approx_for_block"><a href="#val-check_approx_for_block" class="anchor"></a><code><span class="keyword">val </span>check_approx_for_block : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-checked_approx_for_block">checked_approx_for_block</a></code></dt><dd><p>Try to prove that a value with the given approximation may be used as a block.</p></dd></dl><dl><dt class="spec value" id="val-approx_for_bound_var"><a href="#val-approx_for_bound_var" class="anchor"></a><code><span class="keyword">val </span>approx_for_bound_var : <a href="index.html#type-value_set_of_closures">value_set_of_closures</a> <span>&#45;&gt;</span> Var_within_closure.t <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Find the approximation for a bound variable in a set-of-closures approximation. A fatal error is produced if the variable is not bound in the given approximation.</p></dd></dl><dl><dt class="spec value" id="val-freshen_and_check_closure_id"><a href="#val-freshen_and_check_closure_id" class="anchor"></a><code><span class="keyword">val </span>freshen_and_check_closure_id : <a href="index.html#type-value_set_of_closures">value_set_of_closures</a> <span>&#45;&gt;</span> Closure_id.t <span>&#45;&gt;</span> Closure_id.t</code></dt><dd><p>Given a set-of-closures approximation and a closure ID, apply any freshening specified by the approximation to the closure ID, and return the resulting ID. Causes a fatal error if the resulting closure ID does not correspond to any function declaration in the approximation.</p></dd></dl><dl><dt class="spec type" id="type-strict_checked_approx_for_set_of_closures"><a href="#type-strict_checked_approx_for_set_of_closures" class="anchor"></a><code><span class="keyword">type </span>strict_checked_approx_for_set_of_closures</code><code><span class="keyword"> = </span></code><table class="variant"><tr id="type-strict_checked_approx_for_set_of_closures.Wrong" class="anchored"><td class="def constructor"><a href="#type-strict_checked_approx_for_set_of_closures.Wrong" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Wrong</span></code></td></tr><tr id="type-strict_checked_approx_for_set_of_closures.Ok" class="anchored"><td class="def constructor"><a href="#type-strict_checked_approx_for_set_of_closures.Ok" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Ok</span><span class="keyword"> of </span>Variable.t option<span class="keyword"> * </span><a href="index.html#type-value_set_of_closures">value_set_of_closures</a></code></td></tr></table></dt></dl><dl><dt class="spec value" id="val-strict_check_approx_for_set_of_closures"><a href="#val-strict_check_approx_for_set_of_closures" class="anchor"></a><code><span class="keyword">val </span>strict_check_approx_for_set_of_closures : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-strict_checked_approx_for_set_of_closures">strict_checked_approx_for_set_of_closures</a></code></dt></dl><dl><dt class="spec type" id="type-checked_approx_for_set_of_closures"><a href="#type-checked_approx_for_set_of_closures" class="anchor"></a><code><span class="keyword">type </span>checked_approx_for_set_of_closures</code><code><span class="keyword"> = </span></code><table class="variant"><tr id="type-checked_approx_for_set_of_closures.Wrong" class="anchored"><td class="def constructor"><a href="#type-checked_approx_for_set_of_closures.Wrong" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Wrong</span></code></td></tr><tr id="type-checked_approx_for_set_of_closures.Unresolved" class="anchored"><td class="def constructor"><a href="#type-checked_approx_for_set_of_closures.Unresolved" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Unresolved</span><span class="keyword"> of </span>Symbol.t</code></td></tr><tr id="type-checked_approx_for_set_of_closures.Unknown" class="anchored"><td class="def constructor"><a href="#type-checked_approx_for_set_of_closures.Unknown" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Unknown</span></code></td></tr><tr id="type-checked_approx_for_set_of_closures.Unknown_because_of_unresolved_symbol" class="anchored"><td class="def constructor"><a href="#type-checked_approx_for_set_of_closures.Unknown_because_of_unresolved_symbol" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Unknown_because_of_unresolved_symbol</span><span class="keyword"> of </span>Symbol.t</code></td></tr><tr id="type-checked_approx_for_set_of_closures.Ok" class="anchored"><td class="def constructor"><a href="#type-checked_approx_for_set_of_closures.Ok" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Ok</span><span class="keyword"> of </span>Variable.t option<span class="keyword"> * </span><a href="index.html#type-value_set_of_closures">value_set_of_closures</a></code></td></tr></table></dt></dl><dl><dt class="spec value" id="val-check_approx_for_set_of_closures"><a href="#val-check_approx_for_set_of_closures" class="anchor"></a><code><span class="keyword">val </span>check_approx_for_set_of_closures : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-checked_approx_for_set_of_closures">checked_approx_for_set_of_closures</a></code></dt><dd><p>Try to prove that a value with the given approximation may be used as a set of closures. Values coming from external compilation units with unresolved approximations are permitted.</p></dd></dl><dl><dt class="spec type" id="type-checked_approx_for_closure"><a href="#type-checked_approx_for_closure" class="anchor"></a><code><span class="keyword">type </span>checked_approx_for_closure</code><code><span class="keyword"> = </span></code><table class="variant"><tr id="type-checked_approx_for_closure.Wrong" class="anchored"><td class="def constructor"><a href="#type-checked_approx_for_closure.Wrong" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Wrong</span></code></td></tr><tr id="type-checked_approx_for_closure.Ok" class="anchored"><td class="def constructor"><a href="#type-checked_approx_for_closure.Ok" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Ok</span><span class="keyword"> of </span><a href="index.html#type-value_closure">value_closure</a><span class="keyword"> * </span>Variable.t option<span class="keyword"> * </span>Symbol.t option<span class="keyword"> * </span><a href="index.html#type-value_set_of_closures">value_set_of_closures</a></code></td></tr></table></dt></dl><dl><dt class="spec value" id="val-check_approx_for_closure"><a href="#val-check_approx_for_closure" class="anchor"></a><code><span class="keyword">val </span>check_approx_for_closure : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-checked_approx_for_closure">checked_approx_for_closure</a></code></dt><dd><p>Try to prove that a value with the given approximation may be used as a closure. Values coming from external compilation units with unresolved approximations are not permitted.</p></dd></dl><dl><dt class="spec type" id="type-checked_approx_for_closure_allowing_unresolved"><a href="#type-checked_approx_for_closure_allowing_unresolved" class="anchor"></a><code><span class="keyword">type </span>checked_approx_for_closure_allowing_unresolved</code><code><span class="keyword"> = </span></code><table class="variant"><tr id="type-checked_approx_for_closure_allowing_unresolved.Wrong" class="anchored"><td class="def constructor"><a href="#type-checked_approx_for_closure_allowing_unresolved.Wrong" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Wrong</span></code></td></tr><tr id="type-checked_approx_for_closure_allowing_unresolved.Unresolved" class="anchored"><td class="def constructor"><a href="#type-checked_approx_for_closure_allowing_unresolved.Unresolved" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Unresolved</span><span class="keyword"> of </span>Symbol.t</code></td></tr><tr id="type-checked_approx_for_closure_allowing_unresolved.Unknown" class="anchored"><td class="def constructor"><a href="#type-checked_approx_for_closure_allowing_unresolved.Unknown" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Unknown</span></code></td></tr><tr id="type-checked_approx_for_closure_allowing_unresolved.Unknown_because_of_unresolved_symbol" class="anchored"><td class="def constructor"><a href="#type-checked_approx_for_closure_allowing_unresolved.Unknown_because_of_unresolved_symbol" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Unknown_because_of_unresolved_symbol</span><span class="keyword"> of </span>Symbol.t</code></td></tr><tr id="type-checked_approx_for_closure_allowing_unresolved.Ok" class="anchored"><td class="def constructor"><a href="#type-checked_approx_for_closure_allowing_unresolved.Ok" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Ok</span><span class="keyword"> of </span><a href="index.html#type-value_closure">value_closure</a><span class="keyword"> * </span>Variable.t option<span class="keyword"> * </span>Symbol.t option<span class="keyword"> * </span><a href="index.html#type-value_set_of_closures">value_set_of_closures</a></code></td></tr></table></dt></dl><dl><dt class="spec value" id="val-check_approx_for_closure_allowing_unresolved"><a href="#val-check_approx_for_closure_allowing_unresolved" class="anchor"></a><code><span class="keyword">val </span>check_approx_for_closure_allowing_unresolved : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-checked_approx_for_closure_allowing_unresolved">checked_approx_for_closure_allowing_unresolved</a></code></dt><dd><p>As for <code>check_approx_for_closure</code>, but values coming from external compilation units with unresolved approximations are permitted.</p></dd></dl><dl><dt class="spec value" id="val-check_approx_for_float"><a href="#val-check_approx_for_float" class="anchor"></a><code><span class="keyword">val </span>check_approx_for_float : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> float option</code></dt><dd><p>Returns the value if it can be proved to be a constant float</p></dd></dl></div></body></html>