<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Ocaml_plugin__Compiler (ocaml_plugin.Ocaml_plugin__Compiler)</title><link rel="stylesheet" href="../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../index.html">ocaml_plugin</a> &#x00BB; Ocaml_plugin__Compiler</nav><h1>Module <code>Ocaml_plugin__Compiler</code></h1></header><dl><dt class="spec value" id="val-ocamlopt_opt"><a href="#val-ocamlopt_opt" class="anchor"></a><code><span class="keyword">val</span> ocamlopt_opt : string</code></dt><dd><p>The convention over the name of the executables inside the archive. All are native executables (.opt)</p></dd></dl><dl><dt class="spec value" id="val-ocamldep_opt"><a href="#val-ocamldep_opt" class="anchor"></a><code><span class="keyword">val</span> ocamldep_opt : string</code></dt><dt class="spec value" id="val-ppx_exe"><a href="#val-ppx_exe" class="anchor"></a><code><span class="keyword">val</span> ppx_exe : string</code></dt></dl><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> t</code></dt><dd><p>Mutable type to get the compiler and the cmi which must have been embedded in the executable.</p></dd></dl><div class="spec module" id="module-Archive_metadata"><a href="#module-Archive_metadata" class="anchor"></a><code><span class="keyword">module</span> <a href="Archive_metadata/index.html">Archive_metadata</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><dl><dt class="spec type" id="type-create_arguments"><a href="#type-create_arguments" class="anchor"></a><code><span class="keyword">type</span> 'a create_arguments</code><code> = (?&#8288;persistent_archive_dirpath:string <span>&#45;&gt;</span> <span class="type-var">'a</span>) <a href="../Ocaml_plugin/Dynloader/index.html#type-create_arguments">Ocaml_plugin.Dynloader.create_arguments</a></code></dt></dl><dl><dt class="spec value" id="val-create"><a href="#val-create" class="anchor"></a><code><span class="keyword">val</span> create : (unit <span>&#45;&gt;</span> [ `this_needs_manual_cleaning_after of <a href="index.html#type-t">t</a> ] <a href="../../async_kernel/Async_kernel__/Deferred_or_error/index.html#type-t">Async.Deferred.Or_error.t</a>) <a href="index.html#type-create_arguments">create_arguments</a></code></dt><dd><p>This is a special utilisation of the Generic Loader. It relies on a few assumptions, such as a file called ocamlopt.opt is present in the archive, as well as some cmi files, and uses a tmp compilation_directory. A call to this function will retrieve the embedded part of the code, and extract it in the current corresponding directory. The most common use and the default value for <code>code_file</code> is <code>`my_code</code>. Currently this library works with native code only. Called in bytecode, this function will raise. See the documentation of dynloader for other flags, they are passed internally to that module to create the internal dynloader (in _dir, custom_warnings_spec, etc.).</p><p>/!\ By using this manual create, you take the responsibility to call <code>clean t</code> when you're done with all the compilation that you want to do with this compiler. Consider using <code>with_compiler</code>, <code>Make</code> or <code>load_ocaml_src_files</code> if this makes your life simpler.</p></dd></dl><dl><dt class="spec value" id="val-with_compiler"><a href="#val-with_compiler" class="anchor"></a><code><span class="keyword">val</span> with_compiler : (f:(<a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="../../async_kernel/Async_kernel__/Deferred_or_error/index.html#type-t">Async.Deferred.Or_error.t</a>) <span>&#45;&gt;</span> unit <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="../../async_kernel/Async_kernel__/Deferred_or_error/index.html#type-t">Async.Deferred.Or_error.t</a>) <a href="index.html#type-create_arguments">create_arguments</a></code></dt><dd><p>Call create, do something with the compiler, and then take care of calling clean. In case an exception or a shutdown happen and f never returns, an attempt to clean the compiler is still done via an at_shutdown execution.</p></dd></dl><dl><dt class="spec value" id="val-loader"><a href="#val-loader" class="anchor"></a><code><span class="keyword">val</span> loader : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../Ocaml_plugin/Dynloader/index.html#type-t">Ocaml_plugin.Dynloader.t</a></code></dt><dd><p>Get the loader using this compiler and these cmi.</p></dd></dl><dl><dt class="spec value" id="val-clean"><a href="#val-clean" class="anchor"></a><code><span class="keyword">val</span> clean : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit <a href="../../async_kernel/Async_kernel__/Deferred_or_error/index.html#type-t">Async.Deferred.Or_error.t</a></code></dt><dd><p>This will delete the temporary directory created, and remove all the files, included the files generated by the loader. This function should be used when the compiler has been created using <code>create</code> for advanced use of this module. For a simpler usage, look at <code>with_compiler</code> or the functor below.</p></dd></dl><div class="spec module-type" id="module-type-S"><a href="#module-type-S" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-S/index.html">S</a> = <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><dl><dt class="spec module" id="module-Make"><a href="#module-Make" class="anchor"></a><code><span class="keyword">module</span> <a href="Make/index.html">Make</a> : <span class="keyword">functor</span> (<a href="Make/argument-1-X/index.html">X</a> : <a href="../Ocaml_plugin/Dynloader/index.html#module-type-Module_type">Ocaml_plugin.Dynloader.Module_type</a>) <span>&#45;&gt;</span> <a href="index.html#module-type-S">S</a> <span class="keyword">with</span> <span class="keyword">type</span> <a href="Make/index.html#type-t">t</a> := <a href="Make/argument-1-X/index.html#type-t">X.t</a></code></dt><dd><p>This is a wrapper for the similar module in Dynloader that takes care of cleaning the compiler afterwards.</p></dd></dl><dl><dt class="spec module" id="module-Side_effect"><a href="#module-Side_effect" class="anchor"></a><code><span class="keyword">module</span> <a href="Side_effect/index.html">Side_effect</a> : <a href="index.html#module-type-S">S</a> <span class="keyword">with</span> <span class="keyword">type</span> <a href="module-type-S/index.html#type-t">t</a> := unit</code></dt><dd><p>In some cases, we are not interested by the module, but rather because it uses a side effect registering mechanism.</p></dd></dl></div></body></html>