<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Expert (ocaml_plugin.Ocaml_plugin__Dynloader.Make.Expert)</title><link rel="stylesheet" href="../../../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../../../index.html">ocaml_plugin</a> &#x00BB; <a href="../../index.html">Ocaml_plugin__Dynloader</a> &#x00BB; <a href="../index.html">Make</a> &#x00BB; Expert</nav><h1>Module <code>Make.Expert</code></h1></header><aside><p>The following functions are exposed for expert users only, not for the casual user, because they are much more error prone. Prefer <code>load_ocaml_src_files</code> if possible.</p><p>The complexity is due to the following unexpected or unpredictable behavior of <code>Dynlink</code>: dynlinking a file with a given filename only works properly the first time. Further dynlinks with the same filename (even if the contents of the file has changed in the meantime) will not load the new module but instead execute the initial module. Some even says that the behavior upon reload depends on the platform. Long story short: don't do that. Dynlink files at most once.</p><p>To work around this, you may automatically copy the given file to a temporary and unique name before dynlinking it.</p><p>It is worth noting too that the <code>*load_cmxs_file</code> functions below only work with cmxs files produced by ocaml_plugin's <code>compile_ocaml_src_files_into_cmxs_file</code>. They expect the code to perform some internal library calls, thus it cannot be used with any arbitrary cmxs compiled in some other way. Furthermore those functions would return an error even though the cmxs was built with ocaml_plugin when built under a different context (compiler version used, cmi dependencies version, etc.) The intended usage is to have the compilation and loading done using the same executable.</p></aside><dl><dt class="spec value" id="val-compile_ocaml_src_files_into_cmxs_file"><a href="#val-compile_ocaml_src_files_into_cmxs_file" class="anchor"></a><code><span class="keyword">val</span> compile_ocaml_src_files_into_cmxs_file : <a href="../../index.html#type-dynloader">dynloader</a> <span>&#45;&gt;</span> string list <span>&#45;&gt;</span> output_file:string <span>&#45;&gt;</span> unit <a href="../../../../async_kernel/Async_kernel__/Deferred_or_error/index.html#type-t">Async.Deferred.Or_error.t</a></code></dt><dd><p>This compiles the source files into cmxs file, but does not execute the plugin toplevel. The resulting cmxs file can be loaded by the <code>*load_cmxs_file</code> function below either from within the same process or other processes which share the same executable. If compile succeeds, it returns <code>Ok</code> and write the compiled cmxs file into <code>output_file</code> (may override existing file), otherwise it returns <code>Error</code> and won't write to <code>output_file</code> at all.</p></dd></dl><dl><dt class="spec value" id="val-load_cmxs_file"><a href="#val-load_cmxs_file" class="anchor"></a><code><span class="keyword">val</span> load_cmxs_file : string <span>&#45;&gt;</span> <a href="../index.html#type-t">t</a> <a href="../../../../core_kernel/Core_kernel/Or_error/index.html#type-t">Core.Or_error.t</a> <a href="../../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async.Deferred.t</a></code></dt><dt class="spec value" id="val-blocking_load_cmxs_file"><a href="#val-blocking_load_cmxs_file" class="anchor"></a><code><span class="keyword">val</span> blocking_load_cmxs_file : string <span>&#45;&gt;</span> <a href="../index.html#type-t">t</a> <a href="../../../../core_kernel/Core_kernel/Or_error/index.html#type-t">Core.Or_error.t</a></code></dt><dd><p><code>blocking_load_cmxs_file</code> will return an error if called after the async scheduler has been started.</p></dd></dl></div></body></html>