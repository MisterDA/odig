<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>V (opam-format.OpamFormat.V)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../../index.html">opam-format</a> &#x00BB; <a href="../index.html">OpamFormat</a> &#x00BB; V</nav><h1>Module <code>OpamFormat.V</code></h1></header><aside><p>These base converters raise <code>Unexpected</code> when not run on the right input (which is then converted to <code>Bad_format</code> by the parser.</p></aside><dl><dt class="spec value" id="val-bool"><a href="#val-bool" class="anchor"></a><code><span class="keyword">val </span>bool : (OpamTypes.value, bool) OpamPp.t</code></dt><dt class="spec value" id="val-int"><a href="#val-int" class="anchor"></a><code><span class="keyword">val </span>int : (OpamTypes.value, int) OpamPp.t</code></dt><dt class="spec value" id="val-pos_int"><a href="#val-pos_int" class="anchor"></a><code><span class="keyword">val </span>pos_int : (OpamTypes.value, int) OpamPp.t</code></dt><dd><p>positive or null integer</p></dd></dl><dl><dt class="spec value" id="val-ident"><a href="#val-ident" class="anchor"></a><code><span class="keyword">val </span>ident : (OpamTypes.value, string) OpamPp.t</code></dt><dt class="spec value" id="val-string"><a href="#val-string" class="anchor"></a><code><span class="keyword">val </span>string : (OpamTypes.value, string) OpamPp.t</code></dt><dt class="spec value" id="val-string_tr"><a href="#val-string_tr" class="anchor"></a><code><span class="keyword">val </span>string_tr : (OpamTypes.value, string) OpamPp.t</code></dt><dd><p>Trimmed string</p></dd></dl><dl><dt class="spec value" id="val-simple_arg"><a href="#val-simple_arg" class="anchor"></a><code><span class="keyword">val </span>simple_arg : (OpamTypes.value, OpamTypes.simple_arg) OpamPp.t</code></dt><dd><p>Command arguments, i.e. strings or idents</p></dd></dl><dl><dt class="spec value" id="val-variable_contents"><a href="#val-variable_contents" class="anchor"></a><code><span class="keyword">val </span>variable_contents : (OpamTypes.value, OpamTypes.variable_contents) OpamPp.t</code></dt><dd><p>Strings or bools</p></dd></dl><dl><dt class="spec value" id="val-list"><a href="#val-list" class="anchor"></a><code><span class="keyword">val </span>list : (OpamTypes.value, OpamTypes.value list) OpamPp.t</code></dt><dd><p>&quot;<code>a b c</code>&quot;; also allows just &quot;a&quot; to be parsed as a singleton list</p></dd></dl><dl><dt class="spec value" id="val-group"><a href="#val-group" class="anchor"></a><code><span class="keyword">val </span>group : (OpamTypes.value, OpamTypes.value list) OpamPp.t</code></dt><dd><p>&quot;(a b c)&quot;</p></dd></dl><dl><dt class="spec value" id="val-option"><a href="#val-option" class="anchor"></a><code><span class="keyword">val </span>option : (OpamTypes.value, OpamTypes.value<span class="keyword"> * </span>OpamTypes.value list) OpamPp.t</code></dt><dd><p>Options in the <code>value</code> type sense, i.e. a value with an optional list of parameters in braces: <code>&quot;value {op1 op2}&quot;</code></p></dd></dl><dl><dt class="spec value" id="val-map_group"><a href="#val-map_group" class="anchor"></a><code><span class="keyword">val </span>map_group : (OpamTypes.value, <span class="type-var">'a</span>) OpamPp.t <span>&#45;&gt;</span> (OpamTypes.value, <span class="type-var">'a</span> list) OpamPp.t</code></dt><dt class="spec value" id="val-map_list"><a href="#val-map_list" class="anchor"></a><code><span class="keyword">val </span>map_list : ?&#8288;depth:int <span>&#45;&gt;</span> (OpamTypes.value, <span class="type-var">'a</span>) OpamPp.t <span>&#45;&gt;</span> (OpamTypes.value, <span class="type-var">'a</span> list) OpamPp.t</code></dt><dd><p>An expected list depth may be specified to enable removal of extra brackets (never use <code>~depth</code> for an inner list)</p></dd></dl><dl><dt class="spec value" id="val-list_depth"><a href="#val-list_depth" class="anchor"></a><code><span class="keyword">val </span>list_depth : int <span>&#45;&gt;</span> (OpamTypes.value, OpamTypes.value) OpamPp.t</code></dt><dd><p>Normalises to the given list depth when parsing, and removes brackets that can be made implicit when printing</p></dd></dl><dl><dt class="spec value" id="val-map_option"><a href="#val-map_option" class="anchor"></a><code><span class="keyword">val </span>map_option : (OpamTypes.value, <span class="type-var">'a</span>) OpamPp.t <span>&#45;&gt;</span> (OpamTypes.value list, <span class="type-var">'b</span>) OpamPp.t <span>&#45;&gt;</span> (OpamTypes.value, <span class="type-var">'a</span><span class="keyword"> * </span><span class="type-var">'b</span>) OpamPp.t</code></dt><dd><p>Maps on the two terms of an option constructor.</p></dd></dl><dl><dt class="spec value" id="val-map_options_2"><a href="#val-map_options_2" class="anchor"></a><code><span class="keyword">val </span>map_options_2 : (OpamTypes.value, <span class="type-var">'a</span>) OpamPp.t <span>&#45;&gt;</span> (OpamTypes.value list, <span class="type-var">'b</span>) OpamPp.t <span>&#45;&gt;</span> (OpamTypes.value list, <span class="type-var">'c</span>) OpamPp.t <span>&#45;&gt;</span> (OpamTypes.value, <span class="type-var">'a</span><span class="keyword"> * </span><span class="type-var">'b</span><span class="keyword"> * </span><span class="type-var">'c</span>) OpamPp.t</code></dt><dd><p>Maps over two options (e.g. <code>v {op1} {op2}</code>)</p></dd></dl><dl><dt class="spec value" id="val-map_options_3"><a href="#val-map_options_3" class="anchor"></a><code><span class="keyword">val </span>map_options_3 : (OpamTypes.value, <span class="type-var">'a</span>) OpamPp.t <span>&#45;&gt;</span> (OpamTypes.value list, <span class="type-var">'b</span>) OpamPp.t <span>&#45;&gt;</span> (OpamTypes.value list, <span class="type-var">'c</span>) OpamPp.t <span>&#45;&gt;</span> (OpamTypes.value list, <span class="type-var">'d</span>) OpamPp.t <span>&#45;&gt;</span> (OpamTypes.value, <span class="type-var">'a</span><span class="keyword"> * </span><span class="type-var">'b</span><span class="keyword"> * </span><span class="type-var">'c</span><span class="keyword"> * </span><span class="type-var">'d</span>) OpamPp.t</code></dt><dd><p>Maps over three options (e.g. <code>v {op1} {op2} {op3}</code>)</p></dd></dl><dl><dt class="spec value" id="val-map_pair"><a href="#val-map_pair" class="anchor"></a><code><span class="keyword">val </span>map_pair : (OpamTypes.value, <span class="type-var">'a</span>) OpamPp.t <span>&#45;&gt;</span> (OpamTypes.value, <span class="type-var">'b</span>) OpamPp.t <span>&#45;&gt;</span> (OpamTypes.value, <span class="type-var">'a</span><span class="keyword"> * </span><span class="type-var">'b</span>) OpamPp.t</code></dt><dd><p>A pair is simply a list with two elements in the <code>value</code> type</p></dd></dl><dl><dt class="spec value" id="val-map_triple"><a href="#val-map_triple" class="anchor"></a><code><span class="keyword">val </span>map_triple : (OpamTypes.value, <span class="type-var">'a</span>) OpamPp.t <span>&#45;&gt;</span> (OpamTypes.value, <span class="type-var">'b</span>) OpamPp.t <span>&#45;&gt;</span> (OpamTypes.value, <span class="type-var">'c</span>) OpamPp.t <span>&#45;&gt;</span> (OpamTypes.value, <span class="type-var">'a</span><span class="keyword"> * </span><span class="type-var">'b</span><span class="keyword"> * </span><span class="type-var">'c</span>) OpamPp.t</code></dt><dd><p>A triple is simply a list with three elements in the <code>value</code> type</p></dd></dl><dl><dt class="spec value" id="val-url"><a href="#val-url" class="anchor"></a><code><span class="keyword">val </span>url : (OpamTypes.value, OpamTypes.url) OpamPp.t</code></dt><dt class="spec value" id="val-url_with_backend"><a href="#val-url_with_backend" class="anchor"></a><code><span class="keyword">val </span>url_with_backend : OpamUrl.backend <span>&#45;&gt;</span> (OpamTypes.value, OpamTypes.url) OpamPp.t</code></dt><dd><p>Specialised url parser when the backend is already known</p></dd></dl><dl><dt class="spec value" id="val-compiler_version"><a href="#val-compiler_version" class="anchor"></a><code><span class="keyword">val </span>compiler_version : (OpamTypes.value, string) OpamPp.t</code></dt><dt class="spec value" id="val-filter_ident"><a href="#val-filter_ident" class="anchor"></a><code><span class="keyword">val </span>filter_ident : (OpamTypes.value, OpamTypes.name option list<span class="keyword"> * </span>OpamTypes.variable<span class="keyword"> * </span>(string<span class="keyword"> * </span>string) option) OpamPp.t</code></dt><dt class="spec value" id="val-filter"><a href="#val-filter" class="anchor"></a><code><span class="keyword">val </span>filter : (OpamTypes.value list, OpamTypes.filter) OpamPp.t</code></dt><dt class="spec value" id="val-arg"><a href="#val-arg" class="anchor"></a><code><span class="keyword">val </span>arg : (OpamTypes.value, OpamTypes.simple_arg<span class="keyword"> * </span>OpamTypes.filter option) OpamPp.t</code></dt><dd><p>Arguments in commands (term + optional filter)</p></dd></dl><dl><dt class="spec value" id="val-command"><a href="#val-command" class="anchor"></a><code><span class="keyword">val </span>command : (OpamTypes.value, (OpamTypes.simple_arg<span class="keyword"> * </span>OpamTypes.filter option) list<span class="keyword"> * </span>OpamTypes.filter option) OpamPp.t</code></dt><dt class="spec value" id="val-constraints"><a href="#val-constraints" class="anchor"></a><code><span class="keyword">val </span>constraints : (OpamTypes.value, <span class="type-var">'a</span>) OpamPp.t <span>&#45;&gt;</span> (OpamTypes.value list, (OpamFormula.relop<span class="keyword"> * </span><span class="type-var">'a</span>) OpamFormula.formula) OpamPp.t</code></dt><dd><p>Simple dependency constraints</p></dd></dl><dl><dt class="spec value" id="val-filtered_constraints"><a href="#val-filtered_constraints" class="anchor"></a><code><span class="keyword">val </span>filtered_constraints : (OpamTypes.value, <span class="type-var">'version</span>) OpamPp.t <span>&#45;&gt;</span> (OpamTypes.value list, <span class="type-var">'version</span> OpamTypes.filter_or_constraint OpamFormula.formula) OpamPp.t</code></dt><dd><p>Dependency constraints mixed with filters</p></dd></dl><dl><dt class="spec value" id="val-version"><a href="#val-version" class="anchor"></a><code><span class="keyword">val </span>version : (OpamTypes.value, OpamTypes.version) OpamPp.t</code></dt><dd><p>Package versions</p></dd></dl><dl><dt class="spec value" id="val-ext_version"><a href="#val-ext_version" class="anchor"></a><code><span class="keyword">val </span>ext_version : (OpamTypes.value, OpamTypes.filter) OpamPp.t</code></dt><dd><p>Package versions as filters, as they may appear in dependency (may be an expanded string or an ident)</p></dd></dl><dl><dt class="spec value" id="val-pkgname"><a href="#val-pkgname" class="anchor"></a><code><span class="keyword">val </span>pkgname : (OpamTypes.value, OpamTypes.name) OpamPp.t</code></dt><dd><p>A package name, encoded as a string, but with restrictions</p></dd></dl><dl><dt class="spec value" id="val-package_atom"><a href="#val-package_atom" class="anchor"></a><code><span class="keyword">val </span>package_atom : (OpamTypes.value list, <span class="type-var">'a</span>) OpamPp.t <span>&#45;&gt;</span> (OpamTypes.value, OpamTypes.name<span class="keyword"> * </span><span class="type-var">'a</span>) OpamPp.t</code></dt><dd><p>Returns an atom parser <code>(&quot;package&quot; {&gt;= &quot;version&quot;})</code> from a constraint and a version parser</p></dd></dl><dl><dt class="spec value" id="val-package_formula"><a href="#val-package_formula" class="anchor"></a><code><span class="keyword">val </span>package_formula : [&lt; `Conj<span class="keyword"> | </span>`Disj ] <span>&#45;&gt;</span> (OpamTypes.value list, <span class="type-var">'a</span>) OpamPp.t <span>&#45;&gt;</span> (OpamTypes.value, (OpamTypes.name<span class="keyword"> * </span><span class="type-var">'a</span>) OpamFormula.formula) OpamPp.t</code></dt><dd><p>Takes a parser for constraints. Lists without operator will be understood as conjunctions or disjunctions depending on the first argument.</p></dd></dl><dl><dt class="spec value" id="val-package_formula_items"><a href="#val-package_formula_items" class="anchor"></a><code><span class="keyword">val </span>package_formula_items : [&lt; `Conj<span class="keyword"> | </span>`Disj ] <span>&#45;&gt;</span> (OpamTypes.value list, <span class="type-var">'a</span>) OpamPp.t <span>&#45;&gt;</span> (OpamTypes.value list, (OpamTypes.name<span class="keyword"> * </span><span class="type-var">'a</span>) OpamFormula.formula) OpamPp.t</code></dt><dd><p>Like <code>package_formula</code>, but takes the list items directly</p></dd></dl><dl><dt class="spec value" id="val-env_binding"><a href="#val-env_binding" class="anchor"></a><code><span class="keyword">val </span>env_binding : (OpamTypes.value, OpamTypes.env_update) OpamPp.t</code></dt><dd><p>Environment variable updates syntax</p></dd></dl><dl><dt class="spec value" id="val-os_constraint"><a href="#val-os_constraint" class="anchor"></a><code><span class="keyword">val </span>os_constraint : (OpamTypes.value, (bool<span class="keyword"> * </span>string) OpamFormula.formula) OpamPp.t</code></dt></dl></div></body></html>