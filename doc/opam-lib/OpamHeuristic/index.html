<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>OpamHeuristic (opam-lib.OpamHeuristic)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../index.html">opam-lib</a> &#x00BB; OpamHeuristic</nav><h1>Module <code>OpamHeuristic</code></h1><p>Solver heuristics.</p><nav class="toc"><ul><li><a href="#high-level-api">High-level API</a></li><li><a href="#internal-api">Internal API</a><ul><li><a href="#integer-space">Integer space</a></li><li><a href="#polymorphic-space">Polymorphic space</a></li><li><a href="#package-space">Package space</a></li></ul></li></ul></nav></header><aside><p>This module tries to turn an efficient solution checker (such as the one provided by the dose3 library, writen by J. Vouillon) into a relatively good solution finder.</p><p>The method we are using is the following:</p><ul><li>We ultimately rely on a brute-force exploration loop, where we iterate over the state-space implicitely, using a monotonous successor function which encodes the optimization criteria we are interested in;</li></ul><ul><li>As brute-force exploration is costly, the goal is to provide the exploration function a state-space as small as possible. To do so, we use different kind of constraints that we deduce from the request;</li></ul><ul><li>We remove from the state-space every packages and versions that are not needed: we are only considering (i) the installed root packages (with no specific version constraint); (ii) the new packages that the user might have asking to install or upgrade (with some eventual version constraints); and (iii) the transitive closure of (i) and (ii) (with the corresponding version constraints);</li></ul><p>Finally, we run all this in a loop, until we reach a fix point. We use a timeout to interrupt too long explorations.</p></aside><section><header><h3 id="high-level-api"><a href="#high-level-api" class="anchor"></a>High-level API</h3></header><dl><dt class="spec value" id="val-resolve"><a href="#val-resolve" class="anchor"></a><code><span class="keyword">val </span>resolve : ?&#8288;verbose:bool <span>&#45;&gt;</span> version_map:int OpamPackage.Map.t <span>&#45;&gt;</span> (Cudf.universe <span>&#45;&gt;</span> Cudf.universe) <span>&#45;&gt;</span> Cudf.universe <span>&#45;&gt;</span> Cudf_types.vpkg OpamTypes.request <span>&#45;&gt;</span> (Cudf.package OpamTypes.atomic_action list, OpamCudf.conflict) OpamTypes.result</code></dt><dd><p>Optimized resolution</p></dd></dl></section><section><header><h3 id="internal-api"><a href="#internal-api" class="anchor"></a>Internal API</h3></header><aside><p>These functions can be used independently of OPAM, so we document them here. It is not expected than any other file in OPAM use them, though.</p></aside><dl><dt class="spec type" id="type-state"><a href="#type-state" class="anchor"></a><code><span class="keyword">type </span>'a state</code><code><span class="keyword"> = </span><span class="type-var">'a</span> list</code></dt><dd><p>A state. In our case, it is a list package we would like to see installed.</p></dd></dl><dl><dt class="spec type" id="type-state_space"><a href="#type-state_space" class="anchor"></a><code><span class="keyword">type </span>'a state_space</code><code><span class="keyword"> = </span><span class="type-var">'a</span> array list</code></dt><dd><p>A state space. In our case, it is a collection of available packages: each cell contains all the versions available for one package, ordered by version.</p></dd></dl><section><header><h5 id="integer-space"><a href="#integer-space" class="anchor"></a>Integer space</h5></header><aside><p>The hearth of the brute-force algorithm lies here. Wwe want to iterate on the state-space (which can be hudge) and stop the first time we hit a consistant state. This means two things: (i) we don't want to build the full universe before iterating on it; (ii) we need to enumerate the states in a meaningful order, eg. an order which should reflect the optimization criteria we are intersted in.</p></aside><aside><p>To overcome this difficulties, we use a monotonous successor function to compute the next state to test from a given valid non-consistent state, see <code>succ</code> for more details.</p></aside><dl><dt class="spec value" id="val-zero"><a href="#val-zero" class="anchor"></a><code><span class="keyword">val </span>zero : int <span>&#45;&gt;</span> int <a href="index.html#type-state">state</a></code></dt><dd><p><code>zero n</code> returns the tuple with <code>n</code> zeros, which is the first state to explore.</p></dd></dl><dl><dt class="spec value" id="val-succ"><a href="#val-succ" class="anchor"></a><code><span class="keyword">val </span>succ : bounds:int list <span>&#45;&gt;</span> int <a href="index.html#type-state">state</a> <span>&#45;&gt;</span> int <a href="index.html#type-state">state</a> option</code></dt><dd><p>Given a list of bounds and a tuple, return the next tuple which satisfies the bounds (each component will be stricly lesser than the bounds). The enumeration respect the following invariant:</p><ul><li>it is complete, eg. all the state are enumerated until <code>None</code> is returned.</li></ul><ul><li>it it monotonous: the sum of components always increase, eg. <code>|succ x| &gt;= |x|</code>, where <code>|None|</code> is <code>max_int</code>, <code>|Some x| = |x|</code> and <code>|(x_1,...,x_n) = x_1 + ... + x_n|</code>.</li></ul><p>That enumeration encodes the heuristic we are trying to implement, which is: we first try to install the 'ideal' state, where all packages are installed with their most recent versions; if this does not work, we try to minimize the distance between the ideal state and the solution we are proposing.</p></dd></dl></section><section><header><h5 id="polymorphic-space"><a href="#polymorphic-space" class="anchor"></a>Polymorphic space</h5></header><dl><dt class="spec value" id="val-brute_force"><a href="#val-brute_force" class="anchor"></a><code><span class="keyword">val </span>brute_force : ?&#8288;verbose:bool <span>&#45;&gt;</span> dump:(<span class="type-var">'a</span> <a href="index.html#type-state">state</a> <span>&#45;&gt;</span> unit) <span>&#45;&gt;</span> (<span class="type-var">'a</span> <a href="index.html#type-state">state</a> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-state_space">state_space</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-state">state</a> option</code></dt><dd><p><code>explore is_constent state_space</code> explore a state space by implicitely enumerating all the state in a sensitive order.</p></dd></dl></section><section><header><h5 id="package-space"><a href="#package-space" class="anchor"></a>Package space</h5></header><dl><dt class="spec value" id="val-state_space"><a href="#val-state_space" class="anchor"></a><code><span class="keyword">val </span>state_space : ?&#8288;filters:(Cudf_types.pkgname <span>&#45;&gt;</span> Cudf_types.constr) <span>&#45;&gt;</span> Cudf.universe <span>&#45;&gt;</span> Cudf_types.vpkglist <span>&#45;&gt;</span> Cudf_types.pkgname list <span>&#45;&gt;</span> Cudf.package <a href="index.html#type-state_space">state_space</a></code></dt><dd><p>Build a state space from a list of package names. The <code>filter</code> option helps to reduce the size of the state-space, which is useful to deal with both user-defined constraints (added on the command line for instance) and refined requests (see below).</p></dd></dl><dl><dt class="spec value" id="val-explore"><a href="#val-explore" class="anchor"></a><code><span class="keyword">val </span>explore : ?&#8288;verbose:bool <span>&#45;&gt;</span> Cudf.universe <span>&#45;&gt;</span> Cudf.package <a href="index.html#type-state_space">state_space</a> <span>&#45;&gt;</span> Cudf.package <a href="index.html#type-state">state</a> option</code></dt><dd><p>Explore the given package state-space using the <code>brute_force</code> strategy. We assume that all the packages belong to the given universe.</p></dd></dl><dl><dt class="spec value" id="val-state_of_request"><a href="#val-state_of_request" class="anchor"></a><code><span class="keyword">val </span>state_of_request : ?&#8288;verbose:bool <span>&#45;&gt;</span> version_map:int OpamPackage.Map.t <span>&#45;&gt;</span> Cudf.universe <span>&#45;&gt;</span> Cudf_types.vpkg OpamTypes.request <span>&#45;&gt;</span> Cudf.package <a href="index.html#type-state">state</a> option</code></dt><dd><p>Find a possible good state which satisfies a request. The idea is call iteratively this function while refining the constraints in the request until reaching a fix-point. This function tries to minimize the state to explore, based on the request constraints: the more constrained request you have, the smaller the state-space to explore is. Once the state-space is computed using <code>state_space</code>, it calls <code>explore</code> (which will use <code>brute_force</code>) to get an approximate solution to the request.</p></dd></dl><dl><dt class="spec value" id="val-actions_of_state"><a href="#val-actions_of_state" class="anchor"></a><code><span class="keyword">val </span>actions_of_state : version_map:int OpamPackage.Map.t <span>&#45;&gt;</span> Cudf.universe <span>&#45;&gt;</span> Cudf_types.vpkg OpamTypes.request <span>&#45;&gt;</span> Cudf.package <a href="index.html#type-state">state</a> <span>&#45;&gt;</span> Cudf.package OpamTypes.atomic_action list</code></dt><dd><p>Convert a state into a series of action (withour the full closure of reinstallations). Raise <code>Not_reachable</code> is the state is not reachable. This function is called once we get a consistent state to build a solution than we can propose to the user.</p></dd></dl></section></section></div></body></html>