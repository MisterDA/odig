<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Nanocaml__Pass (ppx_nanocaml.Nanocaml__Pass)</title><link rel="stylesheet" href="../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../index.html">ppx_nanocaml</a> &#x00BB; Nanocaml__Pass</nav><h1>Module <code>Nanocaml__Pass</code></h1></header><dl><dt class="spec type" id="type-loc"><a href="#type-loc" class="anchor"></a><code><span class="keyword">type</span> 'a loc</code><code> = <span class="type-var">'a</span> <a href="../Nanocaml/Ast/Asttypes/index.html#type-loc">Nanocaml.Ast.Asttypes.loc</a></code></dt><dt class="spec type" id="type-fun_arg"><a href="#type-fun_arg" class="anchor"></a><code><span class="keyword">type</span> fun_arg</code><code> = <a href="../Nanocaml/Ast/Asttypes/index.html#type-arg_label">Nanocaml.Ast.Asttypes.arg_label</a> * <a href="../Nanocaml/Ast/index.html#type-expression">Nanocaml.Ast.expression</a> option * <a href="../Nanocaml/Ast/index.html#type-pattern">Nanocaml.Ast.pattern</a></code></dt><dt class="spec type" id="type-np_pass"><a href="#type-np_pass" class="anchor"></a><code><span class="keyword">type</span> np_pass</code><code> = </code><code>{</code><table class="record"><tr id="type-np_pass.npp_name" class="anchored"><td class="def field"><a href="#type-np_pass.npp_name" class="anchor"></a><code>npp_name : string;</code></td></tr><tr id="type-np_pass.npp_loc" class="anchored"><td class="def field"><a href="#type-np_pass.npp_loc" class="anchor"></a><code>npp_loc : <a href="../../ocaml/Location/index.html#type-t">Nanocaml.Ast.Location.t</a>;</code></td></tr><tr id="type-np_pass.npp_input" class="anchored"><td class="def field"><a href="#type-np_pass.npp_input" class="anchor"></a><code>npp_input : <a href="../Nanocaml/Lang/index.html#type-np_language">Nanocaml.Lang.np_language</a>;</code></td></tr><tr id="type-np_pass.npp_output" class="anchored"><td class="def field"><a href="#type-np_pass.npp_output" class="anchor"></a><code>npp_output : <a href="../Nanocaml/Lang/index.html#type-np_language">Nanocaml.Lang.np_language</a>;</code></td></tr><tr id="type-np_pass.npp_pre" class="anchored"><td class="def field"><a href="#type-np_pass.npp_pre" class="anchor"></a><code>npp_pre : <a href="../Nanocaml/Ast/index.html#type-expression">Nanocaml.Ast.expression</a> <span>&#45;&gt;</span> <a href="../Nanocaml/Ast/index.html#type-expression">Nanocaml.Ast.expression</a>;</code></td></tr><tr id="type-np_pass.npp_post" class="anchored"><td class="def field"><a href="#type-np_pass.npp_post" class="anchor"></a><code>npp_post : <a href="../Nanocaml/Ast/index.html#type-expression">Nanocaml.Ast.expression</a>;</code></td></tr><tr id="type-np_pass.npp_procs" class="anchored"><td class="def field"><a href="#type-np_pass.npp_procs" class="anchor"></a><code>npp_procs : <a href="index.html#type-np_processor">np_processor</a> list;</code></td></tr></table><code>}</code></dt><dd><p>represents a nanopass definition *</p></dd></dl><dl><dt class="spec type" id="type-np_processor"><a href="#type-np_processor" class="anchor"></a><code><span class="keyword">and</span> np_processor</code><code> = </code><code>{</code><table class="record"><tr id="type-np_processor.npc_name" class="anchored"><td class="def field"><a href="#type-np_processor.npc_name" class="anchor"></a><code>npc_name : string;</code></td></tr><tr id="type-np_processor.npc_loc" class="anchored"><td class="def field"><a href="#type-np_processor.npc_loc" class="anchor"></a><code>npc_loc : <a href="../../ocaml/Location/index.html#type-t">Nanocaml.Ast.Location.t</a>;</code></td></tr><tr id="type-np_processor.npc_dom" class="anchored"><td class="def field"><a href="#type-np_processor.npc_dom" class="anchor"></a><code>npc_dom : <a href="../Nanocaml/Lang/index.html#type-np_nonterm">Nanocaml.Lang.np_nonterm</a>;</code></td></tr><tr id="type-np_processor.npc_cod" class="anchored"><td class="def field"><a href="#type-np_processor.npc_cod" class="anchor"></a><code>npc_cod : <a href="../Nanocaml/Lang/index.html#type-np_nonterm">Nanocaml.Lang.np_nonterm</a> option;</code></td></tr><tr id="type-np_processor.npc_args" class="anchored"><td class="def field"><a href="#type-np_processor.npc_args" class="anchor"></a><code>npc_args : <a href="index.html#type-fun_arg">fun_arg</a> list;</code></td></tr><tr id="type-np_processor.npc_clauses" class="anchored"><td class="def field"><a href="#type-np_processor.npc_clauses" class="anchor"></a><code>npc_clauses : <a href="index.html#type-clause">clause</a> list;</code></td></tr><tr id="type-np_processor.npc_clauses_loc" class="anchored"><td class="def field"><a href="#type-np_processor.npc_clauses_loc" class="anchor"></a><code>npc_clauses_loc : <a href="../../ocaml/Location/index.html#type-t">Nanocaml.Ast.Location.t</a>;</code></td></tr></table><code>}</code></dt><dd><p>represents a processor definition (a transformation between nonterminals in a nanopass) *</p></dd></dl><dl><dt class="spec type" id="type-clause"><a href="#type-clause" class="anchor"></a><code><span class="keyword">and</span> clause</code><code> = <a href="index.html#type-np_pat">np_pat</a> * <a href="../Nanocaml/Ast/index.html#type-expression">Nanocaml.Ast.expression</a></code></dt><dt class="spec type" id="type-np_pat"><a href="#type-np_pat" class="anchor"></a><code><span class="keyword">and</span> np_pat</code><code> = </code><table class="variant"><tr id="type-np_pat.NPpat_any" class="anchored"><td class="def constructor"><a href="#type-np_pat.NPpat_any" class="anchor"></a><code>| </code><code><span class="constructor">NPpat_any</span> <span class="keyword">of</span> <a href="../../ocaml/Location/index.html#type-t">Nanocaml.Ast.Location.t</a></code></td></tr><tr id="type-np_pat.NPpat_var" class="anchored"><td class="def constructor"><a href="#type-np_pat.NPpat_var" class="anchor"></a><code>| </code><code><span class="constructor">NPpat_var</span> <span class="keyword">of</span> string <a href="index.html#type-loc">loc</a></code></td></tr><tr id="type-np_pat.NPpat_alias" class="anchored"><td class="def constructor"><a href="#type-np_pat.NPpat_alias" class="anchor"></a><code>| </code><code><span class="constructor">NPpat_alias</span> <span class="keyword">of</span> <a href="index.html#type-np_pat">np_pat</a> * string <a href="index.html#type-loc">loc</a></code></td></tr><tr id="type-np_pat.NPpat_tuple" class="anchored"><td class="def constructor"><a href="#type-np_pat.NPpat_tuple" class="anchor"></a><code>| </code><code><span class="constructor">NPpat_tuple</span> <span class="keyword">of</span> <a href="index.html#type-np_pat">np_pat</a> list * <a href="../../ocaml/Location/index.html#type-t">Nanocaml.Ast.Location.t</a></code></td></tr><tr id="type-np_pat.NPpat_variant" class="anchored"><td class="def constructor"><a href="#type-np_pat.NPpat_variant" class="anchor"></a><code>| </code><code><span class="constructor">NPpat_variant</span> <span class="keyword">of</span> string * <a href="index.html#type-np_pat">np_pat</a> option * <a href="../../ocaml/Location/index.html#type-t">Nanocaml.Ast.Location.t</a></code></td></tr><tr id="type-np_pat.NPpat_map" class="anchored"><td class="def constructor"><a href="#type-np_pat.NPpat_map" class="anchor"></a><code>| </code><code><span class="constructor">NPpat_map</span> <span class="keyword">of</span> <a href="index.html#type-np_pat">np_pat</a></code></td></tr><tr id="type-np_pat.NPpat_cata" class="anchored"><td class="def constructor"><a href="#type-np_pat.NPpat_cata" class="anchor"></a><code>| </code><code><span class="constructor">NPpat_cata</span> <span class="keyword">of</span> <a href="index.html#type-np_pat">np_pat</a> * <a href="../Nanocaml/Ast/index.html#type-expression">Nanocaml.Ast.expression</a> option</code></td></tr></table></dt><dd><p>represents a pattern in a production. the pattern must be parsed by nanocaml so that we can correctly map over lists and apply catamorphims, e.g. for expressions like <code>(x, e [@r]) [@l]</code>. *</p></dd></dl><dl><dt class="spec value" id="val-loc_of_pat"><a href="#val-loc_of_pat" class="anchor"></a><code><span class="keyword">val</span> loc_of_pat : <a href="index.html#type-np_pat">np_pat</a> <span>&#45;&gt;</span> <a href="../../ocaml/Location/index.html#type-t">Nanocaml.Ast.Location.t</a></code></dt><dd><p>returns the <code>Location.t</code> of the given pattern. *</p></dd></dl><dl><dt class="spec value" id="val-processor_of_rhs"><a href="#val-processor_of_rhs" class="anchor"></a><code><span class="keyword">val</span> processor_of_rhs : name:string <span>&#45;&gt;</span> dom:<a href="../Nanocaml/Lang/index.html#type-np_nonterm">Nanocaml.Lang.np_nonterm</a> <span>&#45;&gt;</span> cod:<a href="../Nanocaml/Lang/index.html#type-np_nonterm">Nanocaml.Lang.np_nonterm</a> option <span>&#45;&gt;</span> loc:<a href="../../ocaml/Location/index.html#type-t">Nanocaml.Ast.Location.t</a> <span>&#45;&gt;</span> <a href="../Nanocaml/Ast/index.html#type-expression">Nanocaml.Ast.expression</a> <span>&#45;&gt;</span> <a href="index.html#type-np_processor">np_processor</a></code></dt><dd><p>convert the RHS of a <code>let</code> into a <code>np_processor</code>. *</p></dd></dl><dl><dt class="spec value" id="val-pat_of_pattern"><a href="#val-pat_of_pattern" class="anchor"></a><code><span class="keyword">val</span> pat_of_pattern : <a href="../Nanocaml/Ast/index.html#type-pattern">Nanocaml.Ast.pattern</a> <span>&#45;&gt;</span> <a href="index.html#type-np_pat">np_pat</a></code></dt><dd><p>convert a <code>pattern</code> into a <code>np_pat</code>. *</p></dd></dl><dl><dt class="spec value" id="val-signature_arrow"><a href="#val-signature_arrow" class="anchor"></a><code><span class="keyword">val</span> signature_arrow : string</code></dt><dt class="spec value" id="val-extract_pass_sig"><a href="#val-extract_pass_sig" class="anchor"></a><code><span class="keyword">val</span> extract_pass_sig : <a href="../Nanocaml/Ast/index.html#type-expression">Nanocaml.Ast.expression</a> <span>&#45;&gt;</span> (string * <a href="../../ocaml/Location/index.html#type-t">Ast_405.Location.t</a>) * (string * <a href="../../ocaml/Location/index.html#type-t">Ast_405.Location.t</a>)</code></dt><dd><p>extract <code>L0</code> and <code>L1</code> out of expression of form <code>L0 --&gt; L1</code>. returns <code>(&quot;L0&quot;, loc_L0), (&quot;L1&quot;, loc_L1)</code> (for this particular example). *</p></dd></dl><dl><dt class="spec value" id="val-extract_dom_cod"><a href="#val-extract_dom_cod" class="anchor"></a><code><span class="keyword">val</span> extract_dom_cod : loc:<a href="../../ocaml/Location/index.html#type-t">Nanocaml.Ast.Location.t</a> <span>&#45;&gt;</span> <a href="../Nanocaml/Lang/index.html#type-np_language">Nanocaml.Lang.np_language</a> <span>&#45;&gt;</span> <a href="../Nanocaml/Lang/index.html#type-np_language">Nanocaml.Lang.np_language</a> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <a href="../Nanocaml/Lang/index.html#type-np_nonterm">Nanocaml.Lang.np_nonterm</a> * <a href="../Nanocaml/Lang/index.html#type-np_nonterm">Nanocaml.Lang.np_nonterm</a> option</code></dt><dd><p>extract domain and co-domain from the name of a production. the rules are: y_of_x =&gt; dom=&quot;x&quot;, cod=&quot;y&quot; x_to_y =&gt; dom=&quot;x&quot;, cod=&quot;y&quot; x =&gt; dom=cod=&quot;x&quot; x_f =&gt; dom=&quot;x&quot;, cof=None</p><p>if the co-domain is not a valid nonterm of the output language, then the co-domain is None.</p><p>given the string name, returns <code>dom, opt_cod</code>. *</p></dd></dl><dl><dt class="spec value" id="val-pass_of_value_binding"><a href="#val-pass_of_value_binding" class="anchor"></a><code><span class="keyword">val</span> pass_of_value_binding : <a href="../Nanocaml/Ast/index.html#type-value_binding">Nanocaml.Ast.value_binding</a> <span>&#45;&gt;</span> <a href="index.html#type-np_pass">np_pass</a></code></dt><dd><p>convert a <code>value_binding</code> into a <code>np_pass</code></p></dd></dl></div></body></html>