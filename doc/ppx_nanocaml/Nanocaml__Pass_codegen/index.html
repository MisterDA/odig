<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Nanocaml__Pass_codegen (ppx_nanocaml.Nanocaml__Pass_codegen)</title><link rel="stylesheet" href="../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../index.html">ppx_nanocaml</a> &#x00BB; Nanocaml__Pass_codegen</nav><h1>Module <code>Nanocaml__Pass_codegen</code></h1></header><div class="spec module" id="module-A"><a href="#module-A" class="anchor"></a><code><span class="keyword">module</span> A = <a href="../Nanocaml/Ast/index.html#module-Ast_helper">Nanocaml.Ast.Ast_helper</a></code></div><div class="spec module" id="module-Enum"><a href="#module-Enum" class="anchor"></a><code><span class="keyword">module</span> <a href="Enum/index.html">Enum</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><dl><dt class="spec value" id="val-compose_all"><a href="#val-compose_all" class="anchor"></a><code><span class="keyword">val</span> compose_all : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span>) list <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p><code>compose_all [f; g; h] x</code> = <code>f (g (h x))</code> *</p></dd></dl><dl><dt class="spec value" id="val-lident_of_id"><a href="#val-lident_of_id" class="anchor"></a><code><span class="keyword">val</span> lident_of_id : string <a href="../Nanocaml/Pass/index.html#type-loc">Nanocaml.Pass.loc</a> <span>&#45;&gt;</span> <a href="../../ocaml/Longident/index.html#type-t">Nanocaml.Ast.Longident.t</a> <a href="../../ocaml/Location/index.html#type-loc">Nanocaml.Ast.Location.loc</a></code></dt><dd><p>convert <code>string loc</code> into <code>Longident.t loc</code> as just a <code>Lident</code>. *</p></dd></dl><dl><dt class="spec value" id="val-exp_of_id"><a href="#val-exp_of_id" class="anchor"></a><code><span class="keyword">val</span> exp_of_id : string <a href="../Nanocaml/Pass/index.html#type-loc">Nanocaml.Pass.loc</a> <span>&#45;&gt;</span> <a href="../../ocaml-migrate-parsetree/Ast_405/Parsetree/index.html#type-expression">Ast_405.Parsetree.expression</a></code></dt><dd><p>convert <code>string loc</code> into <code>expr</code> that is just a <code>Pexp_ident</code>. *</p></dd></dl><dl><dt class="spec value" id="val-simple_let"><a href="#val-simple_let" class="anchor"></a><code><span class="keyword">val</span> simple_let : ?&#8288;recflag:<a href="../Nanocaml/Ast/Asttypes/index.html#type-rec_flag">Nanocaml.Ast.Asttypes.rec_flag</a> <span>&#45;&gt;</span> string <a href="../Nanocaml/Ast/Asttypes/index.html#type-loc">Nanocaml.Ast.Asttypes.loc</a> <span>&#45;&gt;</span> <a href="../../ocaml-migrate-parsetree/Ast_405/Parsetree/index.html#type-expression">Ast_405.Parsetree.expression</a> <span>&#45;&gt;</span> <a href="../../ocaml-migrate-parsetree/Ast_405/Parsetree/index.html#type-expression">Ast_405.Parsetree.expression</a> <span>&#45;&gt;</span> <a href="../../ocaml-migrate-parsetree/Ast_405/Parsetree/index.html#type-expression">Ast_405.Parsetree.expression</a></code></dt><dd><p>generates simple <code>let x = e1 in e2</code> expression *</p></dd></dl><dl><dt class="spec value" id="val-simple_pat_let"><a href="#val-simple_pat_let" class="anchor"></a><code><span class="keyword">val</span> simple_pat_let : ?&#8288;recflag:<a href="../Nanocaml/Ast/Asttypes/index.html#type-rec_flag">Nanocaml.Ast.Asttypes.rec_flag</a> <span>&#45;&gt;</span> <a href="../Nanocaml/Ast/index.html#type-pattern">Nanocaml.Ast.pattern</a> <span>&#45;&gt;</span> <a href="../../ocaml-migrate-parsetree/Ast_405/Parsetree/index.html#type-expression">Ast_405.Parsetree.expression</a> <span>&#45;&gt;</span> <a href="../../ocaml-migrate-parsetree/Ast_405/Parsetree/index.html#type-expression">Ast_405.Parsetree.expression</a> <span>&#45;&gt;</span> <a href="../../ocaml-migrate-parsetree/Ast_405/Parsetree/index.html#type-expression">Ast_405.Parsetree.expression</a></code></dt><dd><p>generates simple <code>let p = e1 in e2</code> expression *</p></dd></dl><dl><dt class="spec value" id="val-fresh"><a href="#val-fresh" class="anchor"></a><code><span class="keyword">val</span> fresh : next_id:int <a href="../../batteries/Batteries/index.html#type-ref">Batteries.ref</a> <span>&#45;&gt;</span> loc:<a href="../../ocaml/Location/index.html#type-t">Ast_405.Location.t</a> <span>&#45;&gt;</span> string <a href="../Nanocaml/Pass/index.html#type-loc">Nanocaml.Pass.loc</a></code></dt><dd><p>generate fresh <code>string loc</code> using the given <code>int ref</code>.</p></dd></dl><dl><dt class="spec value" id="val-vars_of_pattern"><a href="#val-vars_of_pattern" class="anchor"></a><code><span class="keyword">val</span> vars_of_pattern : <a href="../Nanocaml/Pass/index.html#type-np_pat">Nanocaml.Pass.np_pat</a> <span>&#45;&gt;</span> string <a href="../Nanocaml/Pass/index.html#type-loc">Nanocaml.Pass.loc</a> list</code></dt><dd><p>finds all the variables mentioned in the given pattern. returns the <code>string loc</code>s in reverse order.</p></dd></dl><div class="spec module" id="module-Lib_ast"><a href="#module-Lib_ast" class="anchor"></a><code><span class="keyword">module</span> <a href="Lib_ast/index.html">Lib_ast</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><dl><dt class="spec value" id="val-gen_simple_pat"><a href="#val-gen_simple_pat" class="anchor"></a><code><span class="keyword">val</span> gen_simple_pat : <a href="../Nanocaml/Pass/index.html#type-np_pat">Nanocaml.Pass.np_pat</a> <span>&#45;&gt;</span> <a href="../../ocaml-migrate-parsetree/Ast_405/Parsetree/index.html#type-pattern">Ast_405.Parsetree.pattern</a></code></dt><dd><p>given an unconditional pattern, converts it to an equivalent parsetree pattern.</p></dd></dl><dl><dt class="spec value" id="val-gen_pattern"><a href="#val-gen_pattern" class="anchor"></a><code><span class="keyword">val</span> gen_pattern : next_id:int <a href="../../batteries/Batteries/index.html#type-ref">Batteries.ref</a> <span>&#45;&gt;</span> bind_as:<a href="../../ocaml-migrate-parsetree/Ast_405/Ast_helper/index.html#type-str">Ast_405.Ast_helper.str</a> option <span>&#45;&gt;</span> <a href="../Nanocaml/Pass/index.html#type-np_pat">Nanocaml.Pass.np_pat</a> <span>&#45;&gt;</span> <a href="../../ocaml-migrate-parsetree/Ast_405/Parsetree/index.html#type-pattern">Ast_405.Parsetree.pattern</a> * (<a href="../../ocaml-migrate-parsetree/Ast_405/Parsetree/index.html#type-expression">Ast_405.Parsetree.expression</a> <span>&#45;&gt;</span> <a href="../../ocaml-migrate-parsetree/Ast_405/Parsetree/index.html#type-expression">Ast_405.Parsetree.expression</a>)</code></dt><dd><p>given an <code>np_pat</code>, returns <code>ppat, intro</code>, where <code>ppat</code> is the generated pattern, and <code>intro</code> is a function on expressions which introduces let bindings around the given expression. TODO: maybe represent <code>intro</code> as a list of value bindings instead of a function?</p><p><code>~next_id</code> is a <code>ref int</code> used to generate fresh identifies if <code>~bind_as</code> is <code>Some &lt;string loc&gt;</code>, the given string will be bound to the result of the pattern.</p></dd></dl><dl><dt class="spec value" id="val-gen_l_lhs"><a href="#val-gen_l_lhs" class="anchor"></a><code><span class="keyword">val</span> gen_l_lhs : loc:<a href="../../ocaml/Location/index.html#type-t">Nanocaml.Ast.Location.t</a> <span>&#45;&gt;</span> <a href="../Nanocaml/Pass/index.html#type-np_pat">Nanocaml.Pass.np_pat</a> <span>&#45;&gt;</span> <a href="../Nanocaml/Ast/index.html#type-pattern">Nanocaml.Ast.pattern</a></code></dt><dd><p>generate the LHS pattern for a <code>@l</code> pattern (for binding the results of the list comprehension).</p></dd></dl><dl><dt class="spec value" id="val-gen_l_rhs"><a href="#val-gen_l_rhs" class="anchor"></a><code><span class="keyword">val</span> gen_l_rhs : next_id:int <a href="../../batteries/Batteries/index.html#type-ref">Batteries.ref</a> <span>&#45;&gt;</span> <a href="../Nanocaml/Pass/index.html#type-np_pat">Nanocaml.Pass.np_pat</a> <span>&#45;&gt;</span> string <a href="../Nanocaml/Pass/index.html#type-loc">Nanocaml.Pass.loc</a> <span>&#45;&gt;</span> <a href="../../ocaml-migrate-parsetree/Ast_405/Parsetree/index.html#type-expression">Ast_405.Parsetree.expression</a></code></dt><dd><p>generate the RHS expression for a <code>@l</code> pattern (the expression that performs the list comprehension).</p></dd></dl><dl><dt class="spec value" id="val-typ_of_nonterm"><a href="#val-typ_of_nonterm" class="anchor"></a><code><span class="keyword">val</span> typ_of_nonterm : loc:<a href="../../ocaml-migrate-parsetree/Ast_405/Ast_helper/index.html#type-loc">Ast_405.Ast_helper.loc</a> <span>&#45;&gt;</span> <a href="../Nanocaml/Lang/index.html#type-np_language">Nanocaml.Lang.np_language</a> <span>&#45;&gt;</span> <a href="../Nanocaml/Lang/index.html#type-np_nonterm">Nanocaml.Lang.np_nonterm</a> <span>&#45;&gt;</span> <a href="../../ocaml-migrate-parsetree/Ast_405/Parsetree/index.html#type-core_type">Ast_405.Parsetree.core_type</a></code></dt><dd><p>generate type expression from language and nonterm *</p></dd></dl><dl><dt class="spec value" id="val-gen_zipper_exps"><a href="#val-gen_zipper_exps" class="anchor"></a><code><span class="keyword">val</span> gen_zipper_exps : next_id:int <a href="../../batteries/Batteries/index.html#type-ref">Batteries.ref</a> <span>&#45;&gt;</span> loc:<span class="type-var">'a</span> <span>&#45;&gt;</span> <a href="../../ocaml-migrate-parsetree/Ast_405/Parsetree/index.html#type-expression">Ast_405.Parsetree.expression</a> <span>&#45;&gt;</span> <a href="../../ocaml-migrate-parsetree/Ast_405/Parsetree/index.html#type-expression">Ast_405.Parsetree.expression</a></code></dt><dt class="spec value" id="val-gen_processor_vb"><a href="#val-gen_processor_vb" class="anchor"></a><code><span class="keyword">val</span> gen_processor_vb : <a href="../Nanocaml/Lang/index.html#type-np_language">Nanocaml.Lang.np_language</a> <span>&#45;&gt;</span> <a href="../Nanocaml/Lang/index.html#type-np_language">Nanocaml.Lang.np_language</a> <span>&#45;&gt;</span> <a href="../Nanocaml/Pass/index.html#type-np_processor">Nanocaml.Pass.np_processor</a> <span>&#45;&gt;</span> <a href="../../ocaml-migrate-parsetree/Ast_405/Parsetree/index.html#type-value_binding">Ast_405.Parsetree.value_binding</a></code></dt><dd><p>generate <code>value_binding</code> from <code>np_processor</code>. *</p></dd></dl><dl><dt class="spec value" id="val-gen_pass_vb"><a href="#val-gen_pass_vb" class="anchor"></a><code><span class="keyword">val</span> gen_pass_vb : <a href="../Nanocaml/Pass/index.html#type-np_pass">Nanocaml.Pass.np_pass</a> <span>&#45;&gt;</span> <a href="../../ocaml-migrate-parsetree/Ast_405/Parsetree/index.html#type-value_binding">Ast_405.Parsetree.value_binding</a></code></dt><dd><p>generate <code>value_binding</code> from <code>np_pass</code>. *</p></dd></dl></div></body></html>