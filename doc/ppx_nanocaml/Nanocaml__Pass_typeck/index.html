<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Nanocaml__Pass_typeck (ppx_nanocaml.Nanocaml__Pass_typeck)</title><link rel="stylesheet" href="../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../index.html">ppx_nanocaml</a> &#x00BB; Nanocaml__Pass_typeck</nav><h1>Module <code>Nanocaml__Pass_typeck</code></h1></header><dl><dt class="spec value" id="val-typeck_pass"><a href="#val-typeck_pass" class="anchor"></a><code><span class="keyword">val</span> typeck_pass : <a href="../Nanocaml/Pass/index.html#type-np_pass">Nanocaml.Pass.np_pass</a> <span>&#45;&gt;</span> <a href="../Nanocaml/Pass/index.html#type-np_pass">Nanocaml.Pass.np_pass</a></code></dt><dd><p>perform &quot;typechecking&quot; on the clauses in each processor of the pass. this checks the patterns against the production signatures, to make sure that they are well formed. additionally, it elaborates patterns in the following ways: 1) infers catamorphism expressions 2) elaborates catamorphisms that aren't applied directly to a nonterminal</p><p>for instance, given the nonterm type stmt = <code> `Def of (string, expr) list | ... </code> it expands the pattern `Def (defs <code>@r</code>) into `Def ( (_, _ <code>@r expr</code>) <code>@l</code> as defs )</p><p>this way, NPpat_cata is only applied directly to nonterminals (in this case, 'expr'), which simplifies the generation of code.</p><p>non-exhaustive patterns are not allowed within <code>@l</code> or <code>@r</code> forms. This is because they expand to let definitions that match the inner pattern. e.g. `Def (<code></code>) ok `Var ((x,i) <code>@r</code>) ok</p><p>`Def (<code></code> <code>@r</code>) bad would expand into roughly `Def (defs_) -&gt; let <code></code> = List.map (fun (x,e) -&gt; ...) defs_ in ^ if this pattern fails, we are fucked</p><p>`Expr (e' <code>@r</code>, <code></code>) ok NOTE: if the <code></code> match fails, the cata for e' will not be called! expands into `Expr (e_, <code></code>) -&gt; let e' = expr_of_expr e_ in *</p></dd></dl><dl><dt class="spec value" id="val-typeck_err"><a href="#val-typeck_err" class="anchor"></a><code><span class="keyword">val</span> typeck_err : loc:<a href="../../ocaml/Location/index.html#type-t">Nanocaml.Ast.Location.t</a> <span>&#45;&gt;</span> <a href="../Nanocaml/Lang/index.html#type-np_type">Nanocaml.Lang.np_type</a> <span>&#45;&gt;</span> exn</code></dt><dd><p>returns an <code>exn</code> for type errors. *</p></dd></dl><dl><dt class="spec value" id="val-cross_off"><a href="#val-cross_off" class="anchor"></a><code><span class="keyword">val</span> cross_off : <a href="../Nanocaml/Lang/index.html#type-np_production">Nanocaml.Lang.np_production</a> list <span>&#45;&gt;</span> <a href="../Nanocaml/Pass/index.html#type-clause">Nanocaml.Pass.clause</a> list <span>&#45;&gt;</span> <a href="../Nanocaml/Lang/index.html#type-np_production">Nanocaml.Lang.np_production</a> list</code></dt><dd><p>Find all missing productions for a pass</p></dd></dl><dl><dt class="spec value" id="val-gen_missing"><a href="#val-gen_missing" class="anchor"></a><code><span class="keyword">val</span> gen_missing : pass:<a href="../Nanocaml/Pass/index.html#type-np_pass">Nanocaml.Pass.np_pass</a> <span>&#45;&gt;</span> loc:<a href="../../ocaml/Location/index.html#type-t">Nanocaml.Ast.Location.t</a> <span>&#45;&gt;</span> <a href="../Nanocaml/Lang/index.html#type-np_production">Nanocaml.Lang.np_production</a> list <span>&#45;&gt;</span> <a href="../Nanocaml/Pass/index.html#type-clause">Nanocaml.Pass.clause</a> list</code></dt><dt class="spec value" id="val-typeck_pat"><a href="#val-typeck_pat" class="anchor"></a><code><span class="keyword">val</span> typeck_pat : pass:<a href="../Nanocaml/Pass/index.html#type-np_pass">Nanocaml.Pass.np_pass</a> <span>&#45;&gt;</span> <a href="../Nanocaml/Lang/index.html#type-np_type">Nanocaml.Lang.np_type</a> <span>&#45;&gt;</span> <a href="../Nanocaml/Pass/index.html#type-np_pat">Nanocaml.Pass.np_pat</a> <span>&#45;&gt;</span> <a href="../Nanocaml/Pass/index.html#type-np_pat">Nanocaml.Pass.np_pat</a></code></dt><dd><p>typecheck a single pattern, with the given expected type. if it succeeds, returns a pattern that is the same as the given pattern, with all empty <code>@r</code> patterns filled in with an inferred catamorphism function. *</p></dd></dl><dl><dt class="spec value" id="val-typeck_nonterm"><a href="#val-typeck_nonterm" class="anchor"></a><code><span class="keyword">val</span> typeck_nonterm : pass:<a href="../Nanocaml/Pass/index.html#type-np_pass">Nanocaml.Pass.np_pass</a> <span>&#45;&gt;</span> loc:<a href="../../ocaml/Location/index.html#type-t">Nanocaml.Ast.Location.t</a> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <a href="../Nanocaml/Pass/index.html#type-np_pat">Nanocaml.Pass.np_pat</a> option <span>&#45;&gt;</span> <a href="../Nanocaml/Pass/index.html#type-np_pat">Nanocaml.Pass.np_pat</a> option</code></dt><dd><p>typecheck the (optional) argument to a nontermal given <code>pr_name</code>, the name of the production it is associated with. <code>nt_name</code> must be a valid nonterminal in the input language.</p></dd></dl><dl><dt class="spec value" id="val-typeck_cata"><a href="#val-typeck_cata" class="anchor"></a><code><span class="keyword">val</span> typeck_cata : pass:<a href="../Nanocaml/Pass/index.html#type-np_pass">Nanocaml.Pass.np_pass</a> <span>&#45;&gt;</span> loc:<a href="../../ocaml/Location/index.html#type-t">Nanocaml.Ast.Location.t</a> <span>&#45;&gt;</span> <a href="../Nanocaml/Ast/index.html#type-expression">Nanocaml.Ast.expression</a> option <span>&#45;&gt;</span> <a href="../Nanocaml/Lang/index.html#type-np_type">Nanocaml.Lang.np_type</a> <span>&#45;&gt;</span> <a href="../Nanocaml/Pass/index.html#type-np_pat">Nanocaml.Pass.np_pat</a> <span>&#45;&gt;</span> [ `Infer of <a href="../Nanocaml/Ast/index.html#type-expression">Nanocaml.Ast.expression</a> | `Rewrite of <a href="../Nanocaml/Pass/index.html#type-np_pat">Nanocaml.Pass.np_pat</a> ]</code></dt><dd><p>typechecks a catamorphism pattern, which either infers the catamorphism, or rewrites the pattern by moving the catamorphism to deeper sub-patterns. *</p></dd></dl><dl><dt class="spec value" id="val-pat_is_conditional"><a href="#val-pat_is_conditional" class="anchor"></a><code><span class="keyword">val</span> pat_is_conditional : <a href="../Nanocaml/Pass/index.html#type-np_pat">Nanocaml.Pass.np_pat</a> <span>&#45;&gt;</span> bool</code></dt><dd><p>determines if a pattern is conditional, e.g. it can fail for certain values. *</p></dd></dl><dl><dt class="spec value" id="val-catamorphism"><a href="#val-catamorphism" class="anchor"></a><code><span class="keyword">val</span> catamorphism : pass:<a href="../Nanocaml/Pass/index.html#type-np_pass">Nanocaml.Pass.np_pass</a> <span>&#45;&gt;</span> loc:<a href="../../ocaml/Location/index.html#type-t">Nanocaml.Ast.Location.t</a> <span>&#45;&gt;</span> <a href="../Nanocaml/Lang/index.html#type-np_nonterm">Nanocaml.Lang.np_nonterm</a> <span>&#45;&gt;</span> <a href="../Nanocaml/Ast/index.html#type-expression">Nanocaml.Ast.expression</a></code></dt><dd><p>generate an appropriate catamorphism function expression for the given nonterminal. *</p></dd></dl></div></body></html>