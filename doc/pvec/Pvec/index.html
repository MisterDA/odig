<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Pvec (pvec.Pvec)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../index.html">pvec</a> &#x00BB; Pvec</nav><h1>Module <code>Pvec</code></h1><p>Persistent vectors for OCaml.</p><p><code>Pvec</code> provides persistent, indexed, collections of elements with efficient indexing, concatenation and subvector extraction operations.</p><p><b>Terminology.</b> Given a vector <code>v</code> we write <code>v.(i)</code> the element indexed by <code>i</code> in <code>v</code>. Indices are zero-based and the <em>valid indices</em> of a vector <code>v</code> of length <code>l</code> are the integers in the range [<code>0</code>;<code>l-1</code>]. Index <code>0</code> is the <em>first index</em> and this end point is the <em>left</em> of a vector. Index <code>l-1</code> is the <em>last index</em> and this end point is the <em>right</em> of a vector.</p><p><b>Warning.</b> All functions that produce larger vectors from smaller ones raise <code>Invalid_argument</code> if the result is longer than <a href="index.html#val-max_length"><code>max_length</code></a>.</p><p><b>FIXME.</b></p><ul><li>Iterators from <code>first</code> to <code>last</code> could be useful.</li><li>Element predicates it would be nice to always pass the index to predicates but this prevents easy reuse of (elt -&gt; bool) predicates on the vector elements. A wrapping combinator could be added but in practice it seems one would need to use it most of the time. Doubling all functions with <code>i</code> is out of the question -- or not it seems this add ~10 funs and is useful in practice</li><li>Provide functor on leaves ? Could be useful for well packed structures (e.g. a pre-applied <code>Pbytes</code> with strings and/or an infinite number of Pt with <a href="https://github.com/ocaml/ocaml/pull/616">this</a>). What is nice though without functor is the uniformity e.g. for higher order vectors, you always only work with <code>Pvec</code> regardless. Also see w.r.t. <code>Uchar.t</code> plans.</li><li>Implement relaxation and try to keep all ops symmetric.</li><li>Still provide a transient <code>Buffer</code>-like for fast, repeated pre/append ?</li><li>Traversals add <code>first</code> <code>last</code> optional arguments ?</li></ul><p><b>References.</b> N.B. for now not relaxed.</p><ul><li>N. Stucki et al. <em><a href="http://dx.doi.org/10.1145/2784731.2784739">RRB Vector: A Practical General Purpose Immutable Sequence</a></em>. ICFP 2015.</li></ul><p><em>383dcc1 — <a href="UNDEFINED">homepage</a></em></p><nav class="toc"><ul><li><a href="#pvecs">Persistent vectors</a></li><li><a href="#cons">Constructors</a></li><li><a href="#preds">Predicates and comparisons</a></li><li><a href="#get">Getting elements</a></li><li><a href="#add">Adding elements</a></li><li><a href="#set">Setting elements</a></li><li><a href="#rem">Removing elements</a></li><li><a href="#traverse">Traversing</a></li><li><a href="#mapping">Mapping and rearranging</a></li><li><a href="#breaking">Breaking</a><ul><li><a href="#mag_break">Breaking with magnitudes</a></li><li><a href="#pred_break">Breaking with predicates</a></li><li><a href="#cuts">Breaking with separators</a></li></ul></li><li><a href="#search_select">Searching and selecting elements</a></li><li><a href="#edit_dist">Edit distance</a></li><li><a href="#conv">Conversions</a></li><li><a href="#print">Pretty printing</a></li></ul></nav></header><section><header><h2 id="pvecs"><a href="#pvecs" class="anchor"></a>Persistent vectors</h2></header><dl><dt class="spec value" id="val-max_length"><a href="#val-max_length" class="anchor"></a><code><span class="keyword">val </span>max_length : int</code></dt><dd><p><code>max_length</code> is the maximal vector length. Note that this is larger than both <span class="xref-unresolved" title="unresolved reference to &quot;Sys.max_string_length&quot;"><code>Sys</code>.max_string_length</span> and <span class="xref-unresolved" title="unresolved reference to &quot;Sys.max_array_length&quot;"><code>Sys</code>.max_array_length</span>.</p></dd></dl><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type </span>'a t</code></dt><dd><p>The type for persistent vectors indexing elements of type <code>'a</code>.</p></dd></dl><dl><dt class="spec value" id="val-length"><a href="#val-length" class="anchor"></a><code><span class="keyword">val </span>length : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int</code></dt><dd><p><code>length v</code> is the number of elements in <code>v</code>.</p></dd></dl></section><section><header><h2 id="cons"><a href="#cons" class="anchor"></a>Constructors</h2></header><dl><dt class="spec value" id="val-empty"><a href="#val-empty" class="anchor"></a><code><span class="keyword">val </span>empty : <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>empty</code> is the empty vector.</p></dd></dl><dl><dt class="spec value" id="val-v"><a href="#val-v" class="anchor"></a><code><span class="keyword">val </span>v : len:int <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>v len e</code> is a vector <code>u</code> of length <code>len</code> with <code>u.(i) = e</code> for all valid indices <code>i</code> of <code>u</code>. </p><dl><dt>raises Invalid_argument</dt><dd><p>if <code>len</code> is not in the range [<code>0</code>; <a href="index.html#val-max_length"><code>max_length</code></a>].</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-init"><a href="#val-init" class="anchor"></a><code><span class="keyword">val </span>init : len:int <span>&#45;&gt;</span> (int <span>&#45;&gt;</span> <span class="type-var">'a</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>init ~len f</code> is a vector <code>v</code> of length <code>len</code> with <code>v.(i) = f i</code> for all valid indices <code>i</code> of <code>v</code>. </p><dl><dt>raises Invalid_argument</dt><dd><p>if <code>len</code> is not in the range [<code>0</code>; <a href="index.html#val-max_length"><code>max_length</code></a>].</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-singleton"><a href="#val-singleton" class="anchor"></a><code><span class="keyword">val </span>singleton : <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>singleton e</code> is <code>v ~len:1 e</code>.</p></dd></dl><dl><dt class="spec value" id="val-ints"><a href="#val-ints" class="anchor"></a><code><span class="keyword">val </span>ints : ?&#8288;start:int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int <a href="index.html#type-t">t</a></code></dt><dd><p><code>ints n</code> is the sequence of integers from <code>start</code> (defaults to <code>0</code>) to <code>n</code> (included). This is <a href="index.html#val-empty"><code>empty</code></a> if <code>start &gt; n</code>.</p></dd></dl></section><section><header><h2 id="preds"><a href="#preds" class="anchor"></a>Predicates and comparisons</h2></header><dl><dt class="spec value" id="val-is_empty"><a href="#val-is_empty" class="anchor"></a><code><span class="keyword">val </span>is_empty : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>is_empty v</code> is <code>true</code> iff <code>length v = 0</code>.</p></dd></dl><dl><dt class="spec value" id="val-is_filled"><a href="#val-is_filled" class="anchor"></a><code><span class="keyword">val </span>is_filled : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> bool</code></dt><dd><p><code>is_filled v i</code> is <code>true</code> iff <code>v.(i)</code> exists.</p></dd></dl><dl><dt class="spec value" id="val-is_prefix"><a href="#val-is_prefix" class="anchor"></a><code><span class="keyword">val </span>is_prefix : eq:(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> affix:<span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>is_prefix ~eq ~affix v</code> is <code>true</code> iff <code>affix</code> is a prefix of <code>v</code> that is iff <code>eq affix.(i) v.(i)</code> = <code>true</code> for all valid indices <code>i</code> of <code>affix</code>.</p></dd></dl><dl><dt class="spec value" id="val-is_infix"><a href="#val-is_infix" class="anchor"></a><code><span class="keyword">val </span>is_infix : eq:(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> affix:<span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>is_infix ~eq ~affix v</code> is <code>true</code> iff <code>affix</code> can be found in <code>v</code> that is iff there exists an index <code>j</code> in <code>v</code> such that for all valid indices <code>i</code> of <code>affix</code>, <code>eq affix.(i) v.(j + i)</code> = <code>true</code>.</p></dd></dl><dl><dt class="spec value" id="val-is_suffix"><a href="#val-is_suffix" class="anchor"></a><code><span class="keyword">val </span>is_suffix : eq:(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> affix:<span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>is_suffix ~eq ~affix v</code> is <code>true</code> iff <code>affix</code> is a suffix of <code>v</code> that is iff <code>eq affix.(n - i) v.(m - i)</code> = <code>true</code> for all indices <code>i</code> of <code>affix</code> with <code>n = length affix - 1</code> and <code>m = last_index
    v</code>.</p></dd></dl><dl><dt class="spec value" id="val-for_alli"><a href="#val-for_alli" class="anchor"></a><code><span class="keyword">val </span>for_alli : (int <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>for_alli p v</code> is <code>true</code> iff for all indices <code>i</code> of <code>v</code>, <code>p i v.(i) = true</code>.</p></dd></dl><dl><dt class="spec value" id="val-for_all"><a href="#val-for_all" class="anchor"></a><code><span class="keyword">val </span>for_all : (<span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>for_all p v</code> is <code>for_alli (fun _ e -&gt; p e) v</code></p></dd></dl><dl><dt class="spec value" id="val-existsi"><a href="#val-existsi" class="anchor"></a><code><span class="keyword">val </span>existsi : (int <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>existsi p</code> is <code>true</code> iff there exists an index <code>i</code> of <code>v</code> with <code>p i
    v.(i) = true</code>.</p></dd></dl><dl><dt class="spec value" id="val-exists"><a href="#val-exists" class="anchor"></a><code><span class="keyword">val </span>exists : (<span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>exists p</code> is <code>true</code> iff there exists an index <code>i</code> of <code>v</code> with <code>p
    v.(i) = true</code>.</p></dd></dl><dl><dt class="spec value" id="val-equal"><a href="#val-equal" class="anchor"></a><code><span class="keyword">val </span>equal : eq:(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>equal ~eq u v</code> is <code>true</code> iff <code>u</code> and <code>v</code> have the same length and for all indices <code>i</code> of <code>u</code>, <code>eq u.(0) v.(1)</code>.</p></dd></dl><dl><dt class="spec value" id="val-compare"><a href="#val-compare" class="anchor"></a><code><span class="keyword">val </span>compare : cmp:(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> int) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int</code></dt><dd><p><code>compare ~cmp u v</code> is the lexicographic order betwen <code>u</code> and <code>v</code> using <code>cmp</code> to compare elements.</p></dd></dl></section><section><header><h2 id="get"><a href="#get" class="anchor"></a>Getting elements</h2></header><dl><dt class="spec value" id="val-get"><a href="#val-get" class="anchor"></a><code><span class="keyword">val </span>get : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p><code>get v i</code> is <code>v.(i)</code>. </p><dl><dt>raises Invalid_argument</dt><dd><p>if <code>i</code> is not a valid index of <code>v</code>.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-get_first"><a href="#val-get_first" class="anchor"></a><code><span class="keyword">val </span>get_first : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p><code>get_first v</code> is <code>get v 0</code>.</p></dd></dl><dl><dt class="spec value" id="val-get_last"><a href="#val-get_last" class="anchor"></a><code><span class="keyword">val </span>get_last : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p><code>get_last v</code> is <code>get v (length v - 1)</code>.</p></dd></dl><dl><dt class="spec value" id="val-el"><a href="#val-el" class="anchor"></a><code><span class="keyword">val </span>el : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <span class="type-var">'a</span> option</code></dt><dd><p><code>el v i</code> is the element <code>v.(i)</code>, if any; in particular this is <code>None</code> on <code>i &lt; 0</code>.</p></dd></dl><dl><dt class="spec value" id="val-first_el"><a href="#val-first_el" class="anchor"></a><code><span class="keyword">val </span>first_el : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> option</code></dt><dd><p><code>first_el v</code> is <code>el v 0</code>.</p></dd></dl><dl><dt class="spec value" id="val-last_el"><a href="#val-last_el" class="anchor"></a><code><span class="keyword">val </span>last_el : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> option</code></dt><dd><p><code>last_el v</code> is <code>el v (length v - 1)</code>.</p></dd></dl><dl><dt class="spec value" id="val-range"><a href="#val-range" class="anchor"></a><code><span class="keyword">val </span>range : first:int <span>&#45;&gt;</span> last:int <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>range ~first ~last v</code> is <code>u</code> defined as the consecutive elements of <code>v</code> whose indices exist in the range [<code>first</code>;<code>last</code>], in the same order. <code>first</code> and <code>last</code> can be any integer. If the index range does not exist in <code>v</code> or if <code>first &gt; last</code>, <code>u</code> is empty.</p></dd></dl></section><section><header><h2 id="add"><a href="#add" class="anchor"></a>Adding elements</h2></header><dl><dt class="spec value" id="val-append"><a href="#val-append" class="anchor"></a><code><span class="keyword">val </span>append : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>append v u</code> is the vector resulting from appending <code>u</code> to <code>v</code>.</p></dd></dl><dl><dt class="spec value" id="val-(++)"><a href="#val-(++)" class="anchor"></a><code><span class="keyword">val </span>(++) : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>v ++ u</code> is <code>append v u</code>.</p></dd></dl><dl><dt class="spec value" id="val-add_first"><a href="#val-add_first" class="anchor"></a><code><span class="keyword">val </span>add_first : <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>add_first e v</code> is <code>singleton e ++ v</code>.</p></dd></dl><dl><dt class="spec value" id="val-add_last"><a href="#val-add_last" class="anchor"></a><code><span class="keyword">val </span>add_last : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>add_last v e</code> is <code>v ++ singleton e</code>.</p></dd></dl><dl><dt class="spec value" id="val-concat"><a href="#val-concat" class="anchor"></a><code><span class="keyword">val </span>concat : ?&#8288;sep:<span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>concat ~sep vs</code> is the concatenation of the vectors of <code>vs</code>, separated by <code>sep</code> (defaults to <a href="index.html#val-empty"><code>empty</code></a>): <code>vs.(0) ++ sep ++ vs.(2) ++</code> ... <code>vs.(length v - 1)</code> or <a href="index.html#val-empty"><code>empty</code></a> if <code>vs</code> is empty.</p></dd></dl><dl><dt class="spec value" id="val-concat_list"><a href="#val-concat_list" class="anchor"></a><code><span class="keyword">val </span>concat_list : ?&#8288;sep:<span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> list <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>concat_list ~sep vs</code> is <code>concat ~sep (of_list vs)</code>.</p></dd></dl><dl><dt class="spec value" id="val-splice"><a href="#val-splice" class="anchor"></a><code><span class="keyword">val </span>splice : ?&#8288;last:int <span>&#45;&gt;</span> into:<span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> first:int <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>splice ~into ~first ~last v</code> replaces the elements of <code>into</code> in range [<code>first</code>; <code>last</code>] with those of <code>v</code> or inserts <code>v</code> at <code>first</code> if the range is empty. <code>last</code> defaults to <code>first - 1</code>, the range is empty. More precisely this is:</p><ul><li><code>take_left first into ++ v ++ drop_left (last + 1) into</code> if <code>first &lt;= last</code>.</li><li><code>take_left first into ++ v ++ drop_left first into</code> otherwise.</li></ul><p>By definition if <code>last &lt; first</code> inserts <code>v</code> at <code>first</code>, pushing elements of <code>into</code> starting at <code>first</code> on the right. Also by definition, if the specified range does not overlap <code>into</code>'s range this prepends or appends <code>v</code> to <code>into</code> accordingly.</p></dd></dl></section><section><header><h2 id="set"><a href="#set" class="anchor"></a>Setting elements</h2></header><dl><dt class="spec value" id="val-set"><a href="#val-set" class="anchor"></a><code><span class="keyword">val </span>set : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>set v i e</code> is <code>v</code> with the element at index <code>i</code> equal to <code>e</code>.</p><dl><dt>raises Invalid_argument</dt><dd><p>if <code>i</code> is not a valid index of <code>v</code>.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-set_first"><a href="#val-set_first" class="anchor"></a><code><span class="keyword">val </span>set_first : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>set_first v e</code> is <code>set v 0 e</code>.</p></dd></dl><dl><dt class="spec value" id="val-set_last"><a href="#val-set_last" class="anchor"></a><code><span class="keyword">val </span>set_last : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>set_last v e</code> is <code>set v (length v - 1) e</code>.</p></dd></dl><dl><dt class="spec value" id="val-fill"><a href="#val-fill" class="anchor"></a><code><span class="keyword">val </span>fill : pad:<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>fill ~pad u i e</code> is:</p><ul><li><code>set u i e</code> if <code>i</code> is a valid index of <code>u</code>.</li><li><code>set (u ++ (v len:(i + 1 - length v) pad)) i e</code> otherwise.</li></ul><dl><dt>raises Invalid_argument</dt><dd><p>if <code>i</code> is negative.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-fill_first"><a href="#val-fill_first" class="anchor"></a><code><span class="keyword">val </span>fill_first : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>fill_first v e</code> is <code>set v 0 e</code> or <code>singleton e</code> if <code>v</code> is empty.</p></dd></dl><dl><dt class="spec value" id="val-fill_last"><a href="#val-fill_last" class="anchor"></a><code><span class="keyword">val </span>fill_last : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>fill_last v e</code> is <code>set v (length v - 1) e</code> or <code>singleton e</code> if <code>v</code> is empty.</p></dd></dl></section><section><header><h2 id="rem"><a href="#rem" class="anchor"></a>Removing elements</h2></header><dl><dt class="spec value" id="val-rem_range"><a href="#val-rem_range" class="anchor"></a><code><span class="keyword">val </span>rem_range : first:int <span>&#45;&gt;</span> last:int <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>rem_range ~first ~last v</code> is <code>v</code> without the elements of <code>v</code> that exist in the range [<code>first</code>;<code>last</code>]. More precisely this is:</p><ul><li><code>take_left first v ++ drop_left (last + 1) v</code> if <code>first &lt;= last</code>.</li><li><code>v</code> otherwise.</li></ul><p>by definition if the specified range is empty or doesn't overlap with <code>v</code>'s valid indices this is <code>v</code>.</p></dd></dl><dl><dt class="spec value" id="val-rem"><a href="#val-rem" class="anchor"></a><code><span class="keyword">val </span>rem : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>rem v i</code> is <code>rem_range ~first:i ~last:i v</code>.</p></dd></dl><dl><dt class="spec value" id="val-rem_first"><a href="#val-rem_first" class="anchor"></a><code><span class="keyword">val </span>rem_first : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>rem_first v</code> is <code>rem v 0</code>.</p></dd></dl><dl><dt class="spec value" id="val-rem_last"><a href="#val-rem_last" class="anchor"></a><code><span class="keyword">val </span>rem_last : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>rem_last v</code> is <code>rem v (length v - 1)</code>.</p></dd></dl></section><section><header><h2 id="traverse"><a href="#traverse" class="anchor"></a>Traversing</h2></header><dl><dt class="spec value" id="val-foldi_left"><a href="#val-foldi_left" class="anchor"></a><code><span class="keyword">val </span>foldi_left : (<span class="type-var">'a</span> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'a</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p><code>foldi_left f acc v</code> is <code>f (... (f (f acc 0 v.(0)) 1 v.(1)) ...) m s.(m)</code> with <code>m = length v - 1</code> or <code>acc</code> if <code>v</code> is empty.</p></dd></dl><dl><dt class="spec value" id="val-foldi_right"><a href="#val-foldi_right" class="anchor"></a><code><span class="keyword">val </span>foldi_right : (int <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'b</span></code></dt><dd><p><code>fold_right f v acc</code> is <code>f 0 v.(0) (f 1 v.(1) (... (f m v.(m) acc) ..))</code> with <code>m = length v - 1</code> or <code>acc</code> if <code>v</code> is empty.</p></dd></dl><dl><dt class="spec value" id="val-fold_left"><a href="#val-fold_left" class="anchor"></a><code><span class="keyword">val </span>fold_left : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'a</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p><code>fold_left f acc v</code> is <code>foldi_left (fun acc _ e -&gt; f acc) acc v</code>.</p></dd></dl><dl><dt class="spec value" id="val-fold_right"><a href="#val-fold_right" class="anchor"></a><code><span class="keyword">val </span>fold_right : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'b</span></code></dt><dd><p><code>fold_right f v acc</code> is <code>foldi_right (fun _ e acc -&gt; f acc) v acc</code>.</p></dd></dl><dl><dt class="spec value" id="val-iteri_left"><a href="#val-iteri_left" class="anchor"></a><code><span class="keyword">val </span>iteri_left : (int <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> unit) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>iteri_left f v</code> is <code>f 0 v.(0); f 1 v.(1); ...; f m v.(m)</code> with <code>m = length v - 1</code> or <code>()</code> if <code>v</code> is empty.</p></dd></dl><dl><dt class="spec value" id="val-iteri_right"><a href="#val-iteri_right" class="anchor"></a><code><span class="keyword">val </span>iteri_right : (int <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> unit) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>iteri_right f v</code> is <code>f m v.(m); f (m-1) v.(m-1); ...; f 0 v.(0)</code> with <code>m = length v - 1</code> or <code>()</code> if <code>v</code> is empty.</p></dd></dl><dl><dt class="spec value" id="val-iter_left"><a href="#val-iter_left" class="anchor"></a><code><span class="keyword">val </span>iter_left : (<span class="type-var">'a</span> <span>&#45;&gt;</span> unit) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>iter_left f v</code> is <code>iteri_left (fun _ e -&gt; f e) v</code>.</p></dd></dl><dl><dt class="spec value" id="val-iter_right"><a href="#val-iter_right" class="anchor"></a><code><span class="keyword">val </span>iter_right : (<span class="type-var">'a</span> <span>&#45;&gt;</span> unit) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>iter_right f v</code> is <code>iteri_right (fun _ e -&gt; f e) v</code>.</p></dd></dl></section><section><header><h2 id="mapping"><a href="#mapping" class="anchor"></a>Mapping and rearranging</h2></header><dl><dt class="spec value" id="val-mapi"><a href="#val-mapi" class="anchor"></a><code><span class="keyword">val </span>mapi : (int <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>mapi f v</code> is <code>u</code> with <code>u.(i) = f i v.(i)</code> for all indices <code>i</code> of <code>v</code> or the empty vector if <code>v</code> is empty. No guarantee is provided in the invocation order of <code>f</code> on elements.</p></dd></dl><dl><dt class="spec value" id="val-map"><a href="#val-map" class="anchor"></a><code><span class="keyword">val </span>map : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>map f v</code> is <code>mapi (fun _ e -&gt; f e) v</code>.</p></dd></dl><dl><dt class="spec value" id="val-filter_mapi"><a href="#val-filter_mapi" class="anchor"></a><code><span class="keyword">val </span>filter_mapi : (int <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> option) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>filter_map f s</code> is the vector made of the elements of <code>v</code> as (and if) mapped by <code>f</code>, in the same order. No guarantee is provided on the invocation order of <code>f</code> on elements. See also <a href="index.html#val-filter"><code>filter</code></a>.</p></dd></dl><dl><dt class="spec value" id="val-filter_map"><a href="#val-filter_map" class="anchor"></a><code><span class="keyword">val </span>filter_map : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> option) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>filter_map f s</code> is <code>filter_mapi (fun _ e -&gt; f e) v</code>.</p></dd></dl><dl><dt class="spec value" id="val-rev"><a href="#val-rev" class="anchor"></a><code><span class="keyword">val </span>rev : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>rev v</code> is <code>u</code> the vector with elements of <code>v</code> reversed, <code>u.(i) =
    v.(length v - 1 - i)</code> for all indices <code>i</code> of <code>v</code> or the empty vector if <code>v</code> is empty.</p></dd></dl><dl><dt class="spec value" id="val-indices"><a href="#val-indices" class="anchor"></a><code><span class="keyword">val </span>indices : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int <a href="index.html#type-t">t</a></code></dt><dd><p><code>indices v</code> is <code>mapi (fun i _ -&gt; i)</code>.</p></dd></dl><dl><dt class="spec value" id="val-transpose"><a href="#val-transpose" class="anchor"></a><code><span class="keyword">val </span>transpose : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <a href="index.html#type-t">t</a></code></dt><dd><p><code>transpose v</code> is <code>u</code> such that <code>u.(i).(j)</code> = <code>v.(j).(i)</code> for all indices <code>i</code> of <code>v</code> and <code>j</code> of its subvectors.</p></dd></dl><dl><dt class="spec value" id="val-stable_sort"><a href="#val-stable_sort" class="anchor"></a><code><span class="keyword">val </span>stable_sort : cmp:(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> int) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>stable_sort compare v</code> is <code>v</code> with its elements sorted according to <code>compare</code>. The sort is stable, elements that compare equal are kept in their original order.</p></dd></dl><dl><dt class="spec value" id="val-sort_uniq"><a href="#val-sort_uniq" class="anchor"></a><code><span class="keyword">val </span>sort_uniq : cmp:(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> int) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>sort_uniq compare v</code> is like <a href="index.html#val-stable_sort"><code>stable_sort</code></a> except duplicates are removed.</p></dd></dl><dl><dt class="spec value" id="val-shuffle"><a href="#val-shuffle" class="anchor"></a><code><span class="keyword">val </span>shuffle : rand:(int <span>&#45;&gt;</span> int) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>shuffle rand v</code> is a random permutation of <code>v</code>'s elements. <code>rand</code> must be such that <code>rand n</code> is a random number in the range [<code>0</code>;<code>n-1</code>].</p></dd></dl><dl><dt class="spec value" id="val-unstutter"><a href="#val-unstutter" class="anchor"></a><code><span class="keyword">val </span>unstutter : eq:(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>unstutter ~eq v</code> is <code>v</code> without consecutive equal elements.</p></dd></dl></section><section><header><h2 id="breaking"><a href="#breaking" class="anchor"></a>Breaking</h2></header><section><header><h3 id="mag_break"><a href="#mag_break" class="anchor"></a>Breaking with magnitudes</h3></header><dl><dt class="spec value" id="val-take_left"><a href="#val-take_left" class="anchor"></a><code><span class="keyword">val </span>take_left : int <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>take_left n v</code> has the first <code>n</code> elements of <code>v</code>. By definition the result is <a href="index.html#val-empty"><code>empty</code></a> if <code>n</code> is negative and <code>v</code> if <code>n &gt;= length v</code>.</p></dd></dl><dl><dt class="spec value" id="val-take_right"><a href="#val-take_right" class="anchor"></a><code><span class="keyword">val </span>take_right : int <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>take_right n v</code> has the last <code>n</code> elements of <code>v</code>. By definition the result is <a href="index.html#val-empty"><code>empty</code></a> if <code>n</code> is negative and <code>v</code> if <code>n &gt;= length v</code>.</p></dd></dl><dl><dt class="spec value" id="val-drop_left"><a href="#val-drop_left" class="anchor"></a><code><span class="keyword">val </span>drop_left : int <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>drop_left n v</code> has the elements of <code>v</code> without the first <code>n</code> elements. By definition the result is <code>v</code> if <code>n</code> is zero or negative and <a href="index.html#val-empty"><code>empty</code></a> if <code>n &gt;= length v</code>.</p></dd></dl><dl><dt class="spec value" id="val-drop_right"><a href="#val-drop_right" class="anchor"></a><code><span class="keyword">val </span>drop_right : int <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>drop_right n v</code> has the elements of <code>v</code> without the last <code>n</code> elements. By definition the result is <code>v</code> if <code>n</code> is zero or negative and <a href="index.html#val-empty"><code>empty</code></a> if <code>n &gt;= length v</code>.</p></dd></dl><dl><dt class="spec value" id="val-break_left"><a href="#val-break_left" class="anchor"></a><code><span class="keyword">val </span>break_left : int <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a><span class="keyword"> * </span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>break_left n v</code> is <code>(take_left n v, drop_left n v)</code>.</p></dd></dl><dl><dt class="spec value" id="val-break_right"><a href="#val-break_right" class="anchor"></a><code><span class="keyword">val </span>break_right : int <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a><span class="keyword"> * </span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>break_right n v</code> is <code>(drop_right n v, take_right n v)</code>.</p></dd></dl><dl><dt class="spec value" id="val-chunk_left"><a href="#val-chunk_left" class="anchor"></a><code><span class="keyword">val </span>chunk_left : int <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <a href="index.html#type-t">t</a></code></dt><dd><p><code>chunk_left size v</code> is <code>v</code>, in order, chunked into vectors of exactly <code>size</code> elements except maybe for the last one. If <code>length
    v &lt;= size</code> this is <code>singleton v</code>.</p><dl><dt>raises Invalid_argument</dt><dd><p>if <code>size</code> is not strictly positive.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-chunk_right"><a href="#val-chunk_right" class="anchor"></a><code><span class="keyword">val </span>chunk_right : int <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <a href="index.html#type-t">t</a></code></dt><dd><p><code>chunk_right size v</code> is <code>v</code>, in order, chunked into vectors of exactly <code>size</code> elements except maybe for the first one. If <code>length v &lt;= size</code> this is <code>singleton v</code>.</p><dl><dt>raises Invalid_argument</dt><dd><p>if <code>size</code> is not strictly positive.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-pop_first"><a href="#val-pop_first" class="anchor"></a><code><span class="keyword">val </span>pop_first : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span><span class="keyword"> * </span><span class="type-var">'a</span> <a href="index.html#type-t">t</a>) option</code></dt><dd><p><code>pop_first v</code> is <code>Some (get_first v, drop_left 1 v)</code> or <code>None</code> if <code>v</code> is empty.</p></dd></dl><dl><dt class="spec value" id="val-pop_last"><a href="#val-pop_last" class="anchor"></a><code><span class="keyword">val </span>pop_last : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span> <a href="index.html#type-t">t</a><span class="keyword"> * </span><span class="type-var">'a</span>) option</code></dt><dd><p><code>pop_last v</code> is <code>Some (drop_right 1 v,  get_last v)</code> or <code>None</code> if <code>v</code> is empty.</p></dd></dl></section><section><header><h3 id="pred_break"><a href="#pred_break" class="anchor"></a>Breaking with predicates</h3></header><dl><dt class="spec value" id="val-keepi_left"><a href="#val-keepi_left" class="anchor"></a><code><span class="keyword">val </span>keepi_left : (int <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>keep_left sat v</code> has the first consecutive <code>sat</code> satisfying elements of <code>v</code>.</p></dd></dl><dl><dt class="spec value" id="val-keepi_right"><a href="#val-keepi_right" class="anchor"></a><code><span class="keyword">val </span>keepi_right : (int <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>keepi_right sat v</code> has the last consecutive <code>sat</code> satisfying elements of <code>v</code>.</p></dd></dl><dl><dt class="spec value" id="val-keep_left"><a href="#val-keep_left" class="anchor"></a><code><span class="keyword">val </span>keep_left : (<span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>keep_left sat v</code> is <code>keepi_left (fun _ e -&gt; sat e) v</code>.</p></dd></dl><dl><dt class="spec value" id="val-keep_right"><a href="#val-keep_right" class="anchor"></a><code><span class="keyword">val </span>keep_right : (<span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>keep_right sat v</code> is <code>keepi_right (fun _ e -&gt; sat e) v</code>.</p></dd></dl><dl><dt class="spec value" id="val-losei_left"><a href="#val-losei_left" class="anchor"></a><code><span class="keyword">val </span>losei_left : (int <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>lose_left sat v</code> has the elements of <code>v</code> without the first consecutive <code>sat</code> satisfying elements of <code>v</code>.</p></dd></dl><dl><dt class="spec value" id="val-losei_right"><a href="#val-losei_right" class="anchor"></a><code><span class="keyword">val </span>losei_right : (int <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>lose_right sat v</code> has the elements of <code>v</code> without the last consecutive <code>sat</code> satisfying elements of <code>v</code>.</p></dd></dl><dl><dt class="spec value" id="val-lose_left"><a href="#val-lose_left" class="anchor"></a><code><span class="keyword">val </span>lose_left : (<span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>lose_left sat v</code> is <code>loosei_left (fun _ e -&gt; sat e) v</code>.</p></dd></dl><dl><dt class="spec value" id="val-lose_right"><a href="#val-lose_right" class="anchor"></a><code><span class="keyword">val </span>lose_right : (<span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>lose_right sat v</code> is <code>loosei_right (fun _ e -&gt; sat e) v</code>.</p></dd></dl><dl><dt class="spec value" id="val-spani_left"><a href="#val-spani_left" class="anchor"></a><code><span class="keyword">val </span>spani_left : (int <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a><span class="keyword"> * </span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>span_left sat v</code> is <code>(keepi_left sat v, losei_left sat v)</code>.</p></dd></dl><dl><dt class="spec value" id="val-spani_right"><a href="#val-spani_right" class="anchor"></a><code><span class="keyword">val </span>spani_right : (int <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a><span class="keyword"> * </span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>span_right sat v</code> is <code>(losei_right sat v, keepi_right sat v)</code>.</p></dd></dl><dl><dt class="spec value" id="val-span_left"><a href="#val-span_left" class="anchor"></a><code><span class="keyword">val </span>span_left : (<span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a><span class="keyword"> * </span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>span_left sat v</code> is <code>spani_left (fun _ e -&gt; sat e) v</code>.</p></dd></dl><dl><dt class="spec value" id="val-span_right"><a href="#val-span_right" class="anchor"></a><code><span class="keyword">val </span>span_right : (<span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a><span class="keyword"> * </span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>span_right sat v</code> is <code>spani_right (fun _ e -&gt; sat e) v</code>.</p></dd></dl><dl><dt class="spec value" id="val-trimi"><a href="#val-trimi" class="anchor"></a><code><span class="keyword">val </span>trimi : (int <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>trimi drop v</code> is <code>losei_right drop (losei_left drop v)</code>.</p></dd></dl><dl><dt class="spec value" id="val-trim"><a href="#val-trim" class="anchor"></a><code><span class="keyword">val </span>trim : (<span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>trim drop v</code> is <code>trim (fun _ e -&gt; drop e) v</code>.</p></dd></dl></section><section><header><h3 id="cuts"><a href="#cuts" class="anchor"></a>Breaking with separators</h3></header><dl><dt class="spec value" id="val-cut_left"><a href="#val-cut_left" class="anchor"></a><code><span class="keyword">val </span>cut_left : sep:<span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span> <a href="index.html#type-t">t</a><span class="keyword"> * </span><span class="type-var">'a</span> <a href="index.html#type-t">t</a>) option</code></dt><dd><p><code>cut_left sep v</code> is either the pair <code>Some (l, r)</code> of the two (possibly empty) vectors of <code>v</code> that are delimited by the first match of the non empty separator vector <code>sep</code> or <code>None</code> if <code>sep</code> can't be matched in <code>v</code>. Matching starts from the left of <code>v</code>.</p><p>The invariant <code>concat [l; sep; r] = v</code> holds. </p><dl><dt>raises Invalid_argument</dt><dd><p>if <code>sep</code> is empty.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-cut_right"><a href="#val-cut_right" class="anchor"></a><code><span class="keyword">val </span>cut_right : sep:<span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span> <a href="index.html#type-t">t</a><span class="keyword"> * </span><span class="type-var">'a</span> <a href="index.html#type-t">t</a>) option</code></dt><dd><p><code>cut_right sep v</code> is like <a href="index.html#val-cut_right"><code>cut_right</code></a> but matching starts on the right.</p></dd></dl><dl><dt class="spec value" id="val-cuts_left"><a href="#val-cuts_left" class="anchor"></a><code><span class="keyword">val </span>cuts_left : ?&#8288;drop_empty:bool <span>&#45;&gt;</span> sep:<span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <a href="index.html#type-t">t</a></code></dt><dd><p><code>cuts_left ~drop_empty ~sep v</code> is the vector of subvectors of <code>v</code> that are delimited by matches of the non empty separator vector <code>sep</code>. Empty vectors are omitted in the vector if <code>drop_empty</code> is <code>true</code> (defaults to <code>false</code>).</p><p>Matching separators in <code>v</code> starts from the begining of <code>v</code>. Once one is found, the separator is skipped and matching starts again, that is separator matches can't overlap. If there is no separator match in <code>v</code> the vector <code>singleton v</code> is returned.</p><p>The following invariants hold:</p><ul><li><code>concat ~sep (left_cuts ~drop_empty:false ~sep v) = v</code></li><li><code>left_cuts ~drop_empty:false ~sep s &lt;&gt; empty</code></li></ul><dl><dt>raises Invalid_argument</dt><dd><p>if <code>sep</code> is empty.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-cuts_right"><a href="#val-cuts_right" class="anchor"></a><code><span class="keyword">val </span>cuts_right : ?&#8288;drop_empty:bool <span>&#45;&gt;</span> sep:<span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <a href="index.html#type-t">t</a></code></dt><dd><p><code>cuts_right ~drop_empty ~sep v</code> is like <a href="index.html#val-cuts_left"><code>cuts_left</code></a> but matching starts from the right.</p></dd></dl><dl><dt class="spec value" id="val-fields"><a href="#val-fields" class="anchor"></a><code><span class="keyword">val </span>fields : ?&#8288;drop_empty:bool <span>&#45;&gt;</span> is_sep:(<span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <a href="index.html#type-t">t</a></code></dt><dd><p><code>fields ~drop_empty ~is_sep v</code> is the vector of (possibly empty) subvectors that are delimited by elements for which <code>is_sep</code> is <code>true</code>. Empty subvectors are omitted in the vector if <code>drop_empty</code> is <code>true</code> (defaults to <code>false</code>).</p></dd></dl></section></section><section><header><h2 id="search_select"><a href="#search_select" class="anchor"></a>Searching and selecting elements</h2></header><dl><dt class="spec value" id="val-left_findi"><a href="#val-left_findi" class="anchor"></a><code><span class="keyword">val </span>left_findi : ?&#8288;start:int <span>&#45;&gt;</span> (int <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (int<span class="keyword"> * </span><span class="type-var">'a</span>) option</code></dt><dd><p><code>left_findi ~start sat v</code> is <code>Some (i, v.(i))</code> with <code>i</code> the smallest index <code>i</code>, if any, greater or equal to <code>start</code> such that <code>sat i v.(i)</code> is <code>true</code>. <code>start</code> defaults to <code>0</code>. By definition if <code>start &lt; 0</code> the search starts at <code>0</code> and if <code>i &gt; length v - 1</code> <code>None</code> is returned.</p></dd></dl><dl><dt class="spec value" id="val-right_findi"><a href="#val-right_findi" class="anchor"></a><code><span class="keyword">val </span>right_findi : ?&#8288;start:int <span>&#45;&gt;</span> (int <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (int<span class="keyword"> * </span><span class="type-var">'a</span>) option</code></dt><dd><p><code>right_find ~start sat v</code> is <code>Some (i, v.(i))</code> with <code>i</code> the greatest index <code>i</code>, if any, smaller or equal to <code>start</code> such that <code>sat i v.(i)</code> is <code>true</code>. <code>start</code> defaults to <code>length v - 1</code>. By definition if <code>start &lt; 0</code>, <code>None</code> is returned and if <code>start &gt;
    length v - 1</code> the search starts at <code>length v - 1</code>.</p></dd></dl><dl><dt class="spec value" id="val-left_find"><a href="#val-left_find" class="anchor"></a><code><span class="keyword">val </span>left_find : ?&#8288;start:int <span>&#45;&gt;</span> (<span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (int<span class="keyword"> * </span><span class="type-var">'a</span>) option</code></dt><dd><p><code>left_find ~start sat v</code> is <code>left_findi ~start (fun _ e -&gt; sat e) v</code>.</p></dd></dl><dl><dt class="spec value" id="val-right_find"><a href="#val-right_find" class="anchor"></a><code><span class="keyword">val </span>right_find : ?&#8288;start:int <span>&#45;&gt;</span> (<span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (int<span class="keyword"> * </span><span class="type-var">'a</span>) option</code></dt><dd><p><code>right_find ~start sat v</code> is <code>right_findi ~start (fun _ e -&gt; sat e) v</code>.</p></dd></dl><dl><dt class="spec value" id="val-partitioni"><a href="#val-partitioni" class="anchor"></a><code><span class="keyword">val </span>partitioni : (int <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a><span class="keyword"> * </span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>partitioni sat v</code> is a pair of vectors <code>(vt, vf)</code> with <code>vt</code> the elements that satisfy <code>sat</code> and <code>vf</code> the elements that do not. In both vectors the order is preserved. No guarantee is provided on the invocation of <code>f</code> on elements.</p></dd></dl><dl><dt class="spec value" id="val-partition"><a href="#val-partition" class="anchor"></a><code><span class="keyword">val </span>partition : (<span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a><span class="keyword"> * </span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>partition sat v</code> is <code>partitioni (fun _ e -&gt; sat v)</code>.</p></dd></dl><dl><dt class="spec value" id="val-filteri"><a href="#val-filteri" class="anchor"></a><code><span class="keyword">val </span>filteri : (int <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>filter sat v</code> is <code>fst (partitioni sat v)</code>.</p></dd></dl><dl><dt class="spec value" id="val-filter"><a href="#val-filter" class="anchor"></a><code><span class="keyword">val </span>filter : (<span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>filter sat v</code> is <code>fst (partition sat v)</code>.</p></dd></dl></section><section><header><h2 id="edit_dist"><a href="#edit_dist" class="anchor"></a>Edit distance</h2></header><dl><dt class="spec value" id="val-edit_distance"><a href="#val-edit_distance" class="anchor"></a><code><span class="keyword">val </span>edit_distance : eq:(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int</code></dt><dd><p><code>edit_distance ~eq u v</code> is the number of single element edits (insertion, deletion, substitution) that are needed to change <code>u</code> into <code>v</code>.</p></dd></dl><dl><dt class="spec value" id="val-suggest"><a href="#val-suggest" class="anchor"></a><code><span class="keyword">val </span>suggest : ?&#8288;dist:int <span>&#45;&gt;</span> eq:(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <a href="index.html#type-t">t</a></code></dt><dd><p><code>suggest ~dist candidates v</code> are the elements of <code>candidates</code> whose <a href="index.html#val-edit_distance"><code>edit_distance</code></a> is the smallest to <code>s</code> and at most at distance <code>dist</code> of <code>s</code> (defaults to <code>2</code>). If multiple results are returned the order of <code>candidates</code> is preserved.</p></dd></dl></section><section><header><h2 id="conv"><a href="#conv" class="anchor"></a>Conversions</h2><p><b>FIXME.</b> Add conversion from/to bigarrays and <code>buffer_add</code>.</p></header><dl><dt class="spec value" id="val-of_list"><a href="#val-of_list" class="anchor"></a><code><span class="keyword">val </span>of_list : <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>of_list l</code> is <code>l</code> as a persistent vector.</p><dl><dt>raises Invalid_argument</dt><dd><p>if <code>List.length l &gt; Pvec.max_length</code>.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-to_list"><a href="#val-to_list" class="anchor"></a><code><span class="keyword">val </span>to_list : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> list</code></dt><dd><p><code>to_list v</code> is <code>v</code> as a list.</p></dd></dl><dl><dt class="spec value" id="val-of_array"><a href="#val-of_array" class="anchor"></a><code><span class="keyword">val </span>of_array : <span class="type-var">'a</span> array <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>of_array a</code> is <code>a</code> as a persistent vector.</p></dd></dl><dl><dt class="spec value" id="val-to_array"><a href="#val-to_array" class="anchor"></a><code><span class="keyword">val </span>to_array : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> array</code></dt><dd><p><code>to_array v</code> is <code>v</code> as an array.</p><dl><dt>raises Invalid_argument</dt><dd><p>if <code>Pvec.length v &gt; Sys.max_array_length</code></p></dd></dl></dd></dl><dl><dt class="spec value" id="val-of_string"><a href="#val-of_string" class="anchor"></a><code><span class="keyword">val </span>of_string : string <span>&#45;&gt;</span> char <a href="index.html#type-t">t</a></code></dt><dd><p><code>of_string s</code> is <code>s</code> as a persistent vector.</p></dd></dl><dl><dt class="spec value" id="val-to_string"><a href="#val-to_string" class="anchor"></a><code><span class="keyword">val </span>to_string : char <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> string</code></dt><dd><p><code>to_string v</code> is <code>v</code> as a string.</p><dl><dt>raises Invalid_argument</dt><dd><p>if <code>Pvec.length v &gt; Sys.max_array_length</code></p></dd></dl></dd></dl><dl><dt class="spec value" id="val-of_bytes"><a href="#val-of_bytes" class="anchor"></a><code><span class="keyword">val </span>of_bytes : bytes <span>&#45;&gt;</span> char <a href="index.html#type-t">t</a></code></dt><dd><p><code>of_bytes bytes</code> is <code>bytes</code> as a persistent vector.</p></dd></dl><dl><dt class="spec value" id="val-to_bytes"><a href="#val-to_bytes" class="anchor"></a><code><span class="keyword">val </span>to_bytes : char <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bytes</code></dt><dd><p><code>to_string v</code> is <code>v</code> as bytes</p><dl><dt>raises Invalid_argument</dt><dd><p>if <code>Pvec.length v &gt; Sys.max_array_length</code></p></dd></dl></dd></dl></section><section><header><h2 id="print"><a href="#print" class="anchor"></a>Pretty printing</h2></header><dl><dt class="spec value" id="val-pp"><a href="#val-pp" class="anchor"></a><code><span class="keyword">val </span>pp : ?&#8288;sep:(Format.formatter <span>&#45;&gt;</span> unit <span>&#45;&gt;</span> unit) <span>&#45;&gt;</span> (Format.formatter <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> unit) <span>&#45;&gt;</span> Format.formatter <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>pp ~sep pp_v ppf v</code> formats <code>v</code>'s elements. Each element of the vector is formatted in order with <code>pp_v</code>. Elements are separated by <code>sep</code> (defaults to <span class="xref-unresolved" title="unresolved reference to &quot;Format.pp_print_cut&quot;"><code>Format</code>.pp_print_cut</span>). If the vector is empty <code>ppf</code> is left untouched.</p></dd></dl><dl><dt class="spec value" id="val-pp_chars"><a href="#val-pp_chars" class="anchor"></a><code><span class="keyword">val </span>pp_chars : Format.formatter <span>&#45;&gt;</span> char <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>pp_chars</code> is <code>pp ~sep:(fun _ _ -&gt; ()) Format.pp_print_char</code>.</p></dd></dl><dl><dt class="spec value" id="val-dump"><a href="#val-dump" class="anchor"></a><code><span class="keyword">val </span>dump : (Format.formatter <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> unit) <span>&#45;&gt;</span> Format.formatter <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>dump pp_v ppf v</code> prints an unspecified representation of <code>v</code> on <code>ppf</code> using <code>pp_v</code> to print the elements.</p></dd></dl><dl><dt class="spec value" id="val-branching_factor"><a href="#val-branching_factor" class="anchor"></a><code><span class="keyword">val </span>branching_factor : int</code></dt><dd><p>/*</p><p><code>branching_factor</code> is the internal branching factor.</p></dd></dl></section></div></body></html>