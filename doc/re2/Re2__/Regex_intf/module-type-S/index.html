<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>S (re2.Re2__.Regex_intf.S)</title><link rel="stylesheet" href="../../../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../../../index.html">re2</a> &#x00BB; <a href="../../index.html">Re2__</a> &#x00BB; <a href="../index.html">Regex_intf</a> &#x00BB; S</nav><h1>Module type <code>Regex_intf.S</code></h1><nav class="toc"><ul><li><a href="#basic-types">Basic Types</a></li><li><a href="#infix-operators">Infix Operators</a></li><li><a href="#complicated-interface">Complicated Interface</a></li></ul></nav></header><aside><p>These are OCaml bindings for Google's re2 library. Quoting from the re2 homepage:</p><pre>RE2 is a fast, safe, thread-friendly alternative to backtracking regular
expression engines like those used in PCRE, Perl, and Python. It is a C++ library.

Unlike most automata-based engines, RE2 implements almost all the common Perl and
PCRE features and syntactic sugars. It also finds the leftmost-first match, the
same match that Perl would, and can return submatch information. The one
significant exception is that RE2 drops support for backreferences¹ and
generalized zero-width assertions, because they cannot be implemented
efficiently. The syntax page gives full details.</pre><p>Syntax reference: <a href="https://github.com/google/re2/wiki/Syntax">https://github.com/google/re2/wiki/Syntax</a> *</p></aside><aside><p>Although OCaml strings and C++ strings may legally have internal null bytes, this library doesn't handle them correctly by doing conversions via C strings. The failure mode is the search stops early, which isn't bad considering how rare internal null bytes are in practice.</p><p>The strings are considered in UTF-8 encoding by default or in ISO 8859-1 if <code>Options.latin1</code> is used.</p></aside><section><header><h6 id="basic-types"><a href="#basic-types" class="anchor"></a>Basic Types</h6></header><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> t</code></dt></dl><div><div class="spec include"><div class="doc"><details open="open"><summary><span class="def"><code><span class="keyword">include</span> <span class="keyword">sig</span> ... <span class="keyword">end</span></code></span></summary><dl><dt class="spec value" id="val-bin_t"><a href="#val-bin_t" class="anchor"></a><code><span class="keyword">val</span> bin_t : <a href="index.html#type-t">t</a> <a href="../../../../bin_prot/Bin_prot/Type_class/index.html#type-t">Bin_prot.Type_class.t</a></code></dt><dt class="spec value" id="val-bin_read_t"><a href="#val-bin_read_t" class="anchor"></a><code><span class="keyword">val</span> bin_read_t : <a href="index.html#type-t">t</a> <a href="../../../../bin_prot/Bin_prot/Read/index.html#type-reader">Bin_prot.Read.reader</a></code></dt><dt class="spec value" id="val-__bin_read_t__"><a href="#val-__bin_read_t__" class="anchor"></a><code><span class="keyword">val</span> __bin_read_t__ : (int <span>&#45;&gt;</span> <a href="index.html#type-t">t</a>) <a href="../../../../bin_prot/Bin_prot/Read/index.html#type-reader">Bin_prot.Read.reader</a></code></dt><dt class="spec value" id="val-bin_reader_t"><a href="#val-bin_reader_t" class="anchor"></a><code><span class="keyword">val</span> bin_reader_t : <a href="index.html#type-t">t</a> <a href="../../../../bin_prot/Bin_prot/Type_class/index.html#type-reader">Bin_prot.Type_class.reader</a></code></dt><dt class="spec value" id="val-bin_size_t"><a href="#val-bin_size_t" class="anchor"></a><code><span class="keyword">val</span> bin_size_t : <a href="index.html#type-t">t</a> <a href="../../../../bin_prot/Bin_prot/Size/index.html#type-sizer">Bin_prot.Size.sizer</a></code></dt><dt class="spec value" id="val-bin_write_t"><a href="#val-bin_write_t" class="anchor"></a><code><span class="keyword">val</span> bin_write_t : <a href="index.html#type-t">t</a> <a href="../../../../bin_prot/Bin_prot/Write/index.html#type-writer">Bin_prot.Write.writer</a></code></dt><dt class="spec value" id="val-bin_writer_t"><a href="#val-bin_writer_t" class="anchor"></a><code><span class="keyword">val</span> bin_writer_t : <a href="index.html#type-t">t</a> <a href="../../../../bin_prot/Bin_prot/Type_class/index.html#type-writer">Bin_prot.Type_class.writer</a></code></dt><dt class="spec value" id="val-bin_shape_t"><a href="#val-bin_shape_t" class="anchor"></a><code><span class="keyword">val</span> bin_shape_t : <a href="../../../../bin_prot/Bin_prot/Shape/index.html#type-t">Bin_prot.Shape.t</a></code></dt><dt class="spec value" id="val-compare"><a href="#val-compare" class="anchor"></a><code><span class="keyword">val</span> compare : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int</code></dt><dt class="spec value" id="val-t_of_sexp"><a href="#val-t_of_sexp" class="anchor"></a><code><span class="keyword">val</span> t_of_sexp : <a href="../../../../sexplib0/Sexplib0/Sexp/index.html#type-t">Ppx_sexp_conv_lib.Sexp.t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-sexp_of_t"><a href="#val-sexp_of_t" class="anchor"></a><code><span class="keyword">val</span> sexp_of_t : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../../../../sexplib0/Sexplib0/Sexp/index.html#type-t">Ppx_sexp_conv_lib.Sexp.t</a></code></dt><dt class="spec value" id="val-hash_fold_t"><a href="#val-hash_fold_t" class="anchor"></a><code><span class="keyword">val</span> hash_fold_t : <a href="../../../../base/Base/Hash/index.html#type-state">Base.Hash.state</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../../../../base/Base/Hash/index.html#type-state">Base.Hash.state</a></code></dt><dt class="spec value" id="val-hash"><a href="#val-hash" class="anchor"></a><code><span class="keyword">val</span> hash : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../../../../base/Base/Hash/index.html#type-hash_value">Base.Hash.hash_value</a></code></dt></dl></details></div></div></div><dl><dt class="spec type" id="type-regex"><a href="#type-regex" class="anchor"></a><code><span class="keyword">type</span> regex</code><code> = <a href="index.html#type-t">t</a></code></dt><dt class="spec type" id="type-id_t"><a href="#type-id_t" class="anchor"></a><code><span class="keyword">type</span> id_t</code> = <code>[ </code><table class="variant"><tr id="type-id_t.Index" class="anchored"><td class="def constructor"><a href="#type-id_t.Index" class="anchor"></a><code>| </code><code>`Index <span class="keyword">of</span> int</code></td></tr><tr id="type-id_t.Name" class="anchored"><td class="def constructor"><a href="#type-id_t.Name" class="anchor"></a><code>| </code><code>`Name <span class="keyword">of</span> string</code></td></tr></table><code> ]</code></dt><dd><p>Subpatterns are referenced by name if labelled with the <code>/(?P&lt;...&gt;...)/</code> syntax, or else by counting open-parens, with subpattern zero referring to the whole regex.</p></dd></dl><dl><dt class="spec value" id="val-index_of_id_exn"><a href="#val-index_of_id_exn" class="anchor"></a><code><span class="keyword">val</span> index_of_id_exn : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-id_t">id_t</a> <span>&#45;&gt;</span> int</code></dt><dd><p><code>index_of_id t id</code> resolves subpattern names and indices into indices. *</p></dd></dl><aside><p>The <code>sub</code> keyword argument means, omit location information for subpatterns with index greater than <code>sub</code>.</p><p>Subpatterns are indexed by the number of opening parentheses preceding them:</p><p><code>~sub:(`Index 0)</code> : only the whole match <code>~sub:(`Index 1)</code> : the whole match and the first submatch, etc.</p><p>If you only care whether the pattern does match, you can request no location information at all by passing <code>~sub:(`Index -1)</code>.</p><p>With one exception, I quote from re2.h:443,</p><pre>Don't ask for more match information than you will use:
runs much faster with nmatch == 1 than nmatch &gt; 1, and
runs even faster if nmatch == 0.</pre><p>For <code>sub &gt; 1</code>, re2 executes in three steps: 1. run a DFA over the entire input to get the end of the whole match 2. run a DFA backward from the end position to get the start position 3. run an NFA from the match start to match end to extract submatches <code>sub == 1</code> lets it stop after (2) and <code>sub == 0</code> lets it stop after (1). (See re2.cc:692 or so.)</p><p>The one exception is for the functions <code>get_matches</code>, <code>replace</code>, and <code>Iterator.next</code>: Since they must iterate correctly through the whole string, they need at least the whole match (subpattern 0). These functions will silently rewrite <code>~sub</code> to be non-negative.</p></aside><div class="spec module" id="module-Options"><a href="#module-Options" class="anchor"></a><code><span class="keyword">module</span> <a href="Options/index.html">Options</a> : <a href="../../../Re2/Options/index.html#module-type-S">Re2.Options.S</a></code></div><dl><dt class="spec value" id="val-create"><a href="#val-create" class="anchor"></a><code><span class="keyword">val</span> create : ?&#8288;options:<a href="Options/index.html#type-t">Options.t</a> list <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <a href="../../../../core_kernel/Core_kernel/Or_error/index.html#type-t">Core_kernel.Or_error.t</a></code></dt><dt class="spec value" id="val-create_exn"><a href="#val-create_exn" class="anchor"></a><code><span class="keyword">val</span> create_exn : ?&#8288;options:<a href="Options/index.html#type-t">Options.t</a> list <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt></dl><div><div class="spec include"><div class="doc"><details open="open"><summary><span class="def"><code><span class="keyword">include</span> <a href="../../../../core_kernel/Core_kernel/index.html#module-type-Stringable">Core_kernel.Stringable</a> <span class="keyword">with</span> <span class="keyword">type</span> <a href="../../../../core_kernel/Core_kernel/module-type-Stringable/index.html#type-t">t</a> := <a href="index.html#type-t">t</a></code></span></summary><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> t</code></dt></dl><dl><dt class="spec value" id="val-of_string"><a href="#val-of_string" class="anchor"></a><code><span class="keyword">val</span> of_string : string <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-to_string"><a href="#val-to_string" class="anchor"></a><code><span class="keyword">val</span> to_string : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> string</code></dt></dl></details></div></div></div><dl><dt class="spec value" id="val-num_submatches"><a href="#val-num_submatches" class="anchor"></a><code><span class="keyword">val</span> num_submatches : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int</code></dt><dd><p><code>num_submatches t</code> returns 1 + the number of open-parens in the pattern.</p><p>N.B. <code>num_submatches t == 1 + RE2::NumberOfCapturingGroups()</code> because <code>RE2::NumberOfCapturingGroups()</code> ignores the whole match (&quot;subpattern zero&quot;).</p></dd></dl><dl><dt class="spec value" id="val-pattern"><a href="#val-pattern" class="anchor"></a><code><span class="keyword">val</span> pattern : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> string</code></dt><dd><p><code>pattern t</code> returns the pattern from which the regex was constructed.</p></dd></dl><dl><dt class="spec value" id="val-find_all"><a href="#val-find_all" class="anchor"></a><code><span class="keyword">val</span> find_all : ?&#8288;sub:<a href="index.html#type-id_t">id_t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> string list <a href="../../../../core_kernel/Core_kernel/Or_error/index.html#type-t">Core_kernel.Or_error.t</a></code></dt><dd><p><code>find_all t input</code> a convenience function that returns all non-overlapping matches of <code>t</code> against <code>input</code>, in left-to-right order.</p><p>If <code>sub</code> is given, and the requested subpattern did not capture, then no match is returned at that position even if other parts of the regex did match.</p></dd></dl><dl><dt class="spec value" id="val-find_all_exn"><a href="#val-find_all_exn" class="anchor"></a><code><span class="keyword">val</span> find_all_exn : ?&#8288;sub:<a href="index.html#type-id_t">id_t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> string list</code></dt><dt class="spec value" id="val-find_first"><a href="#val-find_first" class="anchor"></a><code><span class="keyword">val</span> find_first : ?&#8288;sub:<a href="index.html#type-id_t">id_t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> string <a href="../../../../core_kernel/Core_kernel/Or_error/index.html#type-t">Core_kernel.Or_error.t</a></code></dt><dd><p><code>find_first ?sub pattern input</code> finds the first match of <code>pattern</code> in <code>input</code>, and returns the subpattern specified by <code>sub</code>, or an error if the subpattern didn't capture.</p></dd></dl><dl><dt class="spec value" id="val-find_first_exn"><a href="#val-find_first_exn" class="anchor"></a><code><span class="keyword">val</span> find_first_exn : ?&#8288;sub:<a href="index.html#type-id_t">id_t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> string</code></dt><dt class="spec value" id="val-find_submatches"><a href="#val-find_submatches" class="anchor"></a><code><span class="keyword">val</span> find_submatches : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> string option array <a href="../../../../core_kernel/Core_kernel/Or_error/index.html#type-t">Core_kernel.Or_error.t</a></code></dt><dd><p><code>find_submatches t input</code> finds the first match and returns all submatches. Element 0 is the whole match and element 1 is the first parenthesized submatch, etc.</p></dd></dl><dl><dt class="spec value" id="val-find_submatches_exn"><a href="#val-find_submatches_exn" class="anchor"></a><code><span class="keyword">val</span> find_submatches_exn : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> string option array</code></dt><dt class="spec value" id="val-matches"><a href="#val-matches" class="anchor"></a><code><span class="keyword">val</span> matches : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> bool</code></dt><dd><p><code>matches pattern input</code> </p><dl><dt>returns</dt><dd><p>true iff <code>pattern</code> matches <code>input</code></p></dd></dl></dd></dl><dl><dt class="spec value" id="val-split"><a href="#val-split" class="anchor"></a><code><span class="keyword">val</span> split : ?&#8288;max:int <span>&#45;&gt;</span> ?&#8288;include_matches:bool <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> string list</code></dt><dd><p><code>split pattern input</code> </p><dl><dt>returns</dt><dd><p><code>input</code> broken into pieces where <code>pattern</code> matches. Subpatterns are ignored.</p></dd></dl><dl><dt>parameter max</dt><dd><p>(default: unlimited) split only at the leftmost <code>max</code> matches</p></dd></dl><dl><dt>parameter include_matches</dt><dd><p>(default: false) include the matched substrings in the returned list (e.g., the regex <code>/[,()]/</code> on <code>&quot;foo(bar,baz)&quot;</code> gives <code>[&quot;foo&quot;; &quot;(&quot;;
      &quot;bar&quot;; &quot;,&quot;; &quot;baz&quot;; &quot;)&quot;]</code> instead of <code>[&quot;foo&quot;; &quot;bar&quot;; &quot;baz&quot;]</code>)</p><p>If <code>t</code> never matches, the returned list has <code>input</code> as its one element.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-rewrite"><a href="#val-rewrite" class="anchor"></a><code><span class="keyword">val</span> rewrite : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> template:string <span>&#45;&gt;</span> string <span>&#45;&gt;</span> string <a href="../../../../core_kernel/Core_kernel/Or_error/index.html#type-t">Core_kernel.Or_error.t</a></code></dt><dd><p><code>rewrite pattern ~template input</code> is a convenience function for <code>replace</code>: Instead of requiring an arbitrary transformation as a function, it accepts a template string with zero or more substrings of the form <code>&quot;\\n&quot;</code>, each of which will be replaced by submatch <code>n</code>. For every match of <code>pattern</code> against <code>input</code>, the template will be specialized and then substituted for the matched substring.</p></dd></dl><dl><dt class="spec value" id="val-rewrite_exn"><a href="#val-rewrite_exn" class="anchor"></a><code><span class="keyword">val</span> rewrite_exn : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> template:string <span>&#45;&gt;</span> string <span>&#45;&gt;</span> string</code></dt><dt class="spec value" id="val-valid_rewrite_template"><a href="#val-valid_rewrite_template" class="anchor"></a><code><span class="keyword">val</span> valid_rewrite_template : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> template:string <span>&#45;&gt;</span> bool</code></dt><dd><p><code>valid_rewrite_template pattern ~template</code> returns <code>true</code> iff <code>template</code> is a valid rewrite template for <code>pattern</code></p></dd></dl><dl><dt class="spec value" id="val-escape"><a href="#val-escape" class="anchor"></a><code><span class="keyword">val</span> escape : string <span>&#45;&gt;</span> string</code></dt><dd><p><code>escape nonregex</code> returns a copy of <code>nonregex</code> with everything escaped (i.e., if the return value were t to regex, it would match exactly the original input)</p></dd></dl></section><section><header><h6 id="infix-operators"><a href="#infix-operators" class="anchor"></a>Infix Operators</h6></header><div class="spec module" id="module-Infix"><a href="#module-Infix" class="anchor"></a><code><span class="keyword">module</span> <a href="Infix/index.html">Infix</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div></section><section><header><h6 id="complicated-interface"><a href="#complicated-interface" class="anchor"></a>Complicated Interface</h6></header><dl><dt class="spec type" id="type-without_trailing_none"><a href="#type-without_trailing_none" class="anchor"></a><code><span class="keyword">type</span> 'a without_trailing_none</code></dt></dl><div><div class="spec include"><div class="doc"><details open="open"><summary><span class="def"><code><span class="keyword">include</span> <span class="keyword">sig</span> ... <span class="keyword">end</span></code></span></summary><dl><dt class="spec value" id="val-sexp_of_without_trailing_none"><a href="#val-sexp_of_without_trailing_none" class="anchor"></a><code><span class="keyword">val</span> sexp_of_without_trailing_none : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <a href="../../../../sexplib0/Sexplib0/Sexp/index.html#type-t">Ppx_sexp_conv_lib.Sexp.t</a>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-without_trailing_none">without_trailing_none</a> <span>&#45;&gt;</span> <a href="../../../../sexplib0/Sexplib0/Sexp/index.html#type-t">Ppx_sexp_conv_lib.Sexp.t</a></code></dt></dl></details></div></div></div><dl><dt class="spec value" id="val-without_trailing_none"><a href="#val-without_trailing_none" class="anchor"></a><code><span class="keyword">val</span> without_trailing_none : <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-without_trailing_none">without_trailing_none</a></code></dt><dd><p>This type marks call sites affected by a bugfix that eliminated a trailing None. When you add this wrapper, check that your call site does not still work around the bug by dropping the last element.</p></dd></dl><div class="spec module" id="module-Match"><a href="#module-Match" class="anchor"></a><code><span class="keyword">module</span> <a href="Match/index.html">Match</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><dl><dt class="spec value" id="val-get_matches"><a href="#val-get_matches" class="anchor"></a><code><span class="keyword">val</span> get_matches : ?&#8288;sub:<a href="index.html#type-id_t">id_t</a> <span>&#45;&gt;</span> ?&#8288;max:int <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <a href="Match/index.html#type-t">Match.t</a> list <a href="../../../../core_kernel/Core_kernel/Or_error/index.html#type-t">Core_kernel.Or_error.t</a></code></dt><dd><p><code>get_matches pattern input</code> returns all non-overlapping matches of <code>pattern</code> against <code>input</code></p><dl><dt>parameter max</dt><dd><p>(default: unlimited) return only the leftmost <code>max</code> matches</p></dd></dl><dl><dt>parameter sub</dt><dd><p>(default: all) returned Match.t's will contain only the first <code>sub</code> matches.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-get_matches_exn"><a href="#val-get_matches_exn" class="anchor"></a><code><span class="keyword">val</span> get_matches_exn : ?&#8288;sub:<a href="index.html#type-id_t">id_t</a> <span>&#45;&gt;</span> ?&#8288;max:int <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <a href="Match/index.html#type-t">Match.t</a> list</code></dt><dt class="spec value" id="val-to_sequence_exn"><a href="#val-to_sequence_exn" class="anchor"></a><code><span class="keyword">val</span> to_sequence_exn : ?&#8288;sub:<a href="index.html#type-id_t">id_t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <a href="Match/index.html#type-t">Match.t</a> <a href="../../../../core_kernel/Core_kernel/Sequence/index.html#type-t">Core_kernel.Sequence.t</a></code></dt><dt class="spec value" id="val-first_match"><a href="#val-first_match" class="anchor"></a><code><span class="keyword">val</span> first_match : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <a href="Match/index.html#type-t">Match.t</a> <a href="../../../../core_kernel/Core_kernel/Or_error/index.html#type-t">Core_kernel.Or_error.t</a></code></dt><dd><p><code>first_match pattern input</code> </p><dl><dt>returns</dt><dd><p>the first match iff <code>pattern</code> matches <code>input</code></p></dd></dl></dd></dl><dl><dt class="spec value" id="val-first_match_exn"><a href="#val-first_match_exn" class="anchor"></a><code><span class="keyword">val</span> first_match_exn : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <a href="Match/index.html#type-t">Match.t</a></code></dt><dt class="spec value" id="val-replace"><a href="#val-replace" class="anchor"></a><code><span class="keyword">val</span> replace : ?&#8288;sub:<a href="index.html#type-id_t">id_t</a> <span>&#45;&gt;</span> ?&#8288;only:int <span>&#45;&gt;</span> f:(<a href="Match/index.html#type-t">Match.t</a> <span>&#45;&gt;</span> string) <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> string <a href="../../../../core_kernel/Core_kernel/Or_error/index.html#type-t">Core_kernel.Or_error.t</a></code></dt><dd><p><code>replace ?sub ?max ~f pattern input</code> </p><dl><dt>returns</dt><dd><p>an edited copy of <code>input</code> with every substring matched by <code>pattern</code> transformed by <code>f</code>.</p></dd></dl><dl><dt>parameter only</dt><dd><p>(default: all) replace only the nth match</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-replace_exn"><a href="#val-replace_exn" class="anchor"></a><code><span class="keyword">val</span> replace_exn : ?&#8288;sub:<a href="index.html#type-id_t">id_t</a> <span>&#45;&gt;</span> ?&#8288;only:int <span>&#45;&gt;</span> f:(<a href="Match/index.html#type-t">Match.t</a> <span>&#45;&gt;</span> string) <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> string</code></dt></dl><div class="spec module" id="module-Exceptions"><a href="#module-Exceptions" class="anchor"></a><code><span class="keyword">module</span> <a href="Exceptions/index.html">Exceptions</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><div class="spec module" id="module-Multiple"><a href="#module-Multiple" class="anchor"></a><code><span class="keyword">module</span> <a href="Multiple/index.html">Multiple</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div></section></div></body></html>