<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>ShardByShard (reed-solomon-erasure.Reed_solomon_erasure.ShardByShard)</title><link rel="stylesheet" href="../../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../../index.html">reed-solomon-erasure</a> &#x00BB; <a href="../index.html">Reed_solomon_erasure</a> &#x00BB; ShardByShard</nav><h1>Module <code>Reed_solomon_erasure.ShardByShard</code></h1><nav class="toc"><ul><li><a href="#naming-conventions">Naming conventions</a></li><li><a href="#use-cases">Use cases</a></li><li><a href="#example">Example</a></li><li><a href="#ownership-of-shards">Ownership of shards</a></li></ul></nav></header><aside><p>Bookkeeper for shard by shard encoding.</p><p>This is useful for avoiding incorrect use of <code>encode_single_typ</code>, and <code>encode_single_sep_typ</code> functions.</p></aside><section><header><h2 id="naming-conventions"><a href="#naming-conventions" class="anchor"></a>Naming conventions</h2><p><code>typ</code> represents <code>bytes</code>, <code>str</code>, and <code>bigstr</code>, e.g. <code>encode_typ</code> represents <code>encode_bytes</code>, <code>encode_str</code>, and <code>encode_bigstr</code>.</p></header></section><section><header><h2 id="use-cases"><a href="#use-cases" class="anchor"></a>Use cases</h2><p>Shard by shard encoding is useful for streamed data encoding where you do not have all the needed data shards immediately, but you want to spread out the encoding workload rather than doing the encoding after everything is ready.</p><p>A concrete example would be network packets encoding, where encoding packet by packet as you receive them may be more efficient than waiting for N packets then encode them all at once.</p></header></section><section><header><h2 id="example"><a href="#example" class="anchor"></a>Example</h2><pre><code class="ml">open Reed_solomon_erasure

let () =
  let r = ReedSolomon.make 3 2 in

  let sbs = ShardByShard.make r in

  let shards = [|Bytes.of_string &quot;\000\001\002\003\004&quot;;
                 Bytes.of_string &quot;\005\006\007\008\009&quot;;
                 (* say we don't have the 3rd data shard yet
                    and we want to fill it in later *)
                 Bytes.of_string &quot;\000\000\000\000\000&quot;;
                 Bytes.of_string &quot;\000\000\000\000\000&quot;;
                 Bytes.of_string &quot;\000\000\000\000\000&quot;|] in

  (* encode 1st and 2nd data shard *)
  ShardByShard.encode_bytes sbs shards;
  ShardByShard.encode_bytes sbs shards;

  (* fill in 3rd data shard *)
  Bytes.set shards.(2) 0 '\010';
  Bytes.set shards.(2) 1 '\011';
  Bytes.set shards.(2) 2 '\012';
  Bytes.set shards.(2) 3 '\013';
  Bytes.set shards.(2) 4 '\014';

  (* now do the encoding*)
  ShardByShard.encode_bytes sbs shards;

  (* above is equivalent to doing ReedSolomon.encode_bytes shards *)

  assert (ReedSolomon.verify_bytes r shards)</code></pre></header></section><section><header><h2 id="ownership-of-shards"><a href="#ownership-of-shards" class="anchor"></a>Ownership of shards</h2><p>The shard by shard codec is just a wrapper around the core codec type <code>reed_solomon</code>, so all potential shard ownership issues in functions provided by <a href="../ReedSolomon/index.html"><code>ReedSolomon</code></a> are carried over.</p><p>See <a href="../ReedSolomon/index.html"><code>ReedSolomon</code></a>, <b>Ownership of shards</b> section for details.</p></header><dl><dt class="spec value" id="val-make"><a href="#val-make" class="anchor"></a><code><span class="keyword">val</span> make : <a href="../index.html#type-reed_solomon">reed_solomon</a> <span>&#45;&gt;</span> <a href="../index.html#type-shard_by_shard">shard_by_shard</a></code></dt><dd><p><code>make r</code></p><p>Makes a new instance of the bookkeeping type. Note that the codec is <b>NOT</b> thread-safe.</p><p>The original Reed-Solomon codec is still usable - <code>shard_by_shard</code> codec does not require exclusive ownership of the Reed-Solomon codec.</p></dd></dl><dl><dt class="spec value" id="val-parity_ready"><a href="#val-parity_ready" class="anchor"></a><code><span class="keyword">val</span> parity_ready : <a href="../index.html#type-shard_by_shard">shard_by_shard</a> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>parity_ready sbs</code></p></dd></dl><dl><dt class="spec value" id="val-reset"><a href="#val-reset" class="anchor"></a><code><span class="keyword">val</span> reset : <a href="../index.html#type-shard_by_shard">shard_by_shard</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>reset sbs</code></p><p>Resets the bookkeeping data.</p><p>You should call this when you have added and encoded all data shards, and have finished using the parity shards.</p><p>Raises <a href="../RS_SBS_Error/Exn/index.html#exception-LeftoverShards"><code>RS_SBS_Error.Exn.LeftoverShards</code></a></p></dd></dl><dl><dt class="spec value" id="val-reset_no_exn"><a href="#val-reset_no_exn" class="anchor"></a><code><span class="keyword">val</span> reset_no_exn : <a href="../index.html#type-shard_by_shard">shard_by_shard</a> <span>&#45;&gt;</span> (unit, <a href="../RS_SBS_Error/index.html#type-t">RS_SBS_Error.t</a>) <a href="../../../ocaml/Stdlib/index.html#type-result">Stdlib.result</a></code></dt><dd><p><code>reset sbs</code></p><p>Error returning variant of <a href="index.html#val-reset"><code>reset</code></a>.</p></dd></dl><dl><dt class="spec value" id="val-reset_force"><a href="#val-reset_force" class="anchor"></a><code><span class="keyword">val</span> reset_force : <a href="../index.html#type-shard_by_shard">shard_by_shard</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>reset_force sbs</code></p><p>Resets the bookkeeping data without checking.</p></dd></dl><dl><dt class="spec value" id="val-cur_input_index"><a href="#val-cur_input_index" class="anchor"></a><code><span class="keyword">val</span> cur_input_index : <a href="../index.html#type-shard_by_shard">shard_by_shard</a> <span>&#45;&gt;</span> int</code></dt><dd><p><code>cur_input_index sbs</code></p><p>Returns the current input shard index.</p></dd></dl><dl><dt class="spec value" id="val-encode_bytes"><a href="#val-encode_bytes" class="anchor"></a><code><span class="keyword">val</span> encode_bytes : <a href="../index.html#type-shard_by_shard">shard_by_shard</a> <span>&#45;&gt;</span> bytes array <span>&#45;&gt;</span> unit</code></dt><dd><p><code>encode_bytes sbs shards</code></p><p>See <a href="index.html#val-encode_bigstr"><code>encode_bigstr</code></a>.</p></dd></dl><dl><dt class="spec value" id="val-encode_sep_bytes"><a href="#val-encode_sep_bytes" class="anchor"></a><code><span class="keyword">val</span> encode_sep_bytes : <a href="../index.html#type-shard_by_shard">shard_by_shard</a> <span>&#45;&gt;</span> bytes array <span>&#45;&gt;</span> bytes array <span>&#45;&gt;</span> unit</code></dt><dd><p><code>encode_sep_bytes sbs data parity</code></p><p>See <a href="index.html#val-encode_sep_bigstr"><code>encode_sep_bigstr</code></a>.</p></dd></dl><dl><dt class="spec value" id="val-encode_str"><a href="#val-encode_str" class="anchor"></a><code><span class="keyword">val</span> encode_str : <a href="../index.html#type-shard_by_shard">shard_by_shard</a> <span>&#45;&gt;</span> string array <span>&#45;&gt;</span> unit</code></dt><dd><p><code>encode_str sbs shards</code></p><p>See <a href="index.html#val-encode_bigstr"><code>encode_bigstr</code></a>.</p></dd></dl><dl><dt class="spec value" id="val-encode_sep_str"><a href="#val-encode_sep_str" class="anchor"></a><code><span class="keyword">val</span> encode_sep_str : <a href="../index.html#type-shard_by_shard">shard_by_shard</a> <span>&#45;&gt;</span> string array <span>&#45;&gt;</span> string array <span>&#45;&gt;</span> unit</code></dt><dd><p><code>encode_sep_str sbs data parity</code></p><p>See <a href="index.html#val-encode_sep_bigstr"><code>encode_sep_bigstr</code></a>.</p></dd></dl><dl><dt class="spec value" id="val-encode_bigstr"><a href="#val-encode_bigstr" class="anchor"></a><code><span class="keyword">val</span> encode_bigstr : <a href="../index.html#type-shard_by_shard">shard_by_shard</a> <span>&#45;&gt;</span> <a href="../index.html#type-bigstring">bigstring</a> array <span>&#45;&gt;</span> unit</code></dt><dd><p><code>encode_bigstr sbs shards</code></p><p>Constructs the parity shards partially using the current input data shard.</p><p>Raises <a href="../RS_SBS_Error/Exn/index.html#exception-TooManyCalls"><code>RS_SBS_Error.Exn.TooManyCalls</code></a> when all input shards have already been filled in via any of the <code>encode</code> functions.</p></dd></dl><dl><dt class="spec value" id="val-encode_sep_bigstr"><a href="#val-encode_sep_bigstr" class="anchor"></a><code><span class="keyword">val</span> encode_sep_bigstr : <a href="../index.html#type-shard_by_shard">shard_by_shard</a> <span>&#45;&gt;</span> <a href="../index.html#type-bigstring">bigstring</a> array <span>&#45;&gt;</span> <a href="../index.html#type-bigstring">bigstring</a> array <span>&#45;&gt;</span> unit</code></dt><dd><p><code>encode_sep_bigstr sbs data parity</code></p><p>Constructs the parity shards partially using the current input data shard.</p><p>Raises <a href="../RS_SBS_Error/Exn/index.html#exception-TooManyCalls"><code>RS_SBS_Error.Exn.TooManyCalls</code></a> when all input shards have already been filled in via any of the encode functions.</p></dd></dl><dl><dt class="spec value" id="val-encode_bytes_no_exn"><a href="#val-encode_bytes_no_exn" class="anchor"></a><code><span class="keyword">val</span> encode_bytes_no_exn : <a href="../index.html#type-shard_by_shard">shard_by_shard</a> <span>&#45;&gt;</span> bytes array <span>&#45;&gt;</span> (unit, <a href="../RS_SBS_Error/index.html#type-t">RS_SBS_Error.t</a>) <a href="../../../ocaml/Stdlib/index.html#type-result">Stdlib.result</a></code></dt><dd><p><code>encode_bytes_no_exn sbs shards</code></p><p>Error returning variant of <a href="index.html#val-encode_bytes"><code>encode_bytes</code></a>.</p></dd></dl><dl><dt class="spec value" id="val-encode_sep_bytes_no_exn"><a href="#val-encode_sep_bytes_no_exn" class="anchor"></a><code><span class="keyword">val</span> encode_sep_bytes_no_exn : <a href="../index.html#type-shard_by_shard">shard_by_shard</a> <span>&#45;&gt;</span> bytes array <span>&#45;&gt;</span> bytes array <span>&#45;&gt;</span> (unit, <a href="../RS_SBS_Error/index.html#type-t">RS_SBS_Error.t</a>) <a href="../../../ocaml/Stdlib/index.html#type-result">Stdlib.result</a></code></dt><dd><p><code>encode_sep_bytes_no_exn sbs data parity</code></p><p>Error returning variant of <a href="index.html#val-encode_sep_bytes"><code>encode_sep_bytes</code></a>.</p></dd></dl><dl><dt class="spec value" id="val-encode_str_no_exn"><a href="#val-encode_str_no_exn" class="anchor"></a><code><span class="keyword">val</span> encode_str_no_exn : <a href="../index.html#type-shard_by_shard">shard_by_shard</a> <span>&#45;&gt;</span> string array <span>&#45;&gt;</span> (unit, <a href="../RS_SBS_Error/index.html#type-t">RS_SBS_Error.t</a>) <a href="../../../ocaml/Stdlib/index.html#type-result">Stdlib.result</a></code></dt><dd><p><code>encode_str_no_exn sbs shards</code></p><p>Error returning variant of <a href="index.html#val-encode_str"><code>encode_str</code></a>.</p></dd></dl><dl><dt class="spec value" id="val-encode_sep_str_no_exn"><a href="#val-encode_sep_str_no_exn" class="anchor"></a><code><span class="keyword">val</span> encode_sep_str_no_exn : <a href="../index.html#type-shard_by_shard">shard_by_shard</a> <span>&#45;&gt;</span> string array <span>&#45;&gt;</span> string array <span>&#45;&gt;</span> (unit, <a href="../RS_SBS_Error/index.html#type-t">RS_SBS_Error.t</a>) <a href="../../../ocaml/Stdlib/index.html#type-result">Stdlib.result</a></code></dt><dd><p><code>encode_sep_str_no_exn sbs data parity</code></p><p>Error returning variant of <a href="index.html#val-encode_sep_str"><code>encode_sep_str</code></a>.</p></dd></dl><dl><dt class="spec value" id="val-encode_bigstr_no_exn"><a href="#val-encode_bigstr_no_exn" class="anchor"></a><code><span class="keyword">val</span> encode_bigstr_no_exn : <a href="../index.html#type-shard_by_shard">shard_by_shard</a> <span>&#45;&gt;</span> <a href="../index.html#type-bigstring">bigstring</a> array <span>&#45;&gt;</span> (unit, <a href="../RS_SBS_Error/index.html#type-t">RS_SBS_Error.t</a>) <a href="../../../ocaml/Stdlib/index.html#type-result">Stdlib.result</a></code></dt><dd><p><code>encode_bigstr_no_exn sbs shards</code></p><p>Error returning variant of <a href="index.html#val-encode_bigstr"><code>encode_bigstr</code></a>.</p></dd></dl><dl><dt class="spec value" id="val-encode_sep_bigstr_no_exn"><a href="#val-encode_sep_bigstr_no_exn" class="anchor"></a><code><span class="keyword">val</span> encode_sep_bigstr_no_exn : <a href="../index.html#type-shard_by_shard">shard_by_shard</a> <span>&#45;&gt;</span> <a href="../index.html#type-bigstring">bigstring</a> array <span>&#45;&gt;</span> <a href="../index.html#type-bigstring">bigstring</a> array <span>&#45;&gt;</span> (unit, <a href="../RS_SBS_Error/index.html#type-t">RS_SBS_Error.t</a>) <a href="../../../ocaml/Stdlib/index.html#type-result">Stdlib.result</a></code></dt><dd><p><code>encode_sep_bigstr_no_exn sbs data parity</code></p><p>Error returning variant of <a href="index.html#val-encode_sep_bigstr"><code>encode_sep_bigstr</code></a>.</p></dd></dl></section></div></body></html>