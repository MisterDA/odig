<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Root1D (root1d.Root1D)</title><link rel="stylesheet" href="../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../index.html">root1d</a> &#x00BB; Root1D</nav><h1>Module <code>Root1D</code></h1><p>1D Root finding algorithms.</p><dl><dt>version</dt><dd>0.5.1</dd></dl></header><dl><dt class="spec value" id="val-brent"><a href="#val-brent" class="anchor"></a><code><span class="keyword">val</span> brent : ?&#8288;tol:float <span>&#45;&gt;</span> (float <span>&#45;&gt;</span> float) <span>&#45;&gt;</span> float <span>&#45;&gt;</span> float <span>&#45;&gt;</span> float</code></dt><dd><p><code>brent f a b</code> returns an approximation <code>x</code> of a root of <code>f</code> in the interval <code>[a,b]</code> with absolute accuracy <code>6. *. epsilon_float
    *. abs_float(x) +. tol</code>.</p><dl><dt>raises Invalid_argument</dt><dd><p>if <code>f(a) *. f(b) &gt; 0.</code>.</p></dd></dl><dl><dt>parameter tol</dt><dd><p>desired length of the interval of uncertainty of the final result (must be <code>&gt;= 0</code>). Default: <code>sqrt epsilon_float</code>.</p><p>Ref.: Brent, R. (1973) Algorithms for Minimization without Derivatives. Englewood Cliffs, NJ: Prentice-Hall.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-bisection"><a href="#val-bisection" class="anchor"></a><code><span class="keyword">val</span> bisection : ?&#8288;eps:float <span>&#45;&gt;</span> (float <span>&#45;&gt;</span> float) <span>&#45;&gt;</span> float <span>&#45;&gt;</span> float <span>&#45;&gt;</span> float</code></dt><dd><p><code>bisection f a b</code> find an approximation of a root in the interval <code>[a,b]</code> using the bisection algorithm.</p><dl><dt>raises Invalid_argument</dt><dd><p>if <code>f(a) *. f(b) &gt; 0.</code> or <code>eps &lt;= 0.</code></p></dd></dl><dl><dt>parameter eps</dt><dd><p>is the desired relative error on the solution. More precisely, it terminates when the interval [a,b] verifies |a-b| ≤ eps max(|a|, |b|). Default: <code>sqrt epsilon_float</code>.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-illinois"><a href="#val-illinois" class="anchor"></a><code><span class="keyword">val</span> illinois : ?&#8288;eps:float <span>&#45;&gt;</span> (float <span>&#45;&gt;</span> float) <span>&#45;&gt;</span> float <span>&#45;&gt;</span> float <span>&#45;&gt;</span> float</code></dt><dd><p><code>illinois f a b</code> find an approximation of a root in the interval <code>[a,b]</code> using the Illinois algorithm (which is the Regula Falsi method with a small twist). Order of convergence: ³√3 ≈ 1.442.</p><dl><dt>raises Invalid_argument</dt><dd><p>if <code>f(a) *. f(b) &gt; 0.</code> or <code>eps &lt;= 0.</code></p></dd></dl><dl><dt>parameter eps</dt><dd><p>is the desired relative error on the solution. More precisely, it terminates when the interval [a,b] verifies |a-b| ≤ eps max(|a|, |b|). Default: <code>sqrt epsilon_float</code>.</p><p>Ref.: <a href="http://link.springer.com/article/10.1007/BF01934364">M. Dowell, P. Jarrat, A modified Regula Falsi method for computing the root of anequation, BIT 11 (1971), 168–174</a>.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-newton"><a href="#val-newton" class="anchor"></a><code><span class="keyword">val</span> newton : ?&#8288;good_enough:(float <span>&#45;&gt;</span> float <span>&#45;&gt;</span> float <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> (float <span>&#45;&gt;</span> float * float) <span>&#45;&gt;</span> float <span>&#45;&gt;</span> float</code></dt><dd><p><code>newton f_f' x0</code> returns an approximate root of <code>f</code> close to the initial guess <code>x0</code> using Newton's method. <code>f_f'</code> is a function such that <code>f_f' x</code> returns the couple <code>(f x, f' x)</code> where <code>f' x</code> is the derivative of <code>f</code> at <code>x</code>.</p><dl><dt>raises Failure</dt><dd><p>if the derivative vanishes during the computations.</p></dd></dl><dl><dt>parameter good_enough</dt><dd><p>takes as arguments the current approximation <code>x</code>, the previous approximation <code>xprev</code>, and <code>f(x)</code> and returns whether <code>x</code> is a good enough approximation. Default: <code>abs_float(f x) &lt; sqrt epsilon_float</code>.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-brent2"><a href="#val-brent2" class="anchor"></a><code><span class="keyword">val</span> brent2 : ?&#8288;tol:float <span>&#45;&gt;</span> (float <span>&#45;&gt;</span> float * int) <span>&#45;&gt;</span> float <span>&#45;&gt;</span> float <span>&#45;&gt;</span> float</code></dt><dd><p><code>brent2 f a b</code> finds a zero of the function <code>f</code> in the same way <code>brent f a b</code> does except that <code>f x</code> returns the couple <code>(y, z)</code> for the number <code>y * 2**z</code>. Thus underflow and overflow can be avoided for a function with large range.</p><p>Ref.: Brent, R. (1973) Algorithms for Minimization without Derivatives. Englewood Cliffs, NJ: Prentice-Hall.</p></dd></dl></div></body></html>