<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Worker (rpc_parallel.Rpc_parallel__Parallel.Worker)</title><link rel="stylesheet" href="../../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../../index.html">rpc_parallel</a> &#x00BB; <a href="../index.html">Rpc_parallel__Parallel</a> &#x00BB; Worker</nav><h1>Module type <code>Rpc_parallel__Parallel.Worker</code></h1></header><dl><dt class="spec type" id="type-_function"><a href="#type-_function" class="anchor"></a><code><span class="keyword">type</span> ('worker, 'query, 'response) _function</code></dt><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> t</code></dt><dd><p>A <code>Worker.t</code> type is defined <code>with bin_io</code> so it is possible to create functions that take a worker as an argument.</p></dd></dl><div><div class="spec include"><div class="doc"><details open="open"><summary><span class="def"><code><span class="keyword">include</span> <span class="keyword">sig</span> ... <span class="keyword">end</span></code></span></summary><dl><dt class="spec value" id="val-bin_t"><a href="#val-bin_t" class="anchor"></a><code><span class="keyword">val</span> bin_t : <a href="index.html#type-t">t</a> <a href="../../../bin_prot/Bin_prot/Type_class/index.html#type-t">Bin_prot.Type_class.t</a></code></dt><dt class="spec value" id="val-bin_read_t"><a href="#val-bin_read_t" class="anchor"></a><code><span class="keyword">val</span> bin_read_t : <a href="index.html#type-t">t</a> <a href="../../../bin_prot/Bin_prot/Read/index.html#type-reader">Bin_prot.Read.reader</a></code></dt><dt class="spec value" id="val-__bin_read_t__"><a href="#val-__bin_read_t__" class="anchor"></a><code><span class="keyword">val</span> __bin_read_t__ : (int <span>&#45;&gt;</span> <a href="index.html#type-t">t</a>) <a href="../../../bin_prot/Bin_prot/Read/index.html#type-reader">Bin_prot.Read.reader</a></code></dt><dt class="spec value" id="val-bin_reader_t"><a href="#val-bin_reader_t" class="anchor"></a><code><span class="keyword">val</span> bin_reader_t : <a href="index.html#type-t">t</a> <a href="../../../bin_prot/Bin_prot/Type_class/index.html#type-reader">Bin_prot.Type_class.reader</a></code></dt><dt class="spec value" id="val-bin_size_t"><a href="#val-bin_size_t" class="anchor"></a><code><span class="keyword">val</span> bin_size_t : <a href="index.html#type-t">t</a> <a href="../../../bin_prot/Bin_prot/Size/index.html#type-sizer">Bin_prot.Size.sizer</a></code></dt><dt class="spec value" id="val-bin_write_t"><a href="#val-bin_write_t" class="anchor"></a><code><span class="keyword">val</span> bin_write_t : <a href="index.html#type-t">t</a> <a href="../../../bin_prot/Bin_prot/Write/index.html#type-writer">Bin_prot.Write.writer</a></code></dt><dt class="spec value" id="val-bin_writer_t"><a href="#val-bin_writer_t" class="anchor"></a><code><span class="keyword">val</span> bin_writer_t : <a href="index.html#type-t">t</a> <a href="../../../bin_prot/Bin_prot/Type_class/index.html#type-writer">Bin_prot.Type_class.writer</a></code></dt><dt class="spec value" id="val-bin_shape_t"><a href="#val-bin_shape_t" class="anchor"></a><code><span class="keyword">val</span> bin_shape_t : <a href="../../../bin_prot/Bin_prot/Shape/index.html#type-t">Bin_prot.Shape.t</a></code></dt><dt class="spec value" id="val-sexp_of_t"><a href="#val-sexp_of_t" class="anchor"></a><code><span class="keyword">val</span> sexp_of_t : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../../../sexplib0/Sexplib0/Sexp/index.html#type-t">Ppx_sexp_conv_lib.Sexp.t</a></code></dt></dl></details></div></div></div><dl><dt class="spec type" id="type-worker"><a href="#type-worker" class="anchor"></a><code><span class="keyword">type</span> worker</code><code> = <a href="index.html#type-t">t</a></code></dt><dd><p>A type alias to make the <code>Connection</code> signature more readable</p></dd></dl><dl><dt class="spec type" id="type-functions"><a href="#type-functions" class="anchor"></a><code><span class="keyword">type</span> 'a functions</code></dt></dl><dl><dt class="spec value" id="val-functions"><a href="#val-functions" class="anchor"></a><code><span class="keyword">val</span> functions : <a href="index.html#type-t">t</a> <a href="index.html#type-functions">functions</a></code></dt><dd><p>Accessor for the functions implemented by this worker type</p></dd></dl><dl><dt class="spec type" id="type-worker_state_init_arg"><a href="#type-worker_state_init_arg" class="anchor"></a><code><span class="keyword">type</span> worker_state_init_arg</code></dt><dt class="spec type" id="type-connection_state_init_arg"><a href="#type-connection_state_init_arg" class="anchor"></a><code><span class="keyword">type</span> connection_state_init_arg</code></dt></dl><div class="spec module" id="module-Id"><a href="#module-Id" class="anchor"></a><code><span class="keyword">module</span> <a href="Id/index.html">Id</a> : <a href="../../../core/Core/index.html#module-type-Identifiable">Core.Identifiable</a></code></div><dl><dt class="spec value" id="val-id"><a href="#val-id" class="anchor"></a><code><span class="keyword">val</span> id : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="Id/index.html#type-t">Id.t</a></code></dt><dt class="spec value" id="val-serve"><a href="#val-serve" class="anchor"></a><code><span class="keyword">val</span> serve : ?&#8288;max_message_size:int <span>&#45;&gt;</span> ?&#8288;handshake_timeout:<a href="../../../core_kernel/Core_kernel__Time_intf/module-type-S/Time/Span/index.html#type-t">Core.Time.Span.t</a> <span>&#45;&gt;</span> ?&#8288;heartbeat_config:<a href="../../../async_rpc_kernel/Async_rpc_kernel__Rpc/Connection/Heartbeat_config/index.html#type-t">Async.Rpc.Connection.Heartbeat_config.t</a> <span>&#45;&gt;</span> <a href="index.html#type-worker_state_init_arg">worker_state_init_arg</a> <span>&#45;&gt;</span> <a href="index.html#type-worker">worker</a> <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async.Deferred.t</a></code></dt><dd><p><code>serve arg</code> will start an Rpc server in process implementing all the functions of the given worker.</p></dd></dl><div class="spec module" id="module-Connection"><a href="#module-Connection" class="anchor"></a><code><span class="keyword">module</span> <a href="Connection/index.html">Connection</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><div class="spec module" id="module-Shutdown_on"><a href="#module-Shutdown_on" class="anchor"></a><code><span class="keyword">module</span> <a href="Shutdown_on/index.html">Shutdown_on</a> : <span class="keyword">functor</span> (<a href="Shutdown_on/argument-1-M/index.html">M</a> : <a href="../../../core/Core/index.html#module-type-T1">Core.T1</a>) <span>&#45;&gt;</span> <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><dl><dt class="spec type" id="type-with_spawn_args"><a href="#type-with_spawn_args" class="anchor"></a><code><span class="keyword">type</span> 'a with_spawn_args</code><code> = ?&#8288;where:<a href="../../Rpc_parallel/Executable_location/index.html#type-t">Rpc_parallel.Executable_location.t</a> <span>&#45;&gt;</span> ?&#8288;name:string <span>&#45;&gt;</span> ?&#8288;env:(string * string) list <span>&#45;&gt;</span> ?&#8288;connection_timeout:<a href="../../../core_kernel/Core_kernel__Time_intf/module-type-S/Time/Span/index.html#type-t">Core.Time.Span.t</a> <span>&#45;&gt;</span> ?&#8288;cd:string <span>&#45;&gt;</span> on_failure:(<a href="../../../core_kernel/Core_kernel/Error/index.html#type-t">Core.Error.t</a> <span>&#45;&gt;</span> unit) <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p>The various <code>spawn</code> functions create a new worker process that implements the functions specified in the <code>Worker_spec</code>.</p><p><code>name</code> will be attached to certain error messages and is useful for debugging.</p><p><code>env</code> extends the environment of the spawned worker process.</p><p><code>connection_timeout</code> is used for various internal timeouts. This may need be to increased if the init arg is really large (serialization and deserialization takes more than <code>connection_timeout</code>).</p><p><code>cd</code> changes the current working directory of a spawned worker process.</p><p><code>shutdown_on</code> specifies when a worker should shut itself down.</p><p><code>on_failure exn</code> will be called in the spawning process upon the worker process raising a background exception. All exceptions raised before functions return will be returned to the caller. <code>on_failure</code> will be called in <code>Monitor.current ()</code> at the time of this spawn call. The worker initiates shutdown upon sending the exception to the master process.</p><p><code>worker_state_init_arg</code> (below) will be passed to <code>init_worker_state</code> of the given <code>Worker_spec</code> module. This initializes a persistent worker state for all connections to this worker.</p></dd></dl><dl><dt class="spec value" id="val-spawn"><a href="#val-spawn" class="anchor"></a><code><span class="keyword">val</span> spawn : (?&#8288;umask:int <span>&#45;&gt;</span> shutdown_on:<span class="type-var">'a</span> <a href="Shutdown_on/index.html#type-t">Shutdown_on(Core.Or_error).t</a> <span>&#45;&gt;</span> redirect_stdout:<a href="../../Rpc_parallel__/Fd_redirection/index.html#type-t">Rpc_parallel__.Fd_redirection.t</a> <span>&#45;&gt;</span> redirect_stderr:<a href="../../Rpc_parallel__/Fd_redirection/index.html#type-t">Rpc_parallel__.Fd_redirection.t</a> <span>&#45;&gt;</span> <a href="index.html#type-worker_state_init_arg">worker_state_init_arg</a> <span>&#45;&gt;</span> <span class="type-var">'a</span>) <a href="index.html#type-with_spawn_args">with_spawn_args</a></code></dt><dd><p>The spawned worker process daemonizes. Any initialization errors that wrote to stderr (Rpc_parallel internal initialization, not user initialization code) will be captured and rewritten to the spawning process's stderr with the prefix &quot;<code>WORKER %NAME% STDERR</code>&quot;.</p><p><code>redirect_stdout</code> and <code>redirect_stderr</code> specify stdout and stderr of the worker process.</p></dd></dl><dl><dt class="spec value" id="val-spawn_exn"><a href="#val-spawn_exn" class="anchor"></a><code><span class="keyword">val</span> spawn_exn : (?&#8288;umask:int <span>&#45;&gt;</span> shutdown_on:<span class="type-var">'a</span> <a href="Shutdown_on/index.html#type-t">Shutdown_on(Core.Monad.Ident).t</a> <span>&#45;&gt;</span> redirect_stdout:<a href="../../Rpc_parallel__/Fd_redirection/index.html#type-t">Rpc_parallel__.Fd_redirection.t</a> <span>&#45;&gt;</span> redirect_stderr:<a href="../../Rpc_parallel__/Fd_redirection/index.html#type-t">Rpc_parallel__.Fd_redirection.t</a> <span>&#45;&gt;</span> <a href="index.html#type-worker_state_init_arg">worker_state_init_arg</a> <span>&#45;&gt;</span> <span class="type-var">'a</span>) <a href="index.html#type-with_spawn_args">with_spawn_args</a></code></dt></dl><div class="spec module" id="module-Spawn_in_foreground_result"><a href="#module-Spawn_in_foreground_result" class="anchor"></a><code><span class="keyword">module</span> <a href="Spawn_in_foreground_result/index.html">Spawn_in_foreground_result</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><dl><dt class="spec value" id="val-spawn_in_foreground"><a href="#val-spawn_in_foreground" class="anchor"></a><code><span class="keyword">val</span> spawn_in_foreground : (shutdown_on:<span class="type-var">'a</span> <a href="Shutdown_on/index.html#type-t">Shutdown_on(Spawn_in_foreground_result).t</a> <span>&#45;&gt;</span> <a href="index.html#type-worker_state_init_arg">worker_state_init_arg</a> <span>&#45;&gt;</span> <span class="type-var">'a</span>) <a href="index.html#type-with_spawn_args">with_spawn_args</a></code></dt><dd><p>Similar to <code>spawn</code> but the worker process does not daemonize. If the process was spawned on a remote host, the ssh <code>Process.t</code> is returned.</p></dd></dl><div class="spec module" id="module-Spawn_in_foreground_exn_result"><a href="#module-Spawn_in_foreground_exn_result" class="anchor"></a><code><span class="keyword">module</span> <a href="Spawn_in_foreground_exn_result/index.html">Spawn_in_foreground_exn_result</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><dl><dt class="spec value" id="val-spawn_in_foreground_exn"><a href="#val-spawn_in_foreground_exn" class="anchor"></a><code><span class="keyword">val</span> spawn_in_foreground_exn : (shutdown_on:<span class="type-var">'a</span> <a href="Shutdown_on/index.html#type-t">Shutdown_on(Spawn_in_foreground_exn_result).t</a> <span>&#45;&gt;</span> <a href="index.html#type-worker_state_init_arg">worker_state_init_arg</a> <span>&#45;&gt;</span> <span class="type-var">'a</span>) <a href="index.html#type-with_spawn_args">with_spawn_args</a></code></dt><dt class="spec value" id="val-shutdown"><a href="#val-shutdown" class="anchor"></a><code><span class="keyword">val</span> shutdown : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit <a href="../../../core_kernel/Core_kernel/Or_error/index.html#type-t">Core.Or_error.t</a> <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async.Deferred.t</a></code></dt><dd><p><code>shutdown</code> attempts to connect to a worker. Upon success, <code>Shutdown.shutdown 0</code> is run in the worker. If you want strong guarantees that a worker did shutdown, consider using <code>spawn_in_foreground</code> and inspecting the <code>Process.t</code>.</p></dd></dl><div class="spec module" id="module-Deprecated"><a href="#module-Deprecated" class="anchor"></a><code><span class="keyword">module</span> <a href="Deprecated/index.html">Deprecated</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div></div></body></html>