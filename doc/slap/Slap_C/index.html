<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Slap_C (slap.Slap_C)</title><link rel="stylesheet" href="../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../index.html">slap</a> &#x00BB; Slap_C</nav><h1>Module <code>Slap_C</code></h1><nav class="toc"><ul><li><a href="#blas-interface">BLAS interface</a><ul><li><a href="#level-1">Level 1</a></li><li><a href="#level-2">Level 2</a></li><li><a href="#level-3">Level 3</a></li></ul></li><li><a href="#lapack-interface">LAPACK interface</a><ul><li><a href="#auxiliary-routines">Auxiliary routines</a></li><li><a href="#linear-equations-(computational-routines)">Linear equations (computational routines)</a></li><li><a href="#linear-equations-(simple-drivers)">Linear equations (simple drivers)</a></li><li><a href="#least-squares-(simple-drivers)">Least squares (simple drivers)</a></li></ul></li><li><a href="#blas-interface">BLAS interface</a><ul><li><a href="#level-1">Level 1</a></li></ul></li></ul></nav></header><dl><dt class="spec type" id="type-prec"><a href="#type-prec" class="anchor"></a><code><span class="keyword">type</span> prec</code><code> = <a href="../../ocaml/Bigarray/index.html#type-complex32_elt">Bigarray.complex32_elt</a></code></dt><dt class="spec type" id="type-num_type"><a href="#type-num_type" class="anchor"></a><code><span class="keyword">type</span> num_type</code><code> = <a href="../../ocaml/Stdlib/Complex/index.html#type-t">Stdlib.Complex.t</a></code></dt><dt class="spec type" id="type-trans3"><a href="#type-trans3" class="anchor"></a><code><span class="keyword">type</span> (+'indim, +'outdim, +'tag) trans3</code><code> = (<span class="type-var">'indim</span>, <span class="type-var">'outdim</span>, <span class="type-var">'tag</span>) <a href="../Slap_common/index.html#type-trans3">Slap_common.trans3</a></code></dt><dd><p>A type of transpose parameters (<a href="../Slap_common/index.html#val-normal"><code>Slap_common.normal</code></a>, <a href="../Slap_common/index.html#type-trans"><code>Slap_common.trans</code></a> or <a href="../Slap_common/index.html#val-conjtr"><code>Slap_common.conjtr</code></a>).</p></dd></dl><dl><dt class="spec type" id="type-vec"><a href="#type-vec" class="anchor"></a><code><span class="keyword">type</span> (+'n, +'cnt_or_dsc) vec</code><code> = (<span class="type-var">'n</span>, <a href="index.html#type-num_type">num_type</a>, <a href="index.html#type-prec">prec</a>, <span class="type-var">'cnt_or_dsc</span>) <a href="../Slap_vec/index.html#type-t">Slap_vec.t</a></code></dt><dd><p>Vectors.</p></dd></dl><dl><dt class="spec type" id="type-mat"><a href="#type-mat" class="anchor"></a><code><span class="keyword">type</span> (+'m, +'n, +'cnt_or_dsc) mat</code><code> = (<span class="type-var">'m</span>, <span class="type-var">'n</span>, <a href="index.html#type-num_type">num_type</a>, <a href="index.html#type-prec">prec</a>, <span class="type-var">'cnt_or_dsc</span>) <a href="../Slap_mat/index.html#type-t">Slap_mat.t</a></code></dt><dd><p>Matrices.</p></dd></dl><dl><dt class="spec type" id="type-rprec"><a href="#type-rprec" class="anchor"></a><code><span class="keyword">type</span> rprec</code><code> = <a href="../../ocaml/Bigarray/index.html#type-float32_elt">Bigarray.float32_elt</a></code></dt><dt class="spec type" id="type-rvec"><a href="#type-rvec" class="anchor"></a><code><span class="keyword">type</span> (+'n, +'cnt_or_dsc) rvec</code><code> = (<span class="type-var">'n</span>, float, <a href="index.html#type-rprec">rprec</a>, <span class="type-var">'cnt_or_dsc</span>) <a href="../Slap_vec/index.html#type-t">Slap_vec.t</a></code></dt><dd><p>Real vectors. (In <a href="../Slap/S/index.html"><code>Slap.S</code></a> and <a href="../Slap/D/index.html"><code>Slap.D</code></a>, <code>rvec</code> is equal to <code>vec</code>.)</p></dd></dl><dl><dt class="spec value" id="val-prec"><a href="#val-prec" class="anchor"></a><code><span class="keyword">val</span> prec : (<a href="index.html#type-num_type">num_type</a>, <a href="index.html#type-prec">prec</a>) <a href="../../ocaml/Bigarray/index.html#type-kind">Bigarray.kind</a></code></dt><dt class="spec value" id="val-rprec"><a href="#val-rprec" class="anchor"></a><code><span class="keyword">val</span> rprec : (float, <a href="index.html#type-rprec">rprec</a>) <a href="../../ocaml/Bigarray/index.html#type-kind">Bigarray.kind</a></code></dt></dl><div class="spec module" id="module-Vec"><a href="#module-Vec" class="anchor"></a><code><span class="keyword">module</span> <a href="Vec/index.html">Vec</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><div class="spec module" id="module-Mat"><a href="#module-Mat" class="anchor"></a><code><span class="keyword">module</span> <a href="Mat/index.html">Mat</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><dl><dt class="spec value" id="val-pp_num"><a href="#val-pp_num" class="anchor"></a><code><span class="keyword">val</span> pp_num : <a href="../../ocaml/Stdlib/Format/index.html#type-formatter">Stdlib.Format.formatter</a> <span>&#45;&gt;</span> <a href="index.html#type-num_type">num_type</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>A pretty-printer for elements in vectors and matrices.</p></dd></dl><dl><dt class="spec value" id="val-pp_vec"><a href="#val-pp_vec" class="anchor"></a><code><span class="keyword">val</span> pp_vec : <a href="../../ocaml/Stdlib/Format/index.html#type-formatter">Stdlib.Format.formatter</a> <span>&#45;&gt;</span> (<span class="type-var">'n</span>, <span class="type-var">'cnt_or_dsc</span>) <a href="index.html#type-vec">vec</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>A pretty-printer for column vectors.</p></dd></dl><dl><dt class="spec value" id="val-pp_mat"><a href="#val-pp_mat" class="anchor"></a><code><span class="keyword">val</span> pp_mat : <a href="../../ocaml/Stdlib/Format/index.html#type-formatter">Stdlib.Format.formatter</a> <span>&#45;&gt;</span> (<span class="type-var">'m</span>, <span class="type-var">'n</span>, <span class="type-var">'cnt_or_dsc</span>) <a href="index.html#type-mat">mat</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>A pretty-printer for matrices.</p></dd></dl><section><header><h3 id="blas-interface"><a href="#blas-interface" class="anchor"></a>BLAS interface</h3></header><section><header><h4 id="level-1"><a href="#level-1" class="anchor"></a>Level 1</h4></header><dl><dt class="spec value" id="val-swap"><a href="#val-swap" class="anchor"></a><code><span class="keyword">val</span> swap : (<span class="type-var">'n</span>, <span class="type-var">'x_cd</span>) <a href="index.html#type-vec">vec</a> <span>&#45;&gt;</span> (<span class="type-var">'n</span>, <span class="type-var">'y_cd</span>) <a href="index.html#type-vec">vec</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>swap x y</code> swaps elements in <code>x</code> and <code>y</code>.</p></dd></dl><dl><dt class="spec value" id="val-scal"><a href="#val-scal" class="anchor"></a><code><span class="keyword">val</span> scal : <a href="index.html#type-num_type">num_type</a> <span>&#45;&gt;</span> (<span class="type-var">'n</span>, <span class="type-var">'cd</span>) <a href="index.html#type-vec">vec</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>scal c x</code> multiplies all elements in <code>x</code> by scalar value <code>c</code>, and destructively assigns the result to <code>x</code>.</p></dd></dl><dl><dt class="spec value" id="val-copy"><a href="#val-copy" class="anchor"></a><code><span class="keyword">val</span> copy : ?&#8288;y:(<span class="type-var">'n</span>, <span class="type-var">'y_cd</span>) <a href="index.html#type-vec">vec</a> <span>&#45;&gt;</span> (<span class="type-var">'n</span>, <span class="type-var">'x_cd</span>) <a href="index.html#type-vec">vec</a> <span>&#45;&gt;</span> (<span class="type-var">'n</span>, <span class="type-var">'y_cd</span>) <a href="index.html#type-vec">vec</a></code></dt><dd><p><code>copy ?y x</code> copies <code>x</code> into <code>y</code>.</p><dl><dt>returns</dt><dd><p>vector <code>y</code>, which is overwritten.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-nrm2"><a href="#val-nrm2" class="anchor"></a><code><span class="keyword">val</span> nrm2 : (<span class="type-var">'n</span>, <span class="type-var">'cd</span>) <a href="index.html#type-vec">vec</a> <span>&#45;&gt;</span> float</code></dt><dd><p><code>nrm2 x</code> retruns the L2 norm of vector <code>x</code>: <code>||x||</code>.</p></dd></dl><dl><dt class="spec value" id="val-axpy"><a href="#val-axpy" class="anchor"></a><code><span class="keyword">val</span> axpy : ?&#8288;alpha:<a href="index.html#type-num_type">num_type</a> <span>&#45;&gt;</span> (<span class="type-var">'n</span>, <span class="type-var">'x_cd</span>) <a href="index.html#type-vec">vec</a> <span>&#45;&gt;</span> (<span class="type-var">'n</span>, <span class="type-var">'y_cd</span>) <a href="index.html#type-vec">vec</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>axpy ?alpha x y</code> executes <code>y := alpha * x + y</code> with scalar value <code>alpha</code>, and vectors <code>x</code> and <code>y</code>.</p><dl><dt>parameter alpha</dt><dd><p>default = <code>1.0</code></p></dd></dl></dd></dl><dl><dt class="spec value" id="val-iamax"><a href="#val-iamax" class="anchor"></a><code><span class="keyword">val</span> iamax : (<span class="type-var">'n</span>, <span class="type-var">'cd</span>) <a href="index.html#type-vec">vec</a> <span>&#45;&gt;</span> int</code></dt><dd><p><code>iamax x</code> returns the index of the maximum value of all elements in <code>x</code>.</p></dd></dl><dl><dt class="spec value" id="val-amax"><a href="#val-amax" class="anchor"></a><code><span class="keyword">val</span> amax : (<span class="type-var">'n</span>, <span class="type-var">'cd</span>) <a href="index.html#type-vec">vec</a> <span>&#45;&gt;</span> <a href="index.html#type-num_type">num_type</a></code></dt><dd><p><code>amax x</code> finds the maximum value of all elements in <code>x</code>.</p></dd></dl></section><section><header><h4 id="level-2"><a href="#level-2" class="anchor"></a>Level 2</h4></header><dl><dt class="spec value" id="val-gemv"><a href="#val-gemv" class="anchor"></a><code><span class="keyword">val</span> gemv : ?&#8288;beta:<a href="index.html#type-num_type">num_type</a> <span>&#45;&gt;</span> ?&#8288;y:(<span class="type-var">'m</span>, <span class="type-var">'y_cd</span>) <a href="index.html#type-vec">vec</a> <span>&#45;&gt;</span> trans:(<span class="type-var">'a_m</span> * <span class="type-var">'a_n</span>, <span class="type-var">'m</span> * <span class="type-var">'n</span>, <span class="type-var">_</span>) <a href="index.html#type-trans3">trans3</a> <span>&#45;&gt;</span> ?&#8288;alpha:<a href="index.html#type-num_type">num_type</a> <span>&#45;&gt;</span> (<span class="type-var">'a_m</span>, <span class="type-var">'a_n</span>, <span class="type-var">'a_cd</span>) <a href="index.html#type-mat">mat</a> <span>&#45;&gt;</span> (<span class="type-var">'n</span>, <span class="type-var">'x_cd</span>) <a href="index.html#type-vec">vec</a> <span>&#45;&gt;</span> (<span class="type-var">'m</span>, <span class="type-var">'y_cd</span>) <a href="index.html#type-vec">vec</a></code></dt><dd><p><code>gemv ?beta ?y ~trans ?alpha a x</code> executes <code>y := alpha * OP(a) * x + beta * y</code>.</p><dl><dt>parameter beta</dt><dd><p>default = <code>0.0</code></p></dd></dl><dl><dt>parameter trans</dt><dd><p>the transpose flag for <code>a</code>:</p><ul><li>If <code>trans</code> = <a href="../Slap_common/index.html#val-normal"><code>Slap_common.normal</code></a>, then <code>OP(a)</code> = <code>a</code>;</li><li>If <code>trans</code> = <a href="../Slap_common/index.html#type-trans"><code>Slap_common.trans</code></a>, then <code>OP(a)</code> = <code>a^T</code>;</li><li>If <code>trans</code> = <a href="../Slap_common/index.html#val-conjtr"><code>Slap_common.conjtr</code></a>, then <code>OP(a)</code> = <code>a^H</code> (the conjugate transpose of <code>a</code>).</li></ul></dd></dl><dl><dt>parameter alpha</dt><dd><p>default = <code>1.0</code></p></dd></dl></dd></dl><dl><dt class="spec value" id="val-gbmv"><a href="#val-gbmv" class="anchor"></a><code><span class="keyword">val</span> gbmv : m:<span class="type-var">'a_m</span> <a href="../Slap_size/index.html#type-t">Slap_size.t</a> <span>&#45;&gt;</span> ?&#8288;beta:<a href="index.html#type-num_type">num_type</a> <span>&#45;&gt;</span> ?&#8288;y:(<span class="type-var">'m</span>, <span class="type-var">'y_cd</span>) <a href="index.html#type-vec">vec</a> <span>&#45;&gt;</span> trans:(<span class="type-var">'a_m</span> * <span class="type-var">'a_n</span>, <span class="type-var">'m</span> * <span class="type-var">'n</span>, <span class="type-var">_</span>) <a href="index.html#type-trans3">trans3</a> <span>&#45;&gt;</span> ?&#8288;alpha:<a href="index.html#type-num_type">num_type</a> <span>&#45;&gt;</span> ((<span class="type-var">'a_m</span>, <span class="type-var">'a_n</span>, <span class="type-var">'kl</span>, <span class="type-var">'ku</span>) <a href="../Slap_size/index.html#type-geband">Slap_size.geband</a>, <span class="type-var">'a_n</span>, <span class="type-var">'a_cd</span>) <a href="index.html#type-mat">mat</a> <span>&#45;&gt;</span> <span class="type-var">'kl</span> <a href="../Slap_size/index.html#type-t">Slap_size.t</a> <span>&#45;&gt;</span> <span class="type-var">'ku</span> <a href="../Slap_size/index.html#type-t">Slap_size.t</a> <span>&#45;&gt;</span> (<span class="type-var">'n</span>, <span class="type-var">'x_cd</span>) <a href="index.html#type-vec">vec</a> <span>&#45;&gt;</span> (<span class="type-var">'m</span>, <span class="type-var">'y_cd</span>) <a href="index.html#type-vec">vec</a></code></dt><dd><p><code>gbmv ~m ?beta ?y ~trans ?alpha a kl ku x</code> computes <code>y := alpha * OP(a) * x + beta * y</code> where <code>a</code> is a band matrix stored in band storage.</p><dl><dt>returns</dt><dd><p>vector <code>y</code>, which is overwritten.</p></dd></dl><dl><dt>parameter beta</dt><dd><p>default = <code>0.0</code></p></dd></dl><dl><dt>parameter trans</dt><dd><p>the transpose flag for <code>a</code>:</p><ul><li>If <code>trans</code> = <a href="../Slap_common/index.html#val-normal"><code>Slap_common.normal</code></a>, then <code>OP(a)</code> = <code>a</code>;</li><li>If <code>trans</code> = <a href="../Slap_common/index.html#type-trans"><code>Slap_common.trans</code></a>, then <code>OP(a)</code> = <code>a^T</code>;</li><li>If <code>trans</code> = <a href="../Slap_common/index.html#val-conjtr"><code>Slap_common.conjtr</code></a>, then <code>OP(a)</code> = <code>a^H</code> (the conjugate transpose of <code>a</code>).</li></ul></dd></dl><dl><dt>parameter alpha</dt><dd><p>default = <code>1.0</code></p></dd></dl><dl><dt>parameter kl</dt><dd><p>the number of subdiagonals of <code>a</code></p></dd></dl><dl><dt>parameter ku</dt><dd><p>the number of superdiagonals of <code>a</code></p></dd></dl><dl><dt>since</dt><dd>0.2.0</dd></dl></dd></dl><dl><dt class="spec value" id="val-symv"><a href="#val-symv" class="anchor"></a><code><span class="keyword">val</span> symv : ?&#8288;beta:<a href="index.html#type-num_type">num_type</a> <span>&#45;&gt;</span> ?&#8288;y:(<span class="type-var">'n</span>, <span class="type-var">'y_cd</span>) <a href="index.html#type-vec">vec</a> <span>&#45;&gt;</span> ?&#8288;up:[&lt; `L | `U ] <a href="../Slap_common/index.html#type-uplo">Slap_common.uplo</a> <span>&#45;&gt;</span> ?&#8288;alpha:<a href="index.html#type-num_type">num_type</a> <span>&#45;&gt;</span> (<span class="type-var">'n</span>, <span class="type-var">'n</span>, <span class="type-var">'a_cd</span>) <a href="index.html#type-mat">mat</a> <span>&#45;&gt;</span> (<span class="type-var">'n</span>, <span class="type-var">'x_cd</span>) <a href="index.html#type-vec">vec</a> <span>&#45;&gt;</span> (<span class="type-var">'n</span>, <span class="type-var">'y_cd</span>) <a href="index.html#type-vec">vec</a></code></dt><dd><p><code>symv ?beta ?y ?up ?alpha a x</code> executes <code>y := alpha * a * x + beta * y</code>.</p><dl><dt>parameter beta</dt><dd><p>default = <code>0.0</code></p></dd></dl><dl><dt>parameter up</dt><dd><p>default = <a href="../Slap_common/index.html#val-upper"><code>Slap_common.upper</code></a></p><ul><li>If <code>up</code> = <a href="../Slap_common/index.html#val-upper"><code>Slap_common.upper</code></a>, then the upper triangular part of <code>a</code> is used;</li><li>If <code>up</code> = <a href="../Slap_common/index.html#val-lower"><code>Slap_common.lower</code></a>, then the lower triangular part of <code>a</code> is used.</li></ul></dd></dl><dl><dt>parameter alpha</dt><dd><p>default = <code>1.0</code></p></dd></dl></dd></dl><dl><dt class="spec value" id="val-trmv"><a href="#val-trmv" class="anchor"></a><code><span class="keyword">val</span> trmv : trans:(<span class="type-var">'n</span> * <span class="type-var">'n</span>, <span class="type-var">'n</span> * <span class="type-var">'n</span>, <span class="type-var">_</span>) <a href="index.html#type-trans3">trans3</a> <span>&#45;&gt;</span> ?&#8288;diag:<a href="../Slap_common/index.html#type-diag">Slap_common.diag</a> <span>&#45;&gt;</span> ?&#8288;up:[&lt; `L | `U ] <a href="../Slap_common/index.html#type-uplo">Slap_common.uplo</a> <span>&#45;&gt;</span> (<span class="type-var">'n</span>, <span class="type-var">'n</span>, <span class="type-var">'a_cd</span>) <a href="index.html#type-mat">mat</a> <span>&#45;&gt;</span> (<span class="type-var">'n</span>, <span class="type-var">'x_cd</span>) <a href="index.html#type-vec">vec</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>trmv ~trans ?diag ?up a x</code> executes <code>x := OP(a) * x</code>.</p><dl><dt>parameter trans</dt><dd><p>the transpose flag for <code>a</code>:</p><ul><li>If <code>trans</code> = <a href="../Slap_common/index.html#val-normal"><code>Slap_common.normal</code></a>, then <code>OP(a)</code> = <code>a</code>;</li><li>If <code>trans</code> = <a href="../Slap_common/index.html#type-trans"><code>Slap_common.trans</code></a>, then <code>OP(a)</code> = <code>a^T</code>;</li><li>If <code>trans</code> = <a href="../Slap_common/index.html#val-conjtr"><code>Slap_common.conjtr</code></a>, then <code>OP(a)</code> = <code>a^H</code> (the conjugate transpose of <code>a</code>).</li></ul></dd></dl><dl><dt>parameter diag</dt><dd><p>default = <a href="../Slap_common/index.html#val-non_unit"><code>Slap_common.non_unit</code></a></p><ul><li>If <code>diag</code> = <a href="../Slap_common/index.html#val-unit"><code>Slap_common.unit</code></a>, then <code>a</code> is unit triangular;</li><li>If <code>diag</code> = <a href="../Slap_common/index.html#val-non_unit"><code>Slap_common.non_unit</code></a>, then <code>a</code> is not unit triangular.</li></ul></dd></dl><dl><dt>parameter up</dt><dd><p>default = <a href="../Slap_common/index.html#val-upper"><code>Slap_common.upper</code></a></p><ul><li>If <code>up</code> = <a href="../Slap_common/index.html#val-upper"><code>Slap_common.upper</code></a>, then the upper triangular part of <code>a</code> is used;</li><li>If <code>up</code> = <a href="../Slap_common/index.html#val-lower"><code>Slap_common.lower</code></a>, then the lower triangular part of <code>a</code> is used.</li></ul></dd></dl></dd></dl><dl><dt class="spec value" id="val-trsv"><a href="#val-trsv" class="anchor"></a><code><span class="keyword">val</span> trsv : trans:(<span class="type-var">'n</span> * <span class="type-var">'n</span>, <span class="type-var">'n</span> * <span class="type-var">'n</span>, <span class="type-var">_</span>) <a href="index.html#type-trans3">trans3</a> <span>&#45;&gt;</span> ?&#8288;diag:<a href="../Slap_common/index.html#type-diag">Slap_common.diag</a> <span>&#45;&gt;</span> ?&#8288;up:[&lt; `L | `U ] <a href="../Slap_common/index.html#type-uplo">Slap_common.uplo</a> <span>&#45;&gt;</span> (<span class="type-var">'n</span>, <span class="type-var">'n</span>, <span class="type-var">'a_cd</span>) <a href="index.html#type-mat">mat</a> <span>&#45;&gt;</span> (<span class="type-var">'n</span>, <span class="type-var">'b_cd</span>) <a href="index.html#type-vec">vec</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>trmv ~trans ?diag ?up a b</code> solves linear system <code>OP(a) * x = b</code> and destructively assigns <code>x</code> to <code>b</code>.</p><dl><dt>parameter trans</dt><dd><p>the transpose flag for <code>a</code>:</p><ul><li>If <code>trans</code> = <a href="../Slap_common/index.html#val-normal"><code>Slap_common.normal</code></a>, then <code>OP(a)</code> = <code>a</code>;</li><li>If <code>trans</code> = <a href="../Slap_common/index.html#type-trans"><code>Slap_common.trans</code></a>, then <code>OP(a)</code> = <code>a^T</code>;</li><li>If <code>trans</code> = <a href="../Slap_common/index.html#val-conjtr"><code>Slap_common.conjtr</code></a>, then <code>OP(a)</code> = <code>a^H</code> (the conjugate transpose of <code>a</code>).</li></ul></dd></dl><dl><dt>parameter diag</dt><dd><p>default = <a href="../Slap_common/index.html#val-non_unit"><code>Slap_common.non_unit</code></a></p><ul><li>If <code>diag</code> = <a href="../Slap_common/index.html#val-unit"><code>Slap_common.unit</code></a>, then <code>a</code> is unit triangular;</li><li>If <code>diag</code> = <a href="../Slap_common/index.html#val-non_unit"><code>Slap_common.non_unit</code></a>, then <code>a</code> is not unit triangular.</li></ul></dd></dl><dl><dt>parameter up</dt><dd><p>default = <a href="../Slap_common/index.html#val-upper"><code>Slap_common.upper</code></a></p><ul><li>If <code>up</code> = <a href="../Slap_common/index.html#val-upper"><code>Slap_common.upper</code></a>, then the upper triangular part of <code>a</code> is used;</li><li>If <code>up</code> = <a href="../Slap_common/index.html#val-lower"><code>Slap_common.lower</code></a>, then the lower triangular part of <code>a</code> is used.</li></ul></dd></dl></dd></dl><dl><dt class="spec value" id="val-tpmv"><a href="#val-tpmv" class="anchor"></a><code><span class="keyword">val</span> tpmv : trans:(<span class="type-var">'n</span> * <span class="type-var">'n</span>, <span class="type-var">'n</span> * <span class="type-var">'n</span>, <span class="type-var">_</span>) <a href="index.html#type-trans3">trans3</a> <span>&#45;&gt;</span> ?&#8288;diag:<a href="../Slap_common/index.html#type-diag">Slap_common.diag</a> <span>&#45;&gt;</span> ?&#8288;up:[&lt; `L | `U ] <a href="../Slap_common/index.html#type-uplo">Slap_common.uplo</a> <span>&#45;&gt;</span> (<span class="type-var">'n</span> <a href="../Slap_size/index.html#type-packed">Slap_size.packed</a>, <a href="../Slap_misc/index.html#type-cnt">Slap_misc.cnt</a>) <a href="index.html#type-vec">vec</a> <span>&#45;&gt;</span> (<span class="type-var">'n</span>, <span class="type-var">'x_cd</span>) <a href="index.html#type-vec">vec</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>tpmv ~trans ?diag ?up a x</code> executes <code>x := OP(a) * x</code> where <code>a</code> is a packed triangular matrix.</p><dl><dt>parameter trans</dt><dd><p>the transpose flag for <code>a</code>:</p><ul><li>If <code>trans</code> = <a href="../Slap_common/index.html#val-normal"><code>Slap_common.normal</code></a>, then <code>OP(a)</code> = <code>a</code>;</li><li>If <code>trans</code> = <a href="../Slap_common/index.html#type-trans"><code>Slap_common.trans</code></a>, then <code>OP(a)</code> = <code>a^T</code>;</li><li>If <code>trans</code> = <a href="../Slap_common/index.html#val-conjtr"><code>Slap_common.conjtr</code></a>, then <code>OP(a)</code> = <code>a^H</code> (the conjugate transpose of <code>a</code>).</li></ul></dd></dl><dl><dt>parameter diag</dt><dd><p>default = <a href="../Slap_common/index.html#val-non_unit"><code>Slap_common.non_unit</code></a></p><ul><li>If <code>diag</code> = <a href="../Slap_common/index.html#val-unit"><code>Slap_common.unit</code></a>, then <code>a</code> is unit triangular;</li><li>If <code>diag</code> = <a href="../Slap_common/index.html#val-non_unit"><code>Slap_common.non_unit</code></a>, then <code>a</code> is not unit triangular.</li></ul></dd></dl><dl><dt>parameter up</dt><dd><p>default = <a href="../Slap_common/index.html#val-upper"><code>Slap_common.upper</code></a></p><ul><li>If <code>up</code> = <a href="../Slap_common/index.html#val-upper"><code>Slap_common.upper</code></a>, then the upper triangular part of <code>a</code> is used;</li><li>If <code>up</code> = <a href="../Slap_common/index.html#val-lower"><code>Slap_common.lower</code></a>, then the lower triangular part of <code>a</code> is used.</li></ul></dd></dl><dl><dt>since</dt><dd>0.2.0</dd></dl></dd></dl><dl><dt class="spec value" id="val-tpsv"><a href="#val-tpsv" class="anchor"></a><code><span class="keyword">val</span> tpsv : trans:(<span class="type-var">'n</span> * <span class="type-var">'n</span>, <span class="type-var">'n</span> * <span class="type-var">'n</span>, <span class="type-var">_</span>) <a href="index.html#type-trans3">trans3</a> <span>&#45;&gt;</span> ?&#8288;diag:<a href="../Slap_common/index.html#type-diag">Slap_common.diag</a> <span>&#45;&gt;</span> ?&#8288;up:[&lt; `L | `U ] <a href="../Slap_common/index.html#type-uplo">Slap_common.uplo</a> <span>&#45;&gt;</span> (<span class="type-var">'n</span> <a href="../Slap_size/index.html#type-packed">Slap_size.packed</a>, <a href="../Slap_misc/index.html#type-cnt">Slap_misc.cnt</a>) <a href="index.html#type-vec">vec</a> <span>&#45;&gt;</span> (<span class="type-var">'n</span>, <span class="type-var">'x_cd</span>) <a href="index.html#type-vec">vec</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>tpsv ~trans ?diag ?up a b</code> solves linear system <code>OP(a) * x = b</code> and destructively assigns <code>x</code> to <code>b</code> where <code>a</code> is a packed triangular matrix.</p><dl><dt>parameter trans</dt><dd><p>the transpose flag for <code>a</code>:</p><ul><li>If <code>trans</code> = <a href="../Slap_common/index.html#val-normal"><code>Slap_common.normal</code></a>, then <code>OP(a)</code> = <code>a</code>;</li><li>If <code>trans</code> = <a href="../Slap_common/index.html#type-trans"><code>Slap_common.trans</code></a>, then <code>OP(a)</code> = <code>a^T</code>;</li><li>If <code>trans</code> = <a href="../Slap_common/index.html#val-conjtr"><code>Slap_common.conjtr</code></a>, then <code>OP(a)</code> = <code>a^H</code> (the conjugate transpose of <code>a</code>).</li></ul></dd></dl><dl><dt>parameter diag</dt><dd><p>default = <a href="../Slap_common/index.html#val-non_unit"><code>Slap_common.non_unit</code></a></p><ul><li>If <code>diag</code> = <a href="../Slap_common/index.html#val-unit"><code>Slap_common.unit</code></a>, then <code>a</code> is unit triangular;</li><li>If <code>diag</code> = <a href="../Slap_common/index.html#val-non_unit"><code>Slap_common.non_unit</code></a>, then <code>a</code> is not unit triangular.</li></ul></dd></dl><dl><dt>parameter up</dt><dd><p>default = <a href="../Slap_common/index.html#val-upper"><code>Slap_common.upper</code></a></p><ul><li>If <code>up</code> = <a href="../Slap_common/index.html#val-upper"><code>Slap_common.upper</code></a>, then the upper triangular part of <code>a</code> is used;</li><li>If <code>up</code> = <a href="../Slap_common/index.html#val-lower"><code>Slap_common.lower</code></a>, then the lower triangular part of <code>a</code> is used.</li></ul></dd></dl><dl><dt>since</dt><dd>0.2.0</dd></dl></dd></dl></section><section><header><h4 id="level-3"><a href="#level-3" class="anchor"></a>Level 3</h4></header><dl><dt class="spec value" id="val-gemm"><a href="#val-gemm" class="anchor"></a><code><span class="keyword">val</span> gemm : ?&#8288;beta:<a href="index.html#type-num_type">num_type</a> <span>&#45;&gt;</span> ?&#8288;c:(<span class="type-var">'m</span>, <span class="type-var">'n</span>, <span class="type-var">'c_cd</span>) <a href="index.html#type-mat">mat</a> <span>&#45;&gt;</span> transa:(<span class="type-var">'a_m</span> * <span class="type-var">'a_k</span>, <span class="type-var">'m</span> * <span class="type-var">'k</span>, <span class="type-var">_</span>) <a href="index.html#type-trans3">trans3</a> <span>&#45;&gt;</span> ?&#8288;alpha:<a href="index.html#type-num_type">num_type</a> <span>&#45;&gt;</span> (<span class="type-var">'a_m</span>, <span class="type-var">'a_k</span>, <span class="type-var">'a_cd</span>) <a href="index.html#type-mat">mat</a> <span>&#45;&gt;</span> transb:(<span class="type-var">'b_k</span> * <span class="type-var">'b_n</span>, <span class="type-var">'k</span> * <span class="type-var">'n</span>, <span class="type-var">_</span>) <a href="index.html#type-trans3">trans3</a> <span>&#45;&gt;</span> (<span class="type-var">'b_k</span>, <span class="type-var">'b_n</span>, <span class="type-var">'b_cd</span>) <a href="index.html#type-mat">mat</a> <span>&#45;&gt;</span> (<span class="type-var">'m</span>, <span class="type-var">'n</span>, <span class="type-var">'c_cd</span>) <a href="index.html#type-mat">mat</a></code></dt><dd><p><code>gemm ?beta ?c ~transa ?alpha a ~transb b</code> executes <code>c := alpha * OP(a) * OP(b) + beta * c</code>.</p><dl><dt>parameter beta</dt><dd><p>default = <code>0.0</code></p></dd></dl><dl><dt>parameter transa</dt><dd><p>the transpose flag for <code>a</code>:</p><ul><li>If <code>transa</code> = <a href="../Slap_common/index.html#val-normal"><code>Slap_common.normal</code></a>, then <code>OP(a)</code> = <code>a</code>;</li><li>If <code>transa</code> = <a href="../Slap_common/index.html#type-trans"><code>Slap_common.trans</code></a>, then <code>OP(a)</code> = <code>a^T</code>;</li><li>If <code>transa</code> = <a href="../Slap_common/index.html#val-conjtr"><code>Slap_common.conjtr</code></a>, then <code>OP(a)</code> = <code>a^H</code> (the conjugate transpose of <code>a</code>).</li></ul></dd></dl><dl><dt>parameter alpha</dt><dd><p>default = <code>1.0</code></p></dd></dl><dl><dt>parameter transb</dt><dd><p>the transpose flag for <code>b</code>:</p><ul><li>If <code>transb</code> = <a href="../Slap_common/index.html#val-normal"><code>Slap_common.normal</code></a>, then <code>OP(b)</code> = <code>b</code>;</li><li>If <code>transb</code> = <a href="../Slap_common/index.html#type-trans"><code>Slap_common.trans</code></a>, then <code>OP(b)</code> = <code>b^T</code>;</li><li>If <code>transb</code> = <a href="../Slap_common/index.html#val-conjtr"><code>Slap_common.conjtr</code></a>, then <code>OP(b)</code> = <code>b^H</code> (the conjugate transpose of <code>b</code>).</li></ul></dd></dl></dd></dl><dl><dt class="spec value" id="val-symm"><a href="#val-symm" class="anchor"></a><code><span class="keyword">val</span> symm : side:(<span class="type-var">'k</span>, <span class="type-var">'m</span>, <span class="type-var">'n</span>) <a href="../Slap_common/index.html#type-side">Slap_common.side</a> <span>&#45;&gt;</span> ?&#8288;up:[&lt; `U | `L ] <a href="../Slap_common/index.html#type-uplo">Slap_common.uplo</a> <span>&#45;&gt;</span> ?&#8288;beta:<a href="index.html#type-num_type">num_type</a> <span>&#45;&gt;</span> ?&#8288;c:(<span class="type-var">'m</span>, <span class="type-var">'n</span>, <span class="type-var">'c_cd</span>) <a href="index.html#type-mat">mat</a> <span>&#45;&gt;</span> ?&#8288;alpha:<a href="index.html#type-num_type">num_type</a> <span>&#45;&gt;</span> (<span class="type-var">'k</span>, <span class="type-var">'k</span>, <span class="type-var">'a_cd</span>) <a href="index.html#type-mat">mat</a> <span>&#45;&gt;</span> (<span class="type-var">'m</span>, <span class="type-var">'n</span>, <span class="type-var">'b_cd</span>) <a href="index.html#type-mat">mat</a> <span>&#45;&gt;</span> (<span class="type-var">'m</span>, <span class="type-var">'n</span>, <span class="type-var">'c_cd</span>) <a href="index.html#type-mat">mat</a></code></dt><dd><p><code>symm ~side ?up ?beta ?c ?alpha a b</code> executes</p><ul><li><code>c := alpha * a * b + beta * c</code> (if <code>side</code> = <a href="../Slap_common/index.html#val-left"><code>Slap_common.left</code></a>) or</li><li><code>c := alpha * b * a + beta * c</code> (if <code>side</code> = <a href="../Slap_common/index.html#val-right"><code>Slap_common.right</code></a>)</li></ul><p>where <code>a</code> is a symmterix matrix, and <code>b</code> and <code>c</code> are general matrices.</p><dl><dt>parameter side</dt><dd><p>the side flag to specify direction of multiplication of <code>a</code> and <code>b</code>.</p></dd></dl><dl><dt>parameter up</dt><dd><p>default = <a href="../Slap_common/index.html#val-upper"><code>Slap_common.upper</code></a></p><ul><li>If <code>up</code> = <a href="../Slap_common/index.html#val-upper"><code>Slap_common.upper</code></a>, then the upper triangular part of <code>a</code> is used;</li><li>If <code>up</code> = <a href="../Slap_common/index.html#val-lower"><code>Slap_common.lower</code></a>, then the lower triangular part of <code>a</code> is used.</li></ul></dd></dl><dl><dt>parameter beta</dt><dd><p>default = <code>0.0</code></p></dd></dl><dl><dt>parameter alpha</dt><dd><p>default = <code>1.0</code></p></dd></dl></dd></dl><dl><dt class="spec value" id="val-trmm"><a href="#val-trmm" class="anchor"></a><code><span class="keyword">val</span> trmm : side:(<span class="type-var">'k</span>, <span class="type-var">'m</span>, <span class="type-var">'n</span>) <a href="../Slap_common/index.html#type-side">Slap_common.side</a> <span>&#45;&gt;</span> ?&#8288;up:[&lt; `U | `L ] <a href="../Slap_common/index.html#type-uplo">Slap_common.uplo</a> <span>&#45;&gt;</span> transa:(<span class="type-var">'k</span> * <span class="type-var">'k</span>, <span class="type-var">'k</span> * <span class="type-var">'k</span>, <span class="type-var">_</span>) <a href="index.html#type-trans3">trans3</a> <span>&#45;&gt;</span> ?&#8288;diag:<a href="../Slap_common/index.html#type-diag">Slap_common.diag</a> <span>&#45;&gt;</span> ?&#8288;alpha:<a href="index.html#type-num_type">num_type</a> <span>&#45;&gt;</span> a:(<span class="type-var">'k</span>, <span class="type-var">'k</span>, <span class="type-var">'a_cd</span>) <a href="index.html#type-mat">mat</a> <span>&#45;&gt;</span> (<span class="type-var">'m</span>, <span class="type-var">'n</span>, <span class="type-var">'b_cd</span>) <a href="index.html#type-mat">mat</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>trmm ~side ?up ~transa ?diag ?alpha ~a b</code> executes</p><ul><li><code>b := alpha * OP(a) * b</code> (if <code>side</code> = <a href="../Slap_common/index.html#val-left"><code>Slap_common.left</code></a>) or</li><li><code>b := alpha * b * OP(a)</code> (if <code>side</code> = <a href="../Slap_common/index.html#val-right"><code>Slap_common.right</code></a>)</li></ul><p>where <code>a</code> is a triangular matrix, and <code>b</code> is a general matrix.</p><dl><dt>parameter side</dt><dd><p>the side flag to specify direction of multiplication of <code>a</code> and <code>b</code>.</p></dd></dl><dl><dt>parameter up</dt><dd><p>default = <a href="../Slap_common/index.html#val-upper"><code>Slap_common.upper</code></a></p><ul><li>If <code>up</code> = <a href="../Slap_common/index.html#val-upper"><code>Slap_common.upper</code></a>, then the upper triangular part of <code>a</code> is used;</li><li>If <code>up</code> = <a href="../Slap_common/index.html#val-lower"><code>Slap_common.lower</code></a>, then the lower triangular part of <code>a</code> is used.</li></ul></dd></dl><dl><dt>parameter transa</dt><dd><p>the transpose flag for <code>a</code>:</p><ul><li>If <code>transa</code> = <a href="../Slap_common/index.html#val-normal"><code>Slap_common.normal</code></a>, then <code>OP(a)</code> = <code>a</code>;</li><li>If <code>transa</code> = <a href="../Slap_common/index.html#type-trans"><code>Slap_common.trans</code></a>, then <code>OP(a)</code> = <code>a^T</code>;</li><li>If <code>transa</code> = <a href="../Slap_common/index.html#val-conjtr"><code>Slap_common.conjtr</code></a>, then <code>OP(a)</code> = <code>a^H</code> (the conjugate transpose of <code>a</code>).</li></ul></dd></dl><dl><dt>parameter diag</dt><dd><p>default = <a href="../Slap_common/index.html#val-non_unit"><code>Slap_common.non_unit</code></a></p><ul><li>If <code>diag</code> = <a href="../Slap_common/index.html#val-unit"><code>Slap_common.unit</code></a>, then <code>a</code> is unit triangular;</li><li>If <code>diag</code> = <a href="../Slap_common/index.html#val-non_unit"><code>Slap_common.non_unit</code></a>, then <code>a</code> is not unit triangular.</li></ul></dd></dl><dl><dt>parameter alpha</dt><dd><p>default = <code>1.0</code></p></dd></dl></dd></dl><dl><dt class="spec value" id="val-trsm"><a href="#val-trsm" class="anchor"></a><code><span class="keyword">val</span> trsm : side:(<span class="type-var">'k</span>, <span class="type-var">'m</span>, <span class="type-var">'n</span>) <a href="../Slap_common/index.html#type-side">Slap_common.side</a> <span>&#45;&gt;</span> ?&#8288;up:[&lt; `U | `L ] <a href="../Slap_common/index.html#type-uplo">Slap_common.uplo</a> <span>&#45;&gt;</span> transa:(<span class="type-var">'k</span> * <span class="type-var">'k</span>, <span class="type-var">'k</span> * <span class="type-var">'k</span>, <span class="type-var">_</span>) <a href="index.html#type-trans3">trans3</a> <span>&#45;&gt;</span> ?&#8288;diag:<a href="../Slap_common/index.html#type-diag">Slap_common.diag</a> <span>&#45;&gt;</span> ?&#8288;alpha:<a href="index.html#type-num_type">num_type</a> <span>&#45;&gt;</span> a:(<span class="type-var">'k</span>, <span class="type-var">'k</span>, <span class="type-var">'a_cd</span>) <a href="index.html#type-mat">mat</a> <span>&#45;&gt;</span> (<span class="type-var">'m</span>, <span class="type-var">'n</span>, <span class="type-var">'b_cd</span>) <a href="index.html#type-mat">mat</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>trsm ~side ?up ~transa ?diag ?alpha ~a b</code> solves a system of linear equations</p><ul><li><code>OP(a) * x = alpha * b</code> (if <code>side</code> = <a href="../Slap_common/index.html#val-left"><code>Slap_common.left</code></a>) or</li><li><code>x * OP(a) = alpha * b</code> (if <code>side</code> = <a href="../Slap_common/index.html#val-right"><code>Slap_common.right</code></a>)</li></ul><p>where <code>a</code> is a triangular matrix, and <code>b</code> is a general matrix. The solution <code>x</code> is returned by <code>b</code>.</p><dl><dt>parameter side</dt><dd><p>the side flag to specify direction of multiplication of <code>a</code> and <code>b</code>.</p></dd></dl><dl><dt>parameter up</dt><dd><p>default = <a href="../Slap_common/index.html#val-upper"><code>Slap_common.upper</code></a></p><ul><li>If <code>up</code> = <a href="../Slap_common/index.html#val-upper"><code>Slap_common.upper</code></a>, then the upper triangular part of <code>a</code> is used;</li><li>If <code>up</code> = <a href="../Slap_common/index.html#val-lower"><code>Slap_common.lower</code></a>, then the lower triangular part of <code>a</code> is used.</li></ul></dd></dl><dl><dt>parameter transa</dt><dd><p>the transpose flag for <code>a</code>:</p><ul><li>If <code>transa</code> = <a href="../Slap_common/index.html#val-normal"><code>Slap_common.normal</code></a>, then <code>OP(a)</code> = <code>a</code>;</li><li>If <code>transa</code> = <a href="../Slap_common/index.html#type-trans"><code>Slap_common.trans</code></a>, then <code>OP(a)</code> = <code>a^T</code>;</li><li>If <code>transa</code> = <a href="../Slap_common/index.html#val-conjtr"><code>Slap_common.conjtr</code></a>, then <code>OP(a)</code> = <code>a^H</code> (the conjugate transpose of <code>a</code>).</li></ul></dd></dl><dl><dt>parameter diag</dt><dd><p>default = <a href="../Slap_common/index.html#val-non_unit"><code>Slap_common.non_unit</code></a></p><ul><li>If <code>diag</code> = <a href="../Slap_common/index.html#val-unit"><code>Slap_common.unit</code></a>, then <code>a</code> is unit triangular;</li><li>If <code>diag</code> = <a href="../Slap_common/index.html#val-non_unit"><code>Slap_common.non_unit</code></a>, then <code>a</code> is not unit triangular.</li></ul></dd></dl><dl><dt>parameter alpha</dt><dd><p>default = <code>1.0</code></p></dd></dl></dd></dl><dl><dt class="spec value" id="val-syrk"><a href="#val-syrk" class="anchor"></a><code><span class="keyword">val</span> syrk : ?&#8288;up:[&lt; `U | `L ] <a href="../Slap_common/index.html#type-uplo">Slap_common.uplo</a> <span>&#45;&gt;</span> ?&#8288;beta:<a href="index.html#type-num_type">num_type</a> <span>&#45;&gt;</span> ?&#8288;c:(<span class="type-var">'n</span>, <span class="type-var">'n</span>, <span class="type-var">'c_cd</span>) <a href="index.html#type-mat">mat</a> <span>&#45;&gt;</span> trans:(<span class="type-var">'a_n</span> * <span class="type-var">'a_k</span>, <span class="type-var">'n</span> * <span class="type-var">'k</span>, <span class="type-var">_</span>) <a href="../Slap_common/index.html#type-trans2">Slap_common.trans2</a> <span>&#45;&gt;</span> ?&#8288;alpha:<a href="index.html#type-num_type">num_type</a> <span>&#45;&gt;</span> (<span class="type-var">'a_n</span>, <span class="type-var">'a_k</span>, <span class="type-var">'a_cd</span>) <a href="index.html#type-mat">mat</a> <span>&#45;&gt;</span> (<span class="type-var">'n</span>, <span class="type-var">'n</span>, <span class="type-var">'c_cd</span>) <a href="index.html#type-mat">mat</a></code></dt><dd><p><code>syrk ?up ?beta ?c ~trans ?alpha a</code> executes</p><ul><li><code>c := alpha * a * a^T + beta * c</code> (if <code>trans</code> = <a href="../Slap_common/index.html#val-normal"><code>Slap_common.normal</code></a>) or</li><li><code>c := alpha * a^T * a + beta * c</code> (if <code>trans</code> = <a href="../Slap_common/index.html#type-trans"><code>Slap_common.trans</code></a>)</li></ul><p>where <code>a</code> is a general matrix and <code>c</code> is a symmetric matrix.</p><dl><dt>parameter up</dt><dd><p>default = <a href="../Slap_common/index.html#val-upper"><code>Slap_common.upper</code></a></p><ul><li>If <code>up</code> = <a href="../Slap_common/index.html#val-upper"><code>Slap_common.upper</code></a>, then the upper triangular part of <code>a</code> is used;</li><li>If <code>up</code> = <a href="../Slap_common/index.html#val-lower"><code>Slap_common.lower</code></a>, then the lower triangular part of <code>a</code> is used.</li></ul></dd></dl><dl><dt>parameter beta</dt><dd><p>default = <code>0.0</code></p></dd></dl><dl><dt>parameter trans</dt><dd><p>the transpose flag for <code>a</code></p></dd></dl><dl><dt>parameter alpha</dt><dd><p>default = <code>1.0</code></p></dd></dl></dd></dl><dl><dt class="spec value" id="val-syr2k"><a href="#val-syr2k" class="anchor"></a><code><span class="keyword">val</span> syr2k : ?&#8288;up:[&lt; `U | `L ] <a href="../Slap_common/index.html#type-uplo">Slap_common.uplo</a> <span>&#45;&gt;</span> ?&#8288;beta:<a href="index.html#type-num_type">num_type</a> <span>&#45;&gt;</span> ?&#8288;c:(<span class="type-var">'n</span>, <span class="type-var">'n</span>, <span class="type-var">'c_cd</span>) <a href="index.html#type-mat">mat</a> <span>&#45;&gt;</span> trans:(<span class="type-var">'p</span> * <span class="type-var">'q</span>, <span class="type-var">'n</span> * <span class="type-var">'k</span>, <span class="type-var">_</span>) <a href="../Slap_common/index.html#type-trans2">Slap_common.trans2</a> <span>&#45;&gt;</span> ?&#8288;alpha:<a href="index.html#type-num_type">num_type</a> <span>&#45;&gt;</span> (<span class="type-var">'p</span>, <span class="type-var">'q</span>, <span class="type-var">'a_cd</span>) <a href="index.html#type-mat">mat</a> <span>&#45;&gt;</span> (<span class="type-var">'p</span>, <span class="type-var">'q</span>, <span class="type-var">'b_cd</span>) <a href="index.html#type-mat">mat</a> <span>&#45;&gt;</span> (<span class="type-var">'n</span>, <span class="type-var">'n</span>, <span class="type-var">'c_cd</span>) <a href="index.html#type-mat">mat</a></code></dt><dd><p><code>syr2k ?up ?beta ?c ~trans ?alpha a b</code> computes</p><ul><li><code>c := alpha * a * b^T + alpha * b * a^T + beta * c</code> (if <code>trans</code> = <a href="../Slap_common/index.html#val-normal"><code>Slap_common.normal</code></a>) or</li><li><code>c := alpha * a^T * b + alpha * b^T * a + beta * c</code> (if <code>trans</code> = <a href="../Slap_common/index.html#type-trans"><code>Slap_common.trans</code></a>)</li></ul><p>with symmetric matrix <code>c</code>, and general matrices <code>a</code> and <code>b</code>.</p><dl><dt>parameter up</dt><dd><p>default = <a href="../Slap_common/index.html#val-upper"><code>Slap_common.upper</code></a></p><ul><li>If <code>up</code> = <a href="../Slap_common/index.html#val-upper"><code>Slap_common.upper</code></a>, then the upper triangular part of <code>a</code> is used;</li><li>If <code>up</code> = <a href="../Slap_common/index.html#val-lower"><code>Slap_common.lower</code></a>, then the lower triangular part of <code>a</code> is used.</li></ul></dd></dl><dl><dt>parameter beta</dt><dd><p>default = <code>0.0</code></p></dd></dl><dl><dt>parameter trans</dt><dd><p>the transpose flag for <code>a</code></p></dd></dl><dl><dt>parameter alpha</dt><dd><p>default = <code>1.0</code></p></dd></dl></dd></dl></section></section><section><header><h3 id="lapack-interface"><a href="#lapack-interface" class="anchor"></a>LAPACK interface</h3></header><section><header><h4 id="auxiliary-routines"><a href="#auxiliary-routines" class="anchor"></a>Auxiliary routines</h4></header><dl><dt class="spec value" id="val-lacpy"><a href="#val-lacpy" class="anchor"></a><code><span class="keyword">val</span> lacpy : ?&#8288;uplo:[&lt; `A | `L | `U ] <a href="../Slap_common/index.html#type-uplo">Slap_common.uplo</a> <span>&#45;&gt;</span> ?&#8288;b:(<span class="type-var">'m</span>, <span class="type-var">'n</span>, <span class="type-var">'b_cd</span>) <a href="index.html#type-mat">mat</a> <span>&#45;&gt;</span> (<span class="type-var">'m</span>, <span class="type-var">'n</span>, <span class="type-var">'a_cd</span>) <a href="index.html#type-mat">mat</a> <span>&#45;&gt;</span> (<span class="type-var">'m</span>, <span class="type-var">'n</span>, <span class="type-var">'b_cd</span>) <a href="index.html#type-mat">mat</a></code></dt><dd><p><code>lacpy ?uplo ?b a</code> copies the matrix <code>a</code> into the matrix <code>b</code>.</p><dl><dt>returns</dt><dd><p><code>b</code>, which is overwritten.</p></dd></dl><dl><dt>parameter uplo</dt><dd><p>default = <a href="../Slap_common/index.html#val-upper_lower"><code>Slap_common.upper_lower</code></a></p><ul><li>If <code>uplo</code> = <a href="../Slap_common/index.html#val-upper"><code>Slap_common.upper</code></a>, then the upper triangular part of <code>a</code> is copied;</li><li>If <code>uplo</code> = <a href="../Slap_common/index.html#val-lower"><code>Slap_common.lower</code></a>, then the lower triangular part of <code>a</code> is copied.</li></ul></dd></dl><dl><dt>parameter b</dt><dd><p>default = a fresh matrix.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-lassq"><a href="#val-lassq" class="anchor"></a><code><span class="keyword">val</span> lassq : ?&#8288;scale:float <span>&#45;&gt;</span> ?&#8288;sumsq:float <span>&#45;&gt;</span> (<span class="type-var">'n</span>, <span class="type-var">'cd</span>) <a href="index.html#type-vec">vec</a> <span>&#45;&gt;</span> float * float</code></dt><dd><p><code>lassq ?scale ?sumsq x</code></p><dl><dt>returns</dt><dd><p><code>(scl, smsq)</code> where <code>scl</code> and <code>smsq</code> satisfy <code>scl^2 * smsq = x1^2 + x2^2 + ... + xn^2 + scale^2 * smsq</code>.</p></dd></dl><dl><dt>parameter scale</dt><dd><p>default = <code>0.0</code></p></dd></dl><dl><dt>parameter sumsq</dt><dd><p>default = <code>1.0</code></p></dd></dl></dd></dl><dl><dt class="spec type" id="type-larnv_liseed"><a href="#type-larnv_liseed" class="anchor"></a><code><span class="keyword">type</span> larnv_liseed</code><code> = <a href="../Slap_size/index.html#type-four">Slap_size.four</a></code></dt></dl><dl><dt class="spec value" id="val-larnv"><a href="#val-larnv" class="anchor"></a><code><span class="keyword">val</span> larnv : ?&#8288;idist:[ `Normal | `Uniform0 | `Uniform1 ] <span>&#45;&gt;</span> ?&#8288;iseed:(<a href="index.html#type-larnv_liseed">larnv_liseed</a>, <a href="../Slap_misc/index.html#type-cnt">Slap_misc.cnt</a>) <a href="../Slap_common/index.html#type-int32_vec">Slap_common.int32_vec</a> <span>&#45;&gt;</span> x:(<span class="type-var">'n</span>, <a href="../Slap_misc/index.html#type-cnt">Slap_misc.cnt</a>) <a href="index.html#type-vec">vec</a> <span>&#45;&gt;</span> unit <span>&#45;&gt;</span> (<span class="type-var">'n</span>, <span class="type-var">'cnt</span>) <a href="index.html#type-vec">vec</a></code></dt><dd><p><code>larnv ?idist ?iseed ~x ()</code> generates a random vector with the random distribution specified by <code>idist</code> and random seed <code>iseed</code>.</p><dl><dt>returns</dt><dd><p>vector <code>x</code>, which is overwritten.</p></dd></dl><dl><dt>parameter idist</dt><dd><p>default = <code>`Normal</code></p></dd></dl><dl><dt>parameter iseed</dt><dd><p>a four-dimensional integer vector with all ones.</p></dd></dl></dd></dl><dl><dt class="spec type" id="type-lange_min_lwork"><a href="#type-lange_min_lwork" class="anchor"></a><code><span class="keyword">type</span> ('m, 'a) lange_min_lwork</code></dt></dl><dl><dt class="spec value" id="val-lange_min_lwork"><a href="#val-lange_min_lwork" class="anchor"></a><code><span class="keyword">val</span> lange_min_lwork : <span class="type-var">'m</span> <a href="../Slap_size/index.html#type-t">Slap_size.t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="../Slap_common/index.html#type-norm4">Slap_common.norm4</a> <span>&#45;&gt;</span> (<span class="type-var">'m</span>, <span class="type-var">'a</span>) <a href="index.html#type-lange_min_lwork">lange_min_lwork</a> <a href="../Slap_size/index.html#type-t">Slap_size.t</a></code></dt><dd><p><code>lange_min_lwork m norm</code> computes the minimum length of workspace for <code>lange</code> routine. <code>m</code> is the number of rows in a matrix, and <code>norm</code> is the sort of matrix norms.</p></dd></dl><dl><dt class="spec value" id="val-lange"><a href="#val-lange" class="anchor"></a><code><span class="keyword">val</span> lange : ?&#8288;norm:<span class="type-var">'a</span> <a href="../Slap_common/index.html#type-norm4">Slap_common.norm4</a> <span>&#45;&gt;</span> ?&#8288;work:(<span class="type-var">'lwork</span>, <a href="../Slap_misc/index.html#type-cnt">Slap_misc.cnt</a>) <a href="index.html#type-rvec">rvec</a> <span>&#45;&gt;</span> (<span class="type-var">'m</span>, <span class="type-var">'n</span>, <span class="type-var">'cd</span>) <a href="index.html#type-mat">mat</a> <span>&#45;&gt;</span> float</code></dt><dd><p><code>lange ?norm ?work a</code></p><dl><dt>returns</dt><dd><p>the norm of matrix <code>a</code>.</p></dd></dl><dl><dt>parameter norm</dt><dd><p>default = <a href="../Slap_common/index.html#val-norm_1"><code>Slap_common.norm_1</code></a>.</p><ul><li>If <code>norm</code> = <a href="../Slap_common/index.html#val-norm_1"><code>Slap_common.norm_1</code></a>, the one norm is returned;</li><li>If <code>norm</code> = <a href="../Slap_common/index.html#val-norm_inf"><code>Slap_common.norm_inf</code></a>, the infinity norm is returned;</li><li>If <code>norm</code> = <a href="../Slap_common/index.html#val-norm_amax"><code>Slap_common.norm_amax</code></a>, the largest absolute value of elements in matrix <code>a</code> (not a matrix norm) is returned;</li><li>If <code>norm</code> = <a href="../Slap_common/index.html#val-norm_frob"><code>Slap_common.norm_frob</code></a>, the Frobenius norm is returned.</li></ul></dd></dl><dl><dt>parameter work</dt><dd><p>default = an optimum-length vector.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-lauum"><a href="#val-lauum" class="anchor"></a><code><span class="keyword">val</span> lauum : ?&#8288;up:[&lt; `U | `L ] <a href="../Slap_common/index.html#type-uplo">Slap_common.uplo</a> <span>&#45;&gt;</span> (<span class="type-var">'n</span>, <span class="type-var">'n</span>, <span class="type-var">'cd</span>) <a href="index.html#type-mat">mat</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>lauum ?up a</code> computes</p><ul><li><code>U * U^T</code> where <code>U</code> is the upper triangular part of matrix <code>a</code> if <code>up</code> is <a href="../Slap_common/index.html#val-upper"><code>Slap_common.upper</code></a>.</li><li><code>L^T * L</code> where <code>L</code> is the lower triangular part of matrix <code>a</code> if <code>up</code> is <a href="../Slap_common/index.html#val-lower"><code>Slap_common.lower</code></a>.</li></ul><p>The upper or lower triangular part is overwritten.</p><dl><dt>parameter up</dt><dd><p>default = <a href="../Slap_common/index.html#val-upper"><code>Slap_common.upper</code></a></p><ul><li>If <code>up</code> = <a href="../Slap_common/index.html#val-upper"><code>Slap_common.upper</code></a>, then the upper triangular part of <code>a</code> is used;</li><li>If <code>up</code> = <a href="../Slap_common/index.html#val-lower"><code>Slap_common.lower</code></a>, then the lower triangular part of <code>a</code> is used.</li></ul></dd></dl></dd></dl></section><section><header><h4 id="linear-equations-(computational-routines)"><a href="#linear-equations-(computational-routines)" class="anchor"></a>Linear equations (computational routines)</h4></header><dl><dt class="spec value" id="val-getrf"><a href="#val-getrf" class="anchor"></a><code><span class="keyword">val</span> getrf : ?&#8288;ipiv:((<span class="type-var">'m</span>, <span class="type-var">'n</span>) <a href="../Slap_size/index.html#type-min">Slap_size.min</a>, <a href="../Slap_misc/index.html#type-cnt">Slap_misc.cnt</a>) <a href="../Slap_common/index.html#type-int32_vec">Slap_common.int32_vec</a> <span>&#45;&gt;</span> (<span class="type-var">'m</span>, <span class="type-var">'n</span>, <span class="type-var">'cd</span>) <a href="index.html#type-mat">mat</a> <span>&#45;&gt;</span> ((<span class="type-var">'m</span>, <span class="type-var">'n</span>) <a href="../Slap_size/index.html#type-min">Slap_size.min</a>, <span class="type-var">'cnt</span>) <a href="../Slap_common/index.html#type-int32_vec">Slap_common.int32_vec</a></code></dt><dd><p><code>getrf ?ipiv a</code> computes LU factorization of matrix <code>a</code> using partial pivoting with row interchanges: <code>a = P * L * U</code> where <code>P</code> is a permutation matrix, and <code>L</code> and <code>U</code> are lower and upper triangular matrices, respectively. the permutation matrix is returned in <code>ipiv</code>.</p><dl><dt>returns</dt><dd><p>vector <code>ipiv</code>, which is overwritten.</p></dd></dl><dl><dt>raises Failure</dt><dd><p>if the matrix is singular.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-getrs"><a href="#val-getrs" class="anchor"></a><code><span class="keyword">val</span> getrs : ?&#8288;ipiv:((<span class="type-var">'n</span>, <span class="type-var">'n</span>) <a href="../Slap_size/index.html#type-min">Slap_size.min</a>, <a href="../Slap_misc/index.html#type-cnt">Slap_misc.cnt</a>) <a href="../Slap_common/index.html#type-int32_vec">Slap_common.int32_vec</a> <span>&#45;&gt;</span> trans:(<span class="type-var">'n</span> * <span class="type-var">'n</span>, <span class="type-var">'n</span> * <span class="type-var">'n</span>, <span class="type-var">_</span>) <a href="index.html#type-trans3">trans3</a> <span>&#45;&gt;</span> (<span class="type-var">'n</span>, <span class="type-var">'n</span>, <span class="type-var">'a_cd</span>) <a href="index.html#type-mat">mat</a> <span>&#45;&gt;</span> (<span class="type-var">'n</span>, <span class="type-var">'nrhs</span>, <span class="type-var">'b_cd</span>) <a href="index.html#type-mat">mat</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>getrs ?ipiv trans a b</code> solves systems of linear equations <code>OP(a) * x = b</code> where <code>a</code> a <code>'n</code>-by-<code>'n</code> general matrix, each column of matrix <code>b</code> is the r.h.s. vector, and each column of matrix <code>x</code> is the corresponding solution. The solution <code>x</code> is returned in <code>b</code>.</p><dl><dt>parameter ipiv</dt><dd><p>a result of <code>gesv</code> or <code>getrf</code>. It is internally computed by <code>getrf</code> if omitted.</p></dd></dl><dl><dt>parameter trans</dt><dd><p>the transpose flag for <code>a</code>:</p><ul><li>If <code>trans</code> = <a href="../Slap_common/index.html#val-normal"><code>Slap_common.normal</code></a>, then <code>OP(a)</code> = <code>a</code>;</li><li>If <code>trans</code> = <a href="../Slap_common/index.html#type-trans"><code>Slap_common.trans</code></a>, then <code>OP(a)</code> = <code>a^T</code>;</li><li>If <code>trans</code> = <a href="../Slap_common/index.html#val-conjtr"><code>Slap_common.conjtr</code></a>, then <code>OP(a)</code> = <code>a^H</code> (the conjugate transpose of <code>a</code>).</li></ul></dd></dl><dl><dt>raises Failure</dt><dd><p>if the matrix is singular.</p></dd></dl></dd></dl><dl><dt class="spec type" id="type-getri_min_lwork"><a href="#type-getri_min_lwork" class="anchor"></a><code><span class="keyword">type</span> 'n getri_min_lwork</code></dt></dl><dl><dt class="spec value" id="val-getri_min_lwork"><a href="#val-getri_min_lwork" class="anchor"></a><code><span class="keyword">val</span> getri_min_lwork : <span class="type-var">'n</span> <a href="../Slap_size/index.html#type-t">Slap_size.t</a> <span>&#45;&gt;</span> <span class="type-var">'n</span> <a href="index.html#type-getri_min_lwork">getri_min_lwork</a> <a href="../Slap_size/index.html#type-t">Slap_size.t</a></code></dt><dd><p><code>getri_min_lwork n</code> computes the minimum length of workspace for <code>getri</code> routine. <code>n</code> is the number of columns or rows in a matrix.</p></dd></dl><dl><dt class="spec value" id="val-getri_opt_lwork"><a href="#val-getri_opt_lwork" class="anchor"></a><code><span class="keyword">val</span> getri_opt_lwork : (<span class="type-var">'n</span>, <span class="type-var">'n</span>, <span class="type-var">'cd</span>) <a href="index.html#type-mat">mat</a> <span>&#45;&gt;</span> (<span class="keyword">module</span> <a href="../Slap_size/module-type-SIZE/index.html">Slap_size.SIZE</a>)</code></dt><dd><p><code>getri_opt_lwork a</code> computes the optimal length of workspace for <code>getri</code> routine.</p></dd></dl><dl><dt class="spec value" id="val-getri"><a href="#val-getri" class="anchor"></a><code><span class="keyword">val</span> getri : ?&#8288;ipiv:((<span class="type-var">'n</span>, <span class="type-var">'n</span>) <a href="../Slap_size/index.html#type-min">Slap_size.min</a>, <a href="../Slap_misc/index.html#type-cnt">Slap_misc.cnt</a>) <a href="../Slap_common/index.html#type-int32_vec">Slap_common.int32_vec</a> <span>&#45;&gt;</span> ?&#8288;work:(<span class="type-var">'lwork</span>, <a href="../Slap_misc/index.html#type-cnt">Slap_misc.cnt</a>) <a href="index.html#type-vec">vec</a> <span>&#45;&gt;</span> (<span class="type-var">'n</span>, <span class="type-var">'n</span>, <span class="type-var">'cd</span>) <a href="index.html#type-mat">mat</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>getri ?ipiv ?work a</code> computes the inverse of general matrix <code>a</code> by LU-factorization. The inverse matrix is returned in <code>a</code>.</p><dl><dt>parameter ipiv</dt><dd><p>a result of <code>gesv</code> or <code>getrf</code>. It is internally computed by <code>getrf</code> if omitted.</p></dd></dl><dl><dt>parameter work</dt><dd><p>default = an optimum-length vector.</p></dd></dl><dl><dt>raises Failure</dt><dd><p>if the matrix is singular.</p></dd></dl></dd></dl><dl><dt class="spec type" id="type-sytrf_min_lwork"><a href="#type-sytrf_min_lwork" class="anchor"></a><code><span class="keyword">type</span> sytrf_min_lwork</code></dt></dl><dl><dt class="spec value" id="val-sytrf_min_lwork"><a href="#val-sytrf_min_lwork" class="anchor"></a><code><span class="keyword">val</span> sytrf_min_lwork : unit <span>&#45;&gt;</span> <a href="index.html#type-sytrf_min_lwork">sytrf_min_lwork</a> <a href="../Slap_size/index.html#type-t">Slap_size.t</a></code></dt><dd><p><code>sytrf_min_lwork ()</code> computes the minimum length of workspace for <code>sytrf</code> routine.</p></dd></dl><dl><dt class="spec value" id="val-sytrf_opt_lwork"><a href="#val-sytrf_opt_lwork" class="anchor"></a><code><span class="keyword">val</span> sytrf_opt_lwork : ?&#8288;up:[&lt; `U | `L ] <a href="../Slap_common/index.html#type-uplo">Slap_common.uplo</a> <span>&#45;&gt;</span> (<span class="type-var">'n</span>, <span class="type-var">'n</span>, <span class="type-var">'cd</span>) <a href="index.html#type-mat">mat</a> <span>&#45;&gt;</span> (<span class="keyword">module</span> <a href="../Slap_size/module-type-SIZE/index.html">Slap_size.SIZE</a>)</code></dt><dd><p><code>sytrf_opt_lwork ?up a</code> computes the optimal length of workspace for <code>sytrf</code> routine.</p><dl><dt>parameter up</dt><dd><p>default = <code>true</code></p><ul><li>If <code>up</code> = <code>true</code>, then the upper triangular part of <code>a</code> is used;</li><li>If <code>up</code> = <code>false</code>, then the lower triangular part of <code>a</code> is used.</li></ul></dd></dl></dd></dl><dl><dt class="spec value" id="val-sytrf"><a href="#val-sytrf" class="anchor"></a><code><span class="keyword">val</span> sytrf : ?&#8288;up:[&lt; `U | `L ] <a href="../Slap_common/index.html#type-uplo">Slap_common.uplo</a> <span>&#45;&gt;</span> ?&#8288;ipiv:(<span class="type-var">'n</span>, <a href="../Slap_misc/index.html#type-cnt">Slap_misc.cnt</a>) <a href="../Slap_common/index.html#type-int32_vec">Slap_common.int32_vec</a> <span>&#45;&gt;</span> ?&#8288;work:(<span class="type-var">'lwork</span>, <a href="../Slap_misc/index.html#type-cnt">Slap_misc.cnt</a>) <a href="index.html#type-vec">vec</a> <span>&#45;&gt;</span> (<span class="type-var">'n</span>, <span class="type-var">'n</span>, <span class="type-var">'cd</span>) <a href="index.html#type-mat">mat</a> <span>&#45;&gt;</span> (<span class="type-var">'n</span>, <span class="type-var">'cnt</span>) <a href="../Slap_common/index.html#type-int32_vec">Slap_common.int32_vec</a></code></dt><dd><p><code>sytrf ?up ?ipiv ?work a</code> factorizes symmetric matrix <code>a</code> using the Bunch-Kaufman diagonal pivoting method:</p><ul><li><code>a = P * U * D * U^T * P^T</code> if <code>up</code> = <code>true</code>;</li><li><code>a = P * L * D * L^T * P^T</code> if <code>up</code> = <code>false</code></li></ul><p>where <code>P</code> is a permutation matrix, <code>U</code> and <code>L</code> are upper and lower triangular matrices with unit diagonal, and <code>D</code> is a symmetric block-diagonal matrix. The permutation matrix is returned in <code>ipiv</code>.</p><dl><dt>returns</dt><dd><p>vector <code>ipiv</code>, which is overwritten.</p></dd></dl><dl><dt>parameter up</dt><dd><p>default = <a href="../Slap_common/index.html#val-upper"><code>Slap_common.upper</code></a></p><ul><li>If <code>up</code> = <a href="../Slap_common/index.html#val-upper"><code>Slap_common.upper</code></a>, then the upper triangular part of <code>a</code> is used;</li><li>If <code>up</code> = <a href="../Slap_common/index.html#val-lower"><code>Slap_common.lower</code></a>, then the lower triangular part of <code>a</code> is used.</li></ul></dd></dl><dl><dt>parameter work</dt><dd><p>default = an optimum-length vector.</p></dd></dl><dl><dt>raises Failure</dt><dd><p>if <code>a</code> is singular.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-sytrs"><a href="#val-sytrs" class="anchor"></a><code><span class="keyword">val</span> sytrs : ?&#8288;up:[&lt; `U | `L ] <a href="../Slap_common/index.html#type-uplo">Slap_common.uplo</a> <span>&#45;&gt;</span> ?&#8288;ipiv:(<span class="type-var">'n</span>, <a href="../Slap_misc/index.html#type-cnt">Slap_misc.cnt</a>) <a href="../Slap_common/index.html#type-int32_vec">Slap_common.int32_vec</a> <span>&#45;&gt;</span> (<span class="type-var">'n</span>, <span class="type-var">'n</span>, <span class="type-var">'a_cd</span>) <a href="index.html#type-mat">mat</a> <span>&#45;&gt;</span> (<span class="type-var">'n</span>, <span class="type-var">'nrhs</span>, <span class="type-var">'b_cd</span>) <a href="index.html#type-mat">mat</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>sytrs ?up ?ipiv a b</code> solves systems of linear equations <code>a * x = b</code> where <code>a</code> is a symmetric matrix, each column of matrix <code>b</code> is the r.h.s. vector, and each column of matrix <code>x</code> is the corresponding solution. The solution <code>x</code> is returned in <code>b</code>.</p><p>This routine uses the Bunch-Kaufman diagonal pivoting method:</p><ul><li><code>a = P * U * D * U^T * P^T</code> if <code>up</code> = <code>true</code>;</li><li><code>a = P * L * D * L^T * P^T</code> if <code>up</code> = <code>false</code></li></ul><p>where <code>P</code> is a permutation matrix, <code>U</code> and <code>L</code> are upper and lower triangular matrices with unit diagonal, and <code>D</code> is a symmetric block-diagonal matrix.</p><dl><dt>parameter up</dt><dd><p>default = <a href="../Slap_common/index.html#val-upper"><code>Slap_common.upper</code></a></p><ul><li>If <code>up</code> = <a href="../Slap_common/index.html#val-upper"><code>Slap_common.upper</code></a>, then the upper triangular part of <code>a</code> is used;</li><li>If <code>up</code> = <a href="../Slap_common/index.html#val-lower"><code>Slap_common.lower</code></a>, then the lower triangular part of <code>a</code> is used.</li></ul></dd></dl><dl><dt>parameter ipiv</dt><dd><p>a result of <code>sytrf</code>. It is internally computed by <code>sytrf</code> if omitted.</p></dd></dl><dl><dt>raises Failure</dt><dd><p>if <code>a</code> is singular.</p></dd></dl></dd></dl><dl><dt class="spec type" id="type-sytri_min_lwork"><a href="#type-sytri_min_lwork" class="anchor"></a><code><span class="keyword">type</span> 'n sytri_min_lwork</code></dt></dl><dl><dt class="spec value" id="val-sytri_min_lwork"><a href="#val-sytri_min_lwork" class="anchor"></a><code><span class="keyword">val</span> sytri_min_lwork : <span class="type-var">'n</span> <a href="../Slap_size/index.html#type-t">Slap_size.t</a> <span>&#45;&gt;</span> <span class="type-var">'n</span> <a href="index.html#type-sytri_min_lwork">sytri_min_lwork</a> <a href="../Slap_size/index.html#type-t">Slap_size.t</a></code></dt><dd><p><code>sytri_min_lwork ()</code> computes the minimum length of workspace for <code>sytri</code> routine.</p></dd></dl><dl><dt class="spec value" id="val-sytri"><a href="#val-sytri" class="anchor"></a><code><span class="keyword">val</span> sytri : ?&#8288;up:[&lt; `U | `L ] <a href="../Slap_common/index.html#type-uplo">Slap_common.uplo</a> <span>&#45;&gt;</span> ?&#8288;ipiv:(<span class="type-var">'n</span>, <a href="../Slap_misc/index.html#type-cnt">Slap_misc.cnt</a>) <a href="../Slap_common/index.html#type-int32_vec">Slap_common.int32_vec</a> <span>&#45;&gt;</span> ?&#8288;work:(<span class="type-var">'lwork</span>, <a href="../Slap_misc/index.html#type-cnt">Slap_misc.cnt</a>) <a href="index.html#type-vec">vec</a> <span>&#45;&gt;</span> (<span class="type-var">'n</span>, <span class="type-var">'n</span>, <span class="type-var">'cd</span>) <a href="index.html#type-mat">mat</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>sytri ?up ?ipiv ?work a</code> computes the inverse of symmetric matrix <code>a</code> using the Bunch-Kaufman diagonal pivoting method:</p><ul><li><code>a = P * U * D * U^T * P^T</code> if <code>up</code> = <code>true</code>;</li><li><code>a = P * L * D * L^T * P^T</code> if <code>up</code> = <code>false</code></li></ul><p>where <code>P</code> is a permutation matrix, <code>U</code> and <code>L</code> are upper and lower triangular matrices with unit diagonal, and <code>D</code> is a symmetric block-diagonal matrix.</p><dl><dt>parameter up</dt><dd><p>default = <a href="../Slap_common/index.html#val-upper"><code>Slap_common.upper</code></a></p><ul><li>If <code>up</code> = <a href="../Slap_common/index.html#val-upper"><code>Slap_common.upper</code></a>, then the upper triangular part of <code>a</code> is used;</li><li>If <code>up</code> = <a href="../Slap_common/index.html#val-lower"><code>Slap_common.lower</code></a>, then the lower triangular part of <code>a</code> is used.</li></ul></dd></dl><dl><dt>parameter ipiv</dt><dd><p>a result of <code>sytrf</code>. It is internally computed by <code>sytrf</code> if omitted.</p></dd></dl><dl><dt>parameter work</dt><dd><p>default = an optimum-length vector.</p></dd></dl><dl><dt>raises Failure</dt><dd><p>if <code>a</code> is singular.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-potrf"><a href="#val-potrf" class="anchor"></a><code><span class="keyword">val</span> potrf : ?&#8288;up:[&lt; `U | `L ] <a href="../Slap_common/index.html#type-uplo">Slap_common.uplo</a> <span>&#45;&gt;</span> ?&#8288;jitter:<a href="index.html#type-num_type">num_type</a> <span>&#45;&gt;</span> (<span class="type-var">'n</span>, <span class="type-var">'n</span>, <span class="type-var">'cd</span>) <a href="index.html#type-mat">mat</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>potrf ?up ?jitter a</code> computes the Cholesky factorization of symmetrix (Hermitian) positive-definite matrix <code>a</code>:</p><ul><li><code>a = U^T * U</code> (real) or <code>a = U^H * U</code> (complex) if <code>up</code> = <code>true</code>;</li><li><code>a = L * L^T</code> (real) or <code>a = L * L^H</code> (complex) if <code>up</code> = <code>false</code></li></ul><p>where <code>U</code> and <code>L</code> are upper and lower triangular matrices, respectively. Either of them is returned in the upper or lower triangular part of <code>a</code>, as specified by <code>up</code>.</p><dl><dt>parameter up</dt><dd><p>default = <a href="../Slap_common/index.html#val-upper"><code>Slap_common.upper</code></a></p><ul><li>If <code>up</code> = <a href="../Slap_common/index.html#val-upper"><code>Slap_common.upper</code></a>, then the upper triangular part of <code>a</code> is used;</li><li>If <code>up</code> = <a href="../Slap_common/index.html#val-lower"><code>Slap_common.lower</code></a>, then the lower triangular part of <code>a</code> is used.</li></ul></dd></dl><dl><dt>parameter jitter</dt><dd><p>default = nothing</p></dd></dl><dl><dt>raises Failure</dt><dd><p>if <code>a</code> is not positive-definite symmetric.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-potrs"><a href="#val-potrs" class="anchor"></a><code><span class="keyword">val</span> potrs : ?&#8288;up:[&lt; `U | `L ] <a href="../Slap_common/index.html#type-uplo">Slap_common.uplo</a> <span>&#45;&gt;</span> (<span class="type-var">'n</span>, <span class="type-var">'n</span>, <span class="type-var">'a_cd</span>) <a href="index.html#type-mat">mat</a> <span>&#45;&gt;</span> ?&#8288;factorize:bool <span>&#45;&gt;</span> ?&#8288;jitter:<a href="index.html#type-num_type">num_type</a> <span>&#45;&gt;</span> (<span class="type-var">'n</span>, <span class="type-var">'nrhs</span>, <span class="type-var">'b_cd</span>) <a href="index.html#type-mat">mat</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>potrf ?up a ?jitter b</code> solves systems of linear equations <code>a * x = b</code> using the Cholesky factorization of symmetrix (Hermitian) positive-definite matrix <code>a</code>:</p><ul><li><code>a = U^T * U</code> (real) or <code>a = U^H * U</code> (complex) if <code>up</code> = <a href="../Slap_common/index.html#val-upper"><code>Slap_common.upper</code></a>;</li><li><code>a = L * L^T</code> (real) or <code>a = L * L^H</code> (complex) if <code>up</code> = <a href="../Slap_common/index.html#val-lower"><code>Slap_common.lower</code></a></li></ul><p>where <code>U</code> and <code>L</code> are upper and lower triangular matrices, respectively.</p><dl><dt>parameter up</dt><dd><p>default = <a href="../Slap_common/index.html#val-upper"><code>Slap_common.upper</code></a></p><ul><li>If <code>up</code> = <a href="../Slap_common/index.html#val-upper"><code>Slap_common.upper</code></a>, then the upper triangular part of <code>a</code> is used;</li><li>If <code>up</code> = <a href="../Slap_common/index.html#val-lower"><code>Slap_common.lower</code></a>, then the lower triangular part of <code>a</code> is used.</li></ul></dd></dl><dl><dt>parameter factorize</dt><dd><p>default = <code>true</code> (<code>potrf</code> is called implicitly)</p></dd></dl><dl><dt>parameter jitter</dt><dd><p>default = nothing</p></dd></dl><dl><dt>raises Failure</dt><dd><p>if <code>a</code> is singular.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-potri"><a href="#val-potri" class="anchor"></a><code><span class="keyword">val</span> potri : ?&#8288;up:[&lt; `U | `L ] <a href="../Slap_common/index.html#type-uplo">Slap_common.uplo</a> <span>&#45;&gt;</span> ?&#8288;factorize:bool <span>&#45;&gt;</span> ?&#8288;jitter:<a href="index.html#type-num_type">num_type</a> <span>&#45;&gt;</span> (<span class="type-var">'n</span>, <span class="type-var">'n</span>, <span class="type-var">'cd</span>) <a href="index.html#type-mat">mat</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>potrf ?up ?jitter a</code> computes the inverse of symmetrix (Hermitian) positive-definite matrix <code>a</code> using the Cholesky factorization:</p><ul><li><code>a = U^T * U</code> (real) or <code>a = U^H * U</code> (complex) if <code>up</code> = <a href="../Slap_common/index.html#val-upper"><code>Slap_common.upper</code></a>;</li><li><code>a = L * L^T</code> (real) or <code>a = L * L^H</code> (complex) if <code>up</code> = <a href="../Slap_common/index.html#val-lower"><code>Slap_common.lower</code></a></li></ul><p>where <code>U</code> and <code>L</code> are upper and lower triangular matrices, respectively.</p><dl><dt>parameter up</dt><dd><p>default = <a href="../Slap_common/index.html#val-upper"><code>Slap_common.upper</code></a></p><ul><li>If <code>up</code> = <a href="../Slap_common/index.html#val-upper"><code>Slap_common.upper</code></a>, then the upper triangular part of <code>a</code> is used;</li><li>If <code>up</code> = <a href="../Slap_common/index.html#val-lower"><code>Slap_common.lower</code></a>, then the lower triangular part of <code>a</code> is used.</li></ul></dd></dl><dl><dt>parameter factorize</dt><dd><p>default = <code>true</code> (<code>potrf</code> is called implicitly)</p></dd></dl><dl><dt>parameter jitter</dt><dd><p>default = nothing</p></dd></dl><dl><dt>raises Failure</dt><dd><p>if <code>a</code> is singular.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-trtrs"><a href="#val-trtrs" class="anchor"></a><code><span class="keyword">val</span> trtrs : ?&#8288;up:[&lt; `U | `L ] <a href="../Slap_common/index.html#type-uplo">Slap_common.uplo</a> <span>&#45;&gt;</span> trans:(<span class="type-var">'n</span> * <span class="type-var">'n</span>, <span class="type-var">'n</span> * <span class="type-var">'n</span>, <span class="type-var">_</span>) <a href="index.html#type-trans3">trans3</a> <span>&#45;&gt;</span> ?&#8288;diag:<a href="../Slap_common/index.html#type-diag">Slap_common.diag</a> <span>&#45;&gt;</span> (<span class="type-var">'n</span>, <span class="type-var">'n</span>, <span class="type-var">'a_cd</span>) <a href="index.html#type-mat">mat</a> <span>&#45;&gt;</span> (<span class="type-var">'n</span>, <span class="type-var">'nrhs</span>, <span class="type-var">'b_cd</span>) <a href="index.html#type-mat">mat</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>trtrs ?up trans ?diag a b</code> solves systems of linear equations <code>OP(a) * x = b</code> where <code>a</code> is a triangular matrix of order <code>'n</code>, each column of matrix <code>b</code> is the r.h.s vector, and each column of matrix <code>x</code> is the corresponding solution. The solution <code>x</code> is returned in <code>b</code>.</p><dl><dt>parameter up</dt><dd><p>default = <a href="../Slap_common/index.html#val-upper"><code>Slap_common.upper</code></a></p><ul><li>If <code>up</code> = <a href="../Slap_common/index.html#val-upper"><code>Slap_common.upper</code></a>, then the upper triangular part of <code>a</code> is used;</li><li>If <code>up</code> = <a href="../Slap_common/index.html#val-lower"><code>Slap_common.lower</code></a>, then the lower triangular part of <code>a</code> is used.</li></ul></dd></dl><dl><dt>parameter trans</dt><dd><p>the transpose flag for <code>a</code>:</p><ul><li>If <code>trans</code> = <a href="../Slap_common/index.html#val-normal"><code>Slap_common.normal</code></a>, then <code>OP(a)</code> = <code>a</code>;</li><li>If <code>trans</code> = <a href="../Slap_common/index.html#type-trans"><code>Slap_common.trans</code></a>, then <code>OP(a)</code> = <code>a^T</code>;</li><li>If <code>trans</code> = <a href="../Slap_common/index.html#val-conjtr"><code>Slap_common.conjtr</code></a>, then <code>OP(a)</code> = <code>a^H</code> (the conjugate transpose of <code>a</code>).</li></ul></dd></dl><dl><dt>parameter diag</dt><dd><p>default = <code>`N</code></p><ul><li>If <code>diag</code> = <code>`U</code>, then <code>a</code> is unit triangular;</li><li>If <code>diag</code> = <code>`N</code>, then <code>a</code> is not unit triangular.</li></ul></dd></dl><dl><dt>raises Failure</dt><dd><p>if <code>a</code> is singular.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-tbtrs"><a href="#val-tbtrs" class="anchor"></a><code><span class="keyword">val</span> tbtrs : kd:<span class="type-var">'kd</span> <a href="../Slap_size/index.html#type-t">Slap_size.t</a> <span>&#45;&gt;</span> ?&#8288;up:[&lt; `U | `L ] <a href="../Slap_common/index.html#type-uplo">Slap_common.uplo</a> <span>&#45;&gt;</span> trans:(<span class="type-var">'n</span> * <span class="type-var">'n</span>, <span class="type-var">'n</span> * <span class="type-var">'n</span>, <span class="type-var">_</span>) <a href="index.html#type-trans3">trans3</a> <span>&#45;&gt;</span> ?&#8288;diag:<a href="../Slap_common/index.html#type-diag">Slap_common.diag</a> <span>&#45;&gt;</span> ((<span class="type-var">'n</span>, <span class="type-var">'kd</span>) <a href="../Slap_size/index.html#type-syband">Slap_size.syband</a>, <span class="type-var">'n</span>, <span class="type-var">'a_cd</span>) <a href="index.html#type-mat">mat</a> <span>&#45;&gt;</span> (<span class="type-var">'n</span>, <span class="type-var">'nrhs</span>, <span class="type-var">'b_cd</span>) <a href="index.html#type-mat">mat</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>tbtrs ~kd ?up ~trans ?diag ab b</code> solves systems of linear equations <code>OP(A) * x = b</code> where <code>A</code> is a triangular band matrix with <code>kd</code> subdiagonals, each column of matrix <code>b</code> is the r.h.s vector, and each column of matrix <code>x</code> is the corresponding solution. Matrix <code>A</code> is stored into <code>ab</code> in band storage format. The solution <code>x</code> is returned in <code>b</code>.</p><dl><dt>parameter kd</dt><dd><p>the number of subdiagonals or superdiagonals in <code>A</code>.</p></dd></dl><dl><dt>parameter up</dt><dd><p>default = <a href="../Slap_common/index.html#val-upper"><code>Slap_common.upper</code></a></p><ul><li>If <code>up</code> = <a href="../Slap_common/index.html#val-upper"><code>Slap_common.upper</code></a>, then the upper triangular part of <code>A</code> is used;</li><li>If <code>up</code> = <a href="../Slap_common/index.html#val-lower"><code>Slap_common.lower</code></a>, then the lower triangular part of <code>A</code> is used.</li></ul></dd></dl><dl><dt>parameter trans</dt><dd><p>the transpose flag for <code>A</code>:</p><ul><li>If <code>trans</code> = <a href="../Slap_common/index.html#val-normal"><code>Slap_common.normal</code></a>, then <code>OP(A)</code> = <code>A</code>;</li><li>If <code>trans</code> = <a href="../Slap_common/index.html#type-trans"><code>Slap_common.trans</code></a>, then <code>OP(A)</code> = <code>A^T</code>;</li><li>If <code>trans</code> = <a href="../Slap_common/index.html#val-conjtr"><code>Slap_common.conjtr</code></a>, then <code>OP(A)</code> = <code>A^H</code> (the conjugate transpose of <code>A</code>).</li></ul></dd></dl><dl><dt>parameter diag</dt><dd><p>default = <code>`N</code></p><ul><li>If <code>diag</code> = <code>`U</code>, then <code>A</code> is unit triangular;</li><li>If <code>diag</code> = <code>`N</code>, then <code>A</code> is not unit triangular.</li></ul></dd></dl><dl><dt>raises Failure</dt><dd><p>if the matrix <code>A</code> is singular.</p></dd></dl><dl><dt>since</dt><dd>0.2.0</dd></dl></dd></dl><dl><dt class="spec value" id="val-trtri"><a href="#val-trtri" class="anchor"></a><code><span class="keyword">val</span> trtri : ?&#8288;up:[&lt; `U | `L ] <a href="../Slap_common/index.html#type-uplo">Slap_common.uplo</a> <span>&#45;&gt;</span> ?&#8288;diag:<a href="../Slap_common/index.html#type-diag">Slap_common.diag</a> <span>&#45;&gt;</span> (<span class="type-var">'n</span>, <span class="type-var">'n</span>, <span class="type-var">'cd</span>) <a href="index.html#type-mat">mat</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>trtri ?up ?diag a</code> computes the inverse of triangular matrix <code>a</code>. The inverse matrix is returned in <code>a</code>.</p><dl><dt>parameter up</dt><dd><p>default = <a href="../Slap_common/index.html#val-upper"><code>Slap_common.upper</code></a></p><ul><li>If <code>up</code> = <a href="../Slap_common/index.html#val-upper"><code>Slap_common.upper</code></a>, then the upper triangular part of <code>A</code> is used;</li><li>If <code>up</code> = <a href="../Slap_common/index.html#val-lower"><code>Slap_common.lower</code></a>, then the lower triangular part of <code>A</code> is used.</li></ul></dd></dl><dl><dt>parameter diag</dt><dd><p>default = <code>`N</code></p><ul><li>If <code>diag</code> = <code>`U</code>, then <code>a</code> is unit triangular;</li><li>If <code>diag</code> = <code>`N</code>, then <code>a</code> is not unit triangular.</li></ul></dd></dl><dl><dt>raises Failure</dt><dd><p>if the matrix <code>a</code> is singular.</p></dd></dl><dl><dt>since</dt><dd>0.2.0</dd></dl></dd></dl><dl><dt class="spec type" id="type-geqrf_min_lwork"><a href="#type-geqrf_min_lwork" class="anchor"></a><code><span class="keyword">type</span> 'n geqrf_min_lwork</code></dt></dl><dl><dt class="spec value" id="val-geqrf_min_lwork"><a href="#val-geqrf_min_lwork" class="anchor"></a><code><span class="keyword">val</span> geqrf_min_lwork : n:<span class="type-var">'n</span> <a href="../Slap_size/index.html#type-t">Slap_size.t</a> <span>&#45;&gt;</span> <span class="type-var">'n</span> <a href="index.html#type-geqrf_min_lwork">geqrf_min_lwork</a> <a href="../Slap_size/index.html#type-t">Slap_size.t</a></code></dt><dd><p><code>geqrf_min_lwork ~n</code> computes the minimum length of workspace for <code>geqrf</code> routine. <code>n</code> is the number of columns in a matrix.</p></dd></dl><dl><dt class="spec value" id="val-geqrf_opt_lwork"><a href="#val-geqrf_opt_lwork" class="anchor"></a><code><span class="keyword">val</span> geqrf_opt_lwork : (<span class="type-var">'m</span>, <span class="type-var">'n</span>, <span class="type-var">'cd</span>) <a href="index.html#type-mat">mat</a> <span>&#45;&gt;</span> (<span class="keyword">module</span> <a href="../Slap_size/module-type-SIZE/index.html">Slap_size.SIZE</a>)</code></dt><dd><p><code>geqrf_opt_lwork a</code> computes the optimum length of workspace for <code>geqrf</code> routine.</p></dd></dl><dl><dt class="spec value" id="val-geqrf"><a href="#val-geqrf" class="anchor"></a><code><span class="keyword">val</span> geqrf : ?&#8288;work:(<span class="type-var">'lwork</span>, <a href="../Slap_misc/index.html#type-cnt">Slap_misc.cnt</a>) <a href="index.html#type-vec">vec</a> <span>&#45;&gt;</span> ?&#8288;tau:((<span class="type-var">'m</span>, <span class="type-var">'n</span>) <a href="../Slap_size/index.html#type-min">Slap_size.min</a>, <a href="../Slap_misc/index.html#type-cnt">Slap_misc.cnt</a>) <a href="index.html#type-vec">vec</a> <span>&#45;&gt;</span> (<span class="type-var">'m</span>, <span class="type-var">'n</span>, <span class="type-var">'cd</span>) <a href="index.html#type-mat">mat</a> <span>&#45;&gt;</span> ((<span class="type-var">'m</span>, <span class="type-var">'n</span>) <a href="../Slap_size/index.html#type-min">Slap_size.min</a>, <span class="type-var">'cnt</span>) <a href="index.html#type-vec">vec</a></code></dt><dd><p><code>geqrf ?work ?tau a</code> computes the QR factorization of general matrix <code>a</code>: <code>a = Q * R</code> where <code>Q</code> is an orthogonal (unitary) matrix and <code>R</code> is an upper triangular matrix. <code>R</code> is returned in <code>a</code>. This routine does not generate <code>Q</code> explicitly. It is generated by <code>orgqr</code>.</p><dl><dt>returns</dt><dd><p>vector <code>tau</code>, which is overwritten.</p></dd></dl><dl><dt>parameter work</dt><dd><p>default = an optimum-length vector.</p></dd></dl></dd></dl></section><section><header><h4 id="linear-equations-(simple-drivers)"><a href="#linear-equations-(simple-drivers)" class="anchor"></a>Linear equations (simple drivers)</h4></header><dl><dt class="spec value" id="val-gesv"><a href="#val-gesv" class="anchor"></a><code><span class="keyword">val</span> gesv : ?&#8288;ipiv:(<span class="type-var">'n</span>, <a href="../Slap_misc/index.html#type-cnt">Slap_misc.cnt</a>) <a href="../Slap_common/index.html#type-int32_vec">Slap_common.int32_vec</a> <span>&#45;&gt;</span> (<span class="type-var">'n</span>, <span class="type-var">'n</span>, <span class="type-var">'a_cd</span>) <a href="index.html#type-mat">mat</a> <span>&#45;&gt;</span> (<span class="type-var">'n</span>, <span class="type-var">'nrhs</span>, <span class="type-var">'b_cd</span>) <a href="index.html#type-mat">mat</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>gesv ?ipiv a b</code> solves a system of linear equations <code>a * x = b</code> where <code>a</code> is a <code>'n</code>-by-<code>'n</code> general matrix, each column of matrix <code>b</code> is the r.h.s. vector, and each column of matrix <code>x</code> is the corresponding solution.</p><p>This routine uses LU factorization: <code>a = P * L * U</code> with permutation matrix <code>P</code>, a lower triangular matrix <code>L</code> and an upper triangular matrix <code>U</code>. By this function, the upper triangular part of <code>a</code> is replaced by <code>U</code>, the lower triangular part by <code>L</code>, and the solution <code>x</code> is returned in <code>b</code>.</p><dl><dt>raises Failure</dt><dd><p>if the matrix is singular.</p></dd></dl><dl><dt>since</dt><dd>0.2.0</dd></dl></dd></dl><dl><dt class="spec value" id="val-gbsv"><a href="#val-gbsv" class="anchor"></a><code><span class="keyword">val</span> gbsv : ?&#8288;ipiv:(<span class="type-var">'n</span>, <a href="../Slap_misc/index.html#type-cnt">Slap_misc.cnt</a>) <a href="../Slap_common/index.html#type-int32_vec">Slap_common.int32_vec</a> <span>&#45;&gt;</span> ((<span class="type-var">'n</span>, <span class="type-var">'n</span>, <span class="type-var">'kl</span>, <span class="type-var">'ku</span>) <a href="../Slap_size/index.html#type-luband">Slap_size.luband</a>, <span class="type-var">'n</span>, <span class="type-var">'a_cd</span>) <a href="index.html#type-mat">mat</a> <span>&#45;&gt;</span> <span class="type-var">'kl</span> <a href="../Slap_size/index.html#type-t">Slap_size.t</a> <span>&#45;&gt;</span> <span class="type-var">'ku</span> <a href="../Slap_size/index.html#type-t">Slap_size.t</a> <span>&#45;&gt;</span> (<span class="type-var">'n</span>, <span class="type-var">'nrhs</span>, <span class="type-var">'b_cd</span>) <a href="index.html#type-mat">mat</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>gbsv ?ipiv ab kl ku b</code> solves a system of linear equations <code>A * X = B</code> where <code>A</code> is a <code>'n</code>-by-<code>'n</code> band matrix, each column of matrix <code>B</code> is the r.h.s. vector, and each column of matrix <code>X</code> is the corresponding solution. The matrix <code>A</code> with <code>kl</code> subdiagonals and <code>ku</code> superdiagonals is stored into <code>ab</code> in band storage format for LU factorizaion.</p><p>This routine uses LU factorization: <code>A = P * L * U</code> with permutation matrix <code>P</code>, a lower triangular matrix <code>L</code> and an upper triangular matrix <code>U</code>. By this function, the upper triangular part of <code>A</code> is replaced by <code>U</code>, the lower triangular part by <code>L</code>, and the solution <code>X</code> is returned in <code>B</code>.</p><dl><dt>raises Failure</dt><dd><p>if the matrix is singular.</p></dd></dl><dl><dt>since</dt><dd>0.2.0</dd></dl></dd></dl><dl><dt class="spec value" id="val-posv"><a href="#val-posv" class="anchor"></a><code><span class="keyword">val</span> posv : ?&#8288;up:[&lt; `U | `L ] <a href="../Slap_common/index.html#type-uplo">Slap_common.uplo</a> <span>&#45;&gt;</span> (<span class="type-var">'n</span>, <span class="type-var">'n</span>, <span class="type-var">'a_cd</span>) <a href="index.html#type-mat">mat</a> <span>&#45;&gt;</span> (<span class="type-var">'n</span>, <span class="type-var">'nrhs</span>, <span class="type-var">'b_cd</span>) <a href="index.html#type-mat">mat</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>posv ?up a b</code> solves systems of linear equations <code>a * x = b</code> where <code>a</code> is a <code>'n</code>-by-<code>'n</code> symmetric positive-definite matrix, each column of matrix <code>b</code> is the r.h.s vector, and each column of matrix <code>x</code> is the corresponding solution. The solution <code>x</code> is returned in <code>b</code>.</p><p>The Cholesky decomposition is used:</p><ul><li>If <code>up</code> = <a href="../Slap_common/index.html#val-upper"><code>Slap_common.upper</code></a>, then <code>a = U^T * U</code> (real) or <code>a = U^H * U</code> (complex)</li><li>If <code>up</code> = <a href="../Slap_common/index.html#val-lower"><code>Slap_common.lower</code></a>, then <code>a = L^T * L</code> (real) or <code>a = L^H * L</code> (complex)</li></ul><p>where <code>U</code> and <code>L</code> are the upper and lower triangular matrices, respectively.</p><dl><dt>parameter up</dt><dd><p>default = <a href="../Slap_common/index.html#val-upper"><code>Slap_common.upper</code></a></p><ul><li>If <code>up</code> = <a href="../Slap_common/index.html#val-upper"><code>Slap_common.upper</code></a>, then the upper triangular part of <code>a</code> is used;</li><li>If <code>up</code> = <a href="../Slap_common/index.html#val-lower"><code>Slap_common.lower</code></a>, then the lower triangular part of <code>a</code> is used.</li></ul></dd></dl><dl><dt>raises Failure</dt><dd><p>if the matrix is singular.</p></dd></dl><dl><dt>since</dt><dd>0.2.0</dd></dl></dd></dl><dl><dt class="spec value" id="val-ppsv"><a href="#val-ppsv" class="anchor"></a><code><span class="keyword">val</span> ppsv : ?&#8288;up:[&lt; `U | `L ] <a href="../Slap_common/index.html#type-uplo">Slap_common.uplo</a> <span>&#45;&gt;</span> (<span class="type-var">'n</span> <a href="../Slap_size/index.html#type-packed">Slap_size.packed</a>, <a href="../Slap_misc/index.html#type-cnt">Slap_misc.cnt</a>) <a href="index.html#type-vec">vec</a> <span>&#45;&gt;</span> (<span class="type-var">'n</span>, <span class="type-var">'nrhs</span>, <span class="type-var">'b_cd</span>) <a href="index.html#type-mat">mat</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>ppsv ?up a b</code> solves systems of linear equations <code>a * x = b</code> where <code>a</code> is a <code>'n</code>-by-<code>'n</code> symmetric positive-definite matrix stored in packed format, each column of matrix <code>b</code> is the r.h.s vector, and each column of matrix <code>x</code> is the corresponding solution. The solution <code>x</code> is returned in <code>b</code>.</p><ul><li>If <code>up</code> = <a href="../Slap_common/index.html#val-upper"><code>Slap_common.upper</code></a>, then <code>a = U^T * U</code> (real) or <code>a = U^H * U</code> (complex)</li><li>If <code>up</code> = <a href="../Slap_common/index.html#val-lower"><code>Slap_common.lower</code></a>, then <code>a = L^T * L</code> (real) or <code>a = L^H * L</code> (complex)</li></ul><p>where <code>U</code> and <code>L</code> are the upper and lower triangular matrices, respectively.</p><dl><dt>parameter up</dt><dd><p>default = <a href="../Slap_common/index.html#val-upper"><code>Slap_common.upper</code></a></p><ul><li>If <code>up</code> = <a href="../Slap_common/index.html#val-upper"><code>Slap_common.upper</code></a>, then the upper triangular part of <code>a</code> is used;</li><li>If <code>up</code> = <a href="../Slap_common/index.html#val-lower"><code>Slap_common.lower</code></a>, then the lower triangular part of <code>a</code> is used.</li></ul></dd></dl><dl><dt>raises Failure</dt><dd><p>if the matrix is singular.</p></dd></dl><dl><dt>since</dt><dd>0.2.0</dd></dl></dd></dl><dl><dt class="spec value" id="val-pbsv"><a href="#val-pbsv" class="anchor"></a><code><span class="keyword">val</span> pbsv : ?&#8288;up:[&lt; `U | `L ] <a href="../Slap_common/index.html#type-uplo">Slap_common.uplo</a> <span>&#45;&gt;</span> kd:<span class="type-var">'kd</span> <a href="../Slap_size/index.html#type-t">Slap_size.t</a> <span>&#45;&gt;</span> ((<span class="type-var">'n</span>, <span class="type-var">'kd</span>) <a href="../Slap_size/index.html#type-syband">Slap_size.syband</a>, <span class="type-var">'n</span>, <span class="type-var">'ab_cd</span>) <a href="index.html#type-mat">mat</a> <span>&#45;&gt;</span> (<span class="type-var">'n</span>, <span class="type-var">'nrhs</span>, <span class="type-var">'b_cd</span>) <a href="index.html#type-mat">mat</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>pbsv ?up ~kd ab b</code> solves systems of linear equations <code>ab * x = b</code> where <code>ab</code> is a <code>'n</code>-by-<code>'n</code> symmetric positive-definite band matrix with <code>kd</code> subdiangonals, stored in band storage format, each column of matrix <code>b</code> is the r.h.s vector, and each column of matrix <code>x</code> is the corresponding solution. The solution <code>x</code> is returned in <code>b</code>.</p><p>This routine uses the Cholesky decomposition:</p><ul><li>If <code>up</code> = <a href="../Slap_common/index.html#val-upper"><code>Slap_common.upper</code></a>, then <code>a = U^T * U</code> (real) or <code>a = U^H * U</code> (complex)</li><li>If <code>up</code> = <a href="../Slap_common/index.html#val-lower"><code>Slap_common.lower</code></a>, then <code>a = L^T * L</code> (real) or <code>a = L^H * L</code> (complex)</li></ul><p>where <code>U</code> and <code>L</code> are the upper and lower triangular matrices, respectively.</p><dl><dt>parameter up</dt><dd><p>default = <a href="../Slap_common/index.html#val-upper"><code>Slap_common.upper</code></a></p><ul><li>If <code>up</code> = <a href="../Slap_common/index.html#val-upper"><code>Slap_common.upper</code></a>, then the upper triangular part of <code>a</code> is used;</li><li>If <code>up</code> = <a href="../Slap_common/index.html#val-lower"><code>Slap_common.lower</code></a>, then the lower triangular part of <code>a</code> is used.</li></ul></dd></dl><dl><dt>parameter kd</dt><dd><p>the number of subdiagonals or superdiagonals in <code>ab</code>.</p></dd></dl><dl><dt>raises Failure</dt><dd><p>if the matrix is singular.</p></dd></dl><dl><dt>since</dt><dd>0.2.0</dd></dl></dd></dl><dl><dt class="spec value" id="val-ptsv"><a href="#val-ptsv" class="anchor"></a><code><span class="keyword">val</span> ptsv : (<span class="type-var">'n</span>, <a href="../Slap_misc/index.html#type-cnt">Slap_misc.cnt</a>) <a href="index.html#type-vec">vec</a> <span>&#45;&gt;</span> (<span class="type-var">'n</span> <a href="../Slap_size/index.html#type-p">Slap_size.p</a>, <a href="../Slap_misc/index.html#type-cnt">Slap_misc.cnt</a>) <a href="index.html#type-vec">vec</a> <span>&#45;&gt;</span> (<span class="type-var">'n</span>, <span class="type-var">'nrhs</span>, <span class="type-var">'b_cd</span>) <a href="index.html#type-mat">mat</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>ptsv d e b</code> solves systems of linear equations <code>A * x = b</code> where <code>A</code> is a <code>'n</code>-by-<code>'n</code> symmetric positive-definite tridiagonal matrix with diagonal elements <code>d</code> and subdiagonal elements <code>e</code>, each column of matrix <code>b</code> is the r.h.s vector, and each column of matrix <code>x</code> is the corresponding solution. The solution <code>x</code> is returned in <code>b</code>.</p><p>This routine uses the Cholesky decomposition: <code>A = L^T * L</code> (real) or <code>A = L^H * L</code> (complex) where <code>L</code> is a lower triangular matrix.</p><dl><dt>raises Failure</dt><dd><p>if the matrix is singular.</p></dd></dl><dl><dt>since</dt><dd>0.2.0</dd></dl></dd></dl><dl><dt class="spec type" id="type-sysv_min_lwork"><a href="#type-sysv_min_lwork" class="anchor"></a><code><span class="keyword">type</span> sysv_min_lwork</code></dt></dl><dl><dt class="spec value" id="val-sysv_min_lwork"><a href="#val-sysv_min_lwork" class="anchor"></a><code><span class="keyword">val</span> sysv_min_lwork : unit <span>&#45;&gt;</span> <a href="index.html#type-sysv_min_lwork">sysv_min_lwork</a> <a href="../Slap_size/index.html#type-t">Slap_size.t</a></code></dt><dd><p><code>sysv_min_lwork ()</code> computes the minimum length of workspace for <code>sysv</code> routine.</p></dd></dl><dl><dt class="spec value" id="val-sysv_opt_lwork"><a href="#val-sysv_opt_lwork" class="anchor"></a><code><span class="keyword">val</span> sysv_opt_lwork : ?&#8288;up:[&lt; `U | `L ] <a href="../Slap_common/index.html#type-uplo">Slap_common.uplo</a> <span>&#45;&gt;</span> (<span class="type-var">'n</span>, <span class="type-var">'n</span>, <span class="type-var">'a_cd</span>) <a href="index.html#type-mat">mat</a> <span>&#45;&gt;</span> (<span class="type-var">'n</span>, <span class="type-var">'nrhs</span>, <span class="type-var">'b_cd</span>) <a href="index.html#type-mat">mat</a> <span>&#45;&gt;</span> (<span class="keyword">module</span> <a href="../Slap_size/module-type-SIZE/index.html">Slap_size.SIZE</a>)</code></dt><dd><p><code>sysv_opt_lwork ?up a b</code> computes the optimal length of workspace for <code>sysv</code> routine.</p></dd></dl><dl><dt class="spec value" id="val-sysv"><a href="#val-sysv" class="anchor"></a><code><span class="keyword">val</span> sysv : ?&#8288;up:[&lt; `U | `L ] <a href="../Slap_common/index.html#type-uplo">Slap_common.uplo</a> <span>&#45;&gt;</span> ?&#8288;ipiv:(<span class="type-var">'n</span>, <a href="../Slap_misc/index.html#type-cnt">Slap_misc.cnt</a>) <a href="../Slap_common/index.html#type-int32_vec">Slap_common.int32_vec</a> <span>&#45;&gt;</span> ?&#8288;work:(<span class="type-var">'lwork</span>, <a href="../Slap_misc/index.html#type-cnt">Slap_misc.cnt</a>) <a href="index.html#type-vec">vec</a> <span>&#45;&gt;</span> (<span class="type-var">'n</span>, <span class="type-var">'n</span>, <span class="type-var">'a_cd</span>) <a href="index.html#type-mat">mat</a> <span>&#45;&gt;</span> (<span class="type-var">'n</span>, <span class="type-var">'nrhs</span>, <span class="type-var">'b_cd</span>) <a href="index.html#type-mat">mat</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>sysv ?up ?ipiv ?work a b</code> solves systems of linear equations <code>a * x = b</code> where <code>a</code> is a <code>'n</code>-by-<code>'n</code> symmetric matrix, each column of matrix <code>b</code> is the r.h.s. vector, and each column of matrix <code>x</code> is the corresponding solution. The solution <code>x</code> is returned in <code>b</code>.</p><p>The diagonal pivoting method is used:</p><ul><li>If <code>up</code> = <a href="../Slap_common/index.html#val-upper"><code>Slap_common.upper</code></a>, then <code>a = U * D * U^T</code></li><li>If <code>up</code> = <a href="../Slap_common/index.html#val-lower"><code>Slap_common.lower</code></a>, then <code>a = L * D * L^T</code> where <code>U</code> and <code>L</code> are the upper and lower triangular matrices, respectively.</li></ul><dl><dt>parameter up</dt><dd><p>default = <a href="../Slap_common/index.html#val-upper"><code>Slap_common.upper</code></a></p><ul><li>If <code>up</code> = <a href="../Slap_common/index.html#val-upper"><code>Slap_common.upper</code></a>, then the upper triangular part of <code>a</code> is used;</li><li>If <code>up</code> = <a href="../Slap_common/index.html#val-lower"><code>Slap_common.lower</code></a>, then the lower triangular part of <code>a</code> is used.</li></ul></dd></dl><dl><dt>parameter ipiv</dt><dd><p>a result of <code>sytrf</code>. It is internally computed by <code>sytrf</code> if omitted.</p></dd></dl><dl><dt>parameter work</dt><dd><p>default = an optimum-length vector.</p></dd></dl><dl><dt>raises Failure</dt><dd><p>if the matrix is singular.</p></dd></dl><dl><dt>since</dt><dd>0.2.0</dd></dl></dd></dl><dl><dt class="spec value" id="val-spsv"><a href="#val-spsv" class="anchor"></a><code><span class="keyword">val</span> spsv : ?&#8288;up:[&lt; `U | `L ] <a href="../Slap_common/index.html#type-uplo">Slap_common.uplo</a> <span>&#45;&gt;</span> ?&#8288;ipiv:(<span class="type-var">'n</span>, <a href="../Slap_misc/index.html#type-cnt">Slap_misc.cnt</a>) <a href="../Slap_common/index.html#type-int32_vec">Slap_common.int32_vec</a> <span>&#45;&gt;</span> (<span class="type-var">'n</span> <a href="../Slap_size/index.html#type-packed">Slap_size.packed</a>, <a href="../Slap_misc/index.html#type-cnt">Slap_misc.cnt</a>) <a href="index.html#type-vec">vec</a> <span>&#45;&gt;</span> (<span class="type-var">'n</span>, <span class="type-var">'nrhs</span>, <span class="type-var">'b_cd</span>) <a href="index.html#type-mat">mat</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>spsv ?up a b</code> solves systems of linear equations <code>a * x = b</code> where <code>a</code> is a <code>'n</code>-by-<code>'n</code> symmetric matrix stored in packed format, each column of matrix <code>b</code> is the r.h.s. vector, and each column of matrix <code>x</code> is the corresponding solution. The solution <code>x</code> is returned in <code>b</code>.</p><p>The diagonal pivoting method is used:</p><ul><li>If <code>up</code> = <a href="../Slap_common/index.html#val-upper"><code>Slap_common.upper</code></a>, then <code>a = U * D * U^T</code></li><li>If <code>up</code> = <a href="../Slap_common/index.html#val-lower"><code>Slap_common.lower</code></a>, then <code>a = L * D * L^T</code> where <code>U</code> and <code>L</code> are the upper and lower triangular matrices, respectively.</li></ul><dl><dt>parameter up</dt><dd><p>default = <a href="../Slap_common/index.html#val-upper"><code>Slap_common.upper</code></a></p><ul><li>If <code>up</code> = <a href="../Slap_common/index.html#val-upper"><code>Slap_common.upper</code></a>, then the upper triangular part of <code>a</code> is used;</li><li>If <code>up</code> = <a href="../Slap_common/index.html#val-lower"><code>Slap_common.lower</code></a>, then the lower triangular part of <code>a</code> is used.</li></ul></dd></dl><dl><dt>parameter ipiv</dt><dd><p>a result of <code>sytrf</code>. It is internally computed by <code>sytrf</code> if omitted.</p></dd></dl><dl><dt>raises Failure</dt><dd><p>if the matrix is singular.</p></dd></dl><dl><dt>since</dt><dd>0.2.0</dd></dl></dd></dl></section><section><header><h4 id="least-squares-(simple-drivers)"><a href="#least-squares-(simple-drivers)" class="anchor"></a>Least squares (simple drivers)</h4></header><dl><dt class="spec type" id="type-gels_min_lwork"><a href="#type-gels_min_lwork" class="anchor"></a><code><span class="keyword">type</span> ('m, 'n, 'nrhs) gels_min_lwork</code></dt></dl><dl><dt class="spec value" id="val-gels_min_lwork"><a href="#val-gels_min_lwork" class="anchor"></a><code><span class="keyword">val</span> gels_min_lwork : m:<span class="type-var">'m</span> <a href="../Slap_size/index.html#type-t">Slap_size.t</a> <span>&#45;&gt;</span> n:<span class="type-var">'n</span> <a href="../Slap_size/index.html#type-t">Slap_size.t</a> <span>&#45;&gt;</span> nrhs:<span class="type-var">'nrhs</span> <a href="../Slap_size/index.html#type-t">Slap_size.t</a> <span>&#45;&gt;</span> (<span class="type-var">'m</span>, <span class="type-var">'n</span>, <span class="type-var">'nrhs</span>) <a href="index.html#type-gels_min_lwork">gels_min_lwork</a> <a href="../Slap_size/index.html#type-t">Slap_size.t</a></code></dt><dd><p><code>gels_min_lwork ~n</code> computes the minimum length of workspace for <code>gels</code> routine.</p><dl><dt>parameter m</dt><dd><p>the number of rows in a matrix.</p></dd></dl><dl><dt>parameter n</dt><dd><p>the number of columns in a matrix.</p></dd></dl><dl><dt>parameter nrhs</dt><dd><p>the number of right hand sides.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-gels_opt_lwork"><a href="#val-gels_opt_lwork" class="anchor"></a><code><span class="keyword">val</span> gels_opt_lwork : trans:(<span class="type-var">'am</span> * <span class="type-var">'an</span>, <span class="type-var">'m</span> * <span class="type-var">'n</span>, <span class="type-var">_</span>) <a href="../Slap_common/index.html#type-trans2">Slap_common.trans2</a> <span>&#45;&gt;</span> (<span class="type-var">'am</span>, <span class="type-var">'an</span>, <span class="type-var">'a_cd</span>) <a href="index.html#type-mat">mat</a> <span>&#45;&gt;</span> (<span class="type-var">'m</span>, <span class="type-var">'nrhs</span>, <span class="type-var">'b_cd</span>) <a href="index.html#type-mat">mat</a> <span>&#45;&gt;</span> (<span class="keyword">module</span> <a href="../Slap_size/module-type-SIZE/index.html">Slap_size.SIZE</a>)</code></dt><dd><p><code>gels_opt_lwork ~trans a b</code> computes the optimum length of workspace for <code>gels</code> routine.</p></dd></dl><dl><dt class="spec value" id="val-gels"><a href="#val-gels" class="anchor"></a><code><span class="keyword">val</span> gels : ?&#8288;work:(<span class="type-var">'work</span>, <a href="../Slap_misc/index.html#type-cnt">Slap_misc.cnt</a>) <a href="index.html#type-vec">vec</a> <span>&#45;&gt;</span> trans:(<span class="type-var">'am</span> * <span class="type-var">'an</span>, <span class="type-var">'m</span> * <span class="type-var">'n</span>, <span class="type-var">_</span>) <a href="../Slap_common/index.html#type-trans2">Slap_common.trans2</a> <span>&#45;&gt;</span> (<span class="type-var">'am</span>, <span class="type-var">'an</span>, <span class="type-var">'a_cd</span>) <a href="index.html#type-mat">mat</a> <span>&#45;&gt;</span> (<span class="type-var">'m</span>, <span class="type-var">'nrhs</span>, <span class="type-var">'b_cd</span>) <a href="index.html#type-mat">mat</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>gels ?work ~trans a b</code> solves an overdetermined or underdetermined system of linear equations using QR or LU factorization.</p><ul><li>If <code>trans</code> = <a href="../Slap_common/index.html#val-normal"><code>Slap_common.normal</code></a> and <code>'m &gt;= 'n</code>: find the least square solution to an overdetermined system by minimizing <code>||b - A * x||^2</code>.</li><li>If <code>trans</code> = <a href="../Slap_common/index.html#val-normal"><code>Slap_common.normal</code></a> and <code>'m &lt; 'n</code>: find the minimum norm solution to an underdetermined system <code>a * x = b</code>.</li><li>If <code>trans</code> = <a href="../Slap_common/index.html#type-trans"><code>Slap_common.trans</code></a>, and <code>'m &gt;= 'n</code>: find the minimum norm solution to an underdetermined system <code>a^H * x = b</code>.</li><li>If <code>trans</code> = <a href="../Slap_common/index.html#type-trans"><code>Slap_common.trans</code></a> and <code>'m &lt; 'n</code>: find the least square solution to an overdetermined system by minimizing <code>||b - A^H * x||^2</code>.</li></ul><dl><dt>parameter work</dt><dd><p>default = an optimum-length vector.</p></dd></dl><dl><dt>parameter trans</dt><dd><p>the transpose flag for <code>a</code>.</p></dd></dl></dd></dl></section></section><section><header><h3 id="blas-interface"><a href="#blas-interface" class="anchor"></a>BLAS interface</h3></header><section><header><h4 id="level-1"><a href="#level-1" class="anchor"></a>Level 1</h4></header><dl><dt class="spec value" id="val-dotu"><a href="#val-dotu" class="anchor"></a><code><span class="keyword">val</span> dotu : (<span class="type-var">'n</span>, <span class="type-var">'x_cd</span>) <a href="index.html#type-vec">vec</a> <span>&#45;&gt;</span> (<span class="type-var">'n</span>, <span class="type-var">'y_cd</span>) <a href="index.html#type-vec">vec</a> <span>&#45;&gt;</span> <a href="index.html#type-num_type">num_type</a></code></dt><dd><p><code>dotc x y</code> computes <code>x^T y</code>.</p><dl><dt>returns</dt><dd><p>an inner product of given two vectors.</p></dd></dl><dl><dt>since</dt><dd>2.0.0</dd></dl></dd></dl><dl><dt class="spec value" id="val-dotc"><a href="#val-dotc" class="anchor"></a><code><span class="keyword">val</span> dotc : (<span class="type-var">'n</span>, <span class="type-var">'x_cd</span>) <a href="index.html#type-vec">vec</a> <span>&#45;&gt;</span> (<span class="type-var">'n</span>, <span class="type-var">'y_cd</span>) <a href="index.html#type-vec">vec</a> <span>&#45;&gt;</span> <a href="index.html#type-num_type">num_type</a></code></dt><dd><p><code>dotc x y</code> computes <code>x^H y</code>.</p><dl><dt>returns</dt><dd><p>an inner product of a conjugated vector with another vector.</p></dd></dl><dl><dt>since</dt><dd>2.0.0</dd></dl></dd></dl></section></section></div></body></html>