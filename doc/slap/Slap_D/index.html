<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Slap_D (slap.Slap_D)</title><link rel="stylesheet" href="../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../index.html">slap</a> &#x00BB; Slap_D</nav><h1>Module <code>Slap_D</code></h1><nav class="toc"><ul><li><a href="#blas-interface">BLAS interface</a><ul><li><a href="#level-1">Level 1</a></li><li><a href="#level-2">Level 2</a></li><li><a href="#level-3">Level 3</a></li></ul></li><li><a href="#lapack-interface">LAPACK interface</a><ul><li><a href="#auxiliary-routines">Auxiliary routines</a></li><li><a href="#linear-equations-(computational-routines)">Linear equations (computational routines)</a></li><li><a href="#linear-equations-(simple-drivers)">Linear equations (simple drivers)</a></li><li><a href="#least-squares-(simple-drivers)">Least squares (simple drivers)</a></li></ul></li><li><a href="#blas-interface">BLAS interface</a><ul><li><a href="#level-1">Level 1</a></li><li><a href="#level-2">Level 2</a></li></ul></li><li><a href="#lapack-interface">LAPACK interface</a><ul><li><a href="#auxiliary-routines">Auxiliary routines</a><ul><li><a href="#lansy">lansy</a></li><li><a href="#lamch">lamch</a></li></ul></li><li><a href="#linear-equations-(computational-routines)">Linear equations (computational routines)</a><ul><li><a href="#orgqr">orgqr</a></li><li><a href="#ormqr">ormqr</a></li><li><a href="#gecon">gecon</a></li><li><a href="#sycon">sycon</a></li><li><a href="#pocon">pocon</a></li></ul></li><li><a href="#least-squares-(expert-drivers)">Least squares (expert drivers)</a><ul><li><a href="#gelsy">gelsy</a></li><li><a href="#gelsd">gelsd</a></li><li><a href="#gelss">gelss</a></li></ul></li><li><a href="#general-svd-routines">General SVD routines</a><ul><li><a href="#gesvd">gesvd</a></li><li><a href="#gesdd">gesdd</a></li></ul></li><li><a href="#general-eigenvalue-problem-(simple-drivers)">General eigenvalue problem (simple drivers)</a><ul><li><a href="#geev">geev</a></li></ul></li><li><a href="#symmetric-matrix-eigenvalue-and-singular-value-problems-(simple-drivers)">Symmetric-matrix eigenvalue and singular value problems (simple drivers)</a><ul><li><a href="#syev">syev</a></li><li><a href="#syevd">syevd</a></li><li><a href="#sbev">sbev</a></li></ul></li><li><a href="#symmetric-matrix-eigenvalue-and-singular-value-problems-(expert-&amp;-rrr-drivers)">Symmetric-matrix eigenvalue and singular value problems (expert &amp; RRR drivers)</a><ul><li><a href="#syevr">syevr</a></li><li><a href="#sygv">sygv</a></li><li><a href="#sbgv">sbgv</a></li></ul></li></ul></li></ul></nav></header><dl><dt class="spec type" id="type-prec"><a href="#type-prec" class="anchor"></a><code><span class="keyword">type</span> prec</code><code> = <a href="../../ocaml/Bigarray/index.html#type-float64_elt">Bigarray.float64_elt</a></code></dt><dt class="spec type" id="type-num_type"><a href="#type-num_type" class="anchor"></a><code><span class="keyword">type</span> num_type</code><code> = float</code></dt><dt class="spec type" id="type-trans3"><a href="#type-trans3" class="anchor"></a><code><span class="keyword">type</span> (+'indim, +'outdim, +'tag) trans3</code><code> = (<span class="type-var">'indim</span>, <span class="type-var">'outdim</span>, <span class="type-var">'tag</span>) <a href="../Slap_common/index.html#type-trans2">Slap_common.trans2</a></code></dt><dd><p>A type of transpose parameters (<a href="../Slap_common/index.html#val-normal"><code>Slap_common.normal</code></a> and <a href="../Slap_common/index.html#type-trans"><code>Slap_common.trans</code></a>). For complex matrices, <a href="../Slap_common/index.html#val-conjtr"><code>Slap_common.conjtr</code></a> is also offered, hence the name.</p></dd></dl><dl><dt class="spec type" id="type-vec"><a href="#type-vec" class="anchor"></a><code><span class="keyword">type</span> (+'n, +'cnt_or_dsc) vec</code><code> = (<span class="type-var">'n</span>, <a href="index.html#type-num_type">num_type</a>, <a href="index.html#type-prec">prec</a>, <span class="type-var">'cnt_or_dsc</span>) <a href="../Slap_vec/index.html#type-t">Slap_vec.t</a></code></dt><dd><p>Vectors.</p></dd></dl><dl><dt class="spec type" id="type-mat"><a href="#type-mat" class="anchor"></a><code><span class="keyword">type</span> (+'m, +'n, +'cnt_or_dsc) mat</code><code> = (<span class="type-var">'m</span>, <span class="type-var">'n</span>, <a href="index.html#type-num_type">num_type</a>, <a href="index.html#type-prec">prec</a>, <span class="type-var">'cnt_or_dsc</span>) <a href="../Slap_mat/index.html#type-t">Slap_mat.t</a></code></dt><dd><p>Matrices.</p></dd></dl><dl><dt class="spec type" id="type-rprec"><a href="#type-rprec" class="anchor"></a><code><span class="keyword">type</span> rprec</code><code> = <a href="../../ocaml/Bigarray/index.html#type-float64_elt">Bigarray.float64_elt</a></code></dt><dt class="spec type" id="type-rvec"><a href="#type-rvec" class="anchor"></a><code><span class="keyword">type</span> (+'n, +'cnt_or_dsc) rvec</code><code> = (<span class="type-var">'n</span>, float, <a href="index.html#type-rprec">rprec</a>, <span class="type-var">'cnt_or_dsc</span>) <a href="../Slap_vec/index.html#type-t">Slap_vec.t</a></code></dt><dd><p>Real vectors. (In <a href="../Slap/S/index.html"><code>Slap.S</code></a> and <a href="../Slap/D/index.html"><code>Slap.D</code></a>, <code>rvec</code> is equal to <code>vec</code>.)</p></dd></dl><dl><dt class="spec value" id="val-prec"><a href="#val-prec" class="anchor"></a><code><span class="keyword">val</span> prec : (<a href="index.html#type-num_type">num_type</a>, <a href="index.html#type-prec">prec</a>) <a href="../../ocaml/Bigarray/index.html#type-kind">Bigarray.kind</a></code></dt><dt class="spec value" id="val-rprec"><a href="#val-rprec" class="anchor"></a><code><span class="keyword">val</span> rprec : (float, <a href="index.html#type-rprec">rprec</a>) <a href="../../ocaml/Bigarray/index.html#type-kind">Bigarray.kind</a></code></dt></dl><div class="spec module" id="module-Vec"><a href="#module-Vec" class="anchor"></a><code><span class="keyword">module</span> <a href="Vec/index.html">Vec</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><div class="spec module" id="module-Mat"><a href="#module-Mat" class="anchor"></a><code><span class="keyword">module</span> <a href="Mat/index.html">Mat</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><dl><dt class="spec value" id="val-pp_num"><a href="#val-pp_num" class="anchor"></a><code><span class="keyword">val</span> pp_num : <a href="../../ocaml/Stdlib/Format/index.html#type-formatter">Stdlib.Format.formatter</a> <span>&#45;&gt;</span> <a href="index.html#type-num_type">num_type</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>A pretty-printer for elements in vectors and matrices.</p></dd></dl><dl><dt class="spec value" id="val-pp_vec"><a href="#val-pp_vec" class="anchor"></a><code><span class="keyword">val</span> pp_vec : <a href="../../ocaml/Stdlib/Format/index.html#type-formatter">Stdlib.Format.formatter</a> <span>&#45;&gt;</span> (<span class="type-var">'n</span>, <span class="type-var">'cnt_or_dsc</span>) <a href="index.html#type-vec">vec</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>A pretty-printer for column vectors.</p></dd></dl><dl><dt class="spec value" id="val-pp_mat"><a href="#val-pp_mat" class="anchor"></a><code><span class="keyword">val</span> pp_mat : <a href="../../ocaml/Stdlib/Format/index.html#type-formatter">Stdlib.Format.formatter</a> <span>&#45;&gt;</span> (<span class="type-var">'m</span>, <span class="type-var">'n</span>, <span class="type-var">'cnt_or_dsc</span>) <a href="index.html#type-mat">mat</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>A pretty-printer for matrices.</p></dd></dl><section><header><h3 id="blas-interface"><a href="#blas-interface" class="anchor"></a>BLAS interface</h3></header><section><header><h4 id="level-1"><a href="#level-1" class="anchor"></a>Level 1</h4></header><dl><dt class="spec value" id="val-swap"><a href="#val-swap" class="anchor"></a><code><span class="keyword">val</span> swap : (<span class="type-var">'n</span>, <span class="type-var">'x_cd</span>) <a href="index.html#type-vec">vec</a> <span>&#45;&gt;</span> (<span class="type-var">'n</span>, <span class="type-var">'y_cd</span>) <a href="index.html#type-vec">vec</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>swap x y</code> swaps elements in <code>x</code> and <code>y</code>.</p></dd></dl><dl><dt class="spec value" id="val-scal"><a href="#val-scal" class="anchor"></a><code><span class="keyword">val</span> scal : <a href="index.html#type-num_type">num_type</a> <span>&#45;&gt;</span> (<span class="type-var">'n</span>, <span class="type-var">'cd</span>) <a href="index.html#type-vec">vec</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>scal c x</code> multiplies all elements in <code>x</code> by scalar value <code>c</code>, and destructively assigns the result to <code>x</code>.</p></dd></dl><dl><dt class="spec value" id="val-copy"><a href="#val-copy" class="anchor"></a><code><span class="keyword">val</span> copy : ?&#8288;y:(<span class="type-var">'n</span>, <span class="type-var">'y_cd</span>) <a href="index.html#type-vec">vec</a> <span>&#45;&gt;</span> (<span class="type-var">'n</span>, <span class="type-var">'x_cd</span>) <a href="index.html#type-vec">vec</a> <span>&#45;&gt;</span> (<span class="type-var">'n</span>, <span class="type-var">'y_cd</span>) <a href="index.html#type-vec">vec</a></code></dt><dd><p><code>copy ?y x</code> copies <code>x</code> into <code>y</code>.</p><dl><dt>returns</dt><dd><p>vector <code>y</code>, which is overwritten.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-nrm2"><a href="#val-nrm2" class="anchor"></a><code><span class="keyword">val</span> nrm2 : (<span class="type-var">'n</span>, <span class="type-var">'cd</span>) <a href="index.html#type-vec">vec</a> <span>&#45;&gt;</span> float</code></dt><dd><p><code>nrm2 x</code> retruns the L2 norm of vector <code>x</code>: <code>||x||</code>.</p></dd></dl><dl><dt class="spec value" id="val-axpy"><a href="#val-axpy" class="anchor"></a><code><span class="keyword">val</span> axpy : ?&#8288;alpha:<a href="index.html#type-num_type">num_type</a> <span>&#45;&gt;</span> (<span class="type-var">'n</span>, <span class="type-var">'x_cd</span>) <a href="index.html#type-vec">vec</a> <span>&#45;&gt;</span> (<span class="type-var">'n</span>, <span class="type-var">'y_cd</span>) <a href="index.html#type-vec">vec</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>axpy ?alpha x y</code> executes <code>y := alpha * x + y</code> with scalar value <code>alpha</code>, and vectors <code>x</code> and <code>y</code>.</p><dl><dt>parameter alpha</dt><dd><p>default = <code>1.0</code></p></dd></dl></dd></dl><dl><dt class="spec value" id="val-iamax"><a href="#val-iamax" class="anchor"></a><code><span class="keyword">val</span> iamax : (<span class="type-var">'n</span>, <span class="type-var">'cd</span>) <a href="index.html#type-vec">vec</a> <span>&#45;&gt;</span> int</code></dt><dd><p><code>iamax x</code> returns the index of the maximum value of all elements in <code>x</code>.</p></dd></dl><dl><dt class="spec value" id="val-amax"><a href="#val-amax" class="anchor"></a><code><span class="keyword">val</span> amax : (<span class="type-var">'n</span>, <span class="type-var">'cd</span>) <a href="index.html#type-vec">vec</a> <span>&#45;&gt;</span> <a href="index.html#type-num_type">num_type</a></code></dt><dd><p><code>amax x</code> finds the maximum value of all elements in <code>x</code>.</p></dd></dl></section><section><header><h4 id="level-2"><a href="#level-2" class="anchor"></a>Level 2</h4></header><dl><dt class="spec value" id="val-gemv"><a href="#val-gemv" class="anchor"></a><code><span class="keyword">val</span> gemv : ?&#8288;beta:<a href="index.html#type-num_type">num_type</a> <span>&#45;&gt;</span> ?&#8288;y:(<span class="type-var">'m</span>, <span class="type-var">'y_cd</span>) <a href="index.html#type-vec">vec</a> <span>&#45;&gt;</span> trans:(<span class="type-var">'a_m</span> * <span class="type-var">'a_n</span>, <span class="type-var">'m</span> * <span class="type-var">'n</span>, <span class="type-var">_</span>) <a href="index.html#type-trans3">trans3</a> <span>&#45;&gt;</span> ?&#8288;alpha:<a href="index.html#type-num_type">num_type</a> <span>&#45;&gt;</span> (<span class="type-var">'a_m</span>, <span class="type-var">'a_n</span>, <span class="type-var">'a_cd</span>) <a href="index.html#type-mat">mat</a> <span>&#45;&gt;</span> (<span class="type-var">'n</span>, <span class="type-var">'x_cd</span>) <a href="index.html#type-vec">vec</a> <span>&#45;&gt;</span> (<span class="type-var">'m</span>, <span class="type-var">'y_cd</span>) <a href="index.html#type-vec">vec</a></code></dt><dd><p><code>gemv ?beta ?y ~trans ?alpha a x</code> executes <code>y := alpha * OP(a) * x + beta * y</code>.</p><dl><dt>parameter beta</dt><dd><p>default = <code>0.0</code></p></dd></dl><dl><dt>parameter trans</dt><dd><p>the transpose flag for <code>a</code>:</p><ul><li>If <code>trans</code> = <a href="../Slap_common/index.html#val-normal"><code>Slap_common.normal</code></a>, then <code>OP(a)</code> = <code>a</code>;</li><li>If <code>trans</code> = <a href="../Slap_common/index.html#type-trans"><code>Slap_common.trans</code></a>, then <code>OP(a)</code> = <code>a^T</code>;</li><li>If <code>trans</code> = <a href="../Slap_common/index.html#val-conjtr"><code>Slap_common.conjtr</code></a>, then <code>OP(a)</code> = <code>a^H</code> (the conjugate transpose of <code>a</code>).</li></ul></dd></dl><dl><dt>parameter alpha</dt><dd><p>default = <code>1.0</code></p></dd></dl></dd></dl><dl><dt class="spec value" id="val-gbmv"><a href="#val-gbmv" class="anchor"></a><code><span class="keyword">val</span> gbmv : m:<span class="type-var">'a_m</span> <a href="../Slap_size/index.html#type-t">Slap_size.t</a> <span>&#45;&gt;</span> ?&#8288;beta:<a href="index.html#type-num_type">num_type</a> <span>&#45;&gt;</span> ?&#8288;y:(<span class="type-var">'m</span>, <span class="type-var">'y_cd</span>) <a href="index.html#type-vec">vec</a> <span>&#45;&gt;</span> trans:(<span class="type-var">'a_m</span> * <span class="type-var">'a_n</span>, <span class="type-var">'m</span> * <span class="type-var">'n</span>, <span class="type-var">_</span>) <a href="index.html#type-trans3">trans3</a> <span>&#45;&gt;</span> ?&#8288;alpha:<a href="index.html#type-num_type">num_type</a> <span>&#45;&gt;</span> ((<span class="type-var">'a_m</span>, <span class="type-var">'a_n</span>, <span class="type-var">'kl</span>, <span class="type-var">'ku</span>) <a href="../Slap_size/index.html#type-geband">Slap_size.geband</a>, <span class="type-var">'a_n</span>, <span class="type-var">'a_cd</span>) <a href="index.html#type-mat">mat</a> <span>&#45;&gt;</span> <span class="type-var">'kl</span> <a href="../Slap_size/index.html#type-t">Slap_size.t</a> <span>&#45;&gt;</span> <span class="type-var">'ku</span> <a href="../Slap_size/index.html#type-t">Slap_size.t</a> <span>&#45;&gt;</span> (<span class="type-var">'n</span>, <span class="type-var">'x_cd</span>) <a href="index.html#type-vec">vec</a> <span>&#45;&gt;</span> (<span class="type-var">'m</span>, <span class="type-var">'y_cd</span>) <a href="index.html#type-vec">vec</a></code></dt><dd><p><code>gbmv ~m ?beta ?y ~trans ?alpha a kl ku x</code> computes <code>y := alpha * OP(a) * x + beta * y</code> where <code>a</code> is a band matrix stored in band storage.</p><dl><dt>returns</dt><dd><p>vector <code>y</code>, which is overwritten.</p></dd></dl><dl><dt>parameter beta</dt><dd><p>default = <code>0.0</code></p></dd></dl><dl><dt>parameter trans</dt><dd><p>the transpose flag for <code>a</code>:</p><ul><li>If <code>trans</code> = <a href="../Slap_common/index.html#val-normal"><code>Slap_common.normal</code></a>, then <code>OP(a)</code> = <code>a</code>;</li><li>If <code>trans</code> = <a href="../Slap_common/index.html#type-trans"><code>Slap_common.trans</code></a>, then <code>OP(a)</code> = <code>a^T</code>;</li><li>If <code>trans</code> = <a href="../Slap_common/index.html#val-conjtr"><code>Slap_common.conjtr</code></a>, then <code>OP(a)</code> = <code>a^H</code> (the conjugate transpose of <code>a</code>).</li></ul></dd></dl><dl><dt>parameter alpha</dt><dd><p>default = <code>1.0</code></p></dd></dl><dl><dt>parameter kl</dt><dd><p>the number of subdiagonals of <code>a</code></p></dd></dl><dl><dt>parameter ku</dt><dd><p>the number of superdiagonals of <code>a</code></p></dd></dl><dl><dt>since</dt><dd>0.2.0</dd></dl></dd></dl><dl><dt class="spec value" id="val-symv"><a href="#val-symv" class="anchor"></a><code><span class="keyword">val</span> symv : ?&#8288;beta:<a href="index.html#type-num_type">num_type</a> <span>&#45;&gt;</span> ?&#8288;y:(<span class="type-var">'n</span>, <span class="type-var">'y_cd</span>) <a href="index.html#type-vec">vec</a> <span>&#45;&gt;</span> ?&#8288;up:[&lt; `L | `U ] <a href="../Slap_common/index.html#type-uplo">Slap_common.uplo</a> <span>&#45;&gt;</span> ?&#8288;alpha:<a href="index.html#type-num_type">num_type</a> <span>&#45;&gt;</span> (<span class="type-var">'n</span>, <span class="type-var">'n</span>, <span class="type-var">'a_cd</span>) <a href="index.html#type-mat">mat</a> <span>&#45;&gt;</span> (<span class="type-var">'n</span>, <span class="type-var">'x_cd</span>) <a href="index.html#type-vec">vec</a> <span>&#45;&gt;</span> (<span class="type-var">'n</span>, <span class="type-var">'y_cd</span>) <a href="index.html#type-vec">vec</a></code></dt><dd><p><code>symv ?beta ?y ?up ?alpha a x</code> executes <code>y := alpha * a * x + beta * y</code>.</p><dl><dt>parameter beta</dt><dd><p>default = <code>0.0</code></p></dd></dl><dl><dt>parameter up</dt><dd><p>default = <a href="../Slap_common/index.html#val-upper"><code>Slap_common.upper</code></a></p><ul><li>If <code>up</code> = <a href="../Slap_common/index.html#val-upper"><code>Slap_common.upper</code></a>, then the upper triangular part of <code>a</code> is used;</li><li>If <code>up</code> = <a href="../Slap_common/index.html#val-lower"><code>Slap_common.lower</code></a>, then the lower triangular part of <code>a</code> is used.</li></ul></dd></dl><dl><dt>parameter alpha</dt><dd><p>default = <code>1.0</code></p></dd></dl></dd></dl><dl><dt class="spec value" id="val-trmv"><a href="#val-trmv" class="anchor"></a><code><span class="keyword">val</span> trmv : trans:(<span class="type-var">'n</span> * <span class="type-var">'n</span>, <span class="type-var">'n</span> * <span class="type-var">'n</span>, <span class="type-var">_</span>) <a href="index.html#type-trans3">trans3</a> <span>&#45;&gt;</span> ?&#8288;diag:<a href="../Slap_common/index.html#type-diag">Slap_common.diag</a> <span>&#45;&gt;</span> ?&#8288;up:[&lt; `L | `U ] <a href="../Slap_common/index.html#type-uplo">Slap_common.uplo</a> <span>&#45;&gt;</span> (<span class="type-var">'n</span>, <span class="type-var">'n</span>, <span class="type-var">'a_cd</span>) <a href="index.html#type-mat">mat</a> <span>&#45;&gt;</span> (<span class="type-var">'n</span>, <span class="type-var">'x_cd</span>) <a href="index.html#type-vec">vec</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>trmv ~trans ?diag ?up a x</code> executes <code>x := OP(a) * x</code>.</p><dl><dt>parameter trans</dt><dd><p>the transpose flag for <code>a</code>:</p><ul><li>If <code>trans</code> = <a href="../Slap_common/index.html#val-normal"><code>Slap_common.normal</code></a>, then <code>OP(a)</code> = <code>a</code>;</li><li>If <code>trans</code> = <a href="../Slap_common/index.html#type-trans"><code>Slap_common.trans</code></a>, then <code>OP(a)</code> = <code>a^T</code>;</li><li>If <code>trans</code> = <a href="../Slap_common/index.html#val-conjtr"><code>Slap_common.conjtr</code></a>, then <code>OP(a)</code> = <code>a^H</code> (the conjugate transpose of <code>a</code>).</li></ul></dd></dl><dl><dt>parameter diag</dt><dd><p>default = <a href="../Slap_common/index.html#val-non_unit"><code>Slap_common.non_unit</code></a></p><ul><li>If <code>diag</code> = <a href="../Slap_common/index.html#val-unit"><code>Slap_common.unit</code></a>, then <code>a</code> is unit triangular;</li><li>If <code>diag</code> = <a href="../Slap_common/index.html#val-non_unit"><code>Slap_common.non_unit</code></a>, then <code>a</code> is not unit triangular.</li></ul></dd></dl><dl><dt>parameter up</dt><dd><p>default = <a href="../Slap_common/index.html#val-upper"><code>Slap_common.upper</code></a></p><ul><li>If <code>up</code> = <a href="../Slap_common/index.html#val-upper"><code>Slap_common.upper</code></a>, then the upper triangular part of <code>a</code> is used;</li><li>If <code>up</code> = <a href="../Slap_common/index.html#val-lower"><code>Slap_common.lower</code></a>, then the lower triangular part of <code>a</code> is used.</li></ul></dd></dl></dd></dl><dl><dt class="spec value" id="val-trsv"><a href="#val-trsv" class="anchor"></a><code><span class="keyword">val</span> trsv : trans:(<span class="type-var">'n</span> * <span class="type-var">'n</span>, <span class="type-var">'n</span> * <span class="type-var">'n</span>, <span class="type-var">_</span>) <a href="index.html#type-trans3">trans3</a> <span>&#45;&gt;</span> ?&#8288;diag:<a href="../Slap_common/index.html#type-diag">Slap_common.diag</a> <span>&#45;&gt;</span> ?&#8288;up:[&lt; `L | `U ] <a href="../Slap_common/index.html#type-uplo">Slap_common.uplo</a> <span>&#45;&gt;</span> (<span class="type-var">'n</span>, <span class="type-var">'n</span>, <span class="type-var">'a_cd</span>) <a href="index.html#type-mat">mat</a> <span>&#45;&gt;</span> (<span class="type-var">'n</span>, <span class="type-var">'b_cd</span>) <a href="index.html#type-vec">vec</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>trmv ~trans ?diag ?up a b</code> solves linear system <code>OP(a) * x = b</code> and destructively assigns <code>x</code> to <code>b</code>.</p><dl><dt>parameter trans</dt><dd><p>the transpose flag for <code>a</code>:</p><ul><li>If <code>trans</code> = <a href="../Slap_common/index.html#val-normal"><code>Slap_common.normal</code></a>, then <code>OP(a)</code> = <code>a</code>;</li><li>If <code>trans</code> = <a href="../Slap_common/index.html#type-trans"><code>Slap_common.trans</code></a>, then <code>OP(a)</code> = <code>a^T</code>;</li><li>If <code>trans</code> = <a href="../Slap_common/index.html#val-conjtr"><code>Slap_common.conjtr</code></a>, then <code>OP(a)</code> = <code>a^H</code> (the conjugate transpose of <code>a</code>).</li></ul></dd></dl><dl><dt>parameter diag</dt><dd><p>default = <a href="../Slap_common/index.html#val-non_unit"><code>Slap_common.non_unit</code></a></p><ul><li>If <code>diag</code> = <a href="../Slap_common/index.html#val-unit"><code>Slap_common.unit</code></a>, then <code>a</code> is unit triangular;</li><li>If <code>diag</code> = <a href="../Slap_common/index.html#val-non_unit"><code>Slap_common.non_unit</code></a>, then <code>a</code> is not unit triangular.</li></ul></dd></dl><dl><dt>parameter up</dt><dd><p>default = <a href="../Slap_common/index.html#val-upper"><code>Slap_common.upper</code></a></p><ul><li>If <code>up</code> = <a href="../Slap_common/index.html#val-upper"><code>Slap_common.upper</code></a>, then the upper triangular part of <code>a</code> is used;</li><li>If <code>up</code> = <a href="../Slap_common/index.html#val-lower"><code>Slap_common.lower</code></a>, then the lower triangular part of <code>a</code> is used.</li></ul></dd></dl></dd></dl><dl><dt class="spec value" id="val-tpmv"><a href="#val-tpmv" class="anchor"></a><code><span class="keyword">val</span> tpmv : trans:(<span class="type-var">'n</span> * <span class="type-var">'n</span>, <span class="type-var">'n</span> * <span class="type-var">'n</span>, <span class="type-var">_</span>) <a href="index.html#type-trans3">trans3</a> <span>&#45;&gt;</span> ?&#8288;diag:<a href="../Slap_common/index.html#type-diag">Slap_common.diag</a> <span>&#45;&gt;</span> ?&#8288;up:[&lt; `L | `U ] <a href="../Slap_common/index.html#type-uplo">Slap_common.uplo</a> <span>&#45;&gt;</span> (<span class="type-var">'n</span> <a href="../Slap_size/index.html#type-packed">Slap_size.packed</a>, <a href="../Slap_misc/index.html#type-cnt">Slap_misc.cnt</a>) <a href="index.html#type-vec">vec</a> <span>&#45;&gt;</span> (<span class="type-var">'n</span>, <span class="type-var">'x_cd</span>) <a href="index.html#type-vec">vec</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>tpmv ~trans ?diag ?up a x</code> executes <code>x := OP(a) * x</code> where <code>a</code> is a packed triangular matrix.</p><dl><dt>parameter trans</dt><dd><p>the transpose flag for <code>a</code>:</p><ul><li>If <code>trans</code> = <a href="../Slap_common/index.html#val-normal"><code>Slap_common.normal</code></a>, then <code>OP(a)</code> = <code>a</code>;</li><li>If <code>trans</code> = <a href="../Slap_common/index.html#type-trans"><code>Slap_common.trans</code></a>, then <code>OP(a)</code> = <code>a^T</code>;</li><li>If <code>trans</code> = <a href="../Slap_common/index.html#val-conjtr"><code>Slap_common.conjtr</code></a>, then <code>OP(a)</code> = <code>a^H</code> (the conjugate transpose of <code>a</code>).</li></ul></dd></dl><dl><dt>parameter diag</dt><dd><p>default = <a href="../Slap_common/index.html#val-non_unit"><code>Slap_common.non_unit</code></a></p><ul><li>If <code>diag</code> = <a href="../Slap_common/index.html#val-unit"><code>Slap_common.unit</code></a>, then <code>a</code> is unit triangular;</li><li>If <code>diag</code> = <a href="../Slap_common/index.html#val-non_unit"><code>Slap_common.non_unit</code></a>, then <code>a</code> is not unit triangular.</li></ul></dd></dl><dl><dt>parameter up</dt><dd><p>default = <a href="../Slap_common/index.html#val-upper"><code>Slap_common.upper</code></a></p><ul><li>If <code>up</code> = <a href="../Slap_common/index.html#val-upper"><code>Slap_common.upper</code></a>, then the upper triangular part of <code>a</code> is used;</li><li>If <code>up</code> = <a href="../Slap_common/index.html#val-lower"><code>Slap_common.lower</code></a>, then the lower triangular part of <code>a</code> is used.</li></ul></dd></dl><dl><dt>since</dt><dd>0.2.0</dd></dl></dd></dl><dl><dt class="spec value" id="val-tpsv"><a href="#val-tpsv" class="anchor"></a><code><span class="keyword">val</span> tpsv : trans:(<span class="type-var">'n</span> * <span class="type-var">'n</span>, <span class="type-var">'n</span> * <span class="type-var">'n</span>, <span class="type-var">_</span>) <a href="index.html#type-trans3">trans3</a> <span>&#45;&gt;</span> ?&#8288;diag:<a href="../Slap_common/index.html#type-diag">Slap_common.diag</a> <span>&#45;&gt;</span> ?&#8288;up:[&lt; `L | `U ] <a href="../Slap_common/index.html#type-uplo">Slap_common.uplo</a> <span>&#45;&gt;</span> (<span class="type-var">'n</span> <a href="../Slap_size/index.html#type-packed">Slap_size.packed</a>, <a href="../Slap_misc/index.html#type-cnt">Slap_misc.cnt</a>) <a href="index.html#type-vec">vec</a> <span>&#45;&gt;</span> (<span class="type-var">'n</span>, <span class="type-var">'x_cd</span>) <a href="index.html#type-vec">vec</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>tpsv ~trans ?diag ?up a b</code> solves linear system <code>OP(a) * x = b</code> and destructively assigns <code>x</code> to <code>b</code> where <code>a</code> is a packed triangular matrix.</p><dl><dt>parameter trans</dt><dd><p>the transpose flag for <code>a</code>:</p><ul><li>If <code>trans</code> = <a href="../Slap_common/index.html#val-normal"><code>Slap_common.normal</code></a>, then <code>OP(a)</code> = <code>a</code>;</li><li>If <code>trans</code> = <a href="../Slap_common/index.html#type-trans"><code>Slap_common.trans</code></a>, then <code>OP(a)</code> = <code>a^T</code>;</li><li>If <code>trans</code> = <a href="../Slap_common/index.html#val-conjtr"><code>Slap_common.conjtr</code></a>, then <code>OP(a)</code> = <code>a^H</code> (the conjugate transpose of <code>a</code>).</li></ul></dd></dl><dl><dt>parameter diag</dt><dd><p>default = <a href="../Slap_common/index.html#val-non_unit"><code>Slap_common.non_unit</code></a></p><ul><li>If <code>diag</code> = <a href="../Slap_common/index.html#val-unit"><code>Slap_common.unit</code></a>, then <code>a</code> is unit triangular;</li><li>If <code>diag</code> = <a href="../Slap_common/index.html#val-non_unit"><code>Slap_common.non_unit</code></a>, then <code>a</code> is not unit triangular.</li></ul></dd></dl><dl><dt>parameter up</dt><dd><p>default = <a href="../Slap_common/index.html#val-upper"><code>Slap_common.upper</code></a></p><ul><li>If <code>up</code> = <a href="../Slap_common/index.html#val-upper"><code>Slap_common.upper</code></a>, then the upper triangular part of <code>a</code> is used;</li><li>If <code>up</code> = <a href="../Slap_common/index.html#val-lower"><code>Slap_common.lower</code></a>, then the lower triangular part of <code>a</code> is used.</li></ul></dd></dl><dl><dt>since</dt><dd>0.2.0</dd></dl></dd></dl></section><section><header><h4 id="level-3"><a href="#level-3" class="anchor"></a>Level 3</h4></header><dl><dt class="spec value" id="val-gemm"><a href="#val-gemm" class="anchor"></a><code><span class="keyword">val</span> gemm : ?&#8288;beta:<a href="index.html#type-num_type">num_type</a> <span>&#45;&gt;</span> ?&#8288;c:(<span class="type-var">'m</span>, <span class="type-var">'n</span>, <span class="type-var">'c_cd</span>) <a href="index.html#type-mat">mat</a> <span>&#45;&gt;</span> transa:(<span class="type-var">'a_m</span> * <span class="type-var">'a_k</span>, <span class="type-var">'m</span> * <span class="type-var">'k</span>, <span class="type-var">_</span>) <a href="index.html#type-trans3">trans3</a> <span>&#45;&gt;</span> ?&#8288;alpha:<a href="index.html#type-num_type">num_type</a> <span>&#45;&gt;</span> (<span class="type-var">'a_m</span>, <span class="type-var">'a_k</span>, <span class="type-var">'a_cd</span>) <a href="index.html#type-mat">mat</a> <span>&#45;&gt;</span> transb:(<span class="type-var">'b_k</span> * <span class="type-var">'b_n</span>, <span class="type-var">'k</span> * <span class="type-var">'n</span>, <span class="type-var">_</span>) <a href="index.html#type-trans3">trans3</a> <span>&#45;&gt;</span> (<span class="type-var">'b_k</span>, <span class="type-var">'b_n</span>, <span class="type-var">'b_cd</span>) <a href="index.html#type-mat">mat</a> <span>&#45;&gt;</span> (<span class="type-var">'m</span>, <span class="type-var">'n</span>, <span class="type-var">'c_cd</span>) <a href="index.html#type-mat">mat</a></code></dt><dd><p><code>gemm ?beta ?c ~transa ?alpha a ~transb b</code> executes <code>c := alpha * OP(a) * OP(b) + beta * c</code>.</p><dl><dt>parameter beta</dt><dd><p>default = <code>0.0</code></p></dd></dl><dl><dt>parameter transa</dt><dd><p>the transpose flag for <code>a</code>:</p><ul><li>If <code>transa</code> = <a href="../Slap_common/index.html#val-normal"><code>Slap_common.normal</code></a>, then <code>OP(a)</code> = <code>a</code>;</li><li>If <code>transa</code> = <a href="../Slap_common/index.html#type-trans"><code>Slap_common.trans</code></a>, then <code>OP(a)</code> = <code>a^T</code>;</li><li>If <code>transa</code> = <a href="../Slap_common/index.html#val-conjtr"><code>Slap_common.conjtr</code></a>, then <code>OP(a)</code> = <code>a^H</code> (the conjugate transpose of <code>a</code>).</li></ul></dd></dl><dl><dt>parameter alpha</dt><dd><p>default = <code>1.0</code></p></dd></dl><dl><dt>parameter transb</dt><dd><p>the transpose flag for <code>b</code>:</p><ul><li>If <code>transb</code> = <a href="../Slap_common/index.html#val-normal"><code>Slap_common.normal</code></a>, then <code>OP(b)</code> = <code>b</code>;</li><li>If <code>transb</code> = <a href="../Slap_common/index.html#type-trans"><code>Slap_common.trans</code></a>, then <code>OP(b)</code> = <code>b^T</code>;</li><li>If <code>transb</code> = <a href="../Slap_common/index.html#val-conjtr"><code>Slap_common.conjtr</code></a>, then <code>OP(b)</code> = <code>b^H</code> (the conjugate transpose of <code>b</code>).</li></ul></dd></dl></dd></dl><dl><dt class="spec value" id="val-symm"><a href="#val-symm" class="anchor"></a><code><span class="keyword">val</span> symm : side:(<span class="type-var">'k</span>, <span class="type-var">'m</span>, <span class="type-var">'n</span>) <a href="../Slap_common/index.html#type-side">Slap_common.side</a> <span>&#45;&gt;</span> ?&#8288;up:[&lt; `U | `L ] <a href="../Slap_common/index.html#type-uplo">Slap_common.uplo</a> <span>&#45;&gt;</span> ?&#8288;beta:<a href="index.html#type-num_type">num_type</a> <span>&#45;&gt;</span> ?&#8288;c:(<span class="type-var">'m</span>, <span class="type-var">'n</span>, <span class="type-var">'c_cd</span>) <a href="index.html#type-mat">mat</a> <span>&#45;&gt;</span> ?&#8288;alpha:<a href="index.html#type-num_type">num_type</a> <span>&#45;&gt;</span> (<span class="type-var">'k</span>, <span class="type-var">'k</span>, <span class="type-var">'a_cd</span>) <a href="index.html#type-mat">mat</a> <span>&#45;&gt;</span> (<span class="type-var">'m</span>, <span class="type-var">'n</span>, <span class="type-var">'b_cd</span>) <a href="index.html#type-mat">mat</a> <span>&#45;&gt;</span> (<span class="type-var">'m</span>, <span class="type-var">'n</span>, <span class="type-var">'c_cd</span>) <a href="index.html#type-mat">mat</a></code></dt><dd><p><code>symm ~side ?up ?beta ?c ?alpha a b</code> executes</p><ul><li><code>c := alpha * a * b + beta * c</code> (if <code>side</code> = <a href="../Slap_common/index.html#val-left"><code>Slap_common.left</code></a>) or</li><li><code>c := alpha * b * a + beta * c</code> (if <code>side</code> = <a href="../Slap_common/index.html#val-right"><code>Slap_common.right</code></a>)</li></ul><p>where <code>a</code> is a symmterix matrix, and <code>b</code> and <code>c</code> are general matrices.</p><dl><dt>parameter side</dt><dd><p>the side flag to specify direction of multiplication of <code>a</code> and <code>b</code>.</p></dd></dl><dl><dt>parameter up</dt><dd><p>default = <a href="../Slap_common/index.html#val-upper"><code>Slap_common.upper</code></a></p><ul><li>If <code>up</code> = <a href="../Slap_common/index.html#val-upper"><code>Slap_common.upper</code></a>, then the upper triangular part of <code>a</code> is used;</li><li>If <code>up</code> = <a href="../Slap_common/index.html#val-lower"><code>Slap_common.lower</code></a>, then the lower triangular part of <code>a</code> is used.</li></ul></dd></dl><dl><dt>parameter beta</dt><dd><p>default = <code>0.0</code></p></dd></dl><dl><dt>parameter alpha</dt><dd><p>default = <code>1.0</code></p></dd></dl></dd></dl><dl><dt class="spec value" id="val-trmm"><a href="#val-trmm" class="anchor"></a><code><span class="keyword">val</span> trmm : side:(<span class="type-var">'k</span>, <span class="type-var">'m</span>, <span class="type-var">'n</span>) <a href="../Slap_common/index.html#type-side">Slap_common.side</a> <span>&#45;&gt;</span> ?&#8288;up:[&lt; `U | `L ] <a href="../Slap_common/index.html#type-uplo">Slap_common.uplo</a> <span>&#45;&gt;</span> transa:(<span class="type-var">'k</span> * <span class="type-var">'k</span>, <span class="type-var">'k</span> * <span class="type-var">'k</span>, <span class="type-var">_</span>) <a href="index.html#type-trans3">trans3</a> <span>&#45;&gt;</span> ?&#8288;diag:<a href="../Slap_common/index.html#type-diag">Slap_common.diag</a> <span>&#45;&gt;</span> ?&#8288;alpha:<a href="index.html#type-num_type">num_type</a> <span>&#45;&gt;</span> a:(<span class="type-var">'k</span>, <span class="type-var">'k</span>, <span class="type-var">'a_cd</span>) <a href="index.html#type-mat">mat</a> <span>&#45;&gt;</span> (<span class="type-var">'m</span>, <span class="type-var">'n</span>, <span class="type-var">'b_cd</span>) <a href="index.html#type-mat">mat</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>trmm ~side ?up ~transa ?diag ?alpha ~a b</code> executes</p><ul><li><code>b := alpha * OP(a) * b</code> (if <code>side</code> = <a href="../Slap_common/index.html#val-left"><code>Slap_common.left</code></a>) or</li><li><code>b := alpha * b * OP(a)</code> (if <code>side</code> = <a href="../Slap_common/index.html#val-right"><code>Slap_common.right</code></a>)</li></ul><p>where <code>a</code> is a triangular matrix, and <code>b</code> is a general matrix.</p><dl><dt>parameter side</dt><dd><p>the side flag to specify direction of multiplication of <code>a</code> and <code>b</code>.</p></dd></dl><dl><dt>parameter up</dt><dd><p>default = <a href="../Slap_common/index.html#val-upper"><code>Slap_common.upper</code></a></p><ul><li>If <code>up</code> = <a href="../Slap_common/index.html#val-upper"><code>Slap_common.upper</code></a>, then the upper triangular part of <code>a</code> is used;</li><li>If <code>up</code> = <a href="../Slap_common/index.html#val-lower"><code>Slap_common.lower</code></a>, then the lower triangular part of <code>a</code> is used.</li></ul></dd></dl><dl><dt>parameter transa</dt><dd><p>the transpose flag for <code>a</code>:</p><ul><li>If <code>transa</code> = <a href="../Slap_common/index.html#val-normal"><code>Slap_common.normal</code></a>, then <code>OP(a)</code> = <code>a</code>;</li><li>If <code>transa</code> = <a href="../Slap_common/index.html#type-trans"><code>Slap_common.trans</code></a>, then <code>OP(a)</code> = <code>a^T</code>;</li><li>If <code>transa</code> = <a href="../Slap_common/index.html#val-conjtr"><code>Slap_common.conjtr</code></a>, then <code>OP(a)</code> = <code>a^H</code> (the conjugate transpose of <code>a</code>).</li></ul></dd></dl><dl><dt>parameter diag</dt><dd><p>default = <a href="../Slap_common/index.html#val-non_unit"><code>Slap_common.non_unit</code></a></p><ul><li>If <code>diag</code> = <a href="../Slap_common/index.html#val-unit"><code>Slap_common.unit</code></a>, then <code>a</code> is unit triangular;</li><li>If <code>diag</code> = <a href="../Slap_common/index.html#val-non_unit"><code>Slap_common.non_unit</code></a>, then <code>a</code> is not unit triangular.</li></ul></dd></dl><dl><dt>parameter alpha</dt><dd><p>default = <code>1.0</code></p></dd></dl></dd></dl><dl><dt class="spec value" id="val-trsm"><a href="#val-trsm" class="anchor"></a><code><span class="keyword">val</span> trsm : side:(<span class="type-var">'k</span>, <span class="type-var">'m</span>, <span class="type-var">'n</span>) <a href="../Slap_common/index.html#type-side">Slap_common.side</a> <span>&#45;&gt;</span> ?&#8288;up:[&lt; `U | `L ] <a href="../Slap_common/index.html#type-uplo">Slap_common.uplo</a> <span>&#45;&gt;</span> transa:(<span class="type-var">'k</span> * <span class="type-var">'k</span>, <span class="type-var">'k</span> * <span class="type-var">'k</span>, <span class="type-var">_</span>) <a href="index.html#type-trans3">trans3</a> <span>&#45;&gt;</span> ?&#8288;diag:<a href="../Slap_common/index.html#type-diag">Slap_common.diag</a> <span>&#45;&gt;</span> ?&#8288;alpha:<a href="index.html#type-num_type">num_type</a> <span>&#45;&gt;</span> a:(<span class="type-var">'k</span>, <span class="type-var">'k</span>, <span class="type-var">'a_cd</span>) <a href="index.html#type-mat">mat</a> <span>&#45;&gt;</span> (<span class="type-var">'m</span>, <span class="type-var">'n</span>, <span class="type-var">'b_cd</span>) <a href="index.html#type-mat">mat</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>trsm ~side ?up ~transa ?diag ?alpha ~a b</code> solves a system of linear equations</p><ul><li><code>OP(a) * x = alpha * b</code> (if <code>side</code> = <a href="../Slap_common/index.html#val-left"><code>Slap_common.left</code></a>) or</li><li><code>x * OP(a) = alpha * b</code> (if <code>side</code> = <a href="../Slap_common/index.html#val-right"><code>Slap_common.right</code></a>)</li></ul><p>where <code>a</code> is a triangular matrix, and <code>b</code> is a general matrix. The solution <code>x</code> is returned by <code>b</code>.</p><dl><dt>parameter side</dt><dd><p>the side flag to specify direction of multiplication of <code>a</code> and <code>b</code>.</p></dd></dl><dl><dt>parameter up</dt><dd><p>default = <a href="../Slap_common/index.html#val-upper"><code>Slap_common.upper</code></a></p><ul><li>If <code>up</code> = <a href="../Slap_common/index.html#val-upper"><code>Slap_common.upper</code></a>, then the upper triangular part of <code>a</code> is used;</li><li>If <code>up</code> = <a href="../Slap_common/index.html#val-lower"><code>Slap_common.lower</code></a>, then the lower triangular part of <code>a</code> is used.</li></ul></dd></dl><dl><dt>parameter transa</dt><dd><p>the transpose flag for <code>a</code>:</p><ul><li>If <code>transa</code> = <a href="../Slap_common/index.html#val-normal"><code>Slap_common.normal</code></a>, then <code>OP(a)</code> = <code>a</code>;</li><li>If <code>transa</code> = <a href="../Slap_common/index.html#type-trans"><code>Slap_common.trans</code></a>, then <code>OP(a)</code> = <code>a^T</code>;</li><li>If <code>transa</code> = <a href="../Slap_common/index.html#val-conjtr"><code>Slap_common.conjtr</code></a>, then <code>OP(a)</code> = <code>a^H</code> (the conjugate transpose of <code>a</code>).</li></ul></dd></dl><dl><dt>parameter diag</dt><dd><p>default = <a href="../Slap_common/index.html#val-non_unit"><code>Slap_common.non_unit</code></a></p><ul><li>If <code>diag</code> = <a href="../Slap_common/index.html#val-unit"><code>Slap_common.unit</code></a>, then <code>a</code> is unit triangular;</li><li>If <code>diag</code> = <a href="../Slap_common/index.html#val-non_unit"><code>Slap_common.non_unit</code></a>, then <code>a</code> is not unit triangular.</li></ul></dd></dl><dl><dt>parameter alpha</dt><dd><p>default = <code>1.0</code></p></dd></dl></dd></dl><dl><dt class="spec value" id="val-syrk"><a href="#val-syrk" class="anchor"></a><code><span class="keyword">val</span> syrk : ?&#8288;up:[&lt; `U | `L ] <a href="../Slap_common/index.html#type-uplo">Slap_common.uplo</a> <span>&#45;&gt;</span> ?&#8288;beta:<a href="index.html#type-num_type">num_type</a> <span>&#45;&gt;</span> ?&#8288;c:(<span class="type-var">'n</span>, <span class="type-var">'n</span>, <span class="type-var">'c_cd</span>) <a href="index.html#type-mat">mat</a> <span>&#45;&gt;</span> trans:(<span class="type-var">'a_n</span> * <span class="type-var">'a_k</span>, <span class="type-var">'n</span> * <span class="type-var">'k</span>, <span class="type-var">_</span>) <a href="../Slap_common/index.html#type-trans2">Slap_common.trans2</a> <span>&#45;&gt;</span> ?&#8288;alpha:<a href="index.html#type-num_type">num_type</a> <span>&#45;&gt;</span> (<span class="type-var">'a_n</span>, <span class="type-var">'a_k</span>, <span class="type-var">'a_cd</span>) <a href="index.html#type-mat">mat</a> <span>&#45;&gt;</span> (<span class="type-var">'n</span>, <span class="type-var">'n</span>, <span class="type-var">'c_cd</span>) <a href="index.html#type-mat">mat</a></code></dt><dd><p><code>syrk ?up ?beta ?c ~trans ?alpha a</code> executes</p><ul><li><code>c := alpha * a * a^T + beta * c</code> (if <code>trans</code> = <a href="../Slap_common/index.html#val-normal"><code>Slap_common.normal</code></a>) or</li><li><code>c := alpha * a^T * a + beta * c</code> (if <code>trans</code> = <a href="../Slap_common/index.html#type-trans"><code>Slap_common.trans</code></a>)</li></ul><p>where <code>a</code> is a general matrix and <code>c</code> is a symmetric matrix.</p><dl><dt>parameter up</dt><dd><p>default = <a href="../Slap_common/index.html#val-upper"><code>Slap_common.upper</code></a></p><ul><li>If <code>up</code> = <a href="../Slap_common/index.html#val-upper"><code>Slap_common.upper</code></a>, then the upper triangular part of <code>a</code> is used;</li><li>If <code>up</code> = <a href="../Slap_common/index.html#val-lower"><code>Slap_common.lower</code></a>, then the lower triangular part of <code>a</code> is used.</li></ul></dd></dl><dl><dt>parameter beta</dt><dd><p>default = <code>0.0</code></p></dd></dl><dl><dt>parameter trans</dt><dd><p>the transpose flag for <code>a</code></p></dd></dl><dl><dt>parameter alpha</dt><dd><p>default = <code>1.0</code></p></dd></dl></dd></dl><dl><dt class="spec value" id="val-syr2k"><a href="#val-syr2k" class="anchor"></a><code><span class="keyword">val</span> syr2k : ?&#8288;up:[&lt; `U | `L ] <a href="../Slap_common/index.html#type-uplo">Slap_common.uplo</a> <span>&#45;&gt;</span> ?&#8288;beta:<a href="index.html#type-num_type">num_type</a> <span>&#45;&gt;</span> ?&#8288;c:(<span class="type-var">'n</span>, <span class="type-var">'n</span>, <span class="type-var">'c_cd</span>) <a href="index.html#type-mat">mat</a> <span>&#45;&gt;</span> trans:(<span class="type-var">'p</span> * <span class="type-var">'q</span>, <span class="type-var">'n</span> * <span class="type-var">'k</span>, <span class="type-var">_</span>) <a href="../Slap_common/index.html#type-trans2">Slap_common.trans2</a> <span>&#45;&gt;</span> ?&#8288;alpha:<a href="index.html#type-num_type">num_type</a> <span>&#45;&gt;</span> (<span class="type-var">'p</span>, <span class="type-var">'q</span>, <span class="type-var">'a_cd</span>) <a href="index.html#type-mat">mat</a> <span>&#45;&gt;</span> (<span class="type-var">'p</span>, <span class="type-var">'q</span>, <span class="type-var">'b_cd</span>) <a href="index.html#type-mat">mat</a> <span>&#45;&gt;</span> (<span class="type-var">'n</span>, <span class="type-var">'n</span>, <span class="type-var">'c_cd</span>) <a href="index.html#type-mat">mat</a></code></dt><dd><p><code>syr2k ?up ?beta ?c ~trans ?alpha a b</code> computes</p><ul><li><code>c := alpha * a * b^T + alpha * b * a^T + beta * c</code> (if <code>trans</code> = <a href="../Slap_common/index.html#val-normal"><code>Slap_common.normal</code></a>) or</li><li><code>c := alpha * a^T * b + alpha * b^T * a + beta * c</code> (if <code>trans</code> = <a href="../Slap_common/index.html#type-trans"><code>Slap_common.trans</code></a>)</li></ul><p>with symmetric matrix <code>c</code>, and general matrices <code>a</code> and <code>b</code>.</p><dl><dt>parameter up</dt><dd><p>default = <a href="../Slap_common/index.html#val-upper"><code>Slap_common.upper</code></a></p><ul><li>If <code>up</code> = <a href="../Slap_common/index.html#val-upper"><code>Slap_common.upper</code></a>, then the upper triangular part of <code>a</code> is used;</li><li>If <code>up</code> = <a href="../Slap_common/index.html#val-lower"><code>Slap_common.lower</code></a>, then the lower triangular part of <code>a</code> is used.</li></ul></dd></dl><dl><dt>parameter beta</dt><dd><p>default = <code>0.0</code></p></dd></dl><dl><dt>parameter trans</dt><dd><p>the transpose flag for <code>a</code></p></dd></dl><dl><dt>parameter alpha</dt><dd><p>default = <code>1.0</code></p></dd></dl></dd></dl></section></section><section><header><h3 id="lapack-interface"><a href="#lapack-interface" class="anchor"></a>LAPACK interface</h3></header><section><header><h4 id="auxiliary-routines"><a href="#auxiliary-routines" class="anchor"></a>Auxiliary routines</h4></header><dl><dt class="spec value" id="val-lacpy"><a href="#val-lacpy" class="anchor"></a><code><span class="keyword">val</span> lacpy : ?&#8288;uplo:[&lt; `A | `L | `U ] <a href="../Slap_common/index.html#type-uplo">Slap_common.uplo</a> <span>&#45;&gt;</span> ?&#8288;b:(<span class="type-var">'m</span>, <span class="type-var">'n</span>, <span class="type-var">'b_cd</span>) <a href="index.html#type-mat">mat</a> <span>&#45;&gt;</span> (<span class="type-var">'m</span>, <span class="type-var">'n</span>, <span class="type-var">'a_cd</span>) <a href="index.html#type-mat">mat</a> <span>&#45;&gt;</span> (<span class="type-var">'m</span>, <span class="type-var">'n</span>, <span class="type-var">'b_cd</span>) <a href="index.html#type-mat">mat</a></code></dt><dd><p><code>lacpy ?uplo ?b a</code> copies the matrix <code>a</code> into the matrix <code>b</code>.</p><dl><dt>returns</dt><dd><p><code>b</code>, which is overwritten.</p></dd></dl><dl><dt>parameter uplo</dt><dd><p>default = <a href="../Slap_common/index.html#val-upper_lower"><code>Slap_common.upper_lower</code></a></p><ul><li>If <code>uplo</code> = <a href="../Slap_common/index.html#val-upper"><code>Slap_common.upper</code></a>, then the upper triangular part of <code>a</code> is copied;</li><li>If <code>uplo</code> = <a href="../Slap_common/index.html#val-lower"><code>Slap_common.lower</code></a>, then the lower triangular part of <code>a</code> is copied.</li></ul></dd></dl><dl><dt>parameter b</dt><dd><p>default = a fresh matrix.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-lassq"><a href="#val-lassq" class="anchor"></a><code><span class="keyword">val</span> lassq : ?&#8288;scale:float <span>&#45;&gt;</span> ?&#8288;sumsq:float <span>&#45;&gt;</span> (<span class="type-var">'n</span>, <span class="type-var">'cd</span>) <a href="index.html#type-vec">vec</a> <span>&#45;&gt;</span> float * float</code></dt><dd><p><code>lassq ?scale ?sumsq x</code></p><dl><dt>returns</dt><dd><p><code>(scl, smsq)</code> where <code>scl</code> and <code>smsq</code> satisfy <code>scl^2 * smsq = x1^2 + x2^2 + ... + xn^2 + scale^2 * smsq</code>.</p></dd></dl><dl><dt>parameter scale</dt><dd><p>default = <code>0.0</code></p></dd></dl><dl><dt>parameter sumsq</dt><dd><p>default = <code>1.0</code></p></dd></dl></dd></dl><dl><dt class="spec type" id="type-larnv_liseed"><a href="#type-larnv_liseed" class="anchor"></a><code><span class="keyword">type</span> larnv_liseed</code><code> = <a href="../Slap_size/index.html#type-four">Slap_size.four</a></code></dt></dl><dl><dt class="spec value" id="val-larnv"><a href="#val-larnv" class="anchor"></a><code><span class="keyword">val</span> larnv : ?&#8288;idist:[ `Normal | `Uniform0 | `Uniform1 ] <span>&#45;&gt;</span> ?&#8288;iseed:(<a href="index.html#type-larnv_liseed">larnv_liseed</a>, <a href="../Slap_misc/index.html#type-cnt">Slap_misc.cnt</a>) <a href="../Slap_common/index.html#type-int32_vec">Slap_common.int32_vec</a> <span>&#45;&gt;</span> x:(<span class="type-var">'n</span>, <a href="../Slap_misc/index.html#type-cnt">Slap_misc.cnt</a>) <a href="index.html#type-vec">vec</a> <span>&#45;&gt;</span> unit <span>&#45;&gt;</span> (<span class="type-var">'n</span>, <span class="type-var">'cnt</span>) <a href="index.html#type-vec">vec</a></code></dt><dd><p><code>larnv ?idist ?iseed ~x ()</code> generates a random vector with the random distribution specified by <code>idist</code> and random seed <code>iseed</code>.</p><dl><dt>returns</dt><dd><p>vector <code>x</code>, which is overwritten.</p></dd></dl><dl><dt>parameter idist</dt><dd><p>default = <code>`Normal</code></p></dd></dl><dl><dt>parameter iseed</dt><dd><p>a four-dimensional integer vector with all ones.</p></dd></dl></dd></dl><dl><dt class="spec type" id="type-lange_min_lwork"><a href="#type-lange_min_lwork" class="anchor"></a><code><span class="keyword">type</span> ('m, 'a) lange_min_lwork</code></dt></dl><dl><dt class="spec value" id="val-lange_min_lwork"><a href="#val-lange_min_lwork" class="anchor"></a><code><span class="keyword">val</span> lange_min_lwork : <span class="type-var">'m</span> <a href="../Slap_size/index.html#type-t">Slap_size.t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="../Slap_common/index.html#type-norm4">Slap_common.norm4</a> <span>&#45;&gt;</span> (<span class="type-var">'m</span>, <span class="type-var">'a</span>) <a href="index.html#type-lange_min_lwork">lange_min_lwork</a> <a href="../Slap_size/index.html#type-t">Slap_size.t</a></code></dt><dd><p><code>lange_min_lwork m norm</code> computes the minimum length of workspace for <code>lange</code> routine. <code>m</code> is the number of rows in a matrix, and <code>norm</code> is the sort of matrix norms.</p></dd></dl><dl><dt class="spec value" id="val-lange"><a href="#val-lange" class="anchor"></a><code><span class="keyword">val</span> lange : ?&#8288;norm:<span class="type-var">'a</span> <a href="../Slap_common/index.html#type-norm4">Slap_common.norm4</a> <span>&#45;&gt;</span> ?&#8288;work:(<span class="type-var">'lwork</span>, <a href="../Slap_misc/index.html#type-cnt">Slap_misc.cnt</a>) <a href="index.html#type-rvec">rvec</a> <span>&#45;&gt;</span> (<span class="type-var">'m</span>, <span class="type-var">'n</span>, <span class="type-var">'cd</span>) <a href="index.html#type-mat">mat</a> <span>&#45;&gt;</span> float</code></dt><dd><p><code>lange ?norm ?work a</code></p><dl><dt>returns</dt><dd><p>the norm of matrix <code>a</code>.</p></dd></dl><dl><dt>parameter norm</dt><dd><p>default = <a href="../Slap_common/index.html#val-norm_1"><code>Slap_common.norm_1</code></a>.</p><ul><li>If <code>norm</code> = <a href="../Slap_common/index.html#val-norm_1"><code>Slap_common.norm_1</code></a>, the one norm is returned;</li><li>If <code>norm</code> = <a href="../Slap_common/index.html#val-norm_inf"><code>Slap_common.norm_inf</code></a>, the infinity norm is returned;</li><li>If <code>norm</code> = <a href="../Slap_common/index.html#val-norm_amax"><code>Slap_common.norm_amax</code></a>, the largest absolute value of elements in matrix <code>a</code> (not a matrix norm) is returned;</li><li>If <code>norm</code> = <a href="../Slap_common/index.html#val-norm_frob"><code>Slap_common.norm_frob</code></a>, the Frobenius norm is returned.</li></ul></dd></dl><dl><dt>parameter work</dt><dd><p>default = an optimum-length vector.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-lauum"><a href="#val-lauum" class="anchor"></a><code><span class="keyword">val</span> lauum : ?&#8288;up:[&lt; `U | `L ] <a href="../Slap_common/index.html#type-uplo">Slap_common.uplo</a> <span>&#45;&gt;</span> (<span class="type-var">'n</span>, <span class="type-var">'n</span>, <span class="type-var">'cd</span>) <a href="index.html#type-mat">mat</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>lauum ?up a</code> computes</p><ul><li><code>U * U^T</code> where <code>U</code> is the upper triangular part of matrix <code>a</code> if <code>up</code> is <a href="../Slap_common/index.html#val-upper"><code>Slap_common.upper</code></a>.</li><li><code>L^T * L</code> where <code>L</code> is the lower triangular part of matrix <code>a</code> if <code>up</code> is <a href="../Slap_common/index.html#val-lower"><code>Slap_common.lower</code></a>.</li></ul><p>The upper or lower triangular part is overwritten.</p><dl><dt>parameter up</dt><dd><p>default = <a href="../Slap_common/index.html#val-upper"><code>Slap_common.upper</code></a></p><ul><li>If <code>up</code> = <a href="../Slap_common/index.html#val-upper"><code>Slap_common.upper</code></a>, then the upper triangular part of <code>a</code> is used;</li><li>If <code>up</code> = <a href="../Slap_common/index.html#val-lower"><code>Slap_common.lower</code></a>, then the lower triangular part of <code>a</code> is used.</li></ul></dd></dl></dd></dl></section><section><header><h4 id="linear-equations-(computational-routines)"><a href="#linear-equations-(computational-routines)" class="anchor"></a>Linear equations (computational routines)</h4></header><dl><dt class="spec value" id="val-getrf"><a href="#val-getrf" class="anchor"></a><code><span class="keyword">val</span> getrf : ?&#8288;ipiv:((<span class="type-var">'m</span>, <span class="type-var">'n</span>) <a href="../Slap_size/index.html#type-min">Slap_size.min</a>, <a href="../Slap_misc/index.html#type-cnt">Slap_misc.cnt</a>) <a href="../Slap_common/index.html#type-int32_vec">Slap_common.int32_vec</a> <span>&#45;&gt;</span> (<span class="type-var">'m</span>, <span class="type-var">'n</span>, <span class="type-var">'cd</span>) <a href="index.html#type-mat">mat</a> <span>&#45;&gt;</span> ((<span class="type-var">'m</span>, <span class="type-var">'n</span>) <a href="../Slap_size/index.html#type-min">Slap_size.min</a>, <span class="type-var">'cnt</span>) <a href="../Slap_common/index.html#type-int32_vec">Slap_common.int32_vec</a></code></dt><dd><p><code>getrf ?ipiv a</code> computes LU factorization of matrix <code>a</code> using partial pivoting with row interchanges: <code>a = P * L * U</code> where <code>P</code> is a permutation matrix, and <code>L</code> and <code>U</code> are lower and upper triangular matrices, respectively. the permutation matrix is returned in <code>ipiv</code>.</p><dl><dt>returns</dt><dd><p>vector <code>ipiv</code>, which is overwritten.</p></dd></dl><dl><dt>raises Failure</dt><dd><p>if the matrix is singular.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-getrs"><a href="#val-getrs" class="anchor"></a><code><span class="keyword">val</span> getrs : ?&#8288;ipiv:((<span class="type-var">'n</span>, <span class="type-var">'n</span>) <a href="../Slap_size/index.html#type-min">Slap_size.min</a>, <a href="../Slap_misc/index.html#type-cnt">Slap_misc.cnt</a>) <a href="../Slap_common/index.html#type-int32_vec">Slap_common.int32_vec</a> <span>&#45;&gt;</span> trans:(<span class="type-var">'n</span> * <span class="type-var">'n</span>, <span class="type-var">'n</span> * <span class="type-var">'n</span>, <span class="type-var">_</span>) <a href="index.html#type-trans3">trans3</a> <span>&#45;&gt;</span> (<span class="type-var">'n</span>, <span class="type-var">'n</span>, <span class="type-var">'a_cd</span>) <a href="index.html#type-mat">mat</a> <span>&#45;&gt;</span> (<span class="type-var">'n</span>, <span class="type-var">'nrhs</span>, <span class="type-var">'b_cd</span>) <a href="index.html#type-mat">mat</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>getrs ?ipiv trans a b</code> solves systems of linear equations <code>OP(a) * x = b</code> where <code>a</code> a <code>'n</code>-by-<code>'n</code> general matrix, each column of matrix <code>b</code> is the r.h.s. vector, and each column of matrix <code>x</code> is the corresponding solution. The solution <code>x</code> is returned in <code>b</code>.</p><dl><dt>parameter ipiv</dt><dd><p>a result of <code>gesv</code> or <code>getrf</code>. It is internally computed by <code>getrf</code> if omitted.</p></dd></dl><dl><dt>parameter trans</dt><dd><p>the transpose flag for <code>a</code>:</p><ul><li>If <code>trans</code> = <a href="../Slap_common/index.html#val-normal"><code>Slap_common.normal</code></a>, then <code>OP(a)</code> = <code>a</code>;</li><li>If <code>trans</code> = <a href="../Slap_common/index.html#type-trans"><code>Slap_common.trans</code></a>, then <code>OP(a)</code> = <code>a^T</code>;</li><li>If <code>trans</code> = <a href="../Slap_common/index.html#val-conjtr"><code>Slap_common.conjtr</code></a>, then <code>OP(a)</code> = <code>a^H</code> (the conjugate transpose of <code>a</code>).</li></ul></dd></dl><dl><dt>raises Failure</dt><dd><p>if the matrix is singular.</p></dd></dl></dd></dl><dl><dt class="spec type" id="type-getri_min_lwork"><a href="#type-getri_min_lwork" class="anchor"></a><code><span class="keyword">type</span> 'n getri_min_lwork</code></dt></dl><dl><dt class="spec value" id="val-getri_min_lwork"><a href="#val-getri_min_lwork" class="anchor"></a><code><span class="keyword">val</span> getri_min_lwork : <span class="type-var">'n</span> <a href="../Slap_size/index.html#type-t">Slap_size.t</a> <span>&#45;&gt;</span> <span class="type-var">'n</span> <a href="index.html#type-getri_min_lwork">getri_min_lwork</a> <a href="../Slap_size/index.html#type-t">Slap_size.t</a></code></dt><dd><p><code>getri_min_lwork n</code> computes the minimum length of workspace for <code>getri</code> routine. <code>n</code> is the number of columns or rows in a matrix.</p></dd></dl><dl><dt class="spec value" id="val-getri_opt_lwork"><a href="#val-getri_opt_lwork" class="anchor"></a><code><span class="keyword">val</span> getri_opt_lwork : (<span class="type-var">'n</span>, <span class="type-var">'n</span>, <span class="type-var">'cd</span>) <a href="index.html#type-mat">mat</a> <span>&#45;&gt;</span> (<span class="keyword">module</span> <a href="../Slap_size/module-type-SIZE/index.html">Slap_size.SIZE</a>)</code></dt><dd><p><code>getri_opt_lwork a</code> computes the optimal length of workspace for <code>getri</code> routine.</p></dd></dl><dl><dt class="spec value" id="val-getri"><a href="#val-getri" class="anchor"></a><code><span class="keyword">val</span> getri : ?&#8288;ipiv:((<span class="type-var">'n</span>, <span class="type-var">'n</span>) <a href="../Slap_size/index.html#type-min">Slap_size.min</a>, <a href="../Slap_misc/index.html#type-cnt">Slap_misc.cnt</a>) <a href="../Slap_common/index.html#type-int32_vec">Slap_common.int32_vec</a> <span>&#45;&gt;</span> ?&#8288;work:(<span class="type-var">'lwork</span>, <a href="../Slap_misc/index.html#type-cnt">Slap_misc.cnt</a>) <a href="index.html#type-vec">vec</a> <span>&#45;&gt;</span> (<span class="type-var">'n</span>, <span class="type-var">'n</span>, <span class="type-var">'cd</span>) <a href="index.html#type-mat">mat</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>getri ?ipiv ?work a</code> computes the inverse of general matrix <code>a</code> by LU-factorization. The inverse matrix is returned in <code>a</code>.</p><dl><dt>parameter ipiv</dt><dd><p>a result of <code>gesv</code> or <code>getrf</code>. It is internally computed by <code>getrf</code> if omitted.</p></dd></dl><dl><dt>parameter work</dt><dd><p>default = an optimum-length vector.</p></dd></dl><dl><dt>raises Failure</dt><dd><p>if the matrix is singular.</p></dd></dl></dd></dl><dl><dt class="spec type" id="type-sytrf_min_lwork"><a href="#type-sytrf_min_lwork" class="anchor"></a><code><span class="keyword">type</span> sytrf_min_lwork</code></dt></dl><dl><dt class="spec value" id="val-sytrf_min_lwork"><a href="#val-sytrf_min_lwork" class="anchor"></a><code><span class="keyword">val</span> sytrf_min_lwork : unit <span>&#45;&gt;</span> <a href="index.html#type-sytrf_min_lwork">sytrf_min_lwork</a> <a href="../Slap_size/index.html#type-t">Slap_size.t</a></code></dt><dd><p><code>sytrf_min_lwork ()</code> computes the minimum length of workspace for <code>sytrf</code> routine.</p></dd></dl><dl><dt class="spec value" id="val-sytrf_opt_lwork"><a href="#val-sytrf_opt_lwork" class="anchor"></a><code><span class="keyword">val</span> sytrf_opt_lwork : ?&#8288;up:[&lt; `U | `L ] <a href="../Slap_common/index.html#type-uplo">Slap_common.uplo</a> <span>&#45;&gt;</span> (<span class="type-var">'n</span>, <span class="type-var">'n</span>, <span class="type-var">'cd</span>) <a href="index.html#type-mat">mat</a> <span>&#45;&gt;</span> (<span class="keyword">module</span> <a href="../Slap_size/module-type-SIZE/index.html">Slap_size.SIZE</a>)</code></dt><dd><p><code>sytrf_opt_lwork ?up a</code> computes the optimal length of workspace for <code>sytrf</code> routine.</p><dl><dt>parameter up</dt><dd><p>default = <code>true</code></p><ul><li>If <code>up</code> = <code>true</code>, then the upper triangular part of <code>a</code> is used;</li><li>If <code>up</code> = <code>false</code>, then the lower triangular part of <code>a</code> is used.</li></ul></dd></dl></dd></dl><dl><dt class="spec value" id="val-sytrf"><a href="#val-sytrf" class="anchor"></a><code><span class="keyword">val</span> sytrf : ?&#8288;up:[&lt; `U | `L ] <a href="../Slap_common/index.html#type-uplo">Slap_common.uplo</a> <span>&#45;&gt;</span> ?&#8288;ipiv:(<span class="type-var">'n</span>, <a href="../Slap_misc/index.html#type-cnt">Slap_misc.cnt</a>) <a href="../Slap_common/index.html#type-int32_vec">Slap_common.int32_vec</a> <span>&#45;&gt;</span> ?&#8288;work:(<span class="type-var">'lwork</span>, <a href="../Slap_misc/index.html#type-cnt">Slap_misc.cnt</a>) <a href="index.html#type-vec">vec</a> <span>&#45;&gt;</span> (<span class="type-var">'n</span>, <span class="type-var">'n</span>, <span class="type-var">'cd</span>) <a href="index.html#type-mat">mat</a> <span>&#45;&gt;</span> (<span class="type-var">'n</span>, <span class="type-var">'cnt</span>) <a href="../Slap_common/index.html#type-int32_vec">Slap_common.int32_vec</a></code></dt><dd><p><code>sytrf ?up ?ipiv ?work a</code> factorizes symmetric matrix <code>a</code> using the Bunch-Kaufman diagonal pivoting method:</p><ul><li><code>a = P * U * D * U^T * P^T</code> if <code>up</code> = <code>true</code>;</li><li><code>a = P * L * D * L^T * P^T</code> if <code>up</code> = <code>false</code></li></ul><p>where <code>P</code> is a permutation matrix, <code>U</code> and <code>L</code> are upper and lower triangular matrices with unit diagonal, and <code>D</code> is a symmetric block-diagonal matrix. The permutation matrix is returned in <code>ipiv</code>.</p><dl><dt>returns</dt><dd><p>vector <code>ipiv</code>, which is overwritten.</p></dd></dl><dl><dt>parameter up</dt><dd><p>default = <a href="../Slap_common/index.html#val-upper"><code>Slap_common.upper</code></a></p><ul><li>If <code>up</code> = <a href="../Slap_common/index.html#val-upper"><code>Slap_common.upper</code></a>, then the upper triangular part of <code>a</code> is used;</li><li>If <code>up</code> = <a href="../Slap_common/index.html#val-lower"><code>Slap_common.lower</code></a>, then the lower triangular part of <code>a</code> is used.</li></ul></dd></dl><dl><dt>parameter work</dt><dd><p>default = an optimum-length vector.</p></dd></dl><dl><dt>raises Failure</dt><dd><p>if <code>a</code> is singular.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-sytrs"><a href="#val-sytrs" class="anchor"></a><code><span class="keyword">val</span> sytrs : ?&#8288;up:[&lt; `U | `L ] <a href="../Slap_common/index.html#type-uplo">Slap_common.uplo</a> <span>&#45;&gt;</span> ?&#8288;ipiv:(<span class="type-var">'n</span>, <a href="../Slap_misc/index.html#type-cnt">Slap_misc.cnt</a>) <a href="../Slap_common/index.html#type-int32_vec">Slap_common.int32_vec</a> <span>&#45;&gt;</span> (<span class="type-var">'n</span>, <span class="type-var">'n</span>, <span class="type-var">'a_cd</span>) <a href="index.html#type-mat">mat</a> <span>&#45;&gt;</span> (<span class="type-var">'n</span>, <span class="type-var">'nrhs</span>, <span class="type-var">'b_cd</span>) <a href="index.html#type-mat">mat</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>sytrs ?up ?ipiv a b</code> solves systems of linear equations <code>a * x = b</code> where <code>a</code> is a symmetric matrix, each column of matrix <code>b</code> is the r.h.s. vector, and each column of matrix <code>x</code> is the corresponding solution. The solution <code>x</code> is returned in <code>b</code>.</p><p>This routine uses the Bunch-Kaufman diagonal pivoting method:</p><ul><li><code>a = P * U * D * U^T * P^T</code> if <code>up</code> = <code>true</code>;</li><li><code>a = P * L * D * L^T * P^T</code> if <code>up</code> = <code>false</code></li></ul><p>where <code>P</code> is a permutation matrix, <code>U</code> and <code>L</code> are upper and lower triangular matrices with unit diagonal, and <code>D</code> is a symmetric block-diagonal matrix.</p><dl><dt>parameter up</dt><dd><p>default = <a href="../Slap_common/index.html#val-upper"><code>Slap_common.upper</code></a></p><ul><li>If <code>up</code> = <a href="../Slap_common/index.html#val-upper"><code>Slap_common.upper</code></a>, then the upper triangular part of <code>a</code> is used;</li><li>If <code>up</code> = <a href="../Slap_common/index.html#val-lower"><code>Slap_common.lower</code></a>, then the lower triangular part of <code>a</code> is used.</li></ul></dd></dl><dl><dt>parameter ipiv</dt><dd><p>a result of <code>sytrf</code>. It is internally computed by <code>sytrf</code> if omitted.</p></dd></dl><dl><dt>raises Failure</dt><dd><p>if <code>a</code> is singular.</p></dd></dl></dd></dl><dl><dt class="spec type" id="type-sytri_min_lwork"><a href="#type-sytri_min_lwork" class="anchor"></a><code><span class="keyword">type</span> 'n sytri_min_lwork</code></dt></dl><dl><dt class="spec value" id="val-sytri_min_lwork"><a href="#val-sytri_min_lwork" class="anchor"></a><code><span class="keyword">val</span> sytri_min_lwork : <span class="type-var">'n</span> <a href="../Slap_size/index.html#type-t">Slap_size.t</a> <span>&#45;&gt;</span> <span class="type-var">'n</span> <a href="index.html#type-sytri_min_lwork">sytri_min_lwork</a> <a href="../Slap_size/index.html#type-t">Slap_size.t</a></code></dt><dd><p><code>sytri_min_lwork ()</code> computes the minimum length of workspace for <code>sytri</code> routine.</p></dd></dl><dl><dt class="spec value" id="val-sytri"><a href="#val-sytri" class="anchor"></a><code><span class="keyword">val</span> sytri : ?&#8288;up:[&lt; `U | `L ] <a href="../Slap_common/index.html#type-uplo">Slap_common.uplo</a> <span>&#45;&gt;</span> ?&#8288;ipiv:(<span class="type-var">'n</span>, <a href="../Slap_misc/index.html#type-cnt">Slap_misc.cnt</a>) <a href="../Slap_common/index.html#type-int32_vec">Slap_common.int32_vec</a> <span>&#45;&gt;</span> ?&#8288;work:(<span class="type-var">'lwork</span>, <a href="../Slap_misc/index.html#type-cnt">Slap_misc.cnt</a>) <a href="index.html#type-vec">vec</a> <span>&#45;&gt;</span> (<span class="type-var">'n</span>, <span class="type-var">'n</span>, <span class="type-var">'cd</span>) <a href="index.html#type-mat">mat</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>sytri ?up ?ipiv ?work a</code> computes the inverse of symmetric matrix <code>a</code> using the Bunch-Kaufman diagonal pivoting method:</p><ul><li><code>a = P * U * D * U^T * P^T</code> if <code>up</code> = <code>true</code>;</li><li><code>a = P * L * D * L^T * P^T</code> if <code>up</code> = <code>false</code></li></ul><p>where <code>P</code> is a permutation matrix, <code>U</code> and <code>L</code> are upper and lower triangular matrices with unit diagonal, and <code>D</code> is a symmetric block-diagonal matrix.</p><dl><dt>parameter up</dt><dd><p>default = <a href="../Slap_common/index.html#val-upper"><code>Slap_common.upper</code></a></p><ul><li>If <code>up</code> = <a href="../Slap_common/index.html#val-upper"><code>Slap_common.upper</code></a>, then the upper triangular part of <code>a</code> is used;</li><li>If <code>up</code> = <a href="../Slap_common/index.html#val-lower"><code>Slap_common.lower</code></a>, then the lower triangular part of <code>a</code> is used.</li></ul></dd></dl><dl><dt>parameter ipiv</dt><dd><p>a result of <code>sytrf</code>. It is internally computed by <code>sytrf</code> if omitted.</p></dd></dl><dl><dt>parameter work</dt><dd><p>default = an optimum-length vector.</p></dd></dl><dl><dt>raises Failure</dt><dd><p>if <code>a</code> is singular.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-potrf"><a href="#val-potrf" class="anchor"></a><code><span class="keyword">val</span> potrf : ?&#8288;up:[&lt; `U | `L ] <a href="../Slap_common/index.html#type-uplo">Slap_common.uplo</a> <span>&#45;&gt;</span> ?&#8288;jitter:<a href="index.html#type-num_type">num_type</a> <span>&#45;&gt;</span> (<span class="type-var">'n</span>, <span class="type-var">'n</span>, <span class="type-var">'cd</span>) <a href="index.html#type-mat">mat</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>potrf ?up ?jitter a</code> computes the Cholesky factorization of symmetrix (Hermitian) positive-definite matrix <code>a</code>:</p><ul><li><code>a = U^T * U</code> (real) or <code>a = U^H * U</code> (complex) if <code>up</code> = <code>true</code>;</li><li><code>a = L * L^T</code> (real) or <code>a = L * L^H</code> (complex) if <code>up</code> = <code>false</code></li></ul><p>where <code>U</code> and <code>L</code> are upper and lower triangular matrices, respectively. Either of them is returned in the upper or lower triangular part of <code>a</code>, as specified by <code>up</code>.</p><dl><dt>parameter up</dt><dd><p>default = <a href="../Slap_common/index.html#val-upper"><code>Slap_common.upper</code></a></p><ul><li>If <code>up</code> = <a href="../Slap_common/index.html#val-upper"><code>Slap_common.upper</code></a>, then the upper triangular part of <code>a</code> is used;</li><li>If <code>up</code> = <a href="../Slap_common/index.html#val-lower"><code>Slap_common.lower</code></a>, then the lower triangular part of <code>a</code> is used.</li></ul></dd></dl><dl><dt>parameter jitter</dt><dd><p>default = nothing</p></dd></dl><dl><dt>raises Failure</dt><dd><p>if <code>a</code> is not positive-definite symmetric.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-potrs"><a href="#val-potrs" class="anchor"></a><code><span class="keyword">val</span> potrs : ?&#8288;up:[&lt; `U | `L ] <a href="../Slap_common/index.html#type-uplo">Slap_common.uplo</a> <span>&#45;&gt;</span> (<span class="type-var">'n</span>, <span class="type-var">'n</span>, <span class="type-var">'a_cd</span>) <a href="index.html#type-mat">mat</a> <span>&#45;&gt;</span> ?&#8288;factorize:bool <span>&#45;&gt;</span> ?&#8288;jitter:<a href="index.html#type-num_type">num_type</a> <span>&#45;&gt;</span> (<span class="type-var">'n</span>, <span class="type-var">'nrhs</span>, <span class="type-var">'b_cd</span>) <a href="index.html#type-mat">mat</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>potrf ?up a ?jitter b</code> solves systems of linear equations <code>a * x = b</code> using the Cholesky factorization of symmetrix (Hermitian) positive-definite matrix <code>a</code>:</p><ul><li><code>a = U^T * U</code> (real) or <code>a = U^H * U</code> (complex) if <code>up</code> = <a href="../Slap_common/index.html#val-upper"><code>Slap_common.upper</code></a>;</li><li><code>a = L * L^T</code> (real) or <code>a = L * L^H</code> (complex) if <code>up</code> = <a href="../Slap_common/index.html#val-lower"><code>Slap_common.lower</code></a></li></ul><p>where <code>U</code> and <code>L</code> are upper and lower triangular matrices, respectively.</p><dl><dt>parameter up</dt><dd><p>default = <a href="../Slap_common/index.html#val-upper"><code>Slap_common.upper</code></a></p><ul><li>If <code>up</code> = <a href="../Slap_common/index.html#val-upper"><code>Slap_common.upper</code></a>, then the upper triangular part of <code>a</code> is used;</li><li>If <code>up</code> = <a href="../Slap_common/index.html#val-lower"><code>Slap_common.lower</code></a>, then the lower triangular part of <code>a</code> is used.</li></ul></dd></dl><dl><dt>parameter factorize</dt><dd><p>default = <code>true</code> (<code>potrf</code> is called implicitly)</p></dd></dl><dl><dt>parameter jitter</dt><dd><p>default = nothing</p></dd></dl><dl><dt>raises Failure</dt><dd><p>if <code>a</code> is singular.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-potri"><a href="#val-potri" class="anchor"></a><code><span class="keyword">val</span> potri : ?&#8288;up:[&lt; `U | `L ] <a href="../Slap_common/index.html#type-uplo">Slap_common.uplo</a> <span>&#45;&gt;</span> ?&#8288;factorize:bool <span>&#45;&gt;</span> ?&#8288;jitter:<a href="index.html#type-num_type">num_type</a> <span>&#45;&gt;</span> (<span class="type-var">'n</span>, <span class="type-var">'n</span>, <span class="type-var">'cd</span>) <a href="index.html#type-mat">mat</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>potrf ?up ?jitter a</code> computes the inverse of symmetrix (Hermitian) positive-definite matrix <code>a</code> using the Cholesky factorization:</p><ul><li><code>a = U^T * U</code> (real) or <code>a = U^H * U</code> (complex) if <code>up</code> = <a href="../Slap_common/index.html#val-upper"><code>Slap_common.upper</code></a>;</li><li><code>a = L * L^T</code> (real) or <code>a = L * L^H</code> (complex) if <code>up</code> = <a href="../Slap_common/index.html#val-lower"><code>Slap_common.lower</code></a></li></ul><p>where <code>U</code> and <code>L</code> are upper and lower triangular matrices, respectively.</p><dl><dt>parameter up</dt><dd><p>default = <a href="../Slap_common/index.html#val-upper"><code>Slap_common.upper</code></a></p><ul><li>If <code>up</code> = <a href="../Slap_common/index.html#val-upper"><code>Slap_common.upper</code></a>, then the upper triangular part of <code>a</code> is used;</li><li>If <code>up</code> = <a href="../Slap_common/index.html#val-lower"><code>Slap_common.lower</code></a>, then the lower triangular part of <code>a</code> is used.</li></ul></dd></dl><dl><dt>parameter factorize</dt><dd><p>default = <code>true</code> (<code>potrf</code> is called implicitly)</p></dd></dl><dl><dt>parameter jitter</dt><dd><p>default = nothing</p></dd></dl><dl><dt>raises Failure</dt><dd><p>if <code>a</code> is singular.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-trtrs"><a href="#val-trtrs" class="anchor"></a><code><span class="keyword">val</span> trtrs : ?&#8288;up:[&lt; `U | `L ] <a href="../Slap_common/index.html#type-uplo">Slap_common.uplo</a> <span>&#45;&gt;</span> trans:(<span class="type-var">'n</span> * <span class="type-var">'n</span>, <span class="type-var">'n</span> * <span class="type-var">'n</span>, <span class="type-var">_</span>) <a href="index.html#type-trans3">trans3</a> <span>&#45;&gt;</span> ?&#8288;diag:<a href="../Slap_common/index.html#type-diag">Slap_common.diag</a> <span>&#45;&gt;</span> (<span class="type-var">'n</span>, <span class="type-var">'n</span>, <span class="type-var">'a_cd</span>) <a href="index.html#type-mat">mat</a> <span>&#45;&gt;</span> (<span class="type-var">'n</span>, <span class="type-var">'nrhs</span>, <span class="type-var">'b_cd</span>) <a href="index.html#type-mat">mat</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>trtrs ?up trans ?diag a b</code> solves systems of linear equations <code>OP(a) * x = b</code> where <code>a</code> is a triangular matrix of order <code>'n</code>, each column of matrix <code>b</code> is the r.h.s vector, and each column of matrix <code>x</code> is the corresponding solution. The solution <code>x</code> is returned in <code>b</code>.</p><dl><dt>parameter up</dt><dd><p>default = <a href="../Slap_common/index.html#val-upper"><code>Slap_common.upper</code></a></p><ul><li>If <code>up</code> = <a href="../Slap_common/index.html#val-upper"><code>Slap_common.upper</code></a>, then the upper triangular part of <code>a</code> is used;</li><li>If <code>up</code> = <a href="../Slap_common/index.html#val-lower"><code>Slap_common.lower</code></a>, then the lower triangular part of <code>a</code> is used.</li></ul></dd></dl><dl><dt>parameter trans</dt><dd><p>the transpose flag for <code>a</code>:</p><ul><li>If <code>trans</code> = <a href="../Slap_common/index.html#val-normal"><code>Slap_common.normal</code></a>, then <code>OP(a)</code> = <code>a</code>;</li><li>If <code>trans</code> = <a href="../Slap_common/index.html#type-trans"><code>Slap_common.trans</code></a>, then <code>OP(a)</code> = <code>a^T</code>;</li><li>If <code>trans</code> = <a href="../Slap_common/index.html#val-conjtr"><code>Slap_common.conjtr</code></a>, then <code>OP(a)</code> = <code>a^H</code> (the conjugate transpose of <code>a</code>).</li></ul></dd></dl><dl><dt>parameter diag</dt><dd><p>default = <code>`N</code></p><ul><li>If <code>diag</code> = <code>`U</code>, then <code>a</code> is unit triangular;</li><li>If <code>diag</code> = <code>`N</code>, then <code>a</code> is not unit triangular.</li></ul></dd></dl><dl><dt>raises Failure</dt><dd><p>if <code>a</code> is singular.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-tbtrs"><a href="#val-tbtrs" class="anchor"></a><code><span class="keyword">val</span> tbtrs : kd:<span class="type-var">'kd</span> <a href="../Slap_size/index.html#type-t">Slap_size.t</a> <span>&#45;&gt;</span> ?&#8288;up:[&lt; `U | `L ] <a href="../Slap_common/index.html#type-uplo">Slap_common.uplo</a> <span>&#45;&gt;</span> trans:(<span class="type-var">'n</span> * <span class="type-var">'n</span>, <span class="type-var">'n</span> * <span class="type-var">'n</span>, <span class="type-var">_</span>) <a href="index.html#type-trans3">trans3</a> <span>&#45;&gt;</span> ?&#8288;diag:<a href="../Slap_common/index.html#type-diag">Slap_common.diag</a> <span>&#45;&gt;</span> ((<span class="type-var">'n</span>, <span class="type-var">'kd</span>) <a href="../Slap_size/index.html#type-syband">Slap_size.syband</a>, <span class="type-var">'n</span>, <span class="type-var">'a_cd</span>) <a href="index.html#type-mat">mat</a> <span>&#45;&gt;</span> (<span class="type-var">'n</span>, <span class="type-var">'nrhs</span>, <span class="type-var">'b_cd</span>) <a href="index.html#type-mat">mat</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>tbtrs ~kd ?up ~trans ?diag ab b</code> solves systems of linear equations <code>OP(A) * x = b</code> where <code>A</code> is a triangular band matrix with <code>kd</code> subdiagonals, each column of matrix <code>b</code> is the r.h.s vector, and each column of matrix <code>x</code> is the corresponding solution. Matrix <code>A</code> is stored into <code>ab</code> in band storage format. The solution <code>x</code> is returned in <code>b</code>.</p><dl><dt>parameter kd</dt><dd><p>the number of subdiagonals or superdiagonals in <code>A</code>.</p></dd></dl><dl><dt>parameter up</dt><dd><p>default = <a href="../Slap_common/index.html#val-upper"><code>Slap_common.upper</code></a></p><ul><li>If <code>up</code> = <a href="../Slap_common/index.html#val-upper"><code>Slap_common.upper</code></a>, then the upper triangular part of <code>A</code> is used;</li><li>If <code>up</code> = <a href="../Slap_common/index.html#val-lower"><code>Slap_common.lower</code></a>, then the lower triangular part of <code>A</code> is used.</li></ul></dd></dl><dl><dt>parameter trans</dt><dd><p>the transpose flag for <code>A</code>:</p><ul><li>If <code>trans</code> = <a href="../Slap_common/index.html#val-normal"><code>Slap_common.normal</code></a>, then <code>OP(A)</code> = <code>A</code>;</li><li>If <code>trans</code> = <a href="../Slap_common/index.html#type-trans"><code>Slap_common.trans</code></a>, then <code>OP(A)</code> = <code>A^T</code>;</li><li>If <code>trans</code> = <a href="../Slap_common/index.html#val-conjtr"><code>Slap_common.conjtr</code></a>, then <code>OP(A)</code> = <code>A^H</code> (the conjugate transpose of <code>A</code>).</li></ul></dd></dl><dl><dt>parameter diag</dt><dd><p>default = <code>`N</code></p><ul><li>If <code>diag</code> = <code>`U</code>, then <code>A</code> is unit triangular;</li><li>If <code>diag</code> = <code>`N</code>, then <code>A</code> is not unit triangular.</li></ul></dd></dl><dl><dt>raises Failure</dt><dd><p>if the matrix <code>A</code> is singular.</p></dd></dl><dl><dt>since</dt><dd>0.2.0</dd></dl></dd></dl><dl><dt class="spec value" id="val-trtri"><a href="#val-trtri" class="anchor"></a><code><span class="keyword">val</span> trtri : ?&#8288;up:[&lt; `U | `L ] <a href="../Slap_common/index.html#type-uplo">Slap_common.uplo</a> <span>&#45;&gt;</span> ?&#8288;diag:<a href="../Slap_common/index.html#type-diag">Slap_common.diag</a> <span>&#45;&gt;</span> (<span class="type-var">'n</span>, <span class="type-var">'n</span>, <span class="type-var">'cd</span>) <a href="index.html#type-mat">mat</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>trtri ?up ?diag a</code> computes the inverse of triangular matrix <code>a</code>. The inverse matrix is returned in <code>a</code>.</p><dl><dt>parameter up</dt><dd><p>default = <a href="../Slap_common/index.html#val-upper"><code>Slap_common.upper</code></a></p><ul><li>If <code>up</code> = <a href="../Slap_common/index.html#val-upper"><code>Slap_common.upper</code></a>, then the upper triangular part of <code>A</code> is used;</li><li>If <code>up</code> = <a href="../Slap_common/index.html#val-lower"><code>Slap_common.lower</code></a>, then the lower triangular part of <code>A</code> is used.</li></ul></dd></dl><dl><dt>parameter diag</dt><dd><p>default = <code>`N</code></p><ul><li>If <code>diag</code> = <code>`U</code>, then <code>a</code> is unit triangular;</li><li>If <code>diag</code> = <code>`N</code>, then <code>a</code> is not unit triangular.</li></ul></dd></dl><dl><dt>raises Failure</dt><dd><p>if the matrix <code>a</code> is singular.</p></dd></dl><dl><dt>since</dt><dd>0.2.0</dd></dl></dd></dl><dl><dt class="spec type" id="type-geqrf_min_lwork"><a href="#type-geqrf_min_lwork" class="anchor"></a><code><span class="keyword">type</span> 'n geqrf_min_lwork</code></dt></dl><dl><dt class="spec value" id="val-geqrf_min_lwork"><a href="#val-geqrf_min_lwork" class="anchor"></a><code><span class="keyword">val</span> geqrf_min_lwork : n:<span class="type-var">'n</span> <a href="../Slap_size/index.html#type-t">Slap_size.t</a> <span>&#45;&gt;</span> <span class="type-var">'n</span> <a href="index.html#type-geqrf_min_lwork">geqrf_min_lwork</a> <a href="../Slap_size/index.html#type-t">Slap_size.t</a></code></dt><dd><p><code>geqrf_min_lwork ~n</code> computes the minimum length of workspace for <code>geqrf</code> routine. <code>n</code> is the number of columns in a matrix.</p></dd></dl><dl><dt class="spec value" id="val-geqrf_opt_lwork"><a href="#val-geqrf_opt_lwork" class="anchor"></a><code><span class="keyword">val</span> geqrf_opt_lwork : (<span class="type-var">'m</span>, <span class="type-var">'n</span>, <span class="type-var">'cd</span>) <a href="index.html#type-mat">mat</a> <span>&#45;&gt;</span> (<span class="keyword">module</span> <a href="../Slap_size/module-type-SIZE/index.html">Slap_size.SIZE</a>)</code></dt><dd><p><code>geqrf_opt_lwork a</code> computes the optimum length of workspace for <code>geqrf</code> routine.</p></dd></dl><dl><dt class="spec value" id="val-geqrf"><a href="#val-geqrf" class="anchor"></a><code><span class="keyword">val</span> geqrf : ?&#8288;work:(<span class="type-var">'lwork</span>, <a href="../Slap_misc/index.html#type-cnt">Slap_misc.cnt</a>) <a href="index.html#type-vec">vec</a> <span>&#45;&gt;</span> ?&#8288;tau:((<span class="type-var">'m</span>, <span class="type-var">'n</span>) <a href="../Slap_size/index.html#type-min">Slap_size.min</a>, <a href="../Slap_misc/index.html#type-cnt">Slap_misc.cnt</a>) <a href="index.html#type-vec">vec</a> <span>&#45;&gt;</span> (<span class="type-var">'m</span>, <span class="type-var">'n</span>, <span class="type-var">'cd</span>) <a href="index.html#type-mat">mat</a> <span>&#45;&gt;</span> ((<span class="type-var">'m</span>, <span class="type-var">'n</span>) <a href="../Slap_size/index.html#type-min">Slap_size.min</a>, <span class="type-var">'cnt</span>) <a href="index.html#type-vec">vec</a></code></dt><dd><p><code>geqrf ?work ?tau a</code> computes the QR factorization of general matrix <code>a</code>: <code>a = Q * R</code> where <code>Q</code> is an orthogonal (unitary) matrix and <code>R</code> is an upper triangular matrix. <code>R</code> is returned in <code>a</code>. This routine does not generate <code>Q</code> explicitly. It is generated by <code>orgqr</code>.</p><dl><dt>returns</dt><dd><p>vector <code>tau</code>, which is overwritten.</p></dd></dl><dl><dt>parameter work</dt><dd><p>default = an optimum-length vector.</p></dd></dl></dd></dl></section><section><header><h4 id="linear-equations-(simple-drivers)"><a href="#linear-equations-(simple-drivers)" class="anchor"></a>Linear equations (simple drivers)</h4></header><dl><dt class="spec value" id="val-gesv"><a href="#val-gesv" class="anchor"></a><code><span class="keyword">val</span> gesv : ?&#8288;ipiv:(<span class="type-var">'n</span>, <a href="../Slap_misc/index.html#type-cnt">Slap_misc.cnt</a>) <a href="../Slap_common/index.html#type-int32_vec">Slap_common.int32_vec</a> <span>&#45;&gt;</span> (<span class="type-var">'n</span>, <span class="type-var">'n</span>, <span class="type-var">'a_cd</span>) <a href="index.html#type-mat">mat</a> <span>&#45;&gt;</span> (<span class="type-var">'n</span>, <span class="type-var">'nrhs</span>, <span class="type-var">'b_cd</span>) <a href="index.html#type-mat">mat</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>gesv ?ipiv a b</code> solves a system of linear equations <code>a * x = b</code> where <code>a</code> is a <code>'n</code>-by-<code>'n</code> general matrix, each column of matrix <code>b</code> is the r.h.s. vector, and each column of matrix <code>x</code> is the corresponding solution.</p><p>This routine uses LU factorization: <code>a = P * L * U</code> with permutation matrix <code>P</code>, a lower triangular matrix <code>L</code> and an upper triangular matrix <code>U</code>. By this function, the upper triangular part of <code>a</code> is replaced by <code>U</code>, the lower triangular part by <code>L</code>, and the solution <code>x</code> is returned in <code>b</code>.</p><dl><dt>raises Failure</dt><dd><p>if the matrix is singular.</p></dd></dl><dl><dt>since</dt><dd>0.2.0</dd></dl></dd></dl><dl><dt class="spec value" id="val-gbsv"><a href="#val-gbsv" class="anchor"></a><code><span class="keyword">val</span> gbsv : ?&#8288;ipiv:(<span class="type-var">'n</span>, <a href="../Slap_misc/index.html#type-cnt">Slap_misc.cnt</a>) <a href="../Slap_common/index.html#type-int32_vec">Slap_common.int32_vec</a> <span>&#45;&gt;</span> ((<span class="type-var">'n</span>, <span class="type-var">'n</span>, <span class="type-var">'kl</span>, <span class="type-var">'ku</span>) <a href="../Slap_size/index.html#type-luband">Slap_size.luband</a>, <span class="type-var">'n</span>, <span class="type-var">'a_cd</span>) <a href="index.html#type-mat">mat</a> <span>&#45;&gt;</span> <span class="type-var">'kl</span> <a href="../Slap_size/index.html#type-t">Slap_size.t</a> <span>&#45;&gt;</span> <span class="type-var">'ku</span> <a href="../Slap_size/index.html#type-t">Slap_size.t</a> <span>&#45;&gt;</span> (<span class="type-var">'n</span>, <span class="type-var">'nrhs</span>, <span class="type-var">'b_cd</span>) <a href="index.html#type-mat">mat</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>gbsv ?ipiv ab kl ku b</code> solves a system of linear equations <code>A * X = B</code> where <code>A</code> is a <code>'n</code>-by-<code>'n</code> band matrix, each column of matrix <code>B</code> is the r.h.s. vector, and each column of matrix <code>X</code> is the corresponding solution. The matrix <code>A</code> with <code>kl</code> subdiagonals and <code>ku</code> superdiagonals is stored into <code>ab</code> in band storage format for LU factorizaion.</p><p>This routine uses LU factorization: <code>A = P * L * U</code> with permutation matrix <code>P</code>, a lower triangular matrix <code>L</code> and an upper triangular matrix <code>U</code>. By this function, the upper triangular part of <code>A</code> is replaced by <code>U</code>, the lower triangular part by <code>L</code>, and the solution <code>X</code> is returned in <code>B</code>.</p><dl><dt>raises Failure</dt><dd><p>if the matrix is singular.</p></dd></dl><dl><dt>since</dt><dd>0.2.0</dd></dl></dd></dl><dl><dt class="spec value" id="val-posv"><a href="#val-posv" class="anchor"></a><code><span class="keyword">val</span> posv : ?&#8288;up:[&lt; `U | `L ] <a href="../Slap_common/index.html#type-uplo">Slap_common.uplo</a> <span>&#45;&gt;</span> (<span class="type-var">'n</span>, <span class="type-var">'n</span>, <span class="type-var">'a_cd</span>) <a href="index.html#type-mat">mat</a> <span>&#45;&gt;</span> (<span class="type-var">'n</span>, <span class="type-var">'nrhs</span>, <span class="type-var">'b_cd</span>) <a href="index.html#type-mat">mat</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>posv ?up a b</code> solves systems of linear equations <code>a * x = b</code> where <code>a</code> is a <code>'n</code>-by-<code>'n</code> symmetric positive-definite matrix, each column of matrix <code>b</code> is the r.h.s vector, and each column of matrix <code>x</code> is the corresponding solution. The solution <code>x</code> is returned in <code>b</code>.</p><p>The Cholesky decomposition is used:</p><ul><li>If <code>up</code> = <a href="../Slap_common/index.html#val-upper"><code>Slap_common.upper</code></a>, then <code>a = U^T * U</code> (real) or <code>a = U^H * U</code> (complex)</li><li>If <code>up</code> = <a href="../Slap_common/index.html#val-lower"><code>Slap_common.lower</code></a>, then <code>a = L^T * L</code> (real) or <code>a = L^H * L</code> (complex)</li></ul><p>where <code>U</code> and <code>L</code> are the upper and lower triangular matrices, respectively.</p><dl><dt>parameter up</dt><dd><p>default = <a href="../Slap_common/index.html#val-upper"><code>Slap_common.upper</code></a></p><ul><li>If <code>up</code> = <a href="../Slap_common/index.html#val-upper"><code>Slap_common.upper</code></a>, then the upper triangular part of <code>a</code> is used;</li><li>If <code>up</code> = <a href="../Slap_common/index.html#val-lower"><code>Slap_common.lower</code></a>, then the lower triangular part of <code>a</code> is used.</li></ul></dd></dl><dl><dt>raises Failure</dt><dd><p>if the matrix is singular.</p></dd></dl><dl><dt>since</dt><dd>0.2.0</dd></dl></dd></dl><dl><dt class="spec value" id="val-ppsv"><a href="#val-ppsv" class="anchor"></a><code><span class="keyword">val</span> ppsv : ?&#8288;up:[&lt; `U | `L ] <a href="../Slap_common/index.html#type-uplo">Slap_common.uplo</a> <span>&#45;&gt;</span> (<span class="type-var">'n</span> <a href="../Slap_size/index.html#type-packed">Slap_size.packed</a>, <a href="../Slap_misc/index.html#type-cnt">Slap_misc.cnt</a>) <a href="index.html#type-vec">vec</a> <span>&#45;&gt;</span> (<span class="type-var">'n</span>, <span class="type-var">'nrhs</span>, <span class="type-var">'b_cd</span>) <a href="index.html#type-mat">mat</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>ppsv ?up a b</code> solves systems of linear equations <code>a * x = b</code> where <code>a</code> is a <code>'n</code>-by-<code>'n</code> symmetric positive-definite matrix stored in packed format, each column of matrix <code>b</code> is the r.h.s vector, and each column of matrix <code>x</code> is the corresponding solution. The solution <code>x</code> is returned in <code>b</code>.</p><ul><li>If <code>up</code> = <a href="../Slap_common/index.html#val-upper"><code>Slap_common.upper</code></a>, then <code>a = U^T * U</code> (real) or <code>a = U^H * U</code> (complex)</li><li>If <code>up</code> = <a href="../Slap_common/index.html#val-lower"><code>Slap_common.lower</code></a>, then <code>a = L^T * L</code> (real) or <code>a = L^H * L</code> (complex)</li></ul><p>where <code>U</code> and <code>L</code> are the upper and lower triangular matrices, respectively.</p><dl><dt>parameter up</dt><dd><p>default = <a href="../Slap_common/index.html#val-upper"><code>Slap_common.upper</code></a></p><ul><li>If <code>up</code> = <a href="../Slap_common/index.html#val-upper"><code>Slap_common.upper</code></a>, then the upper triangular part of <code>a</code> is used;</li><li>If <code>up</code> = <a href="../Slap_common/index.html#val-lower"><code>Slap_common.lower</code></a>, then the lower triangular part of <code>a</code> is used.</li></ul></dd></dl><dl><dt>raises Failure</dt><dd><p>if the matrix is singular.</p></dd></dl><dl><dt>since</dt><dd>0.2.0</dd></dl></dd></dl><dl><dt class="spec value" id="val-pbsv"><a href="#val-pbsv" class="anchor"></a><code><span class="keyword">val</span> pbsv : ?&#8288;up:[&lt; `U | `L ] <a href="../Slap_common/index.html#type-uplo">Slap_common.uplo</a> <span>&#45;&gt;</span> kd:<span class="type-var">'kd</span> <a href="../Slap_size/index.html#type-t">Slap_size.t</a> <span>&#45;&gt;</span> ((<span class="type-var">'n</span>, <span class="type-var">'kd</span>) <a href="../Slap_size/index.html#type-syband">Slap_size.syband</a>, <span class="type-var">'n</span>, <span class="type-var">'ab_cd</span>) <a href="index.html#type-mat">mat</a> <span>&#45;&gt;</span> (<span class="type-var">'n</span>, <span class="type-var">'nrhs</span>, <span class="type-var">'b_cd</span>) <a href="index.html#type-mat">mat</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>pbsv ?up ~kd ab b</code> solves systems of linear equations <code>ab * x = b</code> where <code>ab</code> is a <code>'n</code>-by-<code>'n</code> symmetric positive-definite band matrix with <code>kd</code> subdiangonals, stored in band storage format, each column of matrix <code>b</code> is the r.h.s vector, and each column of matrix <code>x</code> is the corresponding solution. The solution <code>x</code> is returned in <code>b</code>.</p><p>This routine uses the Cholesky decomposition:</p><ul><li>If <code>up</code> = <a href="../Slap_common/index.html#val-upper"><code>Slap_common.upper</code></a>, then <code>a = U^T * U</code> (real) or <code>a = U^H * U</code> (complex)</li><li>If <code>up</code> = <a href="../Slap_common/index.html#val-lower"><code>Slap_common.lower</code></a>, then <code>a = L^T * L</code> (real) or <code>a = L^H * L</code> (complex)</li></ul><p>where <code>U</code> and <code>L</code> are the upper and lower triangular matrices, respectively.</p><dl><dt>parameter up</dt><dd><p>default = <a href="../Slap_common/index.html#val-upper"><code>Slap_common.upper</code></a></p><ul><li>If <code>up</code> = <a href="../Slap_common/index.html#val-upper"><code>Slap_common.upper</code></a>, then the upper triangular part of <code>a</code> is used;</li><li>If <code>up</code> = <a href="../Slap_common/index.html#val-lower"><code>Slap_common.lower</code></a>, then the lower triangular part of <code>a</code> is used.</li></ul></dd></dl><dl><dt>parameter kd</dt><dd><p>the number of subdiagonals or superdiagonals in <code>ab</code>.</p></dd></dl><dl><dt>raises Failure</dt><dd><p>if the matrix is singular.</p></dd></dl><dl><dt>since</dt><dd>0.2.0</dd></dl></dd></dl><dl><dt class="spec value" id="val-ptsv"><a href="#val-ptsv" class="anchor"></a><code><span class="keyword">val</span> ptsv : (<span class="type-var">'n</span>, <a href="../Slap_misc/index.html#type-cnt">Slap_misc.cnt</a>) <a href="index.html#type-vec">vec</a> <span>&#45;&gt;</span> (<span class="type-var">'n</span> <a href="../Slap_size/index.html#type-p">Slap_size.p</a>, <a href="../Slap_misc/index.html#type-cnt">Slap_misc.cnt</a>) <a href="index.html#type-vec">vec</a> <span>&#45;&gt;</span> (<span class="type-var">'n</span>, <span class="type-var">'nrhs</span>, <span class="type-var">'b_cd</span>) <a href="index.html#type-mat">mat</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>ptsv d e b</code> solves systems of linear equations <code>A * x = b</code> where <code>A</code> is a <code>'n</code>-by-<code>'n</code> symmetric positive-definite tridiagonal matrix with diagonal elements <code>d</code> and subdiagonal elements <code>e</code>, each column of matrix <code>b</code> is the r.h.s vector, and each column of matrix <code>x</code> is the corresponding solution. The solution <code>x</code> is returned in <code>b</code>.</p><p>This routine uses the Cholesky decomposition: <code>A = L^T * L</code> (real) or <code>A = L^H * L</code> (complex) where <code>L</code> is a lower triangular matrix.</p><dl><dt>raises Failure</dt><dd><p>if the matrix is singular.</p></dd></dl><dl><dt>since</dt><dd>0.2.0</dd></dl></dd></dl><dl><dt class="spec type" id="type-sysv_min_lwork"><a href="#type-sysv_min_lwork" class="anchor"></a><code><span class="keyword">type</span> sysv_min_lwork</code></dt></dl><dl><dt class="spec value" id="val-sysv_min_lwork"><a href="#val-sysv_min_lwork" class="anchor"></a><code><span class="keyword">val</span> sysv_min_lwork : unit <span>&#45;&gt;</span> <a href="index.html#type-sysv_min_lwork">sysv_min_lwork</a> <a href="../Slap_size/index.html#type-t">Slap_size.t</a></code></dt><dd><p><code>sysv_min_lwork ()</code> computes the minimum length of workspace for <code>sysv</code> routine.</p></dd></dl><dl><dt class="spec value" id="val-sysv_opt_lwork"><a href="#val-sysv_opt_lwork" class="anchor"></a><code><span class="keyword">val</span> sysv_opt_lwork : ?&#8288;up:[&lt; `U | `L ] <a href="../Slap_common/index.html#type-uplo">Slap_common.uplo</a> <span>&#45;&gt;</span> (<span class="type-var">'n</span>, <span class="type-var">'n</span>, <span class="type-var">'a_cd</span>) <a href="index.html#type-mat">mat</a> <span>&#45;&gt;</span> (<span class="type-var">'n</span>, <span class="type-var">'nrhs</span>, <span class="type-var">'b_cd</span>) <a href="index.html#type-mat">mat</a> <span>&#45;&gt;</span> (<span class="keyword">module</span> <a href="../Slap_size/module-type-SIZE/index.html">Slap_size.SIZE</a>)</code></dt><dd><p><code>sysv_opt_lwork ?up a b</code> computes the optimal length of workspace for <code>sysv</code> routine.</p></dd></dl><dl><dt class="spec value" id="val-sysv"><a href="#val-sysv" class="anchor"></a><code><span class="keyword">val</span> sysv : ?&#8288;up:[&lt; `U | `L ] <a href="../Slap_common/index.html#type-uplo">Slap_common.uplo</a> <span>&#45;&gt;</span> ?&#8288;ipiv:(<span class="type-var">'n</span>, <a href="../Slap_misc/index.html#type-cnt">Slap_misc.cnt</a>) <a href="../Slap_common/index.html#type-int32_vec">Slap_common.int32_vec</a> <span>&#45;&gt;</span> ?&#8288;work:(<span class="type-var">'lwork</span>, <a href="../Slap_misc/index.html#type-cnt">Slap_misc.cnt</a>) <a href="index.html#type-vec">vec</a> <span>&#45;&gt;</span> (<span class="type-var">'n</span>, <span class="type-var">'n</span>, <span class="type-var">'a_cd</span>) <a href="index.html#type-mat">mat</a> <span>&#45;&gt;</span> (<span class="type-var">'n</span>, <span class="type-var">'nrhs</span>, <span class="type-var">'b_cd</span>) <a href="index.html#type-mat">mat</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>sysv ?up ?ipiv ?work a b</code> solves systems of linear equations <code>a * x = b</code> where <code>a</code> is a <code>'n</code>-by-<code>'n</code> symmetric matrix, each column of matrix <code>b</code> is the r.h.s. vector, and each column of matrix <code>x</code> is the corresponding solution. The solution <code>x</code> is returned in <code>b</code>.</p><p>The diagonal pivoting method is used:</p><ul><li>If <code>up</code> = <a href="../Slap_common/index.html#val-upper"><code>Slap_common.upper</code></a>, then <code>a = U * D * U^T</code></li><li>If <code>up</code> = <a href="../Slap_common/index.html#val-lower"><code>Slap_common.lower</code></a>, then <code>a = L * D * L^T</code> where <code>U</code> and <code>L</code> are the upper and lower triangular matrices, respectively.</li></ul><dl><dt>parameter up</dt><dd><p>default = <a href="../Slap_common/index.html#val-upper"><code>Slap_common.upper</code></a></p><ul><li>If <code>up</code> = <a href="../Slap_common/index.html#val-upper"><code>Slap_common.upper</code></a>, then the upper triangular part of <code>a</code> is used;</li><li>If <code>up</code> = <a href="../Slap_common/index.html#val-lower"><code>Slap_common.lower</code></a>, then the lower triangular part of <code>a</code> is used.</li></ul></dd></dl><dl><dt>parameter ipiv</dt><dd><p>a result of <code>sytrf</code>. It is internally computed by <code>sytrf</code> if omitted.</p></dd></dl><dl><dt>parameter work</dt><dd><p>default = an optimum-length vector.</p></dd></dl><dl><dt>raises Failure</dt><dd><p>if the matrix is singular.</p></dd></dl><dl><dt>since</dt><dd>0.2.0</dd></dl></dd></dl><dl><dt class="spec value" id="val-spsv"><a href="#val-spsv" class="anchor"></a><code><span class="keyword">val</span> spsv : ?&#8288;up:[&lt; `U | `L ] <a href="../Slap_common/index.html#type-uplo">Slap_common.uplo</a> <span>&#45;&gt;</span> ?&#8288;ipiv:(<span class="type-var">'n</span>, <a href="../Slap_misc/index.html#type-cnt">Slap_misc.cnt</a>) <a href="../Slap_common/index.html#type-int32_vec">Slap_common.int32_vec</a> <span>&#45;&gt;</span> (<span class="type-var">'n</span> <a href="../Slap_size/index.html#type-packed">Slap_size.packed</a>, <a href="../Slap_misc/index.html#type-cnt">Slap_misc.cnt</a>) <a href="index.html#type-vec">vec</a> <span>&#45;&gt;</span> (<span class="type-var">'n</span>, <span class="type-var">'nrhs</span>, <span class="type-var">'b_cd</span>) <a href="index.html#type-mat">mat</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>spsv ?up a b</code> solves systems of linear equations <code>a * x = b</code> where <code>a</code> is a <code>'n</code>-by-<code>'n</code> symmetric matrix stored in packed format, each column of matrix <code>b</code> is the r.h.s. vector, and each column of matrix <code>x</code> is the corresponding solution. The solution <code>x</code> is returned in <code>b</code>.</p><p>The diagonal pivoting method is used:</p><ul><li>If <code>up</code> = <a href="../Slap_common/index.html#val-upper"><code>Slap_common.upper</code></a>, then <code>a = U * D * U^T</code></li><li>If <code>up</code> = <a href="../Slap_common/index.html#val-lower"><code>Slap_common.lower</code></a>, then <code>a = L * D * L^T</code> where <code>U</code> and <code>L</code> are the upper and lower triangular matrices, respectively.</li></ul><dl><dt>parameter up</dt><dd><p>default = <a href="../Slap_common/index.html#val-upper"><code>Slap_common.upper</code></a></p><ul><li>If <code>up</code> = <a href="../Slap_common/index.html#val-upper"><code>Slap_common.upper</code></a>, then the upper triangular part of <code>a</code> is used;</li><li>If <code>up</code> = <a href="../Slap_common/index.html#val-lower"><code>Slap_common.lower</code></a>, then the lower triangular part of <code>a</code> is used.</li></ul></dd></dl><dl><dt>parameter ipiv</dt><dd><p>a result of <code>sytrf</code>. It is internally computed by <code>sytrf</code> if omitted.</p></dd></dl><dl><dt>raises Failure</dt><dd><p>if the matrix is singular.</p></dd></dl><dl><dt>since</dt><dd>0.2.0</dd></dl></dd></dl></section><section><header><h4 id="least-squares-(simple-drivers)"><a href="#least-squares-(simple-drivers)" class="anchor"></a>Least squares (simple drivers)</h4></header><dl><dt class="spec type" id="type-gels_min_lwork"><a href="#type-gels_min_lwork" class="anchor"></a><code><span class="keyword">type</span> ('m, 'n, 'nrhs) gels_min_lwork</code></dt></dl><dl><dt class="spec value" id="val-gels_min_lwork"><a href="#val-gels_min_lwork" class="anchor"></a><code><span class="keyword">val</span> gels_min_lwork : m:<span class="type-var">'m</span> <a href="../Slap_size/index.html#type-t">Slap_size.t</a> <span>&#45;&gt;</span> n:<span class="type-var">'n</span> <a href="../Slap_size/index.html#type-t">Slap_size.t</a> <span>&#45;&gt;</span> nrhs:<span class="type-var">'nrhs</span> <a href="../Slap_size/index.html#type-t">Slap_size.t</a> <span>&#45;&gt;</span> (<span class="type-var">'m</span>, <span class="type-var">'n</span>, <span class="type-var">'nrhs</span>) <a href="index.html#type-gels_min_lwork">gels_min_lwork</a> <a href="../Slap_size/index.html#type-t">Slap_size.t</a></code></dt><dd><p><code>gels_min_lwork ~n</code> computes the minimum length of workspace for <code>gels</code> routine.</p><dl><dt>parameter m</dt><dd><p>the number of rows in a matrix.</p></dd></dl><dl><dt>parameter n</dt><dd><p>the number of columns in a matrix.</p></dd></dl><dl><dt>parameter nrhs</dt><dd><p>the number of right hand sides.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-gels_opt_lwork"><a href="#val-gels_opt_lwork" class="anchor"></a><code><span class="keyword">val</span> gels_opt_lwork : trans:(<span class="type-var">'am</span> * <span class="type-var">'an</span>, <span class="type-var">'m</span> * <span class="type-var">'n</span>, <span class="type-var">_</span>) <a href="../Slap_common/index.html#type-trans2">Slap_common.trans2</a> <span>&#45;&gt;</span> (<span class="type-var">'am</span>, <span class="type-var">'an</span>, <span class="type-var">'a_cd</span>) <a href="index.html#type-mat">mat</a> <span>&#45;&gt;</span> (<span class="type-var">'m</span>, <span class="type-var">'nrhs</span>, <span class="type-var">'b_cd</span>) <a href="index.html#type-mat">mat</a> <span>&#45;&gt;</span> (<span class="keyword">module</span> <a href="../Slap_size/module-type-SIZE/index.html">Slap_size.SIZE</a>)</code></dt><dd><p><code>gels_opt_lwork ~trans a b</code> computes the optimum length of workspace for <code>gels</code> routine.</p></dd></dl><dl><dt class="spec value" id="val-gels"><a href="#val-gels" class="anchor"></a><code><span class="keyword">val</span> gels : ?&#8288;work:(<span class="type-var">'work</span>, <a href="../Slap_misc/index.html#type-cnt">Slap_misc.cnt</a>) <a href="index.html#type-vec">vec</a> <span>&#45;&gt;</span> trans:(<span class="type-var">'am</span> * <span class="type-var">'an</span>, <span class="type-var">'m</span> * <span class="type-var">'n</span>, <span class="type-var">_</span>) <a href="../Slap_common/index.html#type-trans2">Slap_common.trans2</a> <span>&#45;&gt;</span> (<span class="type-var">'am</span>, <span class="type-var">'an</span>, <span class="type-var">'a_cd</span>) <a href="index.html#type-mat">mat</a> <span>&#45;&gt;</span> (<span class="type-var">'m</span>, <span class="type-var">'nrhs</span>, <span class="type-var">'b_cd</span>) <a href="index.html#type-mat">mat</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>gels ?work ~trans a b</code> solves an overdetermined or underdetermined system of linear equations using QR or LU factorization.</p><ul><li>If <code>trans</code> = <a href="../Slap_common/index.html#val-normal"><code>Slap_common.normal</code></a> and <code>'m &gt;= 'n</code>: find the least square solution to an overdetermined system by minimizing <code>||b - A * x||^2</code>.</li><li>If <code>trans</code> = <a href="../Slap_common/index.html#val-normal"><code>Slap_common.normal</code></a> and <code>'m &lt; 'n</code>: find the minimum norm solution to an underdetermined system <code>a * x = b</code>.</li><li>If <code>trans</code> = <a href="../Slap_common/index.html#type-trans"><code>Slap_common.trans</code></a>, and <code>'m &gt;= 'n</code>: find the minimum norm solution to an underdetermined system <code>a^H * x = b</code>.</li><li>If <code>trans</code> = <a href="../Slap_common/index.html#type-trans"><code>Slap_common.trans</code></a> and <code>'m &lt; 'n</code>: find the least square solution to an overdetermined system by minimizing <code>||b - A^H * x||^2</code>.</li></ul><dl><dt>parameter work</dt><dd><p>default = an optimum-length vector.</p></dd></dl><dl><dt>parameter trans</dt><dd><p>the transpose flag for <code>a</code>.</p></dd></dl></dd></dl></section></section><section><header><h3 id="blas-interface"><a href="#blas-interface" class="anchor"></a>BLAS interface</h3></header><section><header><h4 id="level-1"><a href="#level-1" class="anchor"></a>Level 1</h4></header><dl><dt class="spec value" id="val-dot"><a href="#val-dot" class="anchor"></a><code><span class="keyword">val</span> dot : (<span class="type-var">'n</span>, <span class="type-var">'x_cd</span>) <a href="index.html#type-vec">vec</a> <span>&#45;&gt;</span> (<span class="type-var">'n</span>, <span class="type-var">'y_cd</span>) <a href="index.html#type-vec">vec</a> <span>&#45;&gt;</span> float</code></dt><dd><p><code>dot x y</code></p><dl><dt>returns</dt><dd><p>the inner product of the vectors <code>x</code> and <code>y</code>.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-asum"><a href="#val-asum" class="anchor"></a><code><span class="keyword">val</span> asum : (<span class="type-var">'n</span>, <span class="type-var">'x_cd</span>) <a href="index.html#type-vec">vec</a> <span>&#45;&gt;</span> float</code></dt><dd><p><code>asum x</code></p><dl><dt>returns</dt><dd><p>the sum of absolute values of elements in the vector <code>x</code>.</p></dd></dl></dd></dl></section><section><header><h4 id="level-2"><a href="#level-2" class="anchor"></a>Level 2</h4></header><dl><dt class="spec value" id="val-sbmv"><a href="#val-sbmv" class="anchor"></a><code><span class="keyword">val</span> sbmv : k:<span class="type-var">'k</span> <a href="../Slap_size/index.html#type-t">Slap_size.t</a> <span>&#45;&gt;</span> ?&#8288;y:(<span class="type-var">'n</span>, <span class="type-var">'y_cd</span>) <a href="index.html#type-vec">vec</a> <span>&#45;&gt;</span> ((<span class="type-var">'n</span>, <span class="type-var">'k</span>) <a href="../Slap_size/index.html#type-syband">Slap_size.syband</a>, <span class="type-var">'n</span>, <span class="type-var">'a_cd</span>) <a href="index.html#type-mat">mat</a> <span>&#45;&gt;</span> ?&#8288;up:[&lt; `U | `L ] <a href="../Slap_common/index.html#type-uplo">Slap_common.uplo</a> <span>&#45;&gt;</span> ?&#8288;alpha:float <span>&#45;&gt;</span> ?&#8288;beta:float <span>&#45;&gt;</span> (<span class="type-var">'n</span>, <span class="type-var">'x_cd</span>) <a href="index.html#type-vec">vec</a> <span>&#45;&gt;</span> (<span class="type-var">'n</span>, <span class="type-var">'y_cd</span>) <a href="index.html#type-vec">vec</a></code></dt><dd><p><code>sbmv ~k ?y a ?up ?alpha ?beta x</code> computes <code>y := alpha * a * x + beta * y</code> where <code>a</code> is a <code>'n</code>-by-<code>'n</code> symmetric band matrix with <code>k</code> super-(or sub-)diagonals, and <code>x</code> and <code>y</code> are <code>'n</code>-dimensional vectors.</p><dl><dt>returns</dt><dd><p>vector <code>y</code>, which is overwritten.</p></dd></dl><dl><dt>parameter k</dt><dd><p>the number of superdiangonals or subdiangonals</p></dd></dl><dl><dt>parameter up</dt><dd><p>default = <a href="../Slap_common/index.html#val-upper"><code>Slap_common.upper</code></a></p><ul><li>If <code>up</code> = <a href="../Slap_common/index.html#val-upper"><code>Slap_common.upper</code></a>, then the upper triangular part of <code>a</code> is used;</li><li>If <code>up</code> = <a href="../Slap_common/index.html#val-lower"><code>Slap_common.lower</code></a>, then the lower triangular part of <code>a</code> is used.</li></ul></dd></dl><dl><dt>parameter alpha</dt><dd><p>default = <code>1.0</code></p></dd></dl><dl><dt>parameter beta</dt><dd><p>default = <code>0.0</code></p></dd></dl><dl><dt>since</dt><dd>0.2.0</dd></dl></dd></dl><dl><dt class="spec value" id="val-ger"><a href="#val-ger" class="anchor"></a><code><span class="keyword">val</span> ger : ?&#8288;alpha:float <span>&#45;&gt;</span> (<span class="type-var">'m</span>, <span class="type-var">'x_cd</span>) <a href="index.html#type-vec">vec</a> <span>&#45;&gt;</span> (<span class="type-var">'n</span>, <span class="type-var">'y_cd</span>) <a href="index.html#type-vec">vec</a> <span>&#45;&gt;</span> (<span class="type-var">'m</span>, <span class="type-var">'n</span>, <span class="type-var">'a_cd</span>) <a href="index.html#type-mat">mat</a> <span>&#45;&gt;</span> (<span class="type-var">'m</span>, <span class="type-var">'n</span>, <span class="type-var">'a_cd</span>) <a href="index.html#type-mat">mat</a></code></dt><dd><p><code>ger ?alpha x y a</code> computes <code>a := alpha * x * y^T + a</code> with the general matrix <code>a</code>, the vector <code>x</code> and the transposed vector <code>y^T</code> of <code>y</code>.</p><dl><dt>returns</dt><dd><p>matrix <code>a</code>, which is overwritten.</p></dd></dl><dl><dt>parameter alpha</dt><dd><p>default = <code>1.0</code></p></dd></dl></dd></dl><dl><dt class="spec value" id="val-syr"><a href="#val-syr" class="anchor"></a><code><span class="keyword">val</span> syr : ?&#8288;alpha:float <span>&#45;&gt;</span> ?&#8288;up:[&lt; `U | `L ] <a href="../Slap_common/index.html#type-uplo">Slap_common.uplo</a> <span>&#45;&gt;</span> (<span class="type-var">'n</span>, <span class="type-var">'x_cd</span>) <a href="index.html#type-vec">vec</a> <span>&#45;&gt;</span> (<span class="type-var">'n</span>, <span class="type-var">'n</span>, <span class="type-var">'a_cd</span>) <a href="index.html#type-mat">mat</a> <span>&#45;&gt;</span> (<span class="type-var">'n</span>, <span class="type-var">'n</span>, <span class="type-var">'a_cd</span>) <a href="index.html#type-mat">mat</a></code></dt><dd><p><code>syr ?alpha x a</code> computes <code>a := alpha * x * x^T + a</code> with the symmetric matrix <code>a</code>, the vector <code>x</code> and the transposed vector <code>x^T</code> of <code>x</code>.</p><dl><dt>returns</dt><dd><p>matrix <code>a</code>, which is overwritten.</p></dd></dl><dl><dt>parameter alpha</dt><dd><p>default = <code>1.0</code></p></dd></dl><dl><dt>parameter up</dt><dd><p>default = <a href="../Slap_common/index.html#val-upper"><code>Slap_common.upper</code></a></p><ul><li>If <code>up</code> = <a href="../Slap_common/index.html#val-upper"><code>Slap_common.upper</code></a>, then the upper triangular part of <code>a</code> is used;</li><li>If <code>up</code> = <a href="../Slap_common/index.html#val-lower"><code>Slap_common.lower</code></a>, then the lower triangular part of <code>a</code> is used.</li></ul></dd></dl></dd></dl></section></section><section><header><h3 id="lapack-interface"><a href="#lapack-interface" class="anchor"></a>LAPACK interface</h3></header><section><header><h4 id="auxiliary-routines"><a href="#auxiliary-routines" class="anchor"></a>Auxiliary routines</h4></header><section><header><h5 id="lansy"><a href="#lansy" class="anchor"></a>lansy</h5></header><dl><dt class="spec type" id="type-lansy_min_lwork"><a href="#type-lansy_min_lwork" class="anchor"></a><code><span class="keyword">type</span> ('m, 'a) lansy_min_lwork</code></dt></dl><dl><dt class="spec value" id="val-lansy_min_lwork"><a href="#val-lansy_min_lwork" class="anchor"></a><code><span class="keyword">val</span> lansy_min_lwork : <span class="type-var">'n</span> <a href="../Slap_size/index.html#type-t">Slap_size.t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="../Slap_common/index.html#type-norm4">Slap_common.norm4</a> <span>&#45;&gt;</span> (<span class="type-var">'n</span>, <span class="type-var">'a</span>) <a href="index.html#type-lansy_min_lwork">lansy_min_lwork</a> <a href="../Slap_size/index.html#type-t">Slap_size.t</a></code></dt><dd><p><code>lansy_min_lwork n norm</code> computes the minimum length of workspace for <code>lansy</code> routine. <code>n</code> is the number of rows or columns in a matrix. <code>norm</code> is a matrix norm.</p></dd></dl><dl><dt class="spec value" id="val-lansy"><a href="#val-lansy" class="anchor"></a><code><span class="keyword">val</span> lansy : ?&#8288;up:[&lt; `U | `L ] <a href="../Slap_common/index.html#type-uplo">Slap_common.uplo</a> <span>&#45;&gt;</span> ?&#8288;norm:<span class="type-var">'norm</span> <a href="../Slap_common/index.html#type-norm4">Slap_common.norm4</a> <span>&#45;&gt;</span> ?&#8288;work:(<span class="type-var">'lwork</span>, <a href="../Slap_misc/index.html#type-cnt">Slap_misc.cnt</a>) <a href="index.html#type-vec">vec</a> <span>&#45;&gt;</span> (<span class="type-var">'n</span>, <span class="type-var">'n</span>, <span class="type-var">'cd</span>) <a href="index.html#type-mat">mat</a> <span>&#45;&gt;</span> float</code></dt><dd><p><code>lansy ?up ?norm ?work a</code></p><dl><dt>returns</dt><dd><p>the norm of matrix <code>a</code>.</p></dd></dl><dl><dt>parameter up</dt><dd><p>default = <a href="../Slap_common/index.html#val-upper"><code>Slap_common.upper</code></a></p><ul><li>If <code>up</code> = <a href="../Slap_common/index.html#val-upper"><code>Slap_common.upper</code></a>, then the upper triangular part of <code>a</code> is used;</li><li>If <code>up</code> = <a href="../Slap_common/index.html#val-lower"><code>Slap_common.lower</code></a>, then the lower triangular part of <code>a</code> is used.</li></ul></dd></dl><dl><dt>parameter norm</dt><dd><p>default = <a href="../Slap_common/index.html#val-norm_1"><code>Slap_common.norm_1</code></a></p><ul><li>If <code>norm</code> = <a href="../Slap_common/index.html#val-norm_1"><code>Slap_common.norm_1</code></a>, the one norm is returned;</li><li>If <code>norm</code> = <a href="../Slap_common/index.html#val-norm_inf"><code>Slap_common.norm_inf</code></a>, the infinity norm is returned;</li><li>If <code>norm</code> = <a href="../Slap_common/index.html#val-norm_amax"><code>Slap_common.norm_amax</code></a>, the largest absolute value of elements in matrix <code>a</code> (not a matrix norm) is returned;</li><li>If <code>norm</code> = <a href="../Slap_common/index.html#val-norm_frob"><code>Slap_common.norm_frob</code></a>, the Frobenius norm is returned.</li></ul></dd></dl><dl><dt>parameter work</dt><dd><p>default = an optimum-length vector.</p></dd></dl></dd></dl></section><section><header><h5 id="lamch"><a href="#lamch" class="anchor"></a>lamch</h5></header><dl><dt class="spec value" id="val-lamch"><a href="#val-lamch" class="anchor"></a><code><span class="keyword">val</span> lamch : [ `B | `E | `L | `M | `N | `O | `P | `R | `S | `U ] <span>&#45;&gt;</span> float</code></dt><dd><p><code>lamch cmach</code> see LAPACK documentation.</p></dd></dl></section></section><section><header><h4 id="linear-equations-(computational-routines)"><a href="#linear-equations-(computational-routines)" class="anchor"></a>Linear equations (computational routines)</h4></header><section><header><h5 id="orgqr"><a href="#orgqr" class="anchor"></a>orgqr</h5></header><dl><dt class="spec type" id="type-orgqr_min_lwork"><a href="#type-orgqr_min_lwork" class="anchor"></a><code><span class="keyword">type</span> 'n orgqr_min_lwork</code></dt></dl><dl><dt class="spec value" id="val-orgqr_min_lwork"><a href="#val-orgqr_min_lwork" class="anchor"></a><code><span class="keyword">val</span> orgqr_min_lwork : n:<span class="type-var">'n</span> <a href="../Slap_size/index.html#type-t">Slap_size.t</a> <span>&#45;&gt;</span> <span class="type-var">'n</span> <a href="index.html#type-orgqr_min_lwork">orgqr_min_lwork</a> <a href="../Slap_size/index.html#type-t">Slap_size.t</a></code></dt><dd><p><code>orgqr_min_lwork ~n</code> computes the minimum length of workspace for <code>orgqr</code> routine. <code>n</code> is the number of columns in a matrix.</p></dd></dl><dl><dt class="spec value" id="val-orgqr_opt_lwork"><a href="#val-orgqr_opt_lwork" class="anchor"></a><code><span class="keyword">val</span> orgqr_opt_lwork : tau:(<span class="type-var">'k</span>, <a href="../Slap_misc/index.html#type-cnt">Slap_misc.cnt</a>) <a href="index.html#type-vec">vec</a> <span>&#45;&gt;</span> (<span class="type-var">'m</span>, <span class="type-var">'n</span>, <span class="type-var">'cd</span>) <a href="index.html#type-mat">mat</a> <span>&#45;&gt;</span> (<span class="keyword">module</span> <a href="../Slap_size/module-type-SIZE/index.html">Slap_size.SIZE</a>)</code></dt><dd><p><code>orgqr_min_lwork ~tau a</code> computes the optimum length of workspace for <code>orgqr</code> routine.</p></dd></dl><dl><dt class="spec value" id="val-orgqr_dyn"><a href="#val-orgqr_dyn" class="anchor"></a><code><span class="keyword">val</span> orgqr_dyn : ?&#8288;work:(<span class="type-var">'lwork</span>, <a href="../Slap_misc/index.html#type-cnt">Slap_misc.cnt</a>) <a href="index.html#type-vec">vec</a> <span>&#45;&gt;</span> tau:(<span class="type-var">'k</span>, <a href="../Slap_misc/index.html#type-cnt">Slap_misc.cnt</a>) <a href="index.html#type-vec">vec</a> <span>&#45;&gt;</span> (<span class="type-var">'m</span>, <span class="type-var">'n</span>, <span class="type-var">'cd</span>) <a href="index.html#type-mat">mat</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>orgqr_dyn ?work ~tau a</code> generates the orthogonal matrix <code>Q</code> of the QR factorization formed by <code>geqrf</code>/<code>geqpf</code>.</p><dl><dt>parameter work</dt><dd><p>default = an optimum-length vector</p></dd></dl><dl><dt>parameter tau</dt><dd><p>a result of <code>geqrf</code></p></dd></dl><dl><dt>raises Invalid_argument</dt><dd><p>if the following inequality is not satisfied: <code>(Mat.dim1 a) &gt;= (Mat.dim2 a) &gt;= (Vec.dim tau)</code>, i.e., <code>'m &gt;= 'n &gt;= 'k</code>.</p></dd></dl></dd></dl></section><section><header><h5 id="ormqr"><a href="#ormqr" class="anchor"></a>ormqr</h5></header><dl><dt class="spec type" id="type-ormqr_min_lwork"><a href="#type-ormqr_min_lwork" class="anchor"></a><code><span class="keyword">type</span> ('r, 'm, 'n) ormqr_min_lwork</code></dt></dl><dl><dt class="spec value" id="val-ormqr_min_lwork"><a href="#val-ormqr_min_lwork" class="anchor"></a><code><span class="keyword">val</span> ormqr_min_lwork : side:(<span class="type-var">'r</span>, <span class="type-var">'m</span>, <span class="type-var">'n</span>) <a href="../Slap_common/index.html#type-side">Slap_common.side</a> <span>&#45;&gt;</span> m:<span class="type-var">'m</span> <a href="../Slap_size/index.html#type-t">Slap_size.t</a> <span>&#45;&gt;</span> n:<span class="type-var">'n</span> <a href="../Slap_size/index.html#type-t">Slap_size.t</a> <span>&#45;&gt;</span> (<span class="type-var">'r</span>, <span class="type-var">'m</span>, <span class="type-var">'n</span>) <a href="index.html#type-ormqr_min_lwork">ormqr_min_lwork</a> <a href="../Slap_size/index.html#type-t">Slap_size.t</a></code></dt><dd><p><code>ormqr_min_lwork ~side ~m ~n</code> computes the minimum length of workspace for <code>ormqr</code> routine.</p><dl><dt>parameter side</dt><dd><p>the side flag to specify direction of matrix multiplication.</p></dd></dl><dl><dt>parameter m</dt><dd><p>the number of rows in a matrix.</p></dd></dl><dl><dt>parameter n</dt><dd><p>the number of columns in a matrix.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-ormqr_opt_lwork"><a href="#val-ormqr_opt_lwork" class="anchor"></a><code><span class="keyword">val</span> ormqr_opt_lwork : side:(<span class="type-var">'r</span>, <span class="type-var">'m</span>, <span class="type-var">'n</span>) <a href="../Slap_common/index.html#type-side">Slap_common.side</a> <span>&#45;&gt;</span> trans:(<span class="type-var">'r</span> * <span class="type-var">'r</span>, <span class="type-var">'r</span> * <span class="type-var">'r</span>, <span class="type-var">_</span>) <a href="../Slap_common/index.html#type-trans2">Slap_common.trans2</a> <span>&#45;&gt;</span> tau:(<span class="type-var">'k</span>, <a href="../Slap_misc/index.html#type-cnt">Slap_misc.cnt</a>) <a href="index.html#type-vec">vec</a> <span>&#45;&gt;</span> (<span class="type-var">'r</span>, <span class="type-var">'k</span>, <span class="type-var">'a_cd</span>) <a href="index.html#type-mat">mat</a> <span>&#45;&gt;</span> (<span class="type-var">'m</span>, <span class="type-var">'n</span>, <span class="type-var">'c_cd</span>) <a href="index.html#type-mat">mat</a> <span>&#45;&gt;</span> (<span class="keyword">module</span> <a href="../Slap_size/module-type-SIZE/index.html">Slap_size.SIZE</a>)</code></dt><dd><p><code>ormqr_opt_lwork ~side ~trans ~tau a c</code> computes the optimum length of workspace for <code>ormqr</code> routine.</p><dl><dt>parameter side</dt><dd><p>the side flag to specify direction of matrix multiplication.</p></dd></dl><dl><dt>parameter trans</dt><dd><p>the transpose flag for orthogonal matrix <code>Q</code>.</p></dd></dl><dl><dt>parameter tau</dt><dd><p>a result of <code>geqrf</code>.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-ormqr_dyn"><a href="#val-ormqr_dyn" class="anchor"></a><code><span class="keyword">val</span> ormqr_dyn : side:(<span class="type-var">'r</span>, <span class="type-var">'m</span>, <span class="type-var">'n</span>) <a href="../Slap_common/index.html#type-side">Slap_common.side</a> <span>&#45;&gt;</span> trans:(<span class="type-var">'r</span> * <span class="type-var">'r</span>, <span class="type-var">'r</span> * <span class="type-var">'r</span>, <span class="type-var">_</span>) <a href="../Slap_common/index.html#type-trans2">Slap_common.trans2</a> <span>&#45;&gt;</span> ?&#8288;work:(<span class="type-var">'lwork</span>, <a href="../Slap_misc/index.html#type-cnt">Slap_misc.cnt</a>) <a href="index.html#type-vec">vec</a> <span>&#45;&gt;</span> tau:(<span class="type-var">'k</span>, <a href="../Slap_misc/index.html#type-cnt">Slap_misc.cnt</a>) <a href="index.html#type-vec">vec</a> <span>&#45;&gt;</span> (<span class="type-var">'r</span>, <span class="type-var">'k</span>, <span class="type-var">'a_cd</span>) <a href="index.html#type-mat">mat</a> <span>&#45;&gt;</span> (<span class="type-var">'m</span>, <span class="type-var">'n</span>, <span class="type-var">'c_cd</span>) <a href="index.html#type-mat">mat</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>ormqr_dyn ~side ~trans ?work ~tau a c</code> multiplies a matrix <code>c</code> by the orthogonal matrix <code>Q</code> of the QR factorization formed by <code>geqrf</code>/<code>geqpf</code>:</p><ul><li><code>Q * c</code> if <code>side</code> = <a href="../Slap_common/index.html#val-left"><code>Slap_common.left</code></a> and <code>trans</code> = <a href="../Slap_common/index.html#val-normal"><code>Slap_common.normal</code></a>;</li><li><code>Q^T * c</code> if <code>side</code> = <a href="../Slap_common/index.html#val-left"><code>Slap_common.left</code></a> and <code>trans</code> = <a href="../Slap_common/index.html#type-trans"><code>Slap_common.trans</code></a>;</li><li><code>c * Q</code> if <code>side</code> = <a href="../Slap_common/index.html#val-right"><code>Slap_common.right</code></a> and <code>trans</code> = <a href="../Slap_common/index.html#val-normal"><code>Slap_common.normal</code></a>;</li><li><code>c * Q^T</code> if <code>side</code> = <a href="../Slap_common/index.html#val-right"><code>Slap_common.right</code></a> and <code>trans</code> = <a href="../Slap_common/index.html#type-trans"><code>Slap_common.trans</code></a>.</li></ul><dl><dt>parameter side</dt><dd><p>the side flag to specify direction of matrix multiplication of <code>Q</code> and <code>c</code>.</p></dd></dl><dl><dt>parameter trans</dt><dd><p>the transpose flag for orthogonal matrix <code>Q</code>.</p></dd></dl><dl><dt>parameter work</dt><dd><p>default = an optimum-length vector.</p></dd></dl><dl><dt>parameter tau</dt><dd><p>a result of <code>geqrf</code>.</p></dd></dl><dl><dt>raises Invalid_argument</dt><dd><p>if the following inequality is not satisfied:</p><ul><li><code>'m &gt;= 'k</code> if <code>side</code> = <a href="../Slap_common/index.html#val-left"><code>Slap_common.left</code></a>;</li><li><code>'n &gt;= 'k</code> if <code>side</code> = <a href="../Slap_common/index.html#val-right"><code>Slap_common.right</code></a>.</li></ul></dd></dl></dd></dl></section><section><header><h5 id="gecon"><a href="#gecon" class="anchor"></a>gecon</h5></header><dl><dt class="spec type" id="type-gecon_min_lwork"><a href="#type-gecon_min_lwork" class="anchor"></a><code><span class="keyword">type</span> 'n gecon_min_lwork</code></dt></dl><dl><dt class="spec value" id="val-gecon_min_lwork"><a href="#val-gecon_min_lwork" class="anchor"></a><code><span class="keyword">val</span> gecon_min_lwork : <span class="type-var">'n</span> <a href="../Slap_size/index.html#type-t">Slap_size.t</a> <span>&#45;&gt;</span> <span class="type-var">'n</span> <a href="index.html#type-gecon_min_lwork">gecon_min_lwork</a> <a href="../Slap_size/index.html#type-t">Slap_size.t</a></code></dt><dd><p><code>gecon_min_lwork n</code> computes the minimum length of workspace <code>work</code> for <code>gecon</code> routine. <code>n</code> is the number of rows or columns in a matrix.</p></dd></dl><dl><dt class="spec type" id="type-gecon_min_liwork"><a href="#type-gecon_min_liwork" class="anchor"></a><code><span class="keyword">type</span> 'n gecon_min_liwork</code></dt></dl><dl><dt class="spec value" id="val-gecon_min_liwork"><a href="#val-gecon_min_liwork" class="anchor"></a><code><span class="keyword">val</span> gecon_min_liwork : <span class="type-var">'n</span> <a href="../Slap_size/index.html#type-t">Slap_size.t</a> <span>&#45;&gt;</span> <span class="type-var">'n</span> <a href="index.html#type-gecon_min_liwork">gecon_min_liwork</a> <a href="../Slap_size/index.html#type-t">Slap_size.t</a></code></dt><dd><p><code>gecon_min_liwork n</code> computes the minimum length of workspace <code>iwork</code> for <code>gecon</code> routine. <code>n</code> is the number of rows or columns in a matrix.</p></dd></dl><dl><dt class="spec value" id="val-gecon"><a href="#val-gecon" class="anchor"></a><code><span class="keyword">val</span> gecon : ?&#8288;norm:<span class="type-var">_</span> <a href="../Slap_common/index.html#type-norm2">Slap_common.norm2</a> <span>&#45;&gt;</span> ?&#8288;anorm:float <span>&#45;&gt;</span> ?&#8288;work:(<span class="type-var">'lwork</span>, <a href="../Slap_misc/index.html#type-cnt">Slap_misc.cnt</a>) <a href="index.html#type-vec">vec</a> <span>&#45;&gt;</span> ?&#8288;iwork:(<span class="type-var">'liwork</span>, <a href="../Slap_misc/index.html#type-cnt">Slap_misc.cnt</a>) <a href="../Slap_common/index.html#type-int32_vec">Slap_common.int32_vec</a> <span>&#45;&gt;</span> (<span class="type-var">'n</span>, <span class="type-var">'n</span>, <span class="type-var">'cd</span>) <a href="index.html#type-mat">mat</a> <span>&#45;&gt;</span> float</code></dt><dd><p><code>gecon ?norm ?anorm ?work ?iwork a</code> estimates the reciprocal of the condition number of general matrix <code>a</code>.</p><dl><dt>parameter norm</dt><dd><p>default = <a href="../Slap_common/index.html#val-norm_1"><code>Slap_common.norm_1</code></a>.</p><ul><li>If <code>norm</code> = <a href="../Slap_common/index.html#val-norm_1"><code>Slap_common.norm_1</code></a>, the one norm is returned;</li><li>If <code>norm</code> = <a href="../Slap_common/index.html#val-norm_inf"><code>Slap_common.norm_inf</code></a>, the infinity norm is returned.</li></ul></dd></dl><dl><dt>parameter anorm</dt><dd><p>default = the norm of matrix <code>a</code> as returned by <code>lange</code>.</p></dd></dl><dl><dt>parameter work</dt><dd><p>default = an optimum-length vector.</p></dd></dl><dl><dt>parameter iwork</dt><dd><p>default = an optimum-length vector.</p></dd></dl></dd></dl></section><section><header><h5 id="sycon"><a href="#sycon" class="anchor"></a>sycon</h5></header><dl><dt class="spec type" id="type-sycon_min_lwork"><a href="#type-sycon_min_lwork" class="anchor"></a><code><span class="keyword">type</span> 'n sycon_min_lwork</code></dt></dl><dl><dt class="spec value" id="val-sycon_min_lwork"><a href="#val-sycon_min_lwork" class="anchor"></a><code><span class="keyword">val</span> sycon_min_lwork : <span class="type-var">'n</span> <a href="../Slap_size/index.html#type-t">Slap_size.t</a> <span>&#45;&gt;</span> <span class="type-var">'n</span> <a href="index.html#type-sycon_min_lwork">sycon_min_lwork</a> <a href="../Slap_size/index.html#type-t">Slap_size.t</a></code></dt><dd><p><code>sycon_min_lwork n</code> computes the minimum length of workspace <code>work</code> for <code>sycon</code> routine. <code>n</code> is the number of rows or columns in a matrix.</p></dd></dl><dl><dt class="spec type" id="type-sycon_min_liwork"><a href="#type-sycon_min_liwork" class="anchor"></a><code><span class="keyword">type</span> 'n sycon_min_liwork</code></dt></dl><dl><dt class="spec value" id="val-sycon_min_liwork"><a href="#val-sycon_min_liwork" class="anchor"></a><code><span class="keyword">val</span> sycon_min_liwork : <span class="type-var">'n</span> <a href="../Slap_size/index.html#type-t">Slap_size.t</a> <span>&#45;&gt;</span> <span class="type-var">'n</span> <a href="index.html#type-sycon_min_liwork">sycon_min_liwork</a> <a href="../Slap_size/index.html#type-t">Slap_size.t</a></code></dt><dd><p><code>sycon_min_liwork n</code> computes the minimum length of workspace <code>iwork</code> for <code>sycon</code> routine. <code>n</code> is the number of rows or columns in a matrix.</p></dd></dl><dl><dt class="spec value" id="val-sycon"><a href="#val-sycon" class="anchor"></a><code><span class="keyword">val</span> sycon : ?&#8288;up:[&lt; `U | `L ] <a href="../Slap_common/index.html#type-uplo">Slap_common.uplo</a> <span>&#45;&gt;</span> ?&#8288;ipiv:(<span class="type-var">'n</span>, <a href="../Slap_misc/index.html#type-cnt">Slap_misc.cnt</a>) <a href="../Slap_common/index.html#type-int32_vec">Slap_common.int32_vec</a> <span>&#45;&gt;</span> ?&#8288;anorm:float <span>&#45;&gt;</span> ?&#8288;work:(<span class="type-var">'lwork</span>, <a href="../Slap_misc/index.html#type-cnt">Slap_misc.cnt</a>) <a href="index.html#type-vec">vec</a> <span>&#45;&gt;</span> ?&#8288;iwork:(<span class="type-var">'liwork</span>, <a href="../Slap_misc/index.html#type-cnt">Slap_misc.cnt</a>) <a href="../Slap_common/index.html#type-int32_vec">Slap_common.int32_vec</a> <span>&#45;&gt;</span> (<span class="type-var">'n</span>, <span class="type-var">'n</span>, <span class="type-var">'cd</span>) <a href="index.html#type-mat">mat</a> <span>&#45;&gt;</span> float</code></dt><dd><p><code>sycon ?up ?ipiv ?anorm ?work ?iwork a</code> estimates the reciprocal of the condition number of symmetric matrix <code>a</code>. Since <code>a</code> is symmetric, the 1-norm is equal to the infinity norm.</p><dl><dt>parameter up</dt><dd><p>default = <a href="../Slap_common/index.html#val-upper"><code>Slap_common.upper</code></a></p><ul><li>If <code>up</code> = <a href="../Slap_common/index.html#val-upper"><code>Slap_common.upper</code></a>, then the upper triangular part of <code>a</code> is used;</li><li>If <code>up</code> = <a href="../Slap_common/index.html#val-lower"><code>Slap_common.lower</code></a>, then the lower triangular part of <code>a</code> is used.</li></ul></dd></dl><dl><dt>parameter ipiv</dt><dd><p>a result of <code>sytrf</code>. It is internally computed by <code>sytrf</code> if omitted.</p></dd></dl><dl><dt>parameter anorm</dt><dd><p>default = the norm of matrix <code>a</code> as returned by <code>lange</code>.</p></dd></dl><dl><dt>parameter work</dt><dd><p>default = an optimum-length vector.</p></dd></dl><dl><dt>parameter iwork</dt><dd><p>default = an optimum-length vector.</p></dd></dl></dd></dl></section><section><header><h5 id="pocon"><a href="#pocon" class="anchor"></a>pocon</h5></header><dl><dt class="spec type" id="type-pocon_min_lwork"><a href="#type-pocon_min_lwork" class="anchor"></a><code><span class="keyword">type</span> 'n pocon_min_lwork</code></dt></dl><dl><dt class="spec value" id="val-pocon_min_lwork"><a href="#val-pocon_min_lwork" class="anchor"></a><code><span class="keyword">val</span> pocon_min_lwork : <span class="type-var">'n</span> <a href="../Slap_size/index.html#type-t">Slap_size.t</a> <span>&#45;&gt;</span> <span class="type-var">'n</span> <a href="index.html#type-pocon_min_lwork">pocon_min_lwork</a> <a href="../Slap_size/index.html#type-t">Slap_size.t</a></code></dt><dd><p><code>pocon_min_lwork n</code> computes the minimum length of workspace <code>work</code> for <code>pocon</code> routine. <code>n</code> is the number of rows or columns in a matrix.</p></dd></dl><dl><dt class="spec type" id="type-pocon_min_liwork"><a href="#type-pocon_min_liwork" class="anchor"></a><code><span class="keyword">type</span> 'n pocon_min_liwork</code></dt></dl><dl><dt class="spec value" id="val-pocon_min_liwork"><a href="#val-pocon_min_liwork" class="anchor"></a><code><span class="keyword">val</span> pocon_min_liwork : <span class="type-var">'n</span> <a href="../Slap_size/index.html#type-t">Slap_size.t</a> <span>&#45;&gt;</span> <span class="type-var">'n</span> <a href="index.html#type-pocon_min_liwork">pocon_min_liwork</a> <a href="../Slap_size/index.html#type-t">Slap_size.t</a></code></dt><dd><p><code>pocon_min_liwork n</code> computes the minimum length of workspace <code>iwork</code> for <code>pocon</code> routine. <code>n</code> is the number of rows or columns in a matrix.</p></dd></dl><dl><dt class="spec value" id="val-pocon"><a href="#val-pocon" class="anchor"></a><code><span class="keyword">val</span> pocon : ?&#8288;up:[&lt; `U | `L ] <a href="../Slap_common/index.html#type-uplo">Slap_common.uplo</a> <span>&#45;&gt;</span> ?&#8288;anorm:float <span>&#45;&gt;</span> ?&#8288;work:(<span class="type-var">'lwork</span>, <a href="../Slap_misc/index.html#type-cnt">Slap_misc.cnt</a>) <a href="index.html#type-vec">vec</a> <span>&#45;&gt;</span> ?&#8288;iwork:(<span class="type-var">'liwork</span>, <a href="../Slap_misc/index.html#type-cnt">Slap_misc.cnt</a>) <a href="../Slap_common/index.html#type-int32_vec">Slap_common.int32_vec</a> <span>&#45;&gt;</span> (<span class="type-var">'n</span>, <span class="type-var">'n</span>, <span class="type-var">'cd</span>) <a href="index.html#type-mat">mat</a> <span>&#45;&gt;</span> float</code></dt><dd><p><code>pocon ?up ?anorm ?work ?iwork a</code> estimates the reciprocal of the condition number of symmetric positive-definite matrix <code>a</code>. Since <code>a</code> is symmetric, the 1-norm is equal to the infinity norm.</p><dl><dt>parameter up</dt><dd><p>default = <a href="../Slap_common/index.html#val-upper"><code>Slap_common.upper</code></a></p><ul><li>If <code>up</code> = <a href="../Slap_common/index.html#val-upper"><code>Slap_common.upper</code></a>, then the upper triangular part of <code>a</code> is used;</li><li>If <code>up</code> = <a href="../Slap_common/index.html#val-lower"><code>Slap_common.lower</code></a>, then the lower triangular part of <code>a</code> is used.</li></ul></dd></dl><dl><dt>parameter anorm</dt><dd><p>default = the norm of matrix <code>a</code> as returned by <code>lange</code>.</p></dd></dl><dl><dt>parameter work</dt><dd><p>default = an optimum-length vector.</p></dd></dl><dl><dt>parameter iwork</dt><dd><p>default = an optimum-length vector.</p></dd></dl></dd></dl></section></section><section><header><h4 id="least-squares-(expert-drivers)"><a href="#least-squares-(expert-drivers)" class="anchor"></a>Least squares (expert drivers)</h4></header><section><header><h5 id="gelsy"><a href="#gelsy" class="anchor"></a>gelsy</h5></header><dl><dt class="spec type" id="type-gelsy_min_lwork"><a href="#type-gelsy_min_lwork" class="anchor"></a><code><span class="keyword">type</span> ('m, 'n, 'nrhs) gelsy_min_lwork</code></dt></dl><dl><dt class="spec value" id="val-gelsy_min_lwork"><a href="#val-gelsy_min_lwork" class="anchor"></a><code><span class="keyword">val</span> gelsy_min_lwork : m:<span class="type-var">'m</span> <a href="../Slap_size/index.html#type-t">Slap_size.t</a> <span>&#45;&gt;</span> n:<span class="type-var">'n</span> <a href="../Slap_size/index.html#type-t">Slap_size.t</a> <span>&#45;&gt;</span> nrhs:<span class="type-var">'nrhs</span> <a href="../Slap_size/index.html#type-t">Slap_size.t</a> <span>&#45;&gt;</span> (<span class="type-var">'m</span>, <span class="type-var">'n</span>, <span class="type-var">'nrhs</span>) <a href="index.html#type-gelsy_min_lwork">gelsy_min_lwork</a> <a href="../Slap_size/index.html#type-t">Slap_size.t</a></code></dt><dd><p><code>gelsy_min_lwork ~m ~n ~nrhs</code> computes the minimum length of workspace for <code>gelsy</code> routine.</p><dl><dt>parameter m</dt><dd><p>the number of rows in a matrix.</p></dd></dl><dl><dt>parameter n</dt><dd><p>the number of columns in a matrix.</p></dd></dl><dl><dt>parameter nrhs</dt><dd><p>the number of right hand sides.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-gelsy_opt_lwork"><a href="#val-gelsy_opt_lwork" class="anchor"></a><code><span class="keyword">val</span> gelsy_opt_lwork : (<span class="type-var">'m</span>, <span class="type-var">'n</span>, <span class="type-var">'a_cd</span>) <a href="index.html#type-mat">mat</a> <span>&#45;&gt;</span> (<span class="type-var">'n</span>, <span class="type-var">'nrhs</span>, <span class="type-var">'b_cd</span>) <a href="index.html#type-mat">mat</a> <span>&#45;&gt;</span> (<span class="keyword">module</span> <a href="../Slap_size/module-type-SIZE/index.html">Slap_size.SIZE</a>)</code></dt><dd><p><code>gelsy_opt_lwork a b</code> computes the optimum length of workspace for <code>gelsy</code> routine.</p></dd></dl><dl><dt class="spec value" id="val-gelsy"><a href="#val-gelsy" class="anchor"></a><code><span class="keyword">val</span> gelsy : (<span class="type-var">'m</span>, <span class="type-var">'n</span>, <span class="type-var">'a_cd</span>) <a href="index.html#type-mat">mat</a> <span>&#45;&gt;</span> ?&#8288;rcond:float <span>&#45;&gt;</span> ?&#8288;jpvt:(<span class="type-var">'n</span>, <a href="../Slap_misc/index.html#type-cnt">Slap_misc.cnt</a>) <a href="../Slap_common/index.html#type-int32_vec">Slap_common.int32_vec</a> <span>&#45;&gt;</span> ?&#8288;work:(<span class="type-var">'lwork</span>, <a href="../Slap_misc/index.html#type-cnt">Slap_misc.cnt</a>) <a href="index.html#type-vec">vec</a> <span>&#45;&gt;</span> (<span class="type-var">'n</span>, <span class="type-var">'nrhs</span>, <span class="type-var">'b_cd</span>) <a href="index.html#type-mat">mat</a> <span>&#45;&gt;</span> int</code></dt><dd><p><code>gelsy a ?rcond ?jpvt ?work b</code> computes the minimum-norm solution to a linear least square problem (minimize <code>||b - a * x||</code>) using a complete orthogonal factorization of <code>a</code>.</p><dl><dt>returns</dt><dd><p>the effective rank of <code>a</code>.</p></dd></dl><dl><dt>parameter rcond</dt><dd><p>default = <code>-1.0</code> (machine precision)</p></dd></dl><dl><dt>parameter jpvt</dt><dd><p>default = a <code>'n</code>-dimensional vector.</p></dd></dl><dl><dt>parameter work</dt><dd><p>default = an optimum-length vector.</p></dd></dl></dd></dl></section><section><header><h5 id="gelsd"><a href="#gelsd" class="anchor"></a>gelsd</h5></header><dl><dt class="spec type" id="type-gelsd_min_lwork"><a href="#type-gelsd_min_lwork" class="anchor"></a><code><span class="keyword">type</span> ('m, 'n, 'nrhs) gelsd_min_lwork</code></dt></dl><dl><dt class="spec value" id="val-gelsd_min_lwork"><a href="#val-gelsd_min_lwork" class="anchor"></a><code><span class="keyword">val</span> gelsd_min_lwork : m:<span class="type-var">'m</span> <a href="../Slap_size/index.html#type-t">Slap_size.t</a> <span>&#45;&gt;</span> n:<span class="type-var">'n</span> <a href="../Slap_size/index.html#type-t">Slap_size.t</a> <span>&#45;&gt;</span> nrhs:<span class="type-var">'nrhs</span> <a href="../Slap_size/index.html#type-t">Slap_size.t</a> <span>&#45;&gt;</span> (<span class="type-var">'m</span>, <span class="type-var">'n</span>, <span class="type-var">'nrhs</span>) <a href="index.html#type-gelsd_min_lwork">gelsd_min_lwork</a> <a href="../Slap_size/index.html#type-t">Slap_size.t</a></code></dt><dd><p><code>gelsd_min_lwork ~m ~n ~nrhs</code> computes the minimum length of workspace for <code>gelsd</code> routine.</p><dl><dt>parameter m</dt><dd><p>the number of rows in a matrix.</p></dd></dl><dl><dt>parameter n</dt><dd><p>the number of columns in a matrix.</p></dd></dl><dl><dt>parameter nrhs</dt><dd><p>the number of right hand sides.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-gelsd_opt_lwork"><a href="#val-gelsd_opt_lwork" class="anchor"></a><code><span class="keyword">val</span> gelsd_opt_lwork : (<span class="type-var">'m</span>, <span class="type-var">'n</span>, <span class="type-var">'a_cd</span>) <a href="index.html#type-mat">mat</a> <span>&#45;&gt;</span> (<span class="type-var">'n</span>, <span class="type-var">'nrhs</span>, <span class="type-var">'b_cd</span>) <a href="index.html#type-mat">mat</a> <span>&#45;&gt;</span> (<span class="keyword">module</span> <a href="../Slap_size/module-type-SIZE/index.html">Slap_size.SIZE</a>)</code></dt><dd><p><code>gelsd_opt_lwork a b</code> computes the optimum length of workspace for <code>gelsd</code> routine.</p></dd></dl><dl><dt class="spec type" id="type-gelsd_min_iwork"><a href="#type-gelsd_min_iwork" class="anchor"></a><code><span class="keyword">type</span> ('m, 'n, 'nrhs) gelsd_min_iwork</code></dt></dl><dl><dt class="spec value" id="val-gelsd_min_iwork"><a href="#val-gelsd_min_iwork" class="anchor"></a><code><span class="keyword">val</span> gelsd_min_iwork : <span class="type-var">'m</span> <a href="../Slap_size/index.html#type-t">Slap_size.t</a> <span>&#45;&gt;</span> <span class="type-var">'n</span> <a href="../Slap_size/index.html#type-t">Slap_size.t</a> <span>&#45;&gt;</span> (<span class="type-var">'m</span>, <span class="type-var">'n</span>, <span class="type-var">'nrhs</span>) <a href="index.html#type-gelsd_min_iwork">gelsd_min_iwork</a> <a href="../Slap_size/index.html#type-t">Slap_size.t</a></code></dt><dd><p><code>gelsd_min_iwork ~m ~n ~nrhs</code> computes the minimum length of workspace <code>iwork</code> for <code>gelsd</code> routine.</p><dl><dt>parameter m</dt><dd><p>the number of rows in a matrix.</p></dd></dl><dl><dt>parameter n</dt><dd><p>the number of columns in a matrix.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-gelsd"><a href="#val-gelsd" class="anchor"></a><code><span class="keyword">val</span> gelsd : (<span class="type-var">'m</span>, <span class="type-var">'n</span>, <span class="type-var">'a_cd</span>) <a href="index.html#type-mat">mat</a> <span>&#45;&gt;</span> ?&#8288;rcond:float <span>&#45;&gt;</span> ?&#8288;s:((<span class="type-var">'m</span>, <span class="type-var">'n</span>) <a href="../Slap_size/index.html#type-min">Slap_size.min</a>, <a href="../Slap_misc/index.html#type-cnt">Slap_misc.cnt</a>) <a href="index.html#type-vec">vec</a> <span>&#45;&gt;</span> ?&#8288;work:(<span class="type-var">'lwork</span>, <a href="../Slap_misc/index.html#type-cnt">Slap_misc.cnt</a>) <a href="index.html#type-vec">vec</a> <span>&#45;&gt;</span> ?&#8288;iwork:(<span class="type-var">'liwork</span>, <a href="../Slap_misc/index.html#type-cnt">Slap_misc.cnt</a>) <a href="index.html#type-vec">vec</a> <span>&#45;&gt;</span> (<span class="type-var">'n</span>, <span class="type-var">'nrhs</span>, <span class="type-var">'b_cd</span>) <a href="index.html#type-mat">mat</a> <span>&#45;&gt;</span> int</code></dt><dd><p><code>gelsd a ?rcond ?jpvt ?work b</code> computes the minimum-norm solution to a linear least square problem (minimize <code>||b - a * x||</code>) using the singular value decomposition (SVD) of <code>a</code> and a divide and conquer method.</p><dl><dt>returns</dt><dd><p>the effective rank of <code>a</code>.</p></dd></dl><dl><dt>parameter rcond</dt><dd><p>default = <code>-1.0</code> (machine precision)</p></dd></dl><dl><dt>parameter s</dt><dd><p>the singular values of <code>a</code> in decreasing order. They are implicitly computed if omitted.</p></dd></dl><dl><dt>parameter work</dt><dd><p>default = an optimum-length vector.</p></dd></dl><dl><dt>parameter iwork</dt><dd><p>default = an optimum-length vector.</p></dd></dl><dl><dt>raises Failure</dt><dd><p>if the function fails to converge.</p></dd></dl></dd></dl></section><section><header><h5 id="gelss"><a href="#gelss" class="anchor"></a>gelss</h5></header><dl><dt class="spec type" id="type-gelss_min_lwork"><a href="#type-gelss_min_lwork" class="anchor"></a><code><span class="keyword">type</span> ('m, 'n, 'nrhs) gelss_min_lwork</code></dt></dl><dl><dt class="spec value" id="val-gelss_min_lwork"><a href="#val-gelss_min_lwork" class="anchor"></a><code><span class="keyword">val</span> gelss_min_lwork : m:<span class="type-var">'m</span> <a href="../Slap_size/index.html#type-t">Slap_size.t</a> <span>&#45;&gt;</span> n:<span class="type-var">'n</span> <a href="../Slap_size/index.html#type-t">Slap_size.t</a> <span>&#45;&gt;</span> nrhs:<span class="type-var">'nrhs</span> <a href="../Slap_size/index.html#type-t">Slap_size.t</a> <span>&#45;&gt;</span> (<span class="type-var">'m</span>, <span class="type-var">'n</span>, <span class="type-var">'nrhs</span>) <a href="index.html#type-gelss_min_lwork">gelss_min_lwork</a> <a href="../Slap_size/index.html#type-t">Slap_size.t</a></code></dt><dd><p><code>gelss_min_lwork ~m ~n ~nrhs</code> computes the minimum length of workspace for <code>gelss</code> routine.</p><dl><dt>parameter m</dt><dd><p>the number of rows in a matrix.</p></dd></dl><dl><dt>parameter n</dt><dd><p>the number of columns in a matrix.</p></dd></dl><dl><dt>parameter nrhs</dt><dd><p>the number of right hand sides.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-gelss_opt_lwork"><a href="#val-gelss_opt_lwork" class="anchor"></a><code><span class="keyword">val</span> gelss_opt_lwork : (<span class="type-var">'m</span>, <span class="type-var">'n</span>, <span class="type-var">'a_cd</span>) <a href="index.html#type-mat">mat</a> <span>&#45;&gt;</span> (<span class="type-var">'n</span>, <span class="type-var">'nrhs</span>, <span class="type-var">'b_cd</span>) <a href="index.html#type-mat">mat</a> <span>&#45;&gt;</span> (<span class="keyword">module</span> <a href="../Slap_size/module-type-SIZE/index.html">Slap_size.SIZE</a>)</code></dt><dd><p><code>gelss_min_lwork a b</code> computes the optimum length of workspace for <code>gelss</code> routine.</p></dd></dl><dl><dt class="spec value" id="val-gelss"><a href="#val-gelss" class="anchor"></a><code><span class="keyword">val</span> gelss : (<span class="type-var">'m</span>, <span class="type-var">'n</span>, <span class="type-var">'a_cd</span>) <a href="index.html#type-mat">mat</a> <span>&#45;&gt;</span> ?&#8288;rcond:float <span>&#45;&gt;</span> ?&#8288;s:((<span class="type-var">'m</span>, <span class="type-var">'n</span>) <a href="../Slap_size/index.html#type-min">Slap_size.min</a>, <a href="../Slap_misc/index.html#type-cnt">Slap_misc.cnt</a>) <a href="index.html#type-vec">vec</a> <span>&#45;&gt;</span> ?&#8288;work:(<span class="type-var">'lwork</span>, <a href="../Slap_misc/index.html#type-cnt">Slap_misc.cnt</a>) <a href="index.html#type-vec">vec</a> <span>&#45;&gt;</span> (<span class="type-var">'n</span>, <span class="type-var">'nrhs</span>, <span class="type-var">'b_cd</span>) <a href="index.html#type-mat">mat</a> <span>&#45;&gt;</span> int</code></dt><dd><p><code>gelss a ?rcond ?work b</code> computes the minimum-norm solution to a linear least square problem (minimize <code>||b - a * x||</code>) using the singular value decomposition (SVD) of <code>a</code>.</p><dl><dt>returns</dt><dd><p>the effective rank of <code>a</code>.</p></dd></dl><dl><dt>parameter rcond</dt><dd><p>default = <code>-1.0</code> (machine precision)</p></dd></dl><dl><dt>parameter s</dt><dd><p>the singular values of <code>a</code> in decreasing order. They are implicitly computed if omitted.</p></dd></dl><dl><dt>parameter work</dt><dd><p>default = an optimum-length vector.</p></dd></dl><dl><dt>raises Failure</dt><dd><p>if the function fails to converge.</p></dd></dl></dd></dl></section></section><section><header><h4 id="general-svd-routines"><a href="#general-svd-routines" class="anchor"></a>General SVD routines</h4></header><section><header><h5 id="gesvd"><a href="#gesvd" class="anchor"></a>gesvd</h5></header><dl><dt class="spec type" id="type-gesvd_min_lwork"><a href="#type-gesvd_min_lwork" class="anchor"></a><code><span class="keyword">type</span> ('m, 'n) gesvd_min_lwork</code></dt></dl><dl><dt class="spec value" id="val-gesvd_min_lwork"><a href="#val-gesvd_min_lwork" class="anchor"></a><code><span class="keyword">val</span> gesvd_min_lwork : m:<span class="type-var">'m</span> <a href="../Slap_size/index.html#type-t">Slap_size.t</a> <span>&#45;&gt;</span> n:<span class="type-var">'n</span> <a href="../Slap_size/index.html#type-t">Slap_size.t</a> <span>&#45;&gt;</span> (<span class="type-var">'m</span>, <span class="type-var">'n</span>) <a href="index.html#type-gesvd_min_lwork">gesvd_min_lwork</a> <a href="../Slap_size/index.html#type-t">Slap_size.t</a></code></dt><dd><p><code>gesvd_min_lwork ~m ~n</code> computes the minimum length of workspace for <code>gesvd</code> routine.</p><dl><dt>parameter m</dt><dd><p>the number of rows in a matrix.</p></dd></dl><dl><dt>parameter n</dt><dd><p>the number of columns in a matrix.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-gesvd_opt_lwork"><a href="#val-gesvd_opt_lwork" class="anchor"></a><code><span class="keyword">val</span> gesvd_opt_lwork : jobu:(<span class="type-var">'u_cols</span>, <span class="type-var">'m</span>, (<span class="type-var">'m</span>, <span class="type-var">'n</span>) <a href="../Slap_size/index.html#type-min">Slap_size.min</a>, <a href="../Slap_size/index.html#type-z">Slap_size.z</a>, <a href="../Slap_size/index.html#type-z">Slap_size.z</a>) <a href="../Slap_common/index.html#type-svd_job">Slap_common.svd_job</a> <span>&#45;&gt;</span> jobvt:(<span class="type-var">'vt_rows</span>, <span class="type-var">'n</span>, (<span class="type-var">'m</span>, <span class="type-var">'n</span>) <a href="../Slap_size/index.html#type-min">Slap_size.min</a>, <a href="../Slap_size/index.html#type-z">Slap_size.z</a>, <a href="../Slap_size/index.html#type-z">Slap_size.z</a>) <a href="../Slap_common/index.html#type-svd_job">Slap_common.svd_job</a> <span>&#45;&gt;</span> ?&#8288;s:((<span class="type-var">'m</span>, <span class="type-var">'n</span>) <a href="../Slap_size/index.html#type-min">Slap_size.min</a>, <a href="../Slap_misc/index.html#type-cnt">Slap_misc.cnt</a>) <a href="index.html#type-vec">vec</a> <span>&#45;&gt;</span> ?&#8288;u:(<span class="type-var">'m</span>, <span class="type-var">'u_cols</span>, <span class="type-var">'u_cd</span>) <a href="index.html#type-mat">mat</a> <span>&#45;&gt;</span> ?&#8288;vt:(<span class="type-var">'vt_rows</span>, <span class="type-var">'n</span>, <span class="type-var">'vt_cd</span>) <a href="index.html#type-mat">mat</a> <span>&#45;&gt;</span> (<span class="type-var">'m</span>, <span class="type-var">'n</span>, <span class="type-var">'a_cd</span>) <a href="index.html#type-mat">mat</a> <span>&#45;&gt;</span> (<span class="keyword">module</span> <a href="../Slap_size/module-type-SIZE/index.html">Slap_size.SIZE</a>)</code></dt><dd><p><code>gesvd_opt_lwork ~jobu ~jobvt ?s ?u ?vt</code> computes the optimum length of workspace for <code>gesvd</code> routine.</p><dl><dt>parameter jobu</dt><dd><p>the SVD job flag for <code>u</code>.</p></dd></dl><dl><dt>parameter jobvt</dt><dd><p>the SVD job flag for <code>vt</code>.</p></dd></dl><dl><dt>parameter s</dt><dd><p>a return location for singular values.</p></dd></dl><dl><dt>parameter u</dt><dd><p>a return location for left singular vectors.</p></dd></dl><dl><dt>parameter vt</dt><dd><p>a return location for (transposed) right singular vectors.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-gesvd"><a href="#val-gesvd" class="anchor"></a><code><span class="keyword">val</span> gesvd : jobu:(<span class="type-var">'u_cols</span>, <span class="type-var">'m</span>, (<span class="type-var">'m</span>, <span class="type-var">'n</span>) <a href="../Slap_size/index.html#type-min">Slap_size.min</a>, <a href="../Slap_size/index.html#type-z">Slap_size.z</a>, <a href="../Slap_size/index.html#type-z">Slap_size.z</a>) <a href="../Slap_common/index.html#type-svd_job">Slap_common.svd_job</a> <span>&#45;&gt;</span> jobvt:(<span class="type-var">'vt_rows</span>, <span class="type-var">'n</span>, (<span class="type-var">'m</span>, <span class="type-var">'n</span>) <a href="../Slap_size/index.html#type-min">Slap_size.min</a>, <a href="../Slap_size/index.html#type-z">Slap_size.z</a>, <a href="../Slap_size/index.html#type-z">Slap_size.z</a>) <a href="../Slap_common/index.html#type-svd_job">Slap_common.svd_job</a> <span>&#45;&gt;</span> ?&#8288;s:((<span class="type-var">'m</span>, <span class="type-var">'n</span>) <a href="../Slap_size/index.html#type-min">Slap_size.min</a>, <a href="../Slap_misc/index.html#type-cnt">Slap_misc.cnt</a>) <a href="index.html#type-vec">vec</a> <span>&#45;&gt;</span> ?&#8288;u:(<span class="type-var">'m</span>, <span class="type-var">'u_cols</span>, <span class="type-var">'u_cd</span>) <a href="index.html#type-mat">mat</a> <span>&#45;&gt;</span> ?&#8288;vt:(<span class="type-var">'vt_rows</span>, <span class="type-var">'n</span>, <span class="type-var">'vt_cd</span>) <a href="index.html#type-mat">mat</a> <span>&#45;&gt;</span> ?&#8288;work:(<span class="type-var">'lwork</span>, <a href="../Slap_misc/index.html#type-cnt">Slap_misc.cnt</a>) <a href="index.html#type-vec">vec</a> <span>&#45;&gt;</span> (<span class="type-var">'m</span>, <span class="type-var">'n</span>, <span class="type-var">'a_cd</span>) <a href="index.html#type-mat">mat</a> <span>&#45;&gt;</span> ((<span class="type-var">'m</span>, <span class="type-var">'n</span>) <a href="../Slap_size/index.html#type-min">Slap_size.min</a>, <span class="type-var">'cnt</span>) <a href="index.html#type-vec">vec</a> * (<span class="type-var">'m</span>, <span class="type-var">'u_cols</span>, <span class="type-var">'cnt</span>) <a href="index.html#type-mat">mat</a> * (<span class="type-var">'vt_rows</span>, <span class="type-var">'n</span>, <span class="type-var">'cnt</span>) <a href="index.html#type-mat">mat</a></code></dt><dd><p><code>gesvd ?jobu ?jobvt ?s ?u ?vt ?work a</code> computes the singular value decomposition (SVD) of <code>'m</code>-by-<code>'n</code> general rectangular matrix <code>a</code>: <code>a = U * D * V^T</code> where</p><ul><li><code>D</code> is an <code>'m</code>-by-<code>'n</code> matrix (the diagonal elements in <code>D</code> are singular values in descreasing order, and other elements are zeros),</li><li><code>U</code> is an <code>'m</code>-by-<code>'m</code> orthogonal matrix (the columns in <code>U</code> are left singular vectors), and</li><li><code>V</code> is an <code>'n</code>-by-<code>'n</code> orthogonal matrix (the columns in <code>V</code> are right singular vectors).</li></ul><dl><dt>returns</dt><dd><p><code>(s, u, vt)</code> with singular values <code>s</code> in descreasing order, left singular vectors <code>u</code> and right singular vectors <code>vt</code>.</p></dd></dl><dl><dt>parameter jobu</dt><dd><p>the SVD job flag for <code>u</code>:</p><ul><li>If <code>jobu</code> = <a href="../Slap_common/index.html#val-svd_all"><code>Slap_common.svd_all</code></a>, then all <code>'m</code> columns of <code>U</code> are returned in <code>u</code>. (<code>'u_cols</code> = <code>'m</code>.)</li><li>If <code>jobu</code> = <a href="../Slap_common/index.html#val-svd_top"><code>Slap_common.svd_top</code></a>, then the first <code>('m, 'n) min</code> columns of <code>U</code> are returned in <code>u</code>. (<code>'u_cols</code> = <code>('m, 'n) min</code>.)</li><li>If <code>jobu</code> = <a href="../Slap_common/index.html#val-svd_overwrite"><code>Slap_common.svd_overwrite</code></a>, then the first <code>('m, 'n) min</code> columns of <code>U</code> are overwritten on <code>a</code>. (<code>'u_cols</code> = <code>z</code> since <code>u</code> is unused.)</li><li>If <code>jobu</code> = <a href="../Slap_common/index.html#val-svd_no"><code>Slap_common.svd_no</code></a>, then no columns of <code>U</code> are computed. (<code>'u_cols</code> = <code>z</code>.)</li></ul></dd></dl><dl><dt>parameter jobvt</dt><dd><p>the SVD job flag for <code>vt</code>:</p><ul><li>If <code>jobvt</code> = <a href="../Slap_common/index.html#val-svd_all"><code>Slap_common.svd_all</code></a>, then all <code>'n</code> rows of <code>V^T</code> are returned in <code>vt</code>. (<code>'vt_rows</code> = <code>'n</code>.)</li><li>If <code>jobvt</code> = <a href="../Slap_common/index.html#val-svd_top"><code>Slap_common.svd_top</code></a>, then the first <code>('m, 'n) min</code> rows of <code>V^T</code> are returned in <code>vt</code>. (<code>'vt_rows</code> = <code>('m, 'n) min</code>.)</li><li>If <code>jobvt</code> = <a href="../Slap_common/index.html#val-svd_overwrite"><code>Slap_common.svd_overwrite</code></a>, then the first <code>('m, 'n) min</code> rows of <code>V^T</code> are overwritten on <code>a</code>. (<code>'vt_cols</code> = <code>z</code> since <code>vt</code> is unused.)</li><li>If <code>jobvt</code> = <a href="../Slap_common/index.html#val-svd_no"><code>Slap_common.svd_no</code></a>, then no columns of <code>V^T</code> are computed. (<code>'vt_cols</code> = <code>z</code>.)</li></ul></dd></dl><dl><dt>parameter s</dt><dd><p>a return location for singular values. (default = an implicitly allocated vector.)</p></dd></dl><dl><dt>parameter u</dt><dd><p>a return location for left singular vectors. (default = an implicitly allocated matrix.)</p></dd></dl><dl><dt>parameter vt</dt><dd><p>a return location for (transposed) right singular vectors. (default = an implicitly allocated matrix.)</p></dd></dl><dl><dt>parameter work</dt><dd><p>default = an optimum-length vector.</p><p>(<b>Note</b>: <code>jobu</code> and <code>jobvt</code> cannot both be <a href="../Slap_common/index.html#val-svd_overwrite"><code>Slap_common.svd_overwrite</code></a>.)</p></dd></dl></dd></dl></section><section><header><h5 id="gesdd"><a href="#gesdd" class="anchor"></a>gesdd</h5></header><dl><dt class="spec type" id="type-gesdd_liwork"><a href="#type-gesdd_liwork" class="anchor"></a><code><span class="keyword">type</span> ('m, 'n) gesdd_liwork</code></dt></dl><dl><dt class="spec value" id="val-gesdd_liwork"><a href="#val-gesdd_liwork" class="anchor"></a><code><span class="keyword">val</span> gesdd_liwork : m:<span class="type-var">'m</span> <a href="../Slap_size/index.html#type-t">Slap_size.t</a> <span>&#45;&gt;</span> n:<span class="type-var">'n</span> <a href="../Slap_size/index.html#type-t">Slap_size.t</a> <span>&#45;&gt;</span> (<span class="type-var">'m</span>, <span class="type-var">'n</span>) <a href="index.html#type-gesdd_liwork">gesdd_liwork</a> <a href="../Slap_size/index.html#type-t">Slap_size.t</a></code></dt><dd><p><code>gesdd_liwork ~m ~n</code> computes the length of workspace <code>iwork</code> for <code>gesdd</code> routine.</p><dl><dt>parameter m</dt><dd><p>the number of rows in a matrix.</p></dd></dl><dl><dt>parameter n</dt><dd><p>the number of columns in a matrix.</p></dd></dl></dd></dl><dl><dt class="spec type" id="type-gesdd_min_lwork"><a href="#type-gesdd_min_lwork" class="anchor"></a><code><span class="keyword">type</span> ('m, 'n, 'jobz) gesdd_min_lwork</code></dt></dl><dl><dt class="spec value" id="val-gesdd_min_lwork"><a href="#val-gesdd_min_lwork" class="anchor"></a><code><span class="keyword">val</span> gesdd_min_lwork : jobz:(<span class="type-var">'u_cols</span> * <span class="type-var">'vt_rows</span>, <span class="type-var">'m</span> * <span class="type-var">'n</span>, (<span class="type-var">'m</span>, <span class="type-var">'n</span>) <a href="../Slap_size/index.html#type-min">Slap_size.min</a> * (<span class="type-var">'m</span>, <span class="type-var">'n</span>) <a href="../Slap_size/index.html#type-min">Slap_size.min</a>, <span class="type-var">'m</span> * <span class="type-var">'n</span>, <a href="../Slap_size/index.html#type-z">Slap_size.z</a> * <a href="../Slap_size/index.html#type-z">Slap_size.z</a>) <a href="../Slap_common/index.html#type-svd_job">Slap_common.svd_job</a> <span>&#45;&gt;</span> m:<span class="type-var">'m</span> <a href="../Slap_size/index.html#type-t">Slap_size.t</a> <span>&#45;&gt;</span> n:<span class="type-var">'n</span> <a href="../Slap_size/index.html#type-t">Slap_size.t</a> <span>&#45;&gt;</span> unit <span>&#45;&gt;</span> (<span class="type-var">'m</span>, <span class="type-var">'n</span>, <span class="type-var">'u_cols</span> * <span class="type-var">'vt_rows</span>) <a href="index.html#type-gesdd_min_lwork">gesdd_min_lwork</a> <a href="../Slap_size/index.html#type-t">Slap_size.t</a></code></dt><dd><p><code>gesdd_min_lwork ~m ~n</code> computes the minimum length of workspace <code>work</code> for <code>gesdd</code> routine.</p><dl><dt>parameter jobz</dt><dd><p>the SVD job flag.</p></dd></dl><dl><dt>parameter m</dt><dd><p>the number of rows in a matrix.</p></dd></dl><dl><dt>parameter n</dt><dd><p>the number of columns in a matrix.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-gesdd_opt_lwork"><a href="#val-gesdd_opt_lwork" class="anchor"></a><code><span class="keyword">val</span> gesdd_opt_lwork : jobz:(<span class="type-var">'u_cols</span> * <span class="type-var">'vt_rows</span>, <span class="type-var">'m</span> * <span class="type-var">'n</span>, (<span class="type-var">'m</span>, <span class="type-var">'n</span>) <a href="../Slap_size/index.html#type-min">Slap_size.min</a> * (<span class="type-var">'m</span>, <span class="type-var">'n</span>) <a href="../Slap_size/index.html#type-min">Slap_size.min</a>, <span class="type-var">'m</span> * <span class="type-var">'n</span>, <a href="../Slap_size/index.html#type-z">Slap_size.z</a> * <a href="../Slap_size/index.html#type-z">Slap_size.z</a>) <a href="../Slap_common/index.html#type-svd_job">Slap_common.svd_job</a> <span>&#45;&gt;</span> ?&#8288;s:((<span class="type-var">'m</span>, <span class="type-var">'n</span>) <a href="../Slap_size/index.html#type-min">Slap_size.min</a>, <a href="../Slap_misc/index.html#type-cnt">Slap_misc.cnt</a>) <a href="index.html#type-vec">vec</a> <span>&#45;&gt;</span> ?&#8288;u:(<span class="type-var">'m</span>, <span class="type-var">'u_cols</span>, <span class="type-var">'u_cd</span>) <a href="index.html#type-mat">mat</a> <span>&#45;&gt;</span> ?&#8288;vt:(<span class="type-var">'vt_rows</span>, <span class="type-var">'n</span>, <span class="type-var">'vt_cd</span>) <a href="index.html#type-mat">mat</a> <span>&#45;&gt;</span> ?&#8288;iwork:(<span class="type-var">'liwork</span>, <a href="../Slap_misc/index.html#type-cnt">Slap_misc.cnt</a>) <a href="../Slap_common/index.html#type-int32_vec">Slap_common.int32_vec</a> <span>&#45;&gt;</span> (<span class="type-var">'m</span>, <span class="type-var">'n</span>, <span class="type-var">'a_cd</span>) <a href="index.html#type-mat">mat</a> <span>&#45;&gt;</span> (<span class="keyword">module</span> <a href="../Slap_size/module-type-SIZE/index.html">Slap_size.SIZE</a>)</code></dt><dd><p><code>gesdd_opt_lwork ~jobz ?s ?u ?vt ?iwork a</code> computes the optimum length of workspace <code>work</code> for <code>gesdd</code> routine.</p><dl><dt>parameter jobz</dt><dd><p>the SVD job flag.</p></dd></dl><dl><dt>parameter s</dt><dd><p>a return location for singular values. (default = an implicitly allocated vector.)</p></dd></dl><dl><dt>parameter u</dt><dd><p>a return location for left singular vectors. (default = an implicitly allocated matrix.)</p></dd></dl><dl><dt>parameter vt</dt><dd><p>a return location for (transposed) right singular vectors. (default = an implicitly allocated matrix.)</p></dd></dl><dl><dt>parameter iwork</dt><dd><p>default = an optimum-length vector.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-gesdd"><a href="#val-gesdd" class="anchor"></a><code><span class="keyword">val</span> gesdd : jobz:(<span class="type-var">'u_cols</span> * <span class="type-var">'vt_rows</span>, <span class="type-var">'m</span> * <span class="type-var">'n</span>, (<span class="type-var">'m</span>, <span class="type-var">'n</span>) <a href="../Slap_size/index.html#type-min">Slap_size.min</a> * (<span class="type-var">'m</span>, <span class="type-var">'n</span>) <a href="../Slap_size/index.html#type-min">Slap_size.min</a>, <span class="type-var">'m</span> * <span class="type-var">'n</span>, <a href="../Slap_size/index.html#type-z">Slap_size.z</a> * <a href="../Slap_size/index.html#type-z">Slap_size.z</a>) <a href="../Slap_common/index.html#type-svd_job">Slap_common.svd_job</a> <span>&#45;&gt;</span> ?&#8288;s:((<span class="type-var">'m</span>, <span class="type-var">'n</span>) <a href="../Slap_size/index.html#type-min">Slap_size.min</a>, <a href="../Slap_misc/index.html#type-cnt">Slap_misc.cnt</a>) <a href="index.html#type-vec">vec</a> <span>&#45;&gt;</span> ?&#8288;u:(<span class="type-var">'m</span>, <span class="type-var">'u_cols</span>, <span class="type-var">'u_cd</span>) <a href="index.html#type-mat">mat</a> <span>&#45;&gt;</span> ?&#8288;vt:(<span class="type-var">'vt_rows</span>, <span class="type-var">'n</span>, <span class="type-var">'vt_cd</span>) <a href="index.html#type-mat">mat</a> <span>&#45;&gt;</span> ?&#8288;work:(<span class="type-var">'lwork</span>, <a href="../Slap_misc/index.html#type-cnt">Slap_misc.cnt</a>) <a href="index.html#type-vec">vec</a> <span>&#45;&gt;</span> ?&#8288;iwork:(<span class="type-var">'liwork</span>, <a href="../Slap_misc/index.html#type-cnt">Slap_misc.cnt</a>) <a href="../Slap_common/index.html#type-int32_vec">Slap_common.int32_vec</a> <span>&#45;&gt;</span> (<span class="type-var">'m</span>, <span class="type-var">'n</span>, <span class="type-var">'a_cd</span>) <a href="index.html#type-mat">mat</a> <span>&#45;&gt;</span> ((<span class="type-var">'m</span>, <span class="type-var">'n</span>) <a href="../Slap_size/index.html#type-min">Slap_size.min</a>, <span class="type-var">'cnt</span>) <a href="index.html#type-vec">vec</a> * (<span class="type-var">'m</span>, <span class="type-var">'u_cols</span>, <span class="type-var">'u_cd</span>) <a href="index.html#type-mat">mat</a> option * (<span class="type-var">'vt_rows</span>, <span class="type-var">'n</span>, <span class="type-var">'vt_cd</span>) <a href="index.html#type-mat">mat</a> option</code></dt><dd><p><code>gesdd ~jobz ?s ?u ?vt ?work ?iwork a</code> computes the singular value decomposition (SVD) of general rectangular matrix <code>a</code> using a divide and conquer method: <code>a = U * D * V^T</code> where</p><ul><li><code>D</code> is an <code>'m</code>-by-<code>'n</code> matrix (the diagonal elements in <code>D</code> are singular values in descreasing order, and other elements are zeros),</li><li><code>U</code> is an <code>'m</code>-by-<code>'m</code> orthogonal matrix (the columns in <code>U</code> are left singular vectors), and</li><li><code>V</code> is an <code>'n</code>-by-<code>'n</code> orthogonal matrix (the columns in <code>V</code> are right singular vectors).</li></ul><dl><dt>returns</dt><dd><p><code>(s, u, vt)</code> with singular values <code>s</code> in descreasing order, left singular vectors <code>u</code> and right singular vectors <code>vt</code>. If <code>u</code> (<code>vt</code>) is not needed, <code>None</code> is returned.</p></dd></dl><dl><dt>parameter jobz</dt><dd><p>the SVD job flag:</p><ul><li>If <code>jobz</code> is <a href="../Slap_common/index.html#val-svd_all"><code>Slap_common.svd_all</code></a>, all <code>'m</code> columns of <code>U</code> and all <code>'n</code> rows of <code>V^T</code> are returned in <code>u</code> and <code>vt</code>. (<code>'u_cols</code> = <code>'m</code> and <code>'vt_rows</code> = <code>'n</code>.)</li><li>If <code>jobz</code> is <a href="../Slap_common/index.html#val-svd_top"><code>Slap_common.svd_top</code></a>, the first <code>('m, 'n) min</code> columns of <code>U</code> and the first <code>('m, 'n) min</code> rows of <code>V^T</code> are returned in <code>u</code> and <code>vt</code>. (<code>'u_cols</code> = <code>('m, 'n) min</code> and <code>'vt_rows</code> = <code>('m, 'n) min</code>.)</li><li><p>If <code>jobz</code> is <a href="../Slap_common/index.html#val-svd_overwrite"><code>Slap_common.svd_overwrite</code></a>, then</p><ul><li>if <code>'m &gt;= 'n</code>, <code>a</code> is overwritten with the first <code>('m, 'n) min</code> columns of <code>U</code>, and all <code>'n</code> rows of <code>V^T</code> is returned in <code>vt</code>, thus <code>vt</code> is <code>'n</code>-by-<code>'n</code> and <code>u</code> is not used;</li><li>if <code>'m &lt; 'n</code>, <code>a</code> is overwritten with the first <code>('m, 'n) min</code> rows of <code>V^T</code>, and all <code>'m</code> columns of <code>U</code> is returned in <code>u</code>; thereby <code>u</code> is <code>'m</code>-by-<code>'m</code> and <code>vt</code> is not used.</li></ul><p>(In either case, <code>'u_cols</code> = <code>'m</code> and <code>'vt_rows</code> = <code>'n</code>, but either <code>u</code> or <code>vt</code> should be omitted.)</p></li><li>If <code>jobz</code> is <a href="../Slap_common/index.html#val-svd_no"><code>Slap_common.svd_no</code></a>, no singular vectors are computed. (<code>'u_cols</code> = <code>z</code> and <code>'vt_rows</code> = <code>z</code>.)</li></ul></dd></dl><dl><dt>parameter s</dt><dd><p>a return location for singular values. (default = an implicitly allocated vector.)</p></dd></dl><dl><dt>parameter u</dt><dd><p>a return location for left singular vectors. (default = an implicitly allocated matrix.)</p></dd></dl><dl><dt>parameter vt</dt><dd><p>a return location for (transposed) right singular vectors. (default = an implicitly allocated matrix.)</p></dd></dl><dl><dt>parameter work</dt><dd><p>default = an optimum-length vector.</p></dd></dl><dl><dt>parameter iwork</dt><dd><p>default = an optimum-length vector.</p></dd></dl></dd></dl></section></section><section><header><h4 id="general-eigenvalue-problem-(simple-drivers)"><a href="#general-eigenvalue-problem-(simple-drivers)" class="anchor"></a>General eigenvalue problem (simple drivers)</h4></header><section><header><h5 id="geev"><a href="#geev" class="anchor"></a>geev</h5></header><dl><dt class="spec value" id="val-geev_min_lwork"><a href="#val-geev_min_lwork" class="anchor"></a><code><span class="keyword">val</span> geev_min_lwork : ?&#8288;vectors:bool <span>&#45;&gt;</span> <span class="type-var">'n</span> <a href="../Slap_size/index.html#type-t">Slap_size.t</a> <span>&#45;&gt;</span> (<span class="keyword">module</span> <a href="../Slap_size/module-type-SIZE/index.html">Slap_size.SIZE</a>)</code></dt><dd><p><code>geev_min_lwork ?vectors n</code> computes the minimum length of workspace for <code>geev</code> routine. <code>n</code> is the number of rows or columns of a matrix.</p><dl><dt>parameter vectors</dt><dd><p>whether eigenvectors are computed, or not. (default = <code>true</code>, i.e., they are computed.)</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-geev_opt_lwork"><a href="#val-geev_opt_lwork" class="anchor"></a><code><span class="keyword">val</span> geev_opt_lwork : ?&#8288;vl:(<span class="type-var">'n</span>, <span class="type-var">'n</span>, <span class="type-var">'vl_cd</span>) <a href="index.html#type-mat">mat</a> option <span>&#45;&gt;</span> ?&#8288;vr:(<span class="type-var">'n</span>, <span class="type-var">'n</span>, <span class="type-var">'vr_cd</span>) <a href="index.html#type-mat">mat</a> option <span>&#45;&gt;</span> ?&#8288;wr:(<span class="type-var">'n</span>, <a href="../Slap_misc/index.html#type-cnt">Slap_misc.cnt</a>) <a href="index.html#type-vec">vec</a> <span>&#45;&gt;</span> ?&#8288;wi:(<span class="type-var">'n</span>, <a href="../Slap_misc/index.html#type-cnt">Slap_misc.cnt</a>) <a href="index.html#type-vec">vec</a> <span>&#45;&gt;</span> (<span class="type-var">'n</span>, <span class="type-var">'n</span>, <span class="type-var">'a_cd</span>) <a href="index.html#type-mat">mat</a> <span>&#45;&gt;</span> (<span class="keyword">module</span> <a href="../Slap_size/module-type-SIZE/index.html">Slap_size.SIZE</a>)</code></dt><dd><p><code>geev_opt_lwork ?vl ?vr ?wr ?vi a</code> computes the optimum length of workspace for <code>geev</code> routine.</p><dl><dt>parameter vl</dt><dd><p>a return location for left eigenvectors. See LAPACK GEEV documentation for details about storage of complex eigenvectors. (default = an implicitly allocated matrix.)</p><ul><li>If <code>vl</code> = <code>None</code>, left eigenvectors are not computed;</li><li>If <code>vl</code> = <code>Some vl</code>, left eigenvectors are computed.</li></ul></dd></dl><dl><dt>parameter vr</dt><dd><p>a return location for right eigenvectors. See LAPACK GEEV documentation for details about storage of complex eigenvectors. (default = an implicitly allocated matrix.)</p><ul><li>If <code>vr</code> = <code>None</code>, right eigenvectors are not computed;</li><li>If <code>vr</code> = <code>Some vr</code>, right eigenvectors are computed.</li></ul></dd></dl><dl><dt>parameter wr</dt><dd><p>a return location for real parts of eigenvalues. (default = an implicitly allocated vector.)</p></dd></dl><dl><dt>parameter wi</dt><dd><p>a return location for imaginary parts of eigenvalues. (default = an implicitly allocated vector.)</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-geev"><a href="#val-geev" class="anchor"></a><code><span class="keyword">val</span> geev : ?&#8288;work:(<span class="type-var">'lwork</span>, <a href="../Slap_misc/index.html#type-cnt">Slap_misc.cnt</a>) <a href="index.html#type-vec">vec</a> <span>&#45;&gt;</span> ?&#8288;vl:(<span class="type-var">'n</span>, <span class="type-var">'n</span>, <span class="type-var">'vl_cd</span>) <a href="index.html#type-mat">mat</a> option <span>&#45;&gt;</span> ?&#8288;vr:(<span class="type-var">'n</span>, <span class="type-var">'n</span>, <span class="type-var">'vr_cd</span>) <a href="index.html#type-mat">mat</a> option <span>&#45;&gt;</span> ?&#8288;wr:(<span class="type-var">'n</span>, <a href="../Slap_misc/index.html#type-cnt">Slap_misc.cnt</a>) <a href="index.html#type-vec">vec</a> <span>&#45;&gt;</span> ?&#8288;wi:(<span class="type-var">'n</span>, <a href="../Slap_misc/index.html#type-cnt">Slap_misc.cnt</a>) <a href="index.html#type-vec">vec</a> <span>&#45;&gt;</span> (<span class="type-var">'n</span>, <span class="type-var">'n</span>, <span class="type-var">'a_cd</span>) <a href="index.html#type-mat">mat</a> <span>&#45;&gt;</span> (<span class="type-var">'n</span>, <span class="type-var">'n</span>, <span class="type-var">'vl_cd</span>) <a href="index.html#type-mat">mat</a> option * (<span class="type-var">'n</span>, <a href="../Slap_misc/index.html#type-cnt">Slap_misc.cnt</a>) <a href="index.html#type-vec">vec</a> * (<span class="type-var">'n</span>, <a href="../Slap_misc/index.html#type-cnt">Slap_misc.cnt</a>) <a href="index.html#type-vec">vec</a> * (<span class="type-var">'n</span>, <span class="type-var">'n</span>, <span class="type-var">'vr_cd</span>) <a href="index.html#type-mat">mat</a> option</code></dt><dd><p><code>geev ?work ?vl ?vr ?wr ?wi a</code> computes the eigenvalues and the left and right eigenvectors of <code>'n</code>-by-<code>'n</code> nonsymmetric matrix <code>a</code>:</p><p>Let <code>w(j)</code> is the <code>j</code>-th eigenvalue of <code>a</code>. The <code>j</code>-th right eigenvector <code>vr(j)</code> satisfies <code>a * vr(j) = w(j) * vr(j)</code>, and the <code>j</code>-th left eigenvector <code>vl(j)</code> satisfies <code>vl(j)^H * a = vl(j)^H * w(j)</code> where <code>vl(j)^H</code> denotes the conjugate transpose of <code>vl(j)</code>. The computed eigenvalues are normalized by Euclidian norm.</p><dl><dt>returns</dt><dd><p><code>(vl, wr, wi, vr)</code> where <code>vl</code> and <code>vr</code> are left and right eigenvectors, and <code>wr</code> and <code>wi</code> are the real and imaginary parts of eigenvalues. If <code>vl</code> (<code>vr</code>) is an empty matrix, <code>None</code> is set.</p></dd></dl><dl><dt>parameter work</dt><dd><p>default = an optimum-length vector.</p></dd></dl><dl><dt>parameter vl</dt><dd><p>a return location for left eigenvectors. See LAPACK GEEV documentation for details about storage of complex eigenvectors. (default = an implicitly allocated matrix.)</p><ul><li>If <code>vl</code> = <code>None</code>, left eigenvectors are not computed;</li><li>If <code>vl</code> = <code>Some vl</code>, left eigenvectors are computed.</li></ul></dd></dl><dl><dt>parameter vr</dt><dd><p>a return location for right eigenvectors. See LAPACK GEEV documentation for details about storage of complex eigenvectors. (default = an implicitly allocated matrix.)</p><ul><li>If <code>vr</code> = <code>None</code>, right eigenvectors are not computed;</li><li>If <code>vr</code> = <code>Some vr</code>, right eigenvectors are computed.</li></ul></dd></dl><dl><dt>parameter wr</dt><dd><p>a return location for real parts of eigenvalues. (default = an implicitly allocated vector.)</p></dd></dl><dl><dt>parameter wi</dt><dd><p>a return location for imaginary parts of eigenvalues. (default = an implicitly allocated vector.)</p></dd></dl><dl><dt>raises Failure</dt><dd><p>if the function fails to converge.</p></dd></dl></dd></dl></section></section><section><header><h4 id="symmetric-matrix-eigenvalue-and-singular-value-problems-(simple-drivers)"><a href="#symmetric-matrix-eigenvalue-and-singular-value-problems-(simple-drivers)" class="anchor"></a>Symmetric-matrix eigenvalue and singular value problems (simple drivers)</h4></header><section><header><h5 id="syev"><a href="#syev" class="anchor"></a>syev</h5></header><dl><dt class="spec type" id="type-syev_min_lwork"><a href="#type-syev_min_lwork" class="anchor"></a><code><span class="keyword">type</span> 'n syev_min_lwork</code></dt></dl><dl><dt class="spec value" id="val-syev_min_lwork"><a href="#val-syev_min_lwork" class="anchor"></a><code><span class="keyword">val</span> syev_min_lwork : <span class="type-var">'n</span> <a href="../Slap_size/index.html#type-t">Slap_size.t</a> <span>&#45;&gt;</span> <span class="type-var">'n</span> <a href="index.html#type-syev_min_lwork">syev_min_lwork</a> <a href="../Slap_size/index.html#type-t">Slap_size.t</a></code></dt><dd><p><code>syev_min_lwork n</code> computes the minimum length of workspace for <code>syev</code> routine. <code>n</code> is the number of rows or columns of a matrix.</p></dd></dl><dl><dt class="spec value" id="val-syev_opt_lwork"><a href="#val-syev_opt_lwork" class="anchor"></a><code><span class="keyword">val</span> syev_opt_lwork : ?&#8288;vectors:bool <span>&#45;&gt;</span> ?&#8288;up:bool <span>&#45;&gt;</span> (<span class="type-var">'n</span>, <span class="type-var">'n</span>, <span class="type-var">'cd</span>) <a href="index.html#type-mat">mat</a> <span>&#45;&gt;</span> (<span class="keyword">module</span> <a href="../Slap_size/module-type-SIZE/index.html">Slap_size.SIZE</a>)</code></dt><dd><p><code>syev_opt_lwork ?vectors ?up a</code> computes the optimum length of workspace for <code>syev</code> routine.</p><dl><dt>parameter vectors</dt><dd><p>whether eigenvectors are computed, or not. (default = <code>false</code>.)</p><ul><li>If <code>vectors</code> = <code>true</code>, eigenvectors are computed and returned in <code>a</code>.</li><li>If <code>vectors</code> = <code>false</code>, eigenvectors are not computed.</li></ul></dd></dl><dl><dt>parameter up</dt><dd><p>default = <code>true</code></p><ul><li>If <code>up</code> = <code>true</code>, then the upper triangular part of <code>a</code> is used;</li><li>If <code>up</code> = <code>false</code>, then the lower triangular part of <code>a</code> is used.</li></ul></dd></dl></dd></dl><dl><dt class="spec value" id="val-syev"><a href="#val-syev" class="anchor"></a><code><span class="keyword">val</span> syev : ?&#8288;vectors:bool <span>&#45;&gt;</span> ?&#8288;up:bool <span>&#45;&gt;</span> ?&#8288;work:(<span class="type-var">'lwork</span>, <a href="../Slap_misc/index.html#type-cnt">Slap_misc.cnt</a>) <a href="index.html#type-vec">vec</a> <span>&#45;&gt;</span> ?&#8288;w:(<span class="type-var">'n</span>, <a href="../Slap_misc/index.html#type-cnt">Slap_misc.cnt</a>) <a href="index.html#type-vec">vec</a> <span>&#45;&gt;</span> (<span class="type-var">'n</span>, <span class="type-var">'n</span>, <span class="type-var">'cd</span>) <a href="index.html#type-mat">mat</a> <span>&#45;&gt;</span> (<span class="type-var">'n</span>, <span class="type-var">'cnt</span>) <a href="index.html#type-vec">vec</a></code></dt><dd><p><code>syev ?vectors ?up ?work ?w a</code> computes the eigenvalues and the eigenvectors of <code>'n</code>-by-<code>'n</code> symmetric matrix <code>a</code>.</p><dl><dt>returns</dt><dd><p>the vector <code>w</code> of eigenvalues in ascending order.</p></dd></dl><dl><dt>parameter vectors</dt><dd><p>whether eigenvectors are computed, or not. (default = <code>false</code>.)</p><ul><li>If <code>vectors</code> = <code>true</code>, eigenvectors are computed and returned in <code>a</code>.</li><li>If <code>vectors</code> = <code>false</code>, eigenvectors are not computed.</li></ul></dd></dl><dl><dt>parameter up</dt><dd><p>default = <code>true</code></p><ul><li>If <code>up</code> = <code>true</code>, then the upper triangular part of <code>a</code> is used;</li><li>If <code>up</code> = <code>false</code>, then the lower triangular part of <code>a</code> is used.</li></ul></dd></dl><dl><dt>parameter work</dt><dd><p>default = an optimum-length vector.</p></dd></dl><dl><dt>parameter w</dt><dd><p>a return location for eigenvalues. (default = an implicitly allocated vector.)</p></dd></dl><dl><dt>raises Failure</dt><dd><p>if the function fails to converge.</p></dd></dl></dd></dl></section><section><header><h5 id="syevd"><a href="#syevd" class="anchor"></a>syevd</h5></header><dl><dt class="spec value" id="val-syevd_min_lwork"><a href="#val-syevd_min_lwork" class="anchor"></a><code><span class="keyword">val</span> syevd_min_lwork : vectors:bool <span>&#45;&gt;</span> <span class="type-var">'n</span> <a href="../Slap_size/index.html#type-t">Slap_size.t</a> <span>&#45;&gt;</span> (<span class="keyword">module</span> <a href="../Slap_size/module-type-SIZE/index.html">Slap_size.SIZE</a>)</code></dt><dd><p><code>syevd_min_lwork ?vectors n</code> computes the minimum length of workspace <code>work</code> for <code>syevd</code> routine. <code>n</code> is the number of rows or columns of a matrix.</p><dl><dt>parameter vectors</dt><dd><p>whether eigenvectors are computed, or not. (default = <code>false</code>, i.e., they are not computed.)</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-syevd_min_liwork"><a href="#val-syevd_min_liwork" class="anchor"></a><code><span class="keyword">val</span> syevd_min_liwork : vectors:bool <span>&#45;&gt;</span> <span class="type-var">'n</span> <a href="../Slap_size/index.html#type-t">Slap_size.t</a> <span>&#45;&gt;</span> (<span class="keyword">module</span> <a href="../Slap_size/module-type-SIZE/index.html">Slap_size.SIZE</a>)</code></dt><dd><p><code>syevd_min_liwork ?vectors n</code> computes the minimum length of workspace <code>iwork</code> for <code>syevd</code> routine. <code>n</code> is the number of rows or columns of a matrix.</p><dl><dt>parameter vectors</dt><dd><p>whether eigenvectors are computed, or not. (default = <code>false</code>, i.e., they are not computed.)</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-syevd_opt_lwork"><a href="#val-syevd_opt_lwork" class="anchor"></a><code><span class="keyword">val</span> syevd_opt_lwork : ?&#8288;vectors:bool <span>&#45;&gt;</span> ?&#8288;up:bool <span>&#45;&gt;</span> (<span class="type-var">'n</span>, <span class="type-var">'n</span>, <span class="type-var">'cd</span>) <a href="index.html#type-mat">mat</a> <span>&#45;&gt;</span> (<span class="keyword">module</span> <a href="../Slap_size/module-type-SIZE/index.html">Slap_size.SIZE</a>)</code></dt><dd><p><code>syevd_opt_lwork ?vectors ?up a</code> computes the optimum length of workspace <code>work</code> for <code>syevd</code> routine.</p><dl><dt>parameter vectors</dt><dd><p>whether eigenvectors are computed, or not. (default = <code>false</code>, i.e., they are not computed.)</p></dd></dl><dl><dt>parameter up</dt><dd><p>default = <code>true</code></p><ul><li>If <code>up</code> = <code>true</code>, then the upper triangular part of <code>a</code> is used;</li><li>If <code>up</code> = <code>false</code>, then the lower triangular part of <code>a</code> is used.</li></ul></dd></dl></dd></dl><dl><dt class="spec value" id="val-syevd_opt_liwork"><a href="#val-syevd_opt_liwork" class="anchor"></a><code><span class="keyword">val</span> syevd_opt_liwork : ?&#8288;vectors:bool <span>&#45;&gt;</span> ?&#8288;up:bool <span>&#45;&gt;</span> (<span class="type-var">'n</span>, <span class="type-var">'n</span>, <span class="type-var">'cd</span>) <a href="index.html#type-mat">mat</a> <span>&#45;&gt;</span> (<span class="keyword">module</span> <a href="../Slap_size/module-type-SIZE/index.html">Slap_size.SIZE</a>)</code></dt><dd><p><code>syevd_opt_liwork ?vectors ?up a</code> computes the optimum length of workspace <code>iwork</code> for <code>syevd</code> routine.</p><dl><dt>parameter vectors</dt><dd><p>whether eigenvectors are computed, or not. (default = <code>false</code>, i.e., they are not computed.)</p></dd></dl><dl><dt>parameter up</dt><dd><p>default = <code>true</code></p><ul><li>If <code>up</code> = <code>true</code>, then the upper triangular part of <code>a</code> is used;</li><li>If <code>up</code> = <code>false</code>, then the lower triangular part of <code>a</code> is used.</li></ul></dd></dl></dd></dl><dl><dt class="spec value" id="val-syevd"><a href="#val-syevd" class="anchor"></a><code><span class="keyword">val</span> syevd : ?&#8288;vectors:bool <span>&#45;&gt;</span> ?&#8288;up:bool <span>&#45;&gt;</span> ?&#8288;work:(<span class="type-var">'lwork</span>, <a href="../Slap_misc/index.html#type-cnt">Slap_misc.cnt</a>) <a href="index.html#type-vec">vec</a> <span>&#45;&gt;</span> ?&#8288;iwork:(<span class="type-var">'liwork</span>, <a href="../Slap_misc/index.html#type-cnt">Slap_misc.cnt</a>) <a href="../Slap_common/index.html#type-int32_vec">Slap_common.int32_vec</a> <span>&#45;&gt;</span> ?&#8288;w:(<span class="type-var">'n</span>, <a href="../Slap_misc/index.html#type-cnt">Slap_misc.cnt</a>) <a href="index.html#type-vec">vec</a> <span>&#45;&gt;</span> (<span class="type-var">'n</span>, <span class="type-var">'n</span>, <span class="type-var">'a_cd</span>) <a href="index.html#type-mat">mat</a> <span>&#45;&gt;</span> (<span class="type-var">'n</span>, <span class="type-var">'w_cd</span>) <a href="index.html#type-vec">vec</a></code></dt><dd><p><code>syev ?vectors ?up ?w a</code> computes the eigenvalues and the eigenvectors of <code>'n</code>-by-<code>'n</code> symmetric matrix <code>a</code> using divide and conquer method.</p><dl><dt>returns</dt><dd><p>the vector <code>w</code> of eigenvalues in ascending order.</p></dd></dl><dl><dt>parameter vectors</dt><dd><p>whether eigenvectors are computed, or not. (default = <code>false</code>.)</p><ul><li>If <code>vectors</code> = <code>true</code>, eigenvectors are computed and returned in <code>a</code>.</li><li>If <code>vectors</code> = <code>false</code>, eigenvectors are not computed.</li></ul></dd></dl><dl><dt>parameter up</dt><dd><p>default = <code>true</code></p><ul><li>If <code>up</code> = <code>true</code>, then the upper triangular part of <code>a</code> is used;</li><li>If <code>up</code> = <code>false</code>, then the lower triangular part of <code>a</code> is used.</li></ul></dd></dl><dl><dt>parameter work</dt><dd><p>default = an optimum-length vector.</p></dd></dl><dl><dt>parameter iwork</dt><dd><p>default = an optimum-length vector.</p></dd></dl><dl><dt>parameter w</dt><dd><p>a return location for eigenvalues. (default = an implicitly allocated vector.)</p></dd></dl><dl><dt>raises Failure</dt><dd><p>if the function fails to converge.</p></dd></dl></dd></dl></section><section><header><h5 id="sbev"><a href="#sbev" class="anchor"></a>sbev</h5></header><dl><dt class="spec type" id="type-sbev_min_lwork"><a href="#type-sbev_min_lwork" class="anchor"></a><code><span class="keyword">type</span> 'n sbev_min_lwork</code></dt></dl><dl><dt class="spec value" id="val-sbev_min_lwork"><a href="#val-sbev_min_lwork" class="anchor"></a><code><span class="keyword">val</span> sbev_min_lwork : <span class="type-var">'n</span> <a href="../Slap_size/index.html#type-t">Slap_size.t</a> <span>&#45;&gt;</span> <span class="type-var">'n</span> <a href="index.html#type-sbev_min_lwork">sbev_min_lwork</a> <a href="../Slap_size/index.html#type-t">Slap_size.t</a></code></dt><dd><p><code>sbev_min_lwork n</code> computes the minimum length of workspace <code>work</code> for <code>sbev</code> routine. <code>n</code> is the number of rows or columns of a matrix.</p></dd></dl><dl><dt class="spec value" id="val-sbev"><a href="#val-sbev" class="anchor"></a><code><span class="keyword">val</span> sbev : kd:<span class="type-var">'kd</span> <a href="../Slap_size/index.html#type-t">Slap_size.t</a> <span>&#45;&gt;</span> ?&#8288;z:(<span class="type-var">'n</span>, <span class="type-var">'n</span>, <span class="type-var">'z_cd</span>) <a href="index.html#type-mat">mat</a> <span>&#45;&gt;</span> ?&#8288;up:bool <span>&#45;&gt;</span> ?&#8288;work:(<span class="type-var">'lwork</span>, <a href="../Slap_misc/index.html#type-cnt">Slap_misc.cnt</a>) <a href="index.html#type-vec">vec</a> <span>&#45;&gt;</span> ?&#8288;w:(<span class="type-var">'n</span>, <a href="../Slap_misc/index.html#type-cnt">Slap_misc.cnt</a>) <a href="index.html#type-vec">vec</a> <span>&#45;&gt;</span> ((<span class="type-var">'n</span>, <span class="type-var">'kd</span>) <a href="../Slap_size/index.html#type-syband">Slap_size.syband</a>, <span class="type-var">'n</span>, <span class="type-var">'a_cd</span>) <a href="index.html#type-mat">mat</a> <span>&#45;&gt;</span> (<span class="type-var">'n</span>, <span class="type-var">'cnt</span>) <a href="index.html#type-vec">vec</a></code></dt><dd><p><code>sbev ~kd ?z ?up ?work ?w ab</code> computes all eigenvalues and, optionally, eigenvectors of real symmetric band matrix <code>ab</code> store in band storage format.</p><dl><dt>returns</dt><dd><p>vector <code>w</code>, which is overwritten.</p></dd></dl><dl><dt>parameter kd</dt><dd><p>the number of subdiagonals or superdiagonals.</p></dd></dl><dl><dt>parameter z</dt><dd><p>The eigenvectors are returned in <code>z</code> if it is given. They are not computed if omitted.</p></dd></dl><dl><dt>parameter up</dt><dd><p>default = <code>true</code></p><ul><li>If <code>up</code> = <code>true</code>, then the upper triangular part of <code>ab</code> is used;</li><li>If <code>up</code> = <code>false</code>, then the lower triangular part of <code>ab</code> is used.</li></ul></dd></dl><dl><dt>parameter work</dt><dd><p>workspace for <code>sbev</code></p></dd></dl><dl><dt>parameter w</dt><dd><p><code>w</code> is replaced by eigenvalues if it is given, or newly allocated if omitted.</p></dd></dl><dl><dt>raises Failure</dt><dd><p>if the function fails to converge.</p></dd></dl><dl><dt>since</dt><dd>0.2.0</dd></dl></dd></dl></section></section><section><header><h4 id="symmetric-matrix-eigenvalue-and-singular-value-problems-(expert-&amp;-rrr-drivers)"><a href="#symmetric-matrix-eigenvalue-and-singular-value-problems-(expert-&amp;-rrr-drivers)" class="anchor"></a>Symmetric-matrix eigenvalue and singular value problems (expert &amp; RRR drivers)</h4></header><section><header><h5 id="syevr"><a href="#syevr" class="anchor"></a>syevr</h5></header><dl><dt class="spec type" id="type-syevr_min_lwork"><a href="#type-syevr_min_lwork" class="anchor"></a><code><span class="keyword">type</span> 'n syevr_min_lwork</code></dt></dl><dl><dt class="spec value" id="val-syevr_min_lwork"><a href="#val-syevr_min_lwork" class="anchor"></a><code><span class="keyword">val</span> syevr_min_lwork : <span class="type-var">'n</span> <a href="../Slap_size/index.html#type-t">Slap_size.t</a> <span>&#45;&gt;</span> <span class="type-var">'n</span> <a href="index.html#type-syevr_min_lwork">syevr_min_lwork</a> <a href="../Slap_size/index.html#type-t">Slap_size.t</a></code></dt><dd><p><code>sbevr_min_lwork n</code> computes the minimum length of workspace <code>work</code> for <code>syevr</code> routine. <code>n</code> is the number of rows or columns of a matrix.</p></dd></dl><dl><dt class="spec type" id="type-syevr_min_liwork"><a href="#type-syevr_min_liwork" class="anchor"></a><code><span class="keyword">type</span> 'n syevr_min_liwork</code></dt></dl><dl><dt class="spec value" id="val-syevr_min_liwork"><a href="#val-syevr_min_liwork" class="anchor"></a><code><span class="keyword">val</span> syevr_min_liwork : <span class="type-var">'n</span> <a href="../Slap_size/index.html#type-t">Slap_size.t</a> <span>&#45;&gt;</span> <span class="type-var">'n</span> <a href="index.html#type-syevr_min_liwork">syevr_min_liwork</a> <a href="../Slap_size/index.html#type-t">Slap_size.t</a></code></dt><dd><p><code>sbevr_min_liwork n</code> computes the minimum length of workspace <code>iwork</code> for <code>syevr</code> routine. <code>n</code> is the number of rows or columns of a matrix.</p></dd></dl><dl><dt class="spec value" id="val-syevr_opt_lwork"><a href="#val-syevr_opt_lwork" class="anchor"></a><code><span class="keyword">val</span> syevr_opt_lwork : ?&#8288;vectors:bool <span>&#45;&gt;</span> ?&#8288;range:[ `A | `I of int * int | `V of float * float ] <span>&#45;&gt;</span> ?&#8288;up:bool <span>&#45;&gt;</span> ?&#8288;abstol:float <span>&#45;&gt;</span> (<span class="type-var">'n</span>, <span class="type-var">'n</span>, <span class="type-var">'a_cd</span>) <a href="index.html#type-mat">mat</a> <span>&#45;&gt;</span> (<span class="keyword">module</span> <a href="../Slap_size/module-type-SIZE/index.html">Slap_size.SIZE</a>)</code></dt><dd><p><code>sbevr_opt_lwork ?vectors ?range ?up ?abstol a</code> computes the optimum length of workspace <code>work</code> for <code>syevr</code> routine.</p><dl><dt>parameter vectors</dt><dd><p>whether eigenvectors are computed, or not. (default = <code>false</code>, i.e., they are not computed.)</p></dd></dl><dl><dt>parameter range</dt><dd><p>default = <code>`A</code>.</p></dd></dl><dl><dt>parameter up</dt><dd><p>default = <code>true</code>.</p></dd></dl><dl><dt>parameter abstol</dt><dd><p>The absolute error tolerance to which each eigenvalue or eigenvector is required. (default = <code>lamch `S</code>.)</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-syevr_opt_liwork"><a href="#val-syevr_opt_liwork" class="anchor"></a><code><span class="keyword">val</span> syevr_opt_liwork : ?&#8288;vectors:bool <span>&#45;&gt;</span> ?&#8288;range:[ `A | `I of int * int | `V of float * float ] <span>&#45;&gt;</span> ?&#8288;up:bool <span>&#45;&gt;</span> ?&#8288;abstol:float <span>&#45;&gt;</span> (<span class="type-var">'n</span>, <span class="type-var">'n</span>, <span class="type-var">'a_cd</span>) <a href="index.html#type-mat">mat</a> <span>&#45;&gt;</span> (<span class="keyword">module</span> <a href="../Slap_size/module-type-SIZE/index.html">Slap_size.SIZE</a>)</code></dt><dd><p><code>sbevr_opt_liwork ?vectors ?range ?up ?abstol a</code> computes the optimum length of workspace <code>iwork</code> for <code>sbevr</code> routine.</p><dl><dt>parameter vectors</dt><dd><p>whether eigenvectors are computed, or not. (default = <code>false</code>, i.e., they are not computed.)</p></dd></dl><dl><dt>parameter range</dt><dd><p>default = <code>`A</code>.</p></dd></dl><dl><dt>parameter up</dt><dd><p>default = <code>true</code>.</p></dd></dl><dl><dt>parameter abstol</dt><dd><p>The absolute error tolerance to which each eigenvalue or eigenvector is required. (default = <code>lamch `S</code>.)</p></dd></dl></dd></dl><dl><dt class="spec module-type" id="module-type-SYEVR_RESULT"><a href="#module-type-SYEVR_RESULT" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-SYEVR_RESULT/index.html">SYEVR_RESULT</a> = <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>The signature of returned modules of <code>syevr_dyn</code>.</p></dd></dl><dl><dt class="spec value" id="val-syevr_dyn"><a href="#val-syevr_dyn" class="anchor"></a><code><span class="keyword">val</span> syevr_dyn : ?&#8288;vectors:bool <span>&#45;&gt;</span> ?&#8288;range:[ `A | `I of int * int | `V of float * float ] <span>&#45;&gt;</span> ?&#8288;up:bool <span>&#45;&gt;</span> ?&#8288;abstol:float <span>&#45;&gt;</span> ?&#8288;work:(<span class="type-var">'lwork</span>, <a href="../Slap_misc/index.html#type-cnt">Slap_misc.cnt</a>) <a href="index.html#type-vec">vec</a> <span>&#45;&gt;</span> ?&#8288;iwork:(<span class="type-var">'liwork</span>, <a href="../Slap_misc/index.html#type-cnt">Slap_misc.cnt</a>) <a href="../Slap_common/index.html#type-int32_vec">Slap_common.int32_vec</a> <span>&#45;&gt;</span> ?&#8288;w:(<span class="type-var">'n</span>, <a href="../Slap_misc/index.html#type-cnt">Slap_misc.cnt</a>) <a href="index.html#type-vec">vec</a> <span>&#45;&gt;</span> ?&#8288;z:(<span class="type-var">'n</span>, <span class="type-var">'k</span>, <span class="type-var">'z_cd</span>) <a href="index.html#type-mat">mat</a> <span>&#45;&gt;</span> ?&#8288;isuppz:((<span class="type-var">'k</span>, <span class="type-var">'k</span>) <a href="../Slap_size/index.html#type-add">Slap_size.add</a>, <a href="../Slap_misc/index.html#type-cnt">Slap_misc.cnt</a>) <a href="../Slap_common/index.html#type-int32_vec">Slap_common.int32_vec</a> <span>&#45;&gt;</span> (<span class="type-var">'n</span>, <span class="type-var">'n</span>, <span class="type-var">'a_cd</span>) <a href="index.html#type-mat">mat</a> <span>&#45;&gt;</span> (<span class="keyword">module</span> <a href="module-type-SYEVR_RESULT/index.html">SYEVR_RESULT</a> <span class="keyword">with</span> <span class="keyword">type</span> <a href="module-type-SYEVR_RESULT/index.html#type-n">n</a> = <span class="type-var">'n</span>)</code></dt><dd><p><code>syevr_dyn ?vectors ?range ?up ?abstol ?work ?iwork ?w ?z ?isuppz a</code> computes selected eigenvalues <code>w</code> and, optionally, eigenvectors <code>z</code> of a real symmetric matrix <code>a</code> using the Relatively Robust Representations.</p><p>Usage:</p><pre><code class="ml">let f (type nn) ... =
  ...
  let (a : (nn, nn, _) mat) = ... in
  let module X = (val syevr_dyn ?vectors ?range ?up ?abstol
                      ?work ?iwork ?w ?z ?isuppz a
                   : SYEVR_RESULT with type n = nn) in
  let (m, w, z, isuppz) = X.value in
  ...</code></pre><p>where type <code>nn</code> is the size of symmetric matrix <code>a</code>. The returned module <code>X</code> contains tuple <code>X.value = (m, w, z, isuppz)</code> and type <code>X.m</code> for representation of the number of computed eigenvalues:</p><ul><li>Size <code>m : X.m Slap_size.t</code> is the number of eigenvalues.</li><li>Vector <code>w : (X.n, _) vec</code> contains the <code>m</code> eigenvalues in ascending order.</li><li>Matrix <code>z : (X.n, X.m, _) mat</code> contains the <code>m</code> eigenvectors of dimension <code>n</code> in the same order.</li><li><code>2*m</code>-dimensional vector <code>isuppz : ((m, m) Slap.Slap_size.add, _) Slap_common.int32_vec</code> indicates the nonzero elements in <code>z</code>.</li></ul><dl><dt>returns</dt><dd><p>the above-mentioned module <code>X</code>.</p></dd></dl><dl><dt>parameter vectors</dt><dd><p>whether eigenvectors are computed, or not. (default = <code>false</code>.)</p><ul><li>If <code>vectors</code> = <code>true</code>, eigenvectors are computed and returned in <code>a</code>.</li><li>If <code>vectors</code> = <code>false</code>, eigenvectors are not computed.</li></ul></dd></dl><dl><dt>parameter range</dt><dd><p>default = <code>`A</code></p><ul><li>If <code>range</code> = <code>`A</code>, all eigenvalues are computed.</li><li>If <code>range</code> = <code>`I (il, iu)</code>, eigenvalues with indices <code>il</code> to <code>iu</code> are computed.</li><li>If <code>range</code> = <code>`V (vl, vu)</code>, the routine computes eigenvalues <code>w(i)</code> in the half-open interval: <code>vl &lt; w(i) &lt;= vu</code> where <code>vl &lt;= vu</code>.</li></ul></dd></dl><dl><dt>parameter up</dt><dd><p>default = <code>true</code></p><ul><li>If <code>up</code> = <code>true</code>, then the upper triangular part of <code>a</code> is used;</li><li>If <code>up</code> = <code>false</code>, then the lower triangular part of <code>a</code> is used.</li></ul></dd></dl><dl><dt>parameter abstol</dt><dd><p>The absolute error tolerance to which each eigenvalue or eigenvector is required. (default = <code>lamch `S</code>.)</p></dd></dl><dl><dt>parameter work</dt><dd><p>default = an optimum-length vector.</p></dd></dl><dl><dt>parameter iwork</dt><dd><p>default = an optimum-length vector.</p></dd></dl><dl><dt>parameter w</dt><dd><p>a return location for eigenvalues. (default = an implicitly allocated vector of the minimum required dimension.)</p></dd></dl><dl><dt>parameter z</dt><dd><p>a return location for eigenvectors. (default = an implicitly allocated matrix of the minimum required dimension.)</p></dd></dl><dl><dt>parameter isuppz</dt><dd><p>a return location for a vector to indicate the nonzero elements in <code>z</code>. (default = an implicitly allocated matrix of the minimum required dimension.)</p></dd></dl><dl><dt>raises Invalid_argument</dt><dd><p>if not <code>X.m &lt;= 'k</code></p></dd></dl></dd></dl></section><section><header><h5 id="sygv"><a href="#sygv" class="anchor"></a>sygv</h5></header><dl><dt class="spec value" id="val-sygv_opt_lwork"><a href="#val-sygv_opt_lwork" class="anchor"></a><code><span class="keyword">val</span> sygv_opt_lwork : ?&#8288;vectors:bool <span>&#45;&gt;</span> ?&#8288;up:bool <span>&#45;&gt;</span> ?&#8288;itype:[ `AB | `A_B | `BA ] <span>&#45;&gt;</span> (<span class="type-var">'n</span>, <span class="type-var">'n</span>, <span class="type-var">'a_cd</span>) <a href="index.html#type-mat">mat</a> <span>&#45;&gt;</span> (<span class="type-var">'n</span>, <span class="type-var">'n</span>, <span class="type-var">'b_cd</span>) <a href="index.html#type-mat">mat</a> <span>&#45;&gt;</span> (<span class="keyword">module</span> <a href="../Slap_size/module-type-SIZE/index.html">Slap_size.SIZE</a>)</code></dt><dd><p><code>sygv_opt_lwork ?vectors ?up ?itype a b</code> computes the optimum length of workspace <code>work</code> for <code>sbevr</code> routine.</p><dl><dt>parameter vectors</dt><dd><p>whether eigenvectors are computed, or not. (default = <code>false</code>, i.e., they are not computed.)</p></dd></dl><dl><dt>parameter up</dt><dd><p>default = <code>true</code>.</p></dd></dl><dl><dt>parameter itype</dt><dd><p>the behavior of this routine.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-sygv"><a href="#val-sygv" class="anchor"></a><code><span class="keyword">val</span> sygv : ?&#8288;vectors:bool <span>&#45;&gt;</span> ?&#8288;up:bool <span>&#45;&gt;</span> ?&#8288;work:(<span class="type-var">'lwork</span>, <a href="../Slap_misc/index.html#type-cnt">Slap_misc.cnt</a>) <a href="index.html#type-vec">vec</a> <span>&#45;&gt;</span> ?&#8288;w:(<span class="type-var">'n</span>, <a href="../Slap_misc/index.html#type-cnt">Slap_misc.cnt</a>) <a href="index.html#type-vec">vec</a> <span>&#45;&gt;</span> ?&#8288;itype:[ `AB | `A_B | `BA ] <span>&#45;&gt;</span> (<span class="type-var">'n</span>, <span class="type-var">'n</span>, <span class="type-var">'a_cd</span>) <a href="index.html#type-mat">mat</a> <span>&#45;&gt;</span> (<span class="type-var">'n</span>, <span class="type-var">'n</span>, <span class="type-var">'b_cd</span>) <a href="index.html#type-mat">mat</a> <span>&#45;&gt;</span> (<span class="type-var">'n</span>, <span class="type-var">'cnt</span>) <a href="index.html#type-vec">vec</a></code></dt><dd><p><code>sygv ?vectors ?up ?work ?w ?itype a b</code> solves a real generalized symmetric definite eigenproblem:</p><ul><li><code>a * x = lambda * b * x</code> if <code>itype</code> is <code>`A_B</code>;</li><li><code>a * b * x = lambda * x</code> if <code>itype</code> is <code>`AB</code>;</li><li><code>b * a * x = lambda * x</code> if <code>itype</code> is <code>`BA</code></li></ul><p>where <code>a</code> is a <code>'n</code>-by-<code>'n</code> symmetric matrix, and <code>b</code> is a <code>'n</code>-by-<code>'n</code> symmetric positive definite matrix.</p><dl><dt>raises Failure</dt><dd><p>if the function fails to converge.</p></dd></dl><dl><dt>returns</dt><dd><p>vector <code>w</code> of eigenvalues in ascending order.</p></dd></dl><dl><dt>parameter vectors</dt><dd><p>whether eigenvectors are computed, or not. (default = <code>false</code>.)</p><ul><li>If <code>vectors</code> = <code>true</code>, eigenvectors are computed and returned in <code>a</code>.</li><li>If <code>vectors</code> = <code>false</code>, eigenvectors are not computed.</li></ul></dd></dl><dl><dt>parameter up</dt><dd><p>default = <code>true</code>.</p><ul><li>If <code>up</code> = <code>true</code>, then the upper triangular part of <code>a</code> is used;</li><li>If <code>up</code> = <code>false</code>, then the lower triangular part of <code>a</code> is used.</li></ul></dd></dl><dl><dt>parameter work</dt><dd><p>default = an optimum-length workspace.</p></dd></dl><dl><dt>parameter w</dt><dd><p>a return location for eigenvalues. (default = an implicitly allocated vector.)</p></dd></dl><dl><dt>parameter itype</dt><dd><p>the behavior of this routine.</p></dd></dl><dl><dt>raises Failure</dt><dd><p>if the function fails to converge.</p></dd></dl></dd></dl></section><section><header><h5 id="sbgv"><a href="#sbgv" class="anchor"></a>sbgv</h5></header><dl><dt class="spec value" id="val-sbgv"><a href="#val-sbgv" class="anchor"></a><code><span class="keyword">val</span> sbgv : ka:<span class="type-var">'ka</span> <a href="../Slap_size/index.html#type-t">Slap_size.t</a> <span>&#45;&gt;</span> kb:<span class="type-var">'kb</span> <a href="../Slap_size/index.html#type-t">Slap_size.t</a> <span>&#45;&gt;</span> ?&#8288;z:(<span class="type-var">'n</span>, <span class="type-var">'n</span>, <span class="type-var">'z_cd</span>) <a href="index.html#type-mat">mat</a> <span>&#45;&gt;</span> ?&#8288;up:bool <span>&#45;&gt;</span> ?&#8288;work:(<span class="type-var">'lwork</span>, <a href="../Slap_misc/index.html#type-cnt">Slap_misc.cnt</a>) <a href="index.html#type-vec">vec</a> <span>&#45;&gt;</span> ?&#8288;w:(<span class="type-var">'n</span>, <a href="../Slap_misc/index.html#type-cnt">Slap_misc.cnt</a>) <a href="index.html#type-vec">vec</a> <span>&#45;&gt;</span> ((<span class="type-var">'n</span>, <span class="type-var">'ka</span>) <a href="../Slap_size/index.html#type-syband">Slap_size.syband</a>, <span class="type-var">'n</span>, <span class="type-var">'ab_cd</span>) <a href="index.html#type-mat">mat</a> <span>&#45;&gt;</span> ((<span class="type-var">'n</span>, <span class="type-var">'kb</span>) <a href="../Slap_size/index.html#type-syband">Slap_size.syband</a>, <span class="type-var">'n</span>, <span class="type-var">'bb_cd</span>) <a href="index.html#type-mat">mat</a> <span>&#45;&gt;</span> (<span class="type-var">'n</span>, <span class="type-var">'cnt</span>) <a href="index.html#type-vec">vec</a></code></dt><dd><p><code>sbgv ~ka ~kb ?z ?up ?work ?w ab bb</code> solves a general eigenvalue problem <code>ab * z = (lambda) * bb * z</code> where <code>ab</code> is a <code>'n</code>-by-<code>'n</code> symmetric band matrix with <code>ka</code> subdiagonals, and <code>bb</code> is a <code>'n</code>-by-<code>'n</code> symmetric positive-definite band matrix with <code>kb</code> subdiagonals. Both <code>ab</code> and <code>bb</code> are stored in band storage format.</p><dl><dt>returns</dt><dd><p>vector <code>w</code>, which is overwritten.</p></dd></dl><dl><dt>parameter ka</dt><dd><p>the number of subdiagonals or superdiagonals of <code>ab</code>.</p></dd></dl><dl><dt>parameter kb</dt><dd><p>the number of subdiagonals or superdiagonals of <code>bb</code>.</p></dd></dl><dl><dt>parameter z</dt><dd><p>The eigenvectors are returned in <code>z</code> if it is given. They are not computed if omitted.</p></dd></dl><dl><dt>parameter up</dt><dd><p>default = <code>true</code></p><ul><li>If <code>up</code> = <code>true</code>, then the upper triangular part of <code>ab</code> is used;</li><li>If <code>up</code> = <code>false</code>, then the lower triangular part of <code>ab</code> is used.</li></ul></dd></dl><dl><dt>parameter work</dt><dd><p>workspace for <code>sbgv</code></p></dd></dl><dl><dt>parameter w</dt><dd><p><code>w</code> is replaced by eigenvalues if it is given, or newly allocated if omitted.</p></dd></dl><dl><dt>raises Failure</dt><dd><p>if the function fails to converge.</p></dd></dl><dl><dt>since</dt><dd>0.2.0</dd></dl></dd></dl></section></section></section></div></body></html>