<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Slap_ppx (slap.Slap_ppx)</title><link rel="stylesheet" href="../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../index.html">slap</a> &#x00BB; Slap_ppx</nav><h1>Module <code>Slap_ppx</code></h1><p>PPX syntactic extensions for SLAP. (This is a dummy module.)</p><p>For use of the extensions, you need to pass <code>-ppx ppx_slap</code> to the OCaml compiler, or specify <code>-package slap.ppx</code> to OCamlfind. You can also use by</p><pre><code class="ml">#use &quot;topfind&quot;;;
#require &quot;slap.ppx&quot;;;</code></pre><p>on interactive mode.</p><h3 id="literals"><a href="#literals" class="anchor"></a>Literals</h3><h4 id="vector-literals"><a href="#vector-literals" class="anchor"></a>Vector literals</h4><p>Vector literals like <code>[%vec.kind [e1; e2; ...; eN]]</code> are supported where <code>e1</code> ... <code>eN</code> are elements and <code>kind</code> specifies the type and precision of the elements. It corresponds to <code>Bigarray</code> kind:</p><ul><li><code>float32</code>, <code>S</code> or <code>s</code>: 32-bit real number (<code>Bigarray.float32</code>)</li><li><code>float64</code>, <code>D</code> or <code>d</code>: 64-bit real number (<code>Bigarray.float64</code>)</li><li><code>complex32</code>, <code>C</code> or <code>c</code>: 32-bit complex number (<code>Bigarray.complex32</code>)</li><li><code>complex64</code>, <code>Z</code> or <code>z</code>: 64-bit complex number (<code>Bigarray.complex64</code>)</li><li><code>int8_signed</code> or <code>sint8</code>: 8-bit signed integer (<code>Bigarray.int8_signed</code>)</li><li><code>int8_unsigned</code> or <code>uint8</code>: 8-bit unsigned integer (<code>Bigarray.int8_unsigned</code>)</li><li><code>int16_signed</code> or <code>sint16</code>: 16-bit signed integer (<code>Bigarray.int16_signed</code>)</li><li><code>int16_unsigned</code> or <code>uint16</code>: 16-bit unsigned integer (<code>Bigarray.int16_unsigned</code>)</li><li><code>int</code>: 31-bit integer (<code>Bigarray.int</code>)</li><li><code>int32</code>: 32-bit integer (<code>Bigarray.int32</code>)</li><li><code>int64</code>: 64-bit integer (<code>Bigarray.int64</code>)</li><li><code>nativeint</code>: native integer (<code>Bigarray.nativeint</code>)</li><li><code>char</code>: character (<code>Bigarray.char</code>)</li></ul><p>You can omit a kind if you open <code>Slap.[SDCZ]</code>:</p><ul><li><code>[%vec [...]]</code> (referring <code>Slap.[SDCZ].prec</code> as <code>Bigarray</code> kind, corresponding to an opened module)</li><li><code>[%rvec [...]]</code> (referring <code>Slap.[SDCZ].rprec</code> as <code>Bigarray</code> kind, corresponding to an opened module)</li></ul><p>For examples, <code>[%vec.float64 [42.0; 123.0; 456.0]]</code> is a three-dimensional vector that has 64-bit real numbers <code>42.0</code>, <code>123.0</code> and <code>456.0</code>. If you open <code>Slap.D</code>, the vector literal is the same as <code>[%vec [42.0; 123.0; 456.0]]</code>.</p><h4 id="matrix-literals"><a href="#matrix-literals" class="anchor"></a>Matrix literals</h4><p>Matrix literals can be written as</p><pre><code class="ml">[%mat.kind [ [e11; e12; ...; e1N];
             [e21; e22; ...; e2N];
             [...; ...; ...; ...];
             [eM1; eM2; ...; eMN] ]]</code></pre><p>or</p><pre><code class="ml">[%mat.kind [ e11, e12, ..., e1N;
             e21, e22, ..., e2N;
             ..., ..., ..., ...;
             eM1, eM2, ..., eMN ]]</code></pre><p>where <code>kind</code> is one of the above-mentioned identifiers. You can also use <code>[%mat ...]</code> and <code>[%rmat ...]</code> (referring <code>Slap.[SDCZ].prec</code> and <code>Slap.[SDCZ].rprec</code> respectively) as similar to vector literals.</p></header></div></body></html>