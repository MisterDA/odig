<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<link rel="stylesheet" href="style.css" type="text/css">
<meta content="text/html; charset=iso-8859-1" http-equiv="Content-Type">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="Start" href="index.html">
<link rel="Up" href="index.html">
<link title="Index of types" rel=Appendix href="index_types.html">
<link title="Index of values" rel=Appendix href="index_values.html">
<link title="Index of modules" rel=Appendix href="index_modules.html">
<link title="Index of module types" rel=Appendix href="index_module_types.html">
<link title="Spelll" rel="Chapter" href="Spelll.html"><link title="Abstraction over Strings" rel="Section" href="#2_AbstractionoverStrings">
<link title="Continuation list" rel="Section" href="#2_Continuationlist">
<link title="Signature" rel="Section" href="#2_Signature">
<title>Spelll</title>
</head>
<body>
<div class="navbar">&nbsp;<a class="up" href="index.html" title="Index">Up</a>
&nbsp;</div>
<h1>Module <a href="type_Spelll.html">Spelll</a></h1>

<pre><span id="MODULESpelll"><span class="keyword">module</span> Spelll</span>: <code class="code">sig</code> <a href="Spelll.html">..</a> <code class="code">end</code></pre><div class="info module top">
<div class="info-desc">
<h2 id="1_Levenshteindistanceandindex">Levenshtein distance and index</h2>
<p>We take inspiration from
<a href="http://blog.notdot.net/2010/07/Damn-Cool-Algorithms-Levenshtein-Automata">
this blog</a>
for the main algorithm and ideas. However some parts are adapted</p>
</div>
</div>
<hr width="100%">
<h3 id="2_AbstractionoverStrings">Abstraction over Strings</h3><p>Due to the existence of several encodings and string representations we
abstract over the type of strings. A string is a finite array of characters
(8-bits char, unicode runes, etc.) which provides a length operation
and a function to access the n-th character.</p>

<pre><span id="MODULETYPESTRING"><span class="keyword">module type</span> <a href="Spelll.STRING.html">STRING</a></span> = <code class="code">sig</code> <a href="Spelll.STRING.html">..</a> <code class="code">end</code></pre><h3 id="2_Continuationlist">Continuation list</h3>
<p>This data structure is used to represent a list of result that is
evaluated only as far as the user wants. If the user only wants a few elements,
she doesn't pay for the remaining ones.</p>

<p>In particular, when matching a string against a (big) set of indexed
strings, we return a continuation list so that, even if there are many results,
only those actually asked for are evaluated.</p>

<pre><span id="TYPEklist"><span class="keyword">type</span> <code class="type">'a</code> klist</span> = <code class="type">[ `Cons of 'a * (unit -> 'a <a href="Spelll.html#TYPEklist">klist</a>) | `Nil ]</code> </pre>


<pre><span id="VALklist_to_list"><span class="keyword">val</span> klist_to_list</span> : <code class="type">'a <a href="Spelll.html#TYPEklist">klist</a> -> 'a list</code></pre><div class="info ">
<div class="info-desc">
<p>Helper.</p>
</div>
</div>
<h3 id="2_Signature">Signature</h3>
<p>The signature for a given string representation provides 3 main things:</p>

<ul>
<li>a <code class="code">edit_distance</code> function to compute the edit distance between strings</li>
<li>an <code class="code">automaton</code> type that is built from a string <code class="code">s</code> and a maximum distance <code class="code">n</code>,
  and only accepts the strings <code class="code">s'</code> such that <code class="code">edit_distance s s' &lt;= n</code>.</li>
<li>an <code class="code">Index</code> module that can be used to map many strings to values, like
  a regular string map, but for which retrieval is fuzzy (for a given
  maximal distance).</li>
</ul>
<p>A possible use of the index could be:</p>
<pre class="codepre"><code class="code">open Batteries;;

let words = File.with_file_in "/usr/share/dict/english"
  (fun i -&gt; IO.read_all i |&gt; String.nsplit ~by:"\\n");;

let words = List.map (fun s-&gt;s,s) words;;
let idx = Spelll.Index.of_list words;;

Spelll.Index.retrieve ~limit:1 idx "hell" |&gt; Spelll.klist_to_list;;
</code></pre>
<p>Here we use <a href="https://github.com/ocaml-batteries-team/batteries-included">Batteries</a>
to read a dictionary file into a list of words; then we create an index that
maps every string to itself (a set of strings, really), and finally
we find every string at distance at most 1 from "hell" (including "hello"
for instance).</p>

<pre><span id="MODULETYPES"><span class="keyword">module type</span> <a href="Spelll.S.html">S</a></span> = <code class="code">sig</code> <a href="Spelll.S.html">..</a> <code class="code">end</code></pre>
<pre><span id="MODULEMake"><span class="keyword">module</span> <a href="Spelll.Make.html">Make</a></span>: <div class="sig_block"><code class="code">functor (</code><code class="code">Str</code><code class="code"> : </code><code class="type"><a href="Spelll.STRING.html">STRING</a></code><code class="code">) -&gt; </code><code class="type"><a href="Spelll.S.html">S</a></code><code class="type"> 
  with type string_ = Str.t
  and type char_ = Str.char_</code></div></pre>
<pre><span class="keyword">include</span> <a href="Spelll.S.html">Spelll.S</a></pre>

<pre><span id="VALdebug_print"><span class="keyword">val</span> debug_print</span> : <code class="type">Stdlib.out_channel -> automaton -> unit</code></pre></body></html>
