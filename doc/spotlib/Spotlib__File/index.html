<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Spotlib__File (spotlib.Spotlib__File)</title><link rel="stylesheet" href="../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../index.html">spotlib</a> &#x00BB; Spotlib__File</nav><h1>Module <code>Spotlib__File</code></h1><p>Some simple file content iterations and /usr/bin/test style file status checking functions.</p><nav class="toc"><ul><li><a href="#iterators-over-lines">Iterators over lines</a></li></ul></nav></header><section><header><h6 id="iterators-over-lines"><a href="#iterators-over-lines" class="anchor"></a>Iterators over lines</h6></header><dl><dt class="spec value" id="val-iter_lines_exn"><a href="#val-iter_lines_exn" class="anchor"></a><code><span class="keyword">val</span> iter_lines_exn : string <span>&#45;&gt;</span> (string <span>&#45;&gt;</span> <span class="type-var">'a</span>) <span>&#45;&gt;</span> unit</code></dt><dd><p><code>iter_lines_exn filename f</code> iters <code>f</code> over lines of contets of <code>filename</code>.</p><p>Note: lines are obtained by <code>input_line</code>: therefore the newline chars are removed from the lines.</p></dd></dl><dl><dt class="spec value" id="val-iter_lines"><a href="#val-iter_lines" class="anchor"></a><code><span class="keyword">val</span> iter_lines : string <span>&#45;&gt;</span> (string <span>&#45;&gt;</span> unit) <span>&#45;&gt;</span> (unit, [&gt; `Exn of exn ]) <a href="../../ocaml/Stdlib/index.html#type-result">Stdlib.result</a></code></dt><dd><p><code>iter_lines filename f</code> iters <code>f</code> over lines of contets of <code>filename</code>.</p><p>Note: lines are obtained by <code>input_line</code>: therefore the newline chars are removed from the lines.</p></dd></dl><dl><dt class="spec value" id="val-to_lines"><a href="#val-to_lines" class="anchor"></a><code><span class="keyword">val</span> to_lines : string <span>&#45;&gt;</span> (string list, [&gt; `Exn of exn ]) <a href="../../ocaml/Stdlib/index.html#type-result">Stdlib.result</a></code></dt><dd><p><code>to_lines filename</code> returns the contens of the file.</p><p>Note: lines are obtained by <code>input_line</code>: therefore the newline chars are removed from the lines.</p></dd></dl><dl><dt class="spec value" id="val-to_string"><a href="#val-to_string" class="anchor"></a><code><span class="keyword">val</span> to_string : string <span>&#45;&gt;</span> (string, [&gt; `Exn of exn ]) <a href="../../ocaml/Stdlib/index.html#type-result">Stdlib.result</a></code></dt><dd><p><code>to_string filename</code> returns the contens of the file.</p></dd></dl><dl><dt class="spec value" id="val-open_out"><a href="#val-open_out" class="anchor"></a><code><span class="keyword">val</span> open_out : string <span>&#45;&gt;</span> (<a href="../../ocaml/Stdlib/index.html#type-out_channel">Stdlib.out_channel</a> <span>&#45;&gt;</span> <span class="type-var">'a</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p><code>open_out filename f</code> opens <code>filename</code> then runs <code>f</code> over the opened channel. The channel is closed automatically no matter whether <code>f</code> terminates normally or raises an exception.</p></dd></dl><dl><dt class="spec value" id="val-write_lines"><a href="#val-write_lines" class="anchor"></a><code><span class="keyword">val</span> write_lines : string <span>&#45;&gt;</span> string list <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-get_inode"><a href="#val-get_inode" class="anchor"></a><code><span class="keyword">val</span> get_inode : string <span>&#45;&gt;</span> int option</code></dt><dd><p>Get file inode. Works for Unix and MinGW. Cygwin? Never tried.</p></dd></dl><dl><dt class="spec value" id="val-equal"><a href="#val-equal" class="anchor"></a><code><span class="keyword">val</span> equal : string <span>&#45;&gt;</span> string <span>&#45;&gt;</span> bool</code></dt><dd><p>Check two file names share the same inode</p></dd></dl><dl><dt class="spec value" id="val-contains"><a href="#val-contains" class="anchor"></a><code><span class="keyword">val</span> contains : string <span>&#45;&gt;</span> string <span>&#45;&gt;</span> string list option</code></dt><dd><p><code>contains p1 p2</code> return <code>Some compos</code> when <code>p2</code> is equal to <code>p1</code> or under <code>p1</code>. <code>compos</code> is the directory components from <code>p2</code> to reach <code>p1</code>.</p><p>If <code>p1</code> is non existent, the search is performed only by comparison of path names. If <code>p1</code> exists, the search is performed also with the file's inodes.</p></dd></dl><dl><dt class="spec module" id="module-Test"><a href="#module-Test" class="anchor"></a><code><span class="keyword">module</span> <a href="Test/index.html">Test</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>/usr/bin/test like file testing</p></dd></dl></section></div></body></html>