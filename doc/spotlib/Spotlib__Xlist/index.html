<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Spotlib__Xlist (spotlib.Spotlib__Xlist)</title><link rel="stylesheet" href="../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../index.html">spotlib</a> &#x00BB; Spotlib__Xlist</nav><h1>Module <code>Spotlib__Xlist</code></h1><h3 id="type"><a href="#type" class="anchor"></a>Type</h3><nav class="toc"><ul><li><a href="#construction">Construction</a></li><li><a href="#conversions">Conversions</a></li><li><a href="#basics">Basics</a></li><li><a href="#folding">Folding</a></li><li><a href="#access">Access</a></li><li><a href="#find-and-assoc">Find and assoc</a></li><li><a href="#sublist-by-index">Sublist by index</a></li><li><a href="#sublist-by-predicate">Sublist by predicate</a></li><li><a href="#sort-and-uniq">Sort and uniq</a></li><li><a href="#composition">Composition</a></li><li><a href="#with-reference">With reference</a></li><li><a href="#integer-ranges">Integer ranges</a></li><li><a href="#misc">Misc</a></li><li><a href="#modules">Modules</a></li><li><a href="#non-tail-recursive-versions">Non tail recursive versions</a></li><li><a href="#deprecated">Deprecated</a></li></ul></nav></header><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> 'a t</code><code> = <span class="type-var">'a</span> list</code></dt></dl><section><header><h3 id="construction"><a href="#construction" class="anchor"></a>Construction</h3></header><dl><dt class="spec value" id="val-empty"><a href="#val-empty" class="anchor"></a><code><span class="keyword">val</span> empty : <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>empty = []</code></p></dd></dl><dl><dt class="spec value" id="val-singleton"><a href="#val-singleton" class="anchor"></a><code><span class="keyword">val</span> singleton : <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>singleton x = [x]</code></p></dd></dl><dl><dt class="spec value" id="val-make"><a href="#val-make" class="anchor"></a><code><span class="keyword">val</span> make : int <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>make n x</code> returns a list of length <code>n</code> filled with <code>x</code>. Throws <code>Invalid_argument &quot;List.make&quot;</code> when <code>n &lt; 0</code>.</p></dd></dl><dl><dt class="spec value" id="val-init"><a href="#val-init" class="anchor"></a><code><span class="keyword">val</span> init : int <span>&#45;&gt;</span> (int <span>&#45;&gt;</span> <span class="type-var">'a</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>init n f</code> returns a list of <code>[f 0; f 1; ..; f (n-1)]</code>. Throws <code>Invalid_argument &quot;List.init&quot;</code> when <code>n &lt; 0</code>.</p></dd></dl></section><section><header><h3 id="conversions"><a href="#conversions" class="anchor"></a>Conversions</h3></header><dl><dt class="spec value" id="val-to_list"><a href="#val-to_list" class="anchor"></a><code><span class="keyword">val</span> to_list : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> list</code></dt><dt class="spec value" id="val-to_array"><a href="#val-to_array" class="anchor"></a><code><span class="keyword">val</span> to_array : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> array</code></dt><dt class="spec value" id="val-of_list"><a href="#val-of_list" class="anchor"></a><code><span class="keyword">val</span> of_list : <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-of_array"><a href="#val-of_array" class="anchor"></a><code><span class="keyword">val</span> of_array : <span class="type-var">'a</span> array <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt></dl></section><section><header><h3 id="basics"><a href="#basics" class="anchor"></a>Basics</h3></header><dl><dt class="spec value" id="val-append"><a href="#val-append" class="anchor"></a><code><span class="keyword">val</span> append : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Tail recursive version of <code>List.append</code></p></dd></dl><dl><dt class="spec value" id="val-(@)"><a href="#val-(@)" class="anchor"></a><code><span class="keyword">val</span> (@) : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Tail recursive version of <code>List.(@)</code></p></dd></dl><dl><dt class="spec value" id="val-concat"><a href="#val-concat" class="anchor"></a><code><span class="keyword">val</span> concat : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Tail recursive version of <code>List.concat</code></p></dd></dl><dl><dt class="spec value" id="val-flatten"><a href="#val-flatten" class="anchor"></a><code><span class="keyword">val</span> flatten : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Tail recursive version of <code>List.flatten</code></p></dd></dl><dl><dt class="spec value" id="val-replicate"><a href="#val-replicate" class="anchor"></a><code><span class="keyword">val</span> replicate : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>replicate xs n</code> concatenates the list <code>xs</code> <code>n</code>-times</p></dd></dl></section><section><header><h3 id="folding"><a href="#folding" class="anchor"></a>Folding</h3></header><dl><dt class="spec value" id="val-map"><a href="#val-map" class="anchor"></a><code><span class="keyword">val</span> map : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'b</span> list</code></dt><dt class="spec value" id="val-mapi"><a href="#val-mapi" class="anchor"></a><code><span class="keyword">val</span> mapi : (int <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'b</span> list</code></dt><dt class="spec value" id="val-map2"><a href="#val-map2" class="anchor"></a><code><span class="keyword">val</span> map2 : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'c</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'b</span> list <span>&#45;&gt;</span> <span class="type-var">'c</span> list</code></dt><dt class="spec value" id="val-split"><a href="#val-split" class="anchor"></a><code><span class="keyword">val</span> split : (<span class="type-var">'a</span> * <span class="type-var">'b</span>) list <span>&#45;&gt;</span> <span class="type-var">'a</span> list * <span class="type-var">'b</span> list</code></dt><dt class="spec value" id="val-merge"><a href="#val-merge" class="anchor"></a><code><span class="keyword">val</span> merge : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> int) <span>&#45;&gt;</span> <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'a</span> list</code></dt><dt class="spec value" id="val-fold_right"><a href="#val-fold_right" class="anchor"></a><code><span class="keyword">val</span> fold_right : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'st</span> <span>&#45;&gt;</span> <span class="type-var">'st</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'st</span> <span>&#45;&gt;</span> <span class="type-var">'st</span></code></dt><dt class="spec value" id="val-fold_left1"><a href="#val-fold_left1" class="anchor"></a><code><span class="keyword">val</span> fold_left1 : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p>List must be non-empty. Otherwise, it raises <code>Invalid_argment &quot;fold_left1&quot;</code>.</p></dd></dl><dl><dt class="spec value" id="val-fold_right1"><a href="#val-fold_right1" class="anchor"></a><code><span class="keyword">val</span> fold_right1 : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p>List must be non-empty. Otherwise, it raises <code>Invalid_argment &quot;fold_left1&quot;</code>.</p></dd></dl><dl><dt class="spec value" id="val-concat_map"><a href="#val-concat_map" class="anchor"></a><code><span class="keyword">val</span> concat_map : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> list) <span>&#45;&gt;</span> <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'b</span> list</code></dt><dd><p><code>concat_map f xs = concat @@ map f xs</code> but much faster.</p></dd></dl><dl><dt class="spec value" id="val-rev_concat_map"><a href="#val-rev_concat_map" class="anchor"></a><code><span class="keyword">val</span> rev_concat_map : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> list) <span>&#45;&gt;</span> <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'b</span> list</code></dt><dd><p><code>concat_map f xs = rev @@ concat @@ map f xs</code> but much faster.</p></dd></dl><dl><dt class="spec value" id="val-map_accum_left"><a href="#val-map_accum_left" class="anchor"></a><code><span class="keyword">val</span> map_accum_left : (<span class="type-var">'acc</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'acc</span> * <span class="type-var">'b</span>) <span>&#45;&gt;</span> <span class="type-var">'acc</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'acc</span> * <span class="type-var">'b</span> list</code></dt><dd><p><code>mapAccumL f acc t</code> behaves like a combination of <code>map</code> and <code>fold_left</code>; it applies a function <code>f</code> to each element of a list <code>t</code>, passing an accumulating parameter <code>acc</code> from left to right, and returning a final value of this accumulator together with the new list.</p></dd></dl></section><section><header><h3 id="access"><a href="#access" class="anchor"></a>Access</h3></header><dl><dt class="spec value" id="val-last"><a href="#val-last" class="anchor"></a><code><span class="keyword">val</span> last : <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p>The last element of the list. Raises Failure when the argument is <code></code>. <code>last [1;2;3] = 3</code></p></dd></dl></section><section><header><h3 id="find-and-assoc"><a href="#find-and-assoc" class="anchor"></a>Find and assoc</h3></header><dl><dt class="spec value" id="val-find_opt"><a href="#val-find_opt" class="anchor"></a><code><span class="keyword">val</span> find_opt : (<span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'a</span> option</code></dt><dt class="spec value" id="val-find_map_opt"><a href="#val-find_map_opt" class="anchor"></a><code><span class="keyword">val</span> find_map_opt : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> option) <span>&#45;&gt;</span> <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'b</span> option</code></dt><dt class="spec value" id="val-remove_first_match"><a href="#val-remove_first_match" class="anchor"></a><code><span class="keyword">val</span> remove_first_match : (<span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'a</span> list</code></dt><dt class="spec value" id="val-assoc_all"><a href="#val-assoc_all" class="anchor"></a><code><span class="keyword">val</span> assoc_all : <span class="type-var">'a</span> <span>&#45;&gt;</span> (<span class="type-var">'a</span> * <span class="type-var">'b</span>) list <span>&#45;&gt;</span> <span class="type-var">'b</span> list</code></dt><dt class="spec value" id="val-assoc_opt"><a href="#val-assoc_opt" class="anchor"></a><code><span class="keyword">val</span> assoc_opt : <span class="type-var">'a</span> <span>&#45;&gt;</span> (<span class="type-var">'a</span> * <span class="type-var">'b</span>) list <span>&#45;&gt;</span> <span class="type-var">'b</span> option</code></dt><dt class="spec value" id="val-remove_assoc"><a href="#val-remove_assoc" class="anchor"></a><code><span class="keyword">val</span> remove_assoc : <span class="type-var">'a</span> <span>&#45;&gt;</span> (<span class="type-var">'a</span> * <span class="type-var">'b</span>) list <span>&#45;&gt;</span> (<span class="type-var">'a</span> * <span class="type-var">'b</span>) list</code></dt><dt class="spec value" id="val-remove_assq"><a href="#val-remove_assq" class="anchor"></a><code><span class="keyword">val</span> remove_assq : <span class="type-var">'a</span> <span>&#45;&gt;</span> (<span class="type-var">'a</span> * <span class="type-var">'b</span>) list <span>&#45;&gt;</span> (<span class="type-var">'a</span> * <span class="type-var">'b</span>) list</code></dt></dl></section><section><header><h3 id="sublist-by-index"><a href="#sublist-by-index" class="anchor"></a>Sublist by index</h3></header><dl><dt class="spec value" id="val-take"><a href="#val-take" class="anchor"></a><code><span class="keyword">val</span> take : int <span>&#45;&gt;</span> <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'a</span> list</code></dt><dt class="spec value" id="val-drop"><a href="#val-drop" class="anchor"></a><code><span class="keyword">val</span> drop : int <span>&#45;&gt;</span> <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'a</span> list</code></dt><dt class="spec value" id="val-sub_default"><a href="#val-sub_default" class="anchor"></a><code><span class="keyword">val</span> sub_default : <span class="type-var">'a</span> list <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <span class="type-var">'a</span> list</code></dt><dd><p><code>sub_default t pos len</code> returns a sublist of <code>t</code> from the position <code>pos</code> (0-start) and length <code>len</code>.</p><p>The region specified by <code>pos</code> and <code>len</code> is trimmed by <code>t</code>: if it exceeds the size of <code>t</code>, it is intersected with the region from <code>0</code> and length <code>List.length t</code>. One tricky example is:</p><p><code>sub_default [0;1;2;3;4;5] (-1)   3  = [0;1]</code></p></dd></dl><dl><dt class="spec value" id="val-take_exn"><a href="#val-take_exn" class="anchor"></a><code><span class="keyword">val</span> take_exn : int <span>&#45;&gt;</span> <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'a</span> list</code></dt><dt class="spec value" id="val-drop_exn"><a href="#val-drop_exn" class="anchor"></a><code><span class="keyword">val</span> drop_exn : int <span>&#45;&gt;</span> <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'a</span> list</code></dt><dt class="spec value" id="val-sub"><a href="#val-sub" class="anchor"></a><code><span class="keyword">val</span> sub : <span class="type-var">'a</span> list <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <span class="type-var">'a</span> list</code></dt><dt class="spec value" id="val-split_at"><a href="#val-split_at" class="anchor"></a><code><span class="keyword">val</span> split_at : int <span>&#45;&gt;</span> <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'a</span> list * <span class="type-var">'a</span> list</code></dt><dd><p>Haskell's <code>splitAt</code>. Always succeeds.</p></dd></dl><dl><dt class="spec value" id="val-splits_by"><a href="#val-splits_by" class="anchor"></a><code><span class="keyword">val</span> splits_by : int <span>&#45;&gt;</span> <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'a</span> list list</code></dt><dd><p>Split a list into sub-lists of the fixed length</p></dd></dl></section><section><header><h3 id="sublist-by-predicate"><a href="#sublist-by-predicate" class="anchor"></a>Sublist by predicate</h3></header><dl><dt class="spec value" id="val-filter_map"><a href="#val-filter_map" class="anchor"></a><code><span class="keyword">val</span> filter_map : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> option) <span>&#45;&gt;</span> <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'b</span> list</code></dt><dt class="spec value" id="val-rev_filter_map"><a href="#val-rev_filter_map" class="anchor"></a><code><span class="keyword">val</span> rev_filter_map : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> option) <span>&#45;&gt;</span> <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'b</span> list</code></dt><dt class="spec value" id="val-span"><a href="#val-span" class="anchor"></a><code><span class="keyword">val</span> span : (<span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'a</span> list * <span class="type-var">'a</span> list</code></dt><dd><p><code>span p xs</code> extract the longest prefix of <code>xs</code> whose elements satisfy <code>p</code>.</p></dd></dl><dl><dt class="spec value" id="val-partition_map"><a href="#val-partition_map" class="anchor"></a><code><span class="keyword">val</span> partition_map : (<span class="type-var">'a</span> <span>&#45;&gt;</span> [&lt; `Left of <span class="type-var">'left</span> | `Right of <span class="type-var">'right</span> ]) <span>&#45;&gt;</span> <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'left</span> list * <span class="type-var">'right</span> list</code></dt></dl></section><section><header><h3 id="sort-and-uniq"><a href="#sort-and-uniq" class="anchor"></a>Sort and uniq</h3></header><dl><dt class="spec value" id="val-uniq_dup"><a href="#val-uniq_dup" class="anchor"></a><code><span class="keyword">val</span> uniq_dup : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'a</span> list * (<span class="type-var">'a</span> * <span class="type-var">'a</span>) list</code></dt><dd><p>Filter out duplicate elements using the given equality. The first result list is the list of first unique occurrences, the second result list is the rest, the duplications removed from the first result list, paired with the corresponding element of the first result list.</p><p>O(n^2).</p></dd></dl><dl><dt class="spec value" id="val-uniq_dup_sorted"><a href="#val-uniq_dup_sorted" class="anchor"></a><code><span class="keyword">val</span> uniq_dup_sorted : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> int) <span>&#45;&gt;</span> <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'a</span> list * (<span class="type-var">'a</span> * <span class="type-var">'a</span>) list</code></dt><dd><p>Same as <code>uniq_dup</code> but only works for already sorted by the same ordering. O(n log n)</p></dd></dl><dl><dt class="spec value" id="val-unique"><a href="#val-unique" class="anchor"></a><code><span class="keyword">val</span> unique : <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'a</span> list</code></dt><dd><p>Haskell's nub. O(n^2)</p></dd></dl><dl><dt class="spec value" id="val-unique_by"><a href="#val-unique_by" class="anchor"></a><code><span class="keyword">val</span> unique_by : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'a</span> list</code></dt><dt class="spec value" id="val-has_dup"><a href="#val-has_dup" class="anchor"></a><code><span class="keyword">val</span> has_dup : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <span class="type-var">'a</span> list <span>&#45;&gt;</span> (<span class="type-var">'a</span> * <span class="type-var">'a</span>) option</code></dt><dd><p>Check the list is a unique list or not, wrt the equality function. If not, it returns a dupe example.</p><p><code>has_dup (fun x y -&gt; fst x = fst y) [(1,2); (2,3); (4,5)] = None</code> <code>has_dup (fun x y -&gt; fst x = fst y) [(1,2); (2,3); (2,5)] = Some ( (2,3), (2,5) ) </code></p><p>O(n^2)</p></dd></dl><dl><dt class="spec value" id="val-group"><a href="#val-group" class="anchor"></a><code><span class="keyword">val</span> group : <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'a</span> list list</code></dt><dd><p><code>group xs</code> returns a list of lists such that the concatenation of the result is equal to the argument. Moreover, each sublist in the result contains only equal elements:</p><p><code> group ['M'; 'i'; 's'; 's'; 'i'; 's'; 's'; 'i'; 'p'; 'p'; 'i'] = [['M'],['i'],['s';'s'];['i'];['s';'s'];['i'];['p';'p'];['i']] </code></p><p>Haskell's <code>group</code>.</p></dd></dl><dl><dt class="spec value" id="val-group_by"><a href="#val-group_by" class="anchor"></a><code><span class="keyword">val</span> group_by : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'a</span> list list</code></dt><dd><p>Same as <code>group</code> but equality can be given. Haskell's <code>groupBy</code></p></dd></dl><dl><dt class="spec value" id="val-sort_then_group_by"><a href="#val-sort_then_group_by" class="anchor"></a><code><span class="keyword">val</span> sort_then_group_by : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> int) <span>&#45;&gt;</span> <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'a</span> list list</code></dt><dd><p><code>sort</code> then <code>group_by</code></p></dd></dl></section><section><header><h3 id="composition"><a href="#composition" class="anchor"></a>Composition</h3></header><dl><dt class="spec value" id="val-zip"><a href="#val-zip" class="anchor"></a><code><span class="keyword">val</span> zip : <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'b</span> list <span>&#45;&gt;</span> (<span class="type-var">'a</span> * <span class="type-var">'b</span>) list</code></dt><dd><p>Haskell's zip. Like List.combine but does not raise when the lengths are not equal. Tail recursive.</p></dd></dl></section><section><header><h3 id="with-reference"><a href="#with-reference" class="anchor"></a>With reference</h3></header><dl><dt class="spec value" id="val-accum"><a href="#val-accum" class="anchor"></a><code><span class="keyword">val</span> accum : <span class="type-var">'a</span> list <a href="../../ocaml/Stdlib/index.html#type-ref">Stdlib.ref</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>accum xsref x</code> is equivalent with <code>xsref := x :: !xsref</code></p></dd></dl><dl><dt class="spec value" id="val-(+::=)"><a href="#val-(+::=)" class="anchor"></a><code><span class="keyword">val</span> (+::=) : <span class="type-var">'a</span> list <a href="../../ocaml/Stdlib/index.html#type-ref">Stdlib.ref</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> unit</code></dt><dd><p>Same as <code>accum</code></p></dd></dl></section><section><header><h3 id="integer-ranges"><a href="#integer-ranges" class="anchor"></a>Integer ranges</h3></header><dl><dt class="spec value" id="val-from_to"><a href="#val-from_to" class="anchor"></a><code><span class="keyword">val</span> from_to : int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int list</code></dt><dd><p><code>from_to f t = [f..t]</code></p></dd></dl><dl><dt class="spec value" id="val-(--)"><a href="#val-(--)" class="anchor"></a><code><span class="keyword">val</span> (--) : int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int list</code></dt><dd><p>Same as from_to. <code>f--t = [f..t]</code></p></dd></dl><dl><dt class="spec value" id="val-init_from_to"><a href="#val-init_from_to" class="anchor"></a><code><span class="keyword">val</span> init_from_to : int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> (int <span>&#45;&gt;</span> <span class="type-var">'a</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span> list</code></dt><dd><p><code>init_from_to f t fn = [fn x | x &lt;- [f..t] ]</code></p></dd></dl></section><section><header><h3 id="misc"><a href="#misc" class="anchor"></a>Misc</h3></header><dl><dt class="spec value" id="val-intersperse"><a href="#val-intersperse" class="anchor"></a><code><span class="keyword">val</span> intersperse : <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'a</span> list</code></dt><dt class="spec value" id="val-sum"><a href="#val-sum" class="anchor"></a><code><span class="keyword">val</span> sum : int list <span>&#45;&gt;</span> int</code></dt></dl></section><section><header><h3 id="modules"><a href="#modules" class="anchor"></a>Modules</h3></header><div class="spec module" id="module-Infix"><a href="#module-Infix" class="anchor"></a><code><span class="keyword">module</span> <a href="Infix/index.html">Infix</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><div class="spec module" id="module-Pervasives"><a href="#module-Pervasives" class="anchor"></a><code><span class="keyword">module</span> <a href="Pervasives/index.html">Pervasives</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div></section><section><header><h3 id="non-tail-recursive-versions"><a href="#non-tail-recursive-versions" class="anchor"></a>Non tail recursive versions</h3><p>These non tail recursive versions are from stdlib.</p></header><dl><dt class="spec value" id="val-(@.)"><a href="#val-(@.)" class="anchor"></a><code><span class="keyword">val</span> (@.) : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Non tail recursive version of <code>(@)</code></p></dd></dl><dl><dt class="spec value" id="val-append_ntr"><a href="#val-append_ntr" class="anchor"></a><code><span class="keyword">val</span> append_ntr : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-concat_ntr"><a href="#val-concat_ntr" class="anchor"></a><code><span class="keyword">val</span> concat_ntr : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-flatten_ntr"><a href="#val-flatten_ntr" class="anchor"></a><code><span class="keyword">val</span> flatten_ntr : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-map_ntr"><a href="#val-map_ntr" class="anchor"></a><code><span class="keyword">val</span> map_ntr : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-mapi_ntr"><a href="#val-mapi_ntr" class="anchor"></a><code><span class="keyword">val</span> mapi_ntr : (int <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-fold_right_ntr"><a href="#val-fold_right_ntr" class="anchor"></a><code><span class="keyword">val</span> fold_right_ntr : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'b</span></code></dt><dt class="spec value" id="val-map2_ntr"><a href="#val-map2_ntr" class="anchor"></a><code><span class="keyword">val</span> map2_ntr : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'c</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'b</span> list <span>&#45;&gt;</span> <span class="type-var">'c</span> list</code></dt><dt class="spec value" id="val-fold_right2_ntr"><a href="#val-fold_right2_ntr" class="anchor"></a><code><span class="keyword">val</span> fold_right2_ntr : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'c</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'c</span> list <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'b</span></code></dt><dt class="spec value" id="val-remove_assoc_ntr"><a href="#val-remove_assoc_ntr" class="anchor"></a><code><span class="keyword">val</span> remove_assoc_ntr : <span class="type-var">'a</span> <span>&#45;&gt;</span> (<span class="type-var">'a</span> * <span class="type-var">'b</span>) list <span>&#45;&gt;</span> (<span class="type-var">'a</span> * <span class="type-var">'b</span>) list</code></dt><dt class="spec value" id="val-remove_assq_ntr"><a href="#val-remove_assq_ntr" class="anchor"></a><code><span class="keyword">val</span> remove_assq_ntr : <span class="type-var">'a</span> <span>&#45;&gt;</span> (<span class="type-var">'a</span> * <span class="type-var">'b</span>) list <span>&#45;&gt;</span> (<span class="type-var">'a</span> * <span class="type-var">'b</span>) list</code></dt><dt class="spec value" id="val-split_ntr"><a href="#val-split_ntr" class="anchor"></a><code><span class="keyword">val</span> split_ntr : (<span class="type-var">'a</span> * <span class="type-var">'b</span>) list <span>&#45;&gt;</span> <span class="type-var">'a</span> list * <span class="type-var">'b</span> list</code></dt><dt class="spec value" id="val-combine_ntr"><a href="#val-combine_ntr" class="anchor"></a><code><span class="keyword">val</span> combine_ntr : <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'b</span> list <span>&#45;&gt;</span> (<span class="type-var">'a</span> * <span class="type-var">'b</span>) list</code></dt><dt class="spec value" id="val-merge_ntr"><a href="#val-merge_ntr" class="anchor"></a><code><span class="keyword">val</span> merge_ntr : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> int) <span>&#45;&gt;</span> <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'a</span> list</code></dt></dl></section><section><header><h3 id="deprecated"><a href="#deprecated" class="anchor"></a>Deprecated</h3></header><dl><dt class="spec value" id="val-iter_until"><a href="#val-iter_until" class="anchor"></a><code><span class="keyword">val</span> iter_until : (<span class="type-var">'a</span> <span>&#45;&gt;</span> [ `Break of <span class="type-var">'b</span> | `Continue ]) <span>&#45;&gt;</span> <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'b</span> option</code></dt><dt class="spec value" id="val-scani_left"><a href="#val-scani_left" class="anchor"></a><code><span class="keyword">val</span> scani_left : (int <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> [&lt; `Continue of <span class="type-var">'a</span> | `Stop of <span class="type-var">'a</span> ]) <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> list <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dt class="spec value" id="val-is_unique"><a href="#val-is_unique" class="anchor"></a><code><span class="keyword">val</span> is_unique : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span> list <span>&#45;&gt;</span> (<span class="type-var">'a</span> * <span class="type-var">'a</span>) option</code></dt><dd><p>Check the list is a unique list or not, wrt the key function. If not, it returns a dupe example.</p><p><code>is_unique fst [(1,2); (2,3); (4,5)] = None</code> <code>is_unique fst [(1,2); (2,3); (2,5)] = Some ( (2,3), (2,5) ) </code></p></dd></dl><dl><dt class="spec value" id="val-sort_then_group"><a href="#val-sort_then_group" class="anchor"></a><code><span class="keyword">val</span> sort_then_group : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> int) <span>&#45;&gt;</span> <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'a</span> list list</code></dt></dl></section></div></body></html>