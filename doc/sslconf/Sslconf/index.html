<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Sslconf (sslconf.Sslconf)</title><link rel="stylesheet" href="../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../index.html">sslconf</a> &#x00BB; Sslconf</nav><h1>Module <code>Sslconf</code></h1><p>an OCaml version of Openssl's NCONF library</p><p>Version <em>0.8.3</em> — <a href="https://github.com/awuersch/sslconf">homepage</a></p><nav class="toc"><ul><li><a href="#parser-overview">Parser Overview</a></li><li><a href="#first-pass---line-recognition">First Pass - Line Recognition</a><ul><li><a href="#bounded-reads-and-continuation-chars">Bounded Reads and Continuation Chars</a></li></ul></li><li><a href="#second-pass---configuration-recognition">Second Pass - Configuration Recognition</a><ul><li><a href="#error-reporting---line-and-column-numbers">Error reporting - line and column numbers</a></li></ul></li><li><a href="#comment-lines">Comment lines</a></li><li><a href="#section-lines">Section lines</a></li><li><a href="#value-lines">Value lines</a><ul><li><a href="#names">Names</a></li><li><a href="#values">Values</a><ul><li><a href="#quote-wrapped-parts">Quote wrapped parts</a></li><li><a href="#name-substitution">Name substitution</a></li><li><a href="#regular-value-text,-i.e.,-unwrapped-parts">Regular value text, i.e., unwrapped parts</a><ul><li><a href="#escaped-chars-in-regular-text">Escaped chars in regular text</a></li><li><a href="#hash-chars-in-regular-text-start-comments-to-end-of-line">Hash chars in regular text start comments to end of line</a></li><li><a href="#non-special-chars-in-regular-text">Non-special chars in regular text</a></li></ul></li></ul></li></ul></li></ul></nav></header><aside><p>Module <code>Sslconf</code>: a parser for Openssl config files.</p><p>Openssl config file documentation: <a href="https://www.openssl.org/docs/manmaster/man5/config.html">config.html</a></p></aside><aside><p>Openssl config files are ubiquitous in books, in documentation, and in Stack Overflow answers.</p><p>Definition of X509 certificates in Openssl is usually done by Openssl config files.</p><p>This module reproduces the Openssl NCONF implementation. Openssl NCONF is part of the Openssl crypto library (-libcrypto).</p><p>This module attaches no semantics to the strings and stacks it returns. It is similar to Openssl NCONF in this way.</p><p>Openssl attaches semantics to the CONF data structure returned by Openssl NCONF, <em>via</em> commands such as <em>openssl x509</em> or <em>openssl ca</em>.</p><p>This implementation is backed by standard OCaml hash tables and stacks. Some may view this as a weakness. Openssl's NCONF implementation draws on custom hash tables and stacks defined in Openssl's crypto library.</p><p>Openssl code: <a href="https://github.com/openssl/openssl/blob/master/include/openssl/conf.h">conf.h</a> <a href="https://github.com/openssl/openssl/blob/master/crypto/conf/conf_def.c">conf_def.c</a> <a href="https://github.com/openssl/openssl/blob/master/crypto/conf/conf_api.c">conf_api.c</a> <a href="https://github.com/openssl/openssl/blob/master/crypto/conf/conf_lib.c">conf_lib.c</a> <a href="https://github.com/openssl/openssl/blob/master/crypto/bio/bss_fd.c">bss_fd.c</a></p></aside><section><header><h2 id="parser-overview"><a href="#parser-overview" class="anchor"></a>Parser Overview</h2><p>Lines recognized by the parser are:</p><ul><li><p>comment lines, i.e.,</p><ul><li>empty, or all whitespace;</li><li>(Win32 only) a semicolon (<code>';'</code>) before non-white-space; or</li><li>whitespace, then a hash char (<code>'#'</code>), then arbitrary data;</li></ul></li><li><p>section lines, i.e.,</p><ul><li>a (<code>&quot;[&lt;section&gt;]&quot;</code>) string inside square brackets; or</li></ul></li><li><p>value lines, i.e.,</p><ul><li>a (<code>&quot;&lt;name&gt; = &lt;value&gt;&quot;</code>) assignment.</li></ul></li></ul><p>Openssl config file documentation: <a href="https://www.openssl.org/docs/manmaster/man5/config.html">config.html</a></p><p>The Openssl config file documentation is enough for most users, but is not a complete specification.</p><p>What follows is detail for maintainers.</p></header></section><section><header><h2 id="first-pass---line-recognition"><a href="#first-pass---line-recognition" class="anchor"></a>First Pass - Line Recognition</h2><p>If the parser sees an escape char (<code>'\\'</code>) at the end of a line, it combines the line with the next line.</p><p>The escape char may itself be escaped. If escaped, the escape char loses its special meaning as a line continuation mark.</p></header><section><header><h3 id="bounded-reads-and-continuation-chars"><a href="#bounded-reads-and-continuation-chars" class="anchor"></a>Bounded Reads and Continuation Chars</h3><p>The parser reads up to a newline, or a maximum length if no newline is found. If no newline is found, the parser does another read, and so on, until a newline is found or end of file is is detected.</p><p>The max number of characters the parser reads in one read is 510. This number is dictated by a need for C code to put null bytes in a 512 byte buffer.</p><p>This implementation follows the 510 char rule. A config file valid in Openssl will still be valid here.</p><p>If the parser sees an escape char (<code>'\\'</code>) at the end of a read, i.e., as the 510th character, it will apply line continuation logic -- even if a newline is not seen at the end.</p><p>Both newlines and line continuation characters are removed from the strings passed to the parser in its second pass.</p></header></section></section><section><header><h2 id="second-pass---configuration-recognition"><a href="#second-pass---configuration-recognition" class="anchor"></a>Second Pass - Configuration Recognition</h2></header><section><header><h3 id="error-reporting---line-and-column-numbers"><a href="#error-reporting---line-and-column-numbers" class="anchor"></a>Error reporting - line and column numbers</h3><p>Error reporting reports line and column numbers. Line numbers are relative to the file being read.</p><p>The first line is line 1. The first column is column 1.</p></header></section></section><section><header><h2 id="comment-lines"><a href="#comment-lines" class="anchor"></a>Comment lines</h2><p>A comment line is either an empty line, a line of all whitespace, or whitespace followed by a hash char.</p><p>In Win32 only, a line starting with a semicolon is also a comment.</p><p>Comment lines are ignored and not saved.</p><p>The end of a value line may have a comment. Value line comments start with a hash char. Any text up to end of line can follow the hash char.</p></header></section><section><header><h2 id="section-lines"><a href="#section-lines" class="anchor"></a>Section lines</h2><p>A section line has a (<code>&quot;[&lt;section&gt;]&quot;</code>) string surrounded by square brackets. The string names a section.</p><p>Whitespace is trimmed from both ends of the string.</p><p>A section may contain alphanumerics, underscores, punctuation, or whitespace.</p><p>Alphanumerics are any letter (from <code>'a'</code> to <code>z</code> or <code>'A'</code> to <code>'Z'</code>) or a number (from <code>'0'</code> to <code>'9'</code>).</p><p>Underscores are one or more underscore ('_') characters.</p><p>Punctuation is one or more of the following characters: (<code>'!'</code>, <code>'.'</code>, <code>'%'</code>, <code>'&amp;'</code>, <code>'*'</code>, <code>'+'</code>, <code>';'</code>, <code>'?'</code>, <code>'@'</code>, <code>'^'</code>, <code>'~'</code>, <code>'|'</code>, or <code>'-'</code>).</p><p>A section may also contain <em>escaped</em> characters. An escaped character immediately follows an escape (<code>'\\'</code>) char. Any character may be an escaped character.</p><p>If an escaped character is (<code>'r'</code>, <code>'n'</code>, <code>'b'</code>, or <code>'t'</code>), it is translated into a whitespace char (<code>&quot;\r&quot;, &quot;\n&quot;, &quot;\b&quot;, or &quot;\t&quot;</code>). Otherwise, it is retained <em>as is</em>.</p><p>Escape chars are stripped out from a section. Escaped chars therefore appear in section names as if they were not escaped.</p><p>The section named in a section line becomes the default section for lines which follow. It remains the default until a new section line is read.</p></header></section><section><header><h2 id="value-lines"><a href="#value-lines" class="anchor"></a>Value lines</h2><p>A line with a (<code>&quot;&lt;name&gt; = &lt;value&gt;&quot;</code>) assignment is a value line. A value line always has a name, an equal sign, and a value. Whitespace before or after the equal sign is optional.</p><p>A value line assigns a value to a name in a section.</p></header><section><header><h3 id="names"><a href="#names" class="anchor"></a>Names</h3><p>Lexical rules for a name (qualified or unqualified) are more restrictive than for a section in a section line.</p><p>Whitespace is trimmed from both ends of a name.</p><p>A name may contain alphanumerics, underscores, and punctuation. A name may not contain whitespace.</p><p>As with section names, escaped characters are allowed. An escaped character immediately follows an escape (<code>'\\'</code>) char. Any character may be an escaped character.</p><p>Unlike with section names, escape chars are not stripped. An escape char goes in the hash table as part of a name.</p><p>A name can be qualified or unqualified.</p><p>A qualified name splits into two parts, separated by a two-colon string (<code>&quot;::&quot;</code>). The first part of a qualified name is the section. The second part is the name.</p><p>If the section of a qualified name is not in the hash table, a new entry for the section is added.</p><p>An unqualified name belongs to the default section. The default section is the section named by the most recent previous section line, or &quot;default&quot; if no section line has occured yet.</p></header></section><section><header><h3 id="values"><a href="#values" class="anchor"></a>Values</h3><p>A value is a sequence of parts, starting with the first non-whitespace character after the equal sign on a value line.</p><p>A part is one of three kinds:</p><ul><li>wrapped by double or single quotes;</li><li>a name substitution; or</li><li>regular text.</li></ul><p>Whitespace is stripped from the start and end of a value. Whitespace following the equal sign, and whitespace, either to the end of a line, or up to a comment hash char if present, is ignored.</p></header><section><header><h4 id="quote-wrapped-parts"><a href="#quote-wrapped-parts" class="anchor"></a>Quote wrapped parts</h4><p>Unix and Cygwin use default quote wrapping.</p><p>Default quote wrapped parts accept any character <em>as is</em>, and also allow quotes if preceded immediately by escape chars.</p><p>Escape chars and the quotes which wrap surrounded parts are stripped.</p><p>Win32 uses double quote wrapping. Double quote wrapped parts accept any character <em>as is</em>, unless it is a double quote. There is one exception. A double quote may appear inside a double quote wrapped string, if a double quote immediately precedes it.</p><p>Wrapping double quotes, and double quotes which immediately precede double quotes, are stripped.</p></header></section><section><header><h4 id="name-substitution"><a href="#name-substitution" class="anchor"></a>Name substitution</h4><p>Name substitution starts with a (<code>'$'</code>) character. The (<code>'$'</code>) character should be followed by a name. The name may be optionally wrapped by parentheses (<code>&quot;()&quot;</code>) or curly brackets (<code>&quot;{}&quot;</code>). The <code>subst</code> evaluator replaces the (<code>'$'</code>), the optional wrapping, and the name with the value corresponding to the name and its section.</p><p>If the section is not (<code>&quot;ENV&quot;</code>), a value is found from a hashtable with section+name keys. If the section is (<code>&quot;ENV&quot;</code>), a value is found from the process environment.</p><p>If substitution fails, the parser returns an error, reporting that no value could be found for the name.</p><p>A name given for name substitution may only contain alphanumeric or underscore characters. It may not contain punctuation or whitespace, unless these are escaped <em>via</em> an escape (<code>'\\'</code>) character. If an escaped character is in a name, its escape char is <em>retained</em>, along with the escaped character in the name.</p></header></section><section><header><h4 id="regular-value-text,-i.e.,-unwrapped-parts"><a href="#regular-value-text,-i.e.,-unwrapped-parts" class="anchor"></a>Regular value text, i.e., unwrapped parts</h4><p>Regular text accepts any character other than single quotes, double quotes, or the (<code>'$'</code>) substitution character.</p><p>It may still have</p><ul><li>escaped characters; or</li><li>hash chars, for comments to end of line.</li></ul></header><section><header><h5 id="escaped-chars-in-regular-text"><a href="#escaped-chars-in-regular-text" class="anchor"></a>Escaped chars in regular text</h5><p>Regular text can have escaped characters. An escaped character immediately follows an escape (<code>'\\'</code>) char.</p><p>If an escaped character is (<code>'r'</code>, <code>'n'</code>, <code>'b'</code>, or <code>'t'</code>), it is translated into a whitespace char (<code>&quot;\r&quot;, &quot;\n&quot;, &quot;\b&quot;, or &quot;\t&quot;</code>). If it is not one of these characters, it is retained <em>as is</em>.</p><p>The special meanings of escaped characters are cancelled. For example, one can precede a double quote by an escape char, to cancel its usual meaning of starting a quote-wrapped part.</p><p>Escape chars are stripped. They don't appear in hash table values. Escaped characters remain.</p></header></section><section><header><h5 id="hash-chars-in-regular-text-start-comments-to-end-of-line"><a href="#hash-chars-in-regular-text-start-comments-to-end-of-line" class="anchor"></a>Hash chars in regular text start comments to end of line</h5><p>An unescaped hash (<code>'#'</code>) char starts a comment to end of line. Any data following the hash char, up to the end of a line, is ignored.</p></header></section><section><header><h5 id="non-special-chars-in-regular-text"><a href="#non-special-chars-in-regular-text" class="anchor"></a>Non-special chars in regular text</h5><p>Characters not belonging to wrapped segments or name substitutions can be any character. For example, whitespace can occur in the middle of a value.</p></header><div class="spec module" id="module-Buf"><a href="#module-Buf" class="anchor"></a><code><span class="keyword">module</span> <a href="Buf/index.html">Buf</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><div class="spec module" id="module-Bio"><a href="#module-Bio" class="anchor"></a><code><span class="keyword">module</span> <a href="Bio/index.html">Bio</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> t</code></dt><dd><p>Sslconf type</p></dd></dl><dl><dt class="spec value" id="val-create"><a href="#val-create" class="anchor"></a><code><span class="keyword">val</span> create : unit <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Initialize an Sslconf instance</p></dd></dl><dl><dt class="spec value" id="val-nbits"><a href="#val-nbits" class="anchor"></a><code><span class="keyword">val</span> nbits : int option <a href="../../ocaml/Stdlib/index.html#type-ref">Stdlib.ref</a></code></dt><dd><p><code>FOR TESTING ONLY</code> Limits buffer allocated memory to a max bit length.</p></dd></dl><dl><dt class="spec type" id="type-error"><a href="#type-error" class="anchor"></a><code><span class="keyword">type</span> error</code><code> = </code><table class="variant"><tr id="type-error.Open" class="anchored"><td class="def constructor"><a href="#type-error.Open" class="anchor"></a><code>| </code><code><span class="constructor">Open</span> <span class="keyword">of</span> string</code></td></tr><tr id="type-error.Extend" class="anchored"><td class="def constructor"><a href="#type-error.Extend" class="anchor"></a><code>| </code><code><span class="constructor">Extend</span> <span class="keyword">of</span> string * int * int * int</code></td></tr><tr id="type-error.Parse" class="anchored"><td class="def constructor"><a href="#type-error.Parse" class="anchor"></a><code>| </code><code><span class="constructor">Parse</span> <span class="keyword">of</span> string * int * int * string * string</code></td><td class="doc"><p>Open (msg):</p><ul><li>open failure message</li></ul><p>Extend (msg nbits max_length max_alloc):</p><ul><li>failure message;</li><li>number of bits allowed in buffer size;</li><li>requested new length of buffer;</li><li>allocation limit of buffer size.</li></ul><p>Parse (file lineno col proc msg):</p><ul><li>file name;</li><li>line number where error was seen;</li><li>column position where error was seen;</li><li>procedure name in which error was seen;</li><li>error message.</li></ul></td></tr></table></dt></dl><dl><dt class="spec value" id="val-string_of_error"><a href="#val-string_of_error" class="anchor"></a><code><span class="keyword">val</span> string_of_error : <a href="index.html#type-error">error</a> <span>&#45;&gt;</span> string</code></dt><dd><p><code>string_of_error error</code> converts an error to a user-readable string.</p></dd></dl><dl><dt class="spec value" id="val-conf_load_file"><a href="#val-conf_load_file" class="anchor"></a><code><span class="keyword">val</span> conf_load_file : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> (unit, <a href="index.html#type-error">error</a>) <a href="../../rresult/Rresult/index.html#type-result">Rresult.result</a></code></dt><dd><p><code>conf_load_file conf filename</code> loads a file into a <a href="index.html#type-t"><code>t</code></a> instance. The error instance describes only the first failure found.</p></dd></dl><dl><dt class="spec value" id="val-conf_get_value"><a href="#val-conf_get_value" class="anchor"></a><code><span class="keyword">val</span> conf_get_value : ?&#8288;conf:<a href="index.html#type-t">t</a> <span>&#45;&gt;</span> ?&#8288;section:string <span>&#45;&gt;</span> string <span>&#45;&gt;</span> string option</code></dt><dd><p><code>conf_get_value ?conf ?section name</code> gets an optional value from a name. A string option is returned.</p><p>See Openssl <code>NCONF_get_string()</code> in <a href="https://github.com/openssl/openssl/blob/master/crypto/conf/conf_lib.c">conf_lib.c</a>. If a config instance is provided, its hash table with section+name keys is searched. If no config instance is provided, the process environment is searched. If a section is provided, then:</p><ul><li>if the section is <code>&quot;ENV&quot;</code>, the process environment is searched.</li><li>else the section and name are made into a pair, and the pair is searched for in the hash table.</li></ul><p>If no section is provided, or the search in a provided section fails, then section &quot;default&quot; is used with the name.</p></dd></dl><dl><dt class="spec type" id="type-stack"><a href="#type-stack" class="anchor"></a><code><span class="keyword">type</span> stack</code><code> = (string * string) <a href="../../ocaml/Stdlib/Stack/index.html#type-t">Stdlib.Stack.t</a></code></dt><dd><p>A stack with (name, value) entries.</p></dd></dl><dl><dt class="spec value" id="val-conf_get_section"><a href="#val-conf_get_section" class="anchor"></a><code><span class="keyword">val</span> conf_get_section : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <a href="index.html#type-stack">stack</a> option</code></dt><dd><p><code>conf_get_section conf section</code> gets an optional stack of name-value pairs.</p><p>See Openssl function <code>NCONF_get_section()</code> in <a href="https://github.com/openssl/openssl/blob/master/crypto/conf/conf_lib.c">conf_lib.c</a>. A hash table with section names in the config instance is searched for a section. If a stack is returned, and &lt;name&gt; is in a name-value pair on it, then <code>conf_get_value conf section name</code> will get its most recent value.</p></dd></dl><dl><dt class="spec value" id="val-sexp_of_stack"><a href="#val-sexp_of_stack" class="anchor"></a><code><span class="keyword">val</span> sexp_of_stack : <a href="index.html#type-stack">stack</a> <span>&#45;&gt;</span> <a href="../../sexplib/Sexplib/Sexp/index.html#type-t">Sexplib.Sexp.t</a></code></dt><dd><p><code>sexp_of_stack conf section</code> converts a config instance section stack to an s-expression</p></dd></dl><dl><dt class="spec value" id="val-stack_of_sexp"><a href="#val-stack_of_sexp" class="anchor"></a><code><span class="keyword">val</span> stack_of_sexp : <a href="../../sexplib/Sexplib/Sexp/index.html#type-t">Sexplib.Sexp.t</a> <span>&#45;&gt;</span> <a href="index.html#type-stack">stack</a></code></dt><dd><p><code>stack_of_sexp sexp</code> converts an s-expression to a config instance section stack</p></dd></dl><dl><dt class="spec value" id="val-sexp_of_conf"><a href="#val-sexp_of_conf" class="anchor"></a><code><span class="keyword">val</span> sexp_of_conf : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../../sexplib/Sexplib/Sexp/index.html#type-t">Sexplib.Sexp.t</a></code></dt><dd><p><code>sexp_of_conf conf</code> converts a config instance to an s-expression</p></dd></dl><dl><dt class="spec value" id="val-conf_of_sexp"><a href="#val-conf_of_sexp" class="anchor"></a><code><span class="keyword">val</span> conf_of_sexp : <a href="../../sexplib/Sexplib/Sexp/index.html#type-t">Sexplib.Sexp.t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>conf_of_sexp sexp</code> converts an s-expression to a config instance</p></dd></dl></section></section></section></section></div></body></html>