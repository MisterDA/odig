<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Diagram (tdk.S.Diagram)</title><link rel="stylesheet" href="../../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../../index.html">tdk</a> &#x00BB; <a href="../index.html">S</a> &#x00BB; Diagram</nav><h1>Module type <code>S.Diagram</code></h1><p>The signature of a decision diagram</p></header><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> t</code></dt><dd><p>The type of a decision diagram</p></dd></dl><dl><dt class="spec type" id="type-v"><a href="#type-v" class="anchor"></a><code><span class="keyword">type</span> v</code></dt><dd><p>The type of a variable in the decision diagram.</p></dd></dl><dl><dt class="spec type" id="type-r"><a href="#type-r" class="anchor"></a><code><span class="keyword">type</span> r</code></dt><dd><p>The type of a variable in the decision diagram.</p><p>The type of the result of a decision diagram</p></dd></dl><dl><dt class="spec value" id="val-const"><a href="#val-const" class="anchor"></a><code><span class="keyword">val</span> const : <a href="index.html#type-r">r</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>const r</code> creates a constant diagram out of <code>r</code>.</p></dd></dl><dl><dt class="spec value" id="val-atom"><a href="#val-atom" class="anchor"></a><code><span class="keyword">val</span> atom : <a href="index.html#type-v">v</a> <span>&#45;&gt;</span> <a href="index.html#type-r">r</a> <span>&#45;&gt;</span> <a href="index.html#type-r">r</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>atom v t f</code> creates a diagram that checks the variable assignment <code>v</code> holds and returns the result <code>t</code> if it does hold, and the result <code>f</code> otherwise.</p></dd></dl><dl><dt class="spec value" id="val-restrict"><a href="#val-restrict" class="anchor"></a><code><span class="keyword">val</span> restrict : <a href="index.html#type-v">v</a> list <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>restrict vs t</code> returns a diagram derived from <code>t</code> and that agrees with <code>t</code> when every variable assignment <code>v</code> in <code>vs</code> is true. This will eliminate the variables in <code>vs</code> from the diagram, if present.</p><p>This function assumes that a variable will only appear once in the list of variable assignments. If the list assigns multiple values to a variable, then the behavior is unspecified.</p></dd></dl><dl><dt class="spec value" id="val-peek"><a href="#val-peek" class="anchor"></a><code><span class="keyword">val</span> peek : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-r">r</a> option</code></dt><dd><p><code>peek t</code> check if the diagram is a leaf node. If it is, it will return the value at the leaf, and <code>None</code> otherwise.</p><p><code>peek</code>, combined with <a href="index.html#val-restrict"><code>restrict</code></a> are useful when extracting information from a diagram. Through multiple applications of <code>restrict</code> the programmer can attempt to reduce the diagram to a value, and then use <code>peek</code> to extract that value.</p></dd></dl><dl><dt class="spec value" id="val-support"><a href="#val-support" class="anchor"></a><code><span class="keyword">val</span> support : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-v">v</a> list</code></dt><dd><p><code>support t</code> returns the list of variables that occur in the diagram.</p></dd></dl><dl><dt class="spec value" id="val-sum"><a href="#val-sum" class="anchor"></a><code><span class="keyword">val</span> sum : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>sum a b</code> returns the disjunction of the two diagrams. The <code>sum</code> operation on the <code>r</code> type is used to combine leaf nodes.</p></dd></dl><dl><dt class="spec value" id="val-prod"><a href="#val-prod" class="anchor"></a><code><span class="keyword">val</span> prod : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>prod a b</code> returns the conjunction of the two diagrams. The <code>prod</code> operation on the <code>r</code> type is used to combine leaf nodes.</p></dd></dl><dl><dt class="spec value" id="val-map_r"><a href="#val-map_r" class="anchor"></a><code><span class="keyword">val</span> map_r : (<a href="index.html#type-r">r</a> <span>&#45;&gt;</span> <a href="index.html#type-r">r</a>) <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>map_r f t</code> returns a diagram with the same structure but whose leaf nodes have been modified according the function <code>f</code>.</p><p>This function can be used as a general form of negation. For example, if the <code>r</code> type were <code>bool</code>, one could implement negation in the following way:</p><p><code>let neg = map_r (fun r -&gt; not r)</code></p></dd></dl><dl><dt class="spec value" id="val-fold"><a href="#val-fold" class="anchor"></a><code><span class="keyword">val</span> fold : (<a href="index.html#type-r">r</a> <span>&#45;&gt;</span> <span class="type-var">'a</span>) <span>&#45;&gt;</span> (<a href="index.html#type-v">v</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span>) <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p><code>fold f g t</code> traverses the diagram, replacing leaf nodes with applications of <code>f</code> to the values that they hold, and branches on variables with applications of <code>g</code>.</p></dd></dl><dl><dt class="spec value" id="val-destruct"><a href="#val-destruct" class="anchor"></a><code><span class="keyword">val</span> destruct : (<a href="index.html#type-r">r</a> <span>&#45;&gt;</span> <span class="type-var">'a</span>) <span>&#45;&gt;</span> (<a href="index.html#type-v">v</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span>) <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p><code>destruct f g t</code> decomposes the top node of the diagram. <code>f</code> will be called if the diagram is a constant leaf node. Otherwise, <code>g</code> will be called with the decision variable, followed by the true branch, and the false branch of the diagram, respectively.</p></dd></dl><dl><dt class="spec value" id="val-iter"><a href="#val-iter" class="anchor"></a><code><span class="keyword">val</span> iter : ?&#8288;order:[ `Pre | `Post ] <span>&#45;&gt;</span> (<a href="index.html#type-r">r</a> <span>&#45;&gt;</span> unit) <span>&#45;&gt;</span> (<a href="index.html#type-v">v</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit) <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>iter ~order f g t</code> iterates over the structure of the diagram, calling <code>f</code> at leaf nodes and <code>g</code> at branch nodes. The user can control the order of the traversal by using the <code>order</code> argument. Specifying <code>`Pre</code> will cause <code>iter</code> to call <code>g</code> on a branch node before traversing its children, while specifying <code>`Post</code> will cause <code>iter</code> to call <code>g</code> after it has traversed its children.</p></dd></dl><dl><dt class="spec value" id="val-equal"><a href="#val-equal" class="anchor"></a><code><span class="keyword">val</span> equal : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>equal a b</code> returns whether or not the two diagrams are structurally equal.</p><p>If two diagrams are structurally equal, then they represent the same combinatorial object. However, if two diagrams are not equal, they still may represent the same combinatorial object. Whether or not this is the case depends on they behavior of the type <code>v</code>.</p></dd></dl><dl><dt class="spec value" id="val-to_string"><a href="#val-to_string" class="anchor"></a><code><span class="keyword">val</span> to_string : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> string</code></dt><dd><p><code>to_string t</code> returns a string representation of the diagram.</p></dd></dl><dl><dt class="spec value" id="val-to_dot"><a href="#val-to_dot" class="anchor"></a><code><span class="keyword">val</span> to_dot : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> string</code></dt><dd><p><code>to_dot t</code> returns a string representation of the diagram using the DOT graph description language. The result of this function can be rendered using Graphviz or any other program that supports the DOT language.</p></dd></dl></div></body></html>