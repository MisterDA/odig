<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Useri_backend (useri.Useri_backend)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../index.html">useri</a> &#x00BB; Useri_backend</nav><h1>Module <code>Useri_backend</code></h1><p>Simple declarative user interaction with <code>React</code>.</p><p><code>Useri</code> gathers user input as <code>React</code> signals and events from a single rendering surface.</p><p>Open the module to use it, this defines only modules in your scope.</p><p><b>Note.</b> Before <a href="App/index.html#val-init"><code>App.init</code></a> is called all signals hold invalid data.</p><p><b>Caveat.</b> Do not expect to be able to fully exploit the possibilities and flexibility of the platforms underlying the backends. This library is a <em>simple</em> abstraction library and thus remains limited by design.</p><p><em>Release v0.0.0-82-g567f882 — %%MAINTAINER%%</em></p><nav class="toc"><ul><li><a href="#useri">Useri</a></li><li><a href="#minimal-example">Minimal example</a></li><li><a href="#cooperate">Integration with cooperative concurency</a></li><li><a href="#rendercoord">Input, animation and rendering coordination</a></li></ul></nav></header><section><header><h2 id="useri"><a href="#useri" class="anchor"></a>Useri</h2></header><dl><dt class="spec module" id="module-Time"><a href="#module-Time" class="anchor"></a><code><span class="keyword">module </span><a href="Time/index.html">Time</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Monotonic time.</p></dd></dl><dl><dt class="spec module" id="module-Surface"><a href="#module-Surface" class="anchor"></a><code><span class="keyword">module </span><a href="Surface/index.html">Surface</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Rendering surface.</p></dd></dl><dl><dt class="spec module" id="module-Mouse"><a href="#module-Mouse" class="anchor"></a><code><span class="keyword">module </span><a href="Mouse/index.html">Mouse</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>User mouse.</p></dd></dl><dl><dt class="spec module" id="module-Touch"><a href="#module-Touch" class="anchor"></a><code><span class="keyword">module </span><a href="Touch/index.html">Touch</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>User touches.</p></dd></dl><dl><dt class="spec module" id="module-Key"><a href="#module-Key" class="anchor"></a><code><span class="keyword">module </span><a href="Key/index.html">Key</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>User keyboard.</p></dd></dl><dl><dt class="spec module" id="module-Text"><a href="#module-Text" class="anchor"></a><code><span class="keyword">module </span><a href="Text/index.html">Text</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>User textual input and clipboard.</p></dd></dl><dl><dt class="spec module" id="module-Drop"><a href="#module-Drop" class="anchor"></a><code><span class="keyword">module </span><a href="Drop/index.html">Drop</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>User drag and drop.</p></dd></dl><dl><dt class="spec module" id="module-Human"><a href="#module-Human" class="anchor"></a><code><span class="keyword">module </span><a href="Human/index.html">Human</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Human factors.</p></dd></dl><dl><dt class="spec module" id="module-App"><a href="#module-App" class="anchor"></a><code><span class="keyword">module </span><a href="App/index.html">App</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Application</p></dd></dl></section><section><header><h2 id="minimal-example"><a href="#minimal-example" class="anchor"></a>Minimal example</h2><p>This minimal example can be used on both synchronous and asynchronous backends.</p><pre><code class="ml"></code></pre></header></section><section><header><h2 id="cooperate"><a href="#cooperate" class="anchor"></a>Integration with cooperative concurency</h2><p>A good way of managing side-effects at the boundaries of your functional reactive system is to use a cooperative concurency library and convert event occurences and signal changes to yielding futures/threads (to avoid the problem of forbidden recursive primitive feedback) and convert futures/threads to a primitive event with a single occurence.</p><p>You will need however need to cooperate with <code>Useri</code>'s event loop and give it a high priority as the ability to interact should <b>never</b> take over a long running computation.</p><p>The following code shows how to do that with Lwt and Fut</p><pre><code class="ml"></code></pre></header></section><section><header><h2 id="rendercoord"><a href="#rendercoord" class="anchor"></a>Input, animation and rendering coordination</h2><p>The <a href="Time/index.html"><code>Time</code></a> and <a href="Surface/index.html"><code>Surface</code></a> modules provide support for coordinating input, animation and rendering. We can distinguish two patterns for rendering:</p><ul><li>Rendering as an effectful event or signal. This is more likely to be done in simple cases whenever you are not using cooperative concurrency. In this case rendering is simply performed in a <span class="xref-unresolved" title="unresolved reference to &quot;React.steps&quot;"><span>React update step</span></span> simultanous with the <a href="Surface/index.html#val-refresh"><code>Surface.refresh</code></a> event, in this step you can sample signals needed for rendering (as long as they <em>do not</em> depend on <a href="Surface/index.html#val-refresh"><code>Surface.refresh</code></a>).</li><li>Rendering as a task, in more complex rendering scenarios and especially with <a href="index.html#cooperate"><span>cooperative concurency</span></a>. In this case <a href="Surface/index.html#val-refresh"><code>Surface.refresh</code></a> occurences simply generate a task that is run outside React's update step, this means that the signals needed for rendering can be safely sampled using <span class="xref-unresolved" title="unresolved reference to &quot;React.S.value&quot;"><span class="xref-unresolved" title="unresolved reference to &quot;React.S&quot;"><code>React</code>.S</span>.value</span> for rendering data.</li></ul><p>In both cases rendering is coordinated by the <a href="Surface/index.html#val-refresh"><code>Surface.refresh</code></a> event. It is important to use this event for the following reasons:</p><ul><li>It occurs at important times in the life cycle of the application. For example whenever the application surface is first shown to the user or immediately after the application surface <a href="Surface/index.html#val-raster_size"><code>Surface.raster_size</code></a> changes.</li><li>If steady refreshes or timing signals are requested to perform animation it allows them to occur in an energy efficient way, avoiding overdraw. It will also gracefully cope with processing load by dropping animation frames if the rendering system cannot follow.</li></ul><p>There are various <em>non-exclusive</em> ways of generating occurences of <a href="Surface/index.html#val-refresh"><code>Surface.refresh</code></a>:</p><ul><li>Steady refresh. If for a given time span until an event occurs (which may be <span class="xref-unresolved" title="unresolved reference to &quot;E.never&quot;"><code>E</code>.never</span>) you need steady refreshing, use <a href="Surface/index.html#val-steady_refresh"><code>Surface.steady_refresh</code></a>.</li><li><p>Animation timing signals. <a href="Surface/index.html#val-refresh"><code>Surface.refresh</code></a> occurences are generated immediately after the following signals are created and updated:</p><ul><li><a href="Time/index.html#val-unit"><code>Time.unit</code></a>, for animations with a known time span, returns a signal increasing from <code>0.</code> to <code>1.</code> during that time span.</li><li><a href="Time/index.html#val-count"><code>Time.count</code></a>, for animations with an unknown time span, returns a signal monotically increasing from <code>0.</code> to the time until a specified event occurs.</li></ul></li><li>If there are a few events after which you know you need to redraw, <span class="xref-unresolved" title="unresolved reference to &quot;E.select&quot;"><code>E</code>.select</span> them and register the resulting event with <a href="Surface/index.html#val-set_refresher"><code>Surface.set_refresher</code></a>.</li></ul></header></section></div></body></html>