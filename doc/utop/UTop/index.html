<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>UTop (utop.UTop)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../index.html">utop</a> &#x00BB; UTop</nav><h1>Module <code>UTop</code></h1><p>UTop configuration.</p><nav class="toc"><ul><li><a href="#history">History</a></li><li><a href="#console-specific-configuration">Console specific configuration</a></li><li><a href="#hooks">Hooks</a></li><li><a href="#parsing">Parsing</a></li><li><a href="#helpers">Helpers</a></li><li><a href="#compiler-libs-reexports">compiler-libs reexports</a></li></ul></nav></header><dl><dt class="spec value" id="val-version"><a href="#val-version" class="anchor"></a><code><span class="keyword">val </span>version : string</code></dt><dd><p>Version of utop.</p></dd></dl><dl><dt class="spec value" id="val-count"><a href="#val-count" class="anchor"></a><code><span class="keyword">val </span>count : int React.signal</code></dt><dd><p>The number of commands already executed.</p></dd></dl><dl><dt class="spec value" id="val-keywords"><a href="#val-keywords" class="anchor"></a><code><span class="keyword">val </span>keywords : Set.Make(String).t Pervasives.ref</code></dt><dd><p>The set of OCaml keywords.</p></dd></dl><dl><dt class="spec value" id="val-add_keyword"><a href="#val-add_keyword" class="anchor"></a><code><span class="keyword">val </span>add_keyword : string <span>&#45;&gt;</span> unit</code></dt><dd><p>Add a new OCaml keyword.</p></dd></dl><dl><dt class="spec value" id="val-require"><a href="#val-require" class="anchor"></a><code><span class="keyword">val </span>require : string list <span>&#45;&gt;</span> unit</code></dt><dd><p>Load all the given findlib packages</p></dd></dl><dl><dt class="spec type" id="type-ui"><a href="#type-ui" class="anchor"></a><code><span class="keyword">type </span>ui</code><code><span class="keyword"> = </span></code><table class="variant"><tr id="type-ui.Console" class="anchored"><td class="def constructor"><a href="#type-ui.Console" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Console</span></code></td></tr><tr id="type-ui.Emacs" class="anchored"><td class="def constructor"><a href="#type-ui.Emacs" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Emacs</span></code></td><td class="doc"><p>The user interface in use.</p></td></tr></table></dt></dl><dl><dt class="spec value" id="val-get_ui"><a href="#val-get_ui" class="anchor"></a><code><span class="keyword">val </span>get_ui : unit <span>&#45;&gt;</span> <a href="index.html#type-ui">ui</a></code></dt><dd><p>Returns the user interface in use.</p></dd></dl><dl><dt class="spec value" id="val-hide_reserved"><a href="#val-hide_reserved" class="anchor"></a><code><span class="keyword">val </span>hide_reserved : bool React.signal</code></dt><dd><p>If <code>true</code> (the default) identifiers starting with a '_' will be hidden from the output. i.e. the following phrase won't produces any output:</p><pre><code class="ml">let _x = 1</code></pre><p>This is for hidding variables created by code generators for internal use. It can also be set/unset by the command line options <code>-hide-reserved</code> and <code>-show-reserved</code>.</p></dd></dl><dl><dt class="spec value" id="val-get_hide_reserved"><a href="#val-get_hide_reserved" class="anchor"></a><code><span class="keyword">val </span>get_hide_reserved : unit <span>&#45;&gt;</span> bool</code></dt><dd><p>Returns the value of <a href="index.html#val-hide_reserved"><code>hide_reserved</code></a>.</p></dd></dl><dl><dt class="spec value" id="val-set_hide_reserved"><a href="#val-set_hide_reserved" class="anchor"></a><code><span class="keyword">val </span>set_hide_reserved : bool <span>&#45;&gt;</span> unit</code></dt><dd><p>Modifies <a href="index.html#val-hide_reserved"><code>hide_reserved</code></a>.</p></dd></dl><dl><dt class="spec value" id="val-create_implicits"><a href="#val-create_implicits" class="anchor"></a><code><span class="keyword">val </span>create_implicits : bool React.signal</code></dt><dd><p>If <code>true</code> (not the default) expressions entered in the toplevel are automatically bound, for example:</p><pre><code class="ml"># 3 + 4;;
_0 : int = 7
# _0 + 10;;
_1 : int = 17</code></pre></dd></dl><dl><dt class="spec value" id="val-get_create_implicits"><a href="#val-get_create_implicits" class="anchor"></a><code><span class="keyword">val </span>get_create_implicits : unit <span>&#45;&gt;</span> bool</code></dt><dd><p>Returns the value of <a href="index.html#val-create_implicits"><code>create_implicits</code></a>.</p></dd></dl><dl><dt class="spec value" id="val-set_create_implicits"><a href="#val-set_create_implicits" class="anchor"></a><code><span class="keyword">val </span>set_create_implicits : bool <span>&#45;&gt;</span> unit</code></dt><dd><p>Modifies <a href="index.html#val-create_implicits"><code>create_implicits</code></a>.</p></dd></dl><dl><dt class="spec value" id="val-topfind_verbose"><a href="#val-topfind_verbose" class="anchor"></a><code><span class="keyword">val </span>topfind_verbose : bool React.signal</code></dt><dd><p>If <code>false</code> (the default) messages from findlib are hidden. This is only effective with findlib &gt;= 1.4.</p></dd></dl><dl><dt class="spec value" id="val-get_topfind_verbose"><a href="#val-get_topfind_verbose" class="anchor"></a><code><span class="keyword">val </span>get_topfind_verbose : unit <span>&#45;&gt;</span> bool</code></dt><dd><p>Returns the value of <a href="index.html#val-topfind_verbose"><code>topfind_verbose</code></a>.</p></dd></dl><dl><dt class="spec value" id="val-set_topfind_verbose"><a href="#val-set_topfind_verbose" class="anchor"></a><code><span class="keyword">val </span>set_topfind_verbose : bool <span>&#45;&gt;</span> unit</code></dt><dd><p>Modifies <a href="index.html#val-topfind_verbose"><code>topfind_verbose</code></a>.</p></dd></dl><dl><dt class="spec value" id="val-topfind_log"><a href="#val-topfind_log" class="anchor"></a><code><span class="keyword">val </span>topfind_log : string list React.signal</code></dt><dd><p>List of messages logged by findlib since the beginning of the session. This requires findlib &gt;= 1.4.</p></dd></dl><dl><dt class="spec value" id="val-show_box"><a href="#val-show_box" class="anchor"></a><code><span class="keyword">val </span>show_box : bool React.signal</code></dt><dd><p>If <code>true</code> (the default) the completion bar is displayed.</p></dd></dl><dl><dt class="spec value" id="val-get_show_box"><a href="#val-get_show_box" class="anchor"></a><code><span class="keyword">val </span>get_show_box : unit <span>&#45;&gt;</span> bool</code></dt><dd><p>Returns the value of <a href="index.html#val-show_box"><code>show_box</code></a>.</p></dd></dl><dl><dt class="spec value" id="val-set_show_box"><a href="#val-set_show_box" class="anchor"></a><code><span class="keyword">val </span>set_show_box : bool <span>&#45;&gt;</span> unit</code></dt><dd><p>Modifies <a href="index.html#val-show_box"><code>show_box</code></a>.</p></dd></dl><dl><dt class="spec value" id="val-set_margin_function"><a href="#val-set_margin_function" class="anchor"></a><code><span class="keyword">val </span>set_margin_function : (LTerm_geom.size <span>&#45;&gt;</span> int option) <span>&#45;&gt;</span> unit</code></dt><dd><p>Margin of the standard and error formatters as a function of the screen size.</p><p>The default is:</p><pre><code class="ml">fun size -&gt; Some (min 80 size.cols)</code></pre></dd></dl><dl><dt class="spec type" id="type-syntax"><a href="#type-syntax" class="anchor"></a><code><span class="keyword">type </span>syntax</code><code><span class="keyword"> = </span></code><table class="variant"><tr id="type-syntax.Normal" class="anchored"><td class="def constructor"><a href="#type-syntax.Normal" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Normal</span></code></td><td class="doc"><p>No camlp4.</p></td></tr><tr id="type-syntax.Camlp4o" class="anchored"><td class="def constructor"><a href="#type-syntax.Camlp4o" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Camlp4o</span></code></td><td class="doc"><p>Camlp4, original syntax.</p></td></tr><tr id="type-syntax.Camlp4r" class="anchored"><td class="def constructor"><a href="#type-syntax.Camlp4r" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Camlp4r</span></code></td><td class="doc"><p>Camlp4, revised syntax.</p></td></tr></table></dt><dd><p>Syntax.</p></dd></dl><dl><dt class="spec value" id="val-syntax"><a href="#val-syntax" class="anchor"></a><code><span class="keyword">val </span>syntax : <a href="index.html#type-syntax">syntax</a> React.signal</code></dt><dd><p>The syntax in use. If it is <a href="index.html#type-syntax.Camlp4o"><code>Camlp4o</code></a> or <a href="index.html#type-syntax.Camlp4r"><code>Camlp4r</code></a> quotations are recognized. It is modified when you type <code>#camlp4o</code> or <code>#camlp4r</code>. At the beginning it is <a href="index.html#type-syntax.Normal"><code>Normal</code></a>.</p></dd></dl><dl><dt class="spec value" id="val-get_syntax"><a href="#val-get_syntax" class="anchor"></a><code><span class="keyword">val </span>get_syntax : unit <span>&#45;&gt;</span> <a href="index.html#type-syntax">syntax</a></code></dt><dd><p>Returns the current value of <a href="index.html#type-syntax"><code>syntax</code></a>.</p></dd></dl><dl><dt class="spec value" id="val-set_syntax"><a href="#val-set_syntax" class="anchor"></a><code><span class="keyword">val </span>set_syntax : <a href="index.html#type-syntax">syntax</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Changes the syntax used in utop. If the syntax is the same as the current one, it does nothing. Otherwise it loads camlp4 and setup several configuration variables.</p><p>Notes:</p><ul><li>the syntax can only be changed once. Once you set it to <a href="index.html#type-syntax.Camlp4o"><code>Camlp4o</code></a> or <a href="index.html#type-syntax.Camlp4r"><code>Camlp4r</code></a> you cannot change it again.</li><li>Typing <code>#camlp4o</code> is the same as calling <code>set_syntax Camlp4o</code>.</li><li>Typing <code>#camlp4r</code> is the same as calling <code>set_syntax Camlp4r</code>.</li></ul></dd></dl><dl><dt class="spec value" id="val-phrase_terminator"><a href="#val-phrase_terminator" class="anchor"></a><code><span class="keyword">val </span>phrase_terminator : string React.signal</code></dt><dd><p>The phrase terminator. It is &quot;;;&quot; by default and &quot;;&quot; when you use revised syntax.</p></dd></dl><dl><dt class="spec value" id="val-get_phrase_terminator"><a href="#val-get_phrase_terminator" class="anchor"></a><code><span class="keyword">val </span>get_phrase_terminator : unit <span>&#45;&gt;</span> string</code></dt><dd><p>Returns the value of <a href="index.html#val-phrase_terminator"><code>phrase_terminator</code></a>.</p></dd></dl><dl><dt class="spec value" id="val-set_phrase_terminator"><a href="#val-set_phrase_terminator" class="anchor"></a><code><span class="keyword">val </span>set_phrase_terminator : string <span>&#45;&gt;</span> unit</code></dt><dd><p>Modifies <a href="index.html#val-phrase_terminator"><code>phrase_terminator</code></a>.</p></dd></dl><dl><dt class="spec value" id="val-auto_run_lwt"><a href="#val-auto_run_lwt" class="anchor"></a><code><span class="keyword">val </span>auto_run_lwt : bool React.signal</code></dt><dd><p>If <code>true</code> (the default) toplevel lwt expressions are automatically run with <code>Lwt_main.run</code>. i.e. if you type:</p><pre><code class="ml">Lwt_io.printl &quot;Hello, world&quot;</code></pre><p>this will be replaced by:</p><pre><code class="ml">Lwt_main.run (Lwt_io.printl &quot;Hello, world&quot;)</code></pre></dd></dl><dl><dt class="spec value" id="val-get_auto_run_lwt"><a href="#val-get_auto_run_lwt" class="anchor"></a><code><span class="keyword">val </span>get_auto_run_lwt : unit <span>&#45;&gt;</span> bool</code></dt><dd><p>Returns the value of <a href="index.html#val-auto_run_lwt"><code>auto_run_lwt</code></a>.</p></dd></dl><dl><dt class="spec value" id="val-set_auto_run_lwt"><a href="#val-set_auto_run_lwt" class="anchor"></a><code><span class="keyword">val </span>set_auto_run_lwt : bool <span>&#45;&gt;</span> unit</code></dt><dd><p>Modifies <a href="index.html#val-auto_run_lwt"><code>auto_run_lwt</code></a>.</p></dd></dl><dl><dt class="spec value" id="val-auto_run_async"><a href="#val-auto_run_async" class="anchor"></a><code><span class="keyword">val </span>auto_run_async : bool React.signal</code></dt><dd><p>If <code>true</code> (the default) toplevel Async expressions are automatically run with in a separate thread with <code>Thread_safe.block_on_async_exn</code>. i.e. if you type:</p><pre><code class="ml">after (Time.Span.of_s 1.0)</code></pre><p>this will be replaced by:</p><pre><code class="ml">Thread_safe.block_on_async_exn (fun () -&gt; after (Time.Span.of_s 1.0))</code></pre></dd></dl><dl><dt class="spec value" id="val-get_auto_run_async"><a href="#val-get_auto_run_async" class="anchor"></a><code><span class="keyword">val </span>get_auto_run_async : unit <span>&#45;&gt;</span> bool</code></dt><dd><p>Returns the value of <a href="index.html#val-auto_run_async"><code>auto_run_async</code></a>.</p></dd></dl><dl><dt class="spec value" id="val-set_auto_run_async"><a href="#val-set_auto_run_async" class="anchor"></a><code><span class="keyword">val </span>set_auto_run_async : bool <span>&#45;&gt;</span> unit</code></dt><dd><p>Modifies <a href="index.html#val-auto_run_async"><code>auto_run_async</code></a>.</p></dd></dl><dl><dt class="spec value" id="val-end_and_accept_current_phrase"><a href="#val-end_and_accept_current_phrase" class="anchor"></a><code><span class="keyword">val </span>end_and_accept_current_phrase : LTerm_read_line.action</code></dt><dd><p>Action that add the phrase terminator at the end of the current phrase and accepts it. For instance to avoid typing <code>;;</code>, add this to your ~/.ocamlinit:</p><pre><code class="ml">#require &quot;lambda-term&quot;;;
LTerm_read_line.bind
  [ { control = false; meta = false; shift = false; code = Enter } ]
  [ UTop.end_and_accept_current_phrase ]</code></pre></dd></dl><dl><dt class="spec value" id="val-external_editor"><a href="#val-external_editor" class="anchor"></a><code><span class="keyword">val </span>external_editor : string React.signal</code></dt><dd><p>External editor command. <code>None</code> for default.</p></dd></dl><dl><dt class="spec value" id="val-set_external_editor"><a href="#val-set_external_editor" class="anchor"></a><code><span class="keyword">val </span>set_external_editor : string <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-get_external_editor"><a href="#val-get_external_editor" class="anchor"></a><code><span class="keyword">val </span>get_external_editor : unit <span>&#45;&gt;</span> string</code></dt></dl><section><header><h6 id="history"><a href="#history" class="anchor"></a>History</h6></header><dl><dt class="spec value" id="val-history"><a href="#val-history" class="anchor"></a><code><span class="keyword">val </span>history : LTerm_history.t</code></dt><dd><p>The history used by utop. You can configure limits using the <code>LTerm_history</code> module.</p><p>For example if you want to limit the history to 1000 line, add these lines to your ~/.ocamlinit file:</p><pre><code class="ml">#require &quot;lambda-term&quot;;;
LTerm_history.set_max_entries UTop.history 1000;;</code></pre></dd></dl><dl><dt class="spec value" id="val-history_file_name"><a href="#val-history_file_name" class="anchor"></a><code><span class="keyword">val </span>history_file_name : string option Pervasives.ref</code></dt><dd><p>Name of the history file. If <code>None</code>, no history will be loaded or saved.</p></dd></dl><dl><dt class="spec value" id="val-history_file_max_size"><a href="#val-history_file_max_size" class="anchor"></a><code><span class="keyword">val </span>history_file_max_size : int option Pervasives.ref</code></dt><dd><p>Maximum size of the history file. If <code>None</code> (the default) the maximum size of <code>history</code> will be used.</p></dd></dl><dl><dt class="spec value" id="val-history_file_max_entries"><a href="#val-history_file_max_entries" class="anchor"></a><code><span class="keyword">val </span>history_file_max_entries : int option Pervasives.ref</code></dt><dd><p>Maximum entries to store in the history file. If <code>None</code> (the default) the maximum number of entries if <code>history</code> will be used.</p></dd></dl><dl><dt class="spec value" id="val-stashable_session_history"><a href="#val-stashable_session_history" class="anchor"></a><code><span class="keyword">val </span>stashable_session_history : UTop_history.t</code></dt><dd><p>A history consisting of inputs and resulting values or errors of the current session. Because stashing is supposed to produce a valid OCaml file which will behave roughly the same as the console, it is best if this history never gets truncated. While this will certainly lead to a slight memory leaking problem, UTop sessions are rarely long enough to make it a serious issue.</p></dd></dl></section><section><header><h6 id="console-specific-configuration"><a href="#console-specific-configuration" class="anchor"></a>Console specific configuration</h6></header><dl><dt class="spec type" id="type-profile"><a href="#type-profile" class="anchor"></a><code><span class="keyword">type </span>profile</code><code><span class="keyword"> = </span></code><table class="variant"><tr id="type-profile.Dark" class="anchored"><td class="def constructor"><a href="#type-profile.Dark" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Dark</span></code></td></tr><tr id="type-profile.Light" class="anchored"><td class="def constructor"><a href="#type-profile.Light" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Light</span></code></td><td class="doc"><p>Profile for colors.</p></td></tr></table></dt></dl><dl><dt class="spec value" id="val-profile"><a href="#val-profile" class="anchor"></a><code><span class="keyword">val </span>profile : <a href="index.html#type-profile">profile</a> React.signal</code></dt><dd><p>The color profile. It defaults to <a href="index.html#type-profile.Dark"><code>Dark</code></a>. This is used by the default prompt to choose colors.</p></dd></dl><dl><dt class="spec value" id="val-set_profile"><a href="#val-set_profile" class="anchor"></a><code><span class="keyword">val </span>set_profile : <a href="index.html#type-profile">profile</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Sets the color profile.</p></dd></dl><dl><dt class="spec value" id="val-size"><a href="#val-size" class="anchor"></a><code><span class="keyword">val </span>size : LTerm_geom.size React.signal</code></dt><dd><p>The current size of the terminal. This is used only in the console UI.</p></dd></dl><dl><dt class="spec value" id="val-key_sequence"><a href="#val-key_sequence" class="anchor"></a><code><span class="keyword">val </span>key_sequence : LTerm_key.t list React.signal</code></dt><dd><p>The current key sequence entered by the user. This is used only in the console UI.</p></dd></dl><dl><dt class="spec value" id="val-time"><a href="#val-time" class="anchor"></a><code><span class="keyword">val </span>time : float Pervasives.ref</code></dt><dd><p>The time of the beginning of the current command.</p></dd></dl><dl><dt class="spec value" id="val-prompt"><a href="#val-prompt" class="anchor"></a><code><span class="keyword">val </span>prompt : LTerm_text.t React.signal Pervasives.ref</code></dt><dd><p>The prompt.</p></dd></dl></section><section><header><h6 id="hooks"><a href="#hooks" class="anchor"></a>Hooks</h6></header><dl><dt class="spec value" id="val-new_command_hooks"><a href="#val-new_command_hooks" class="anchor"></a><code><span class="keyword">val </span>new_command_hooks : (unit <span>&#45;&gt;</span> unit) LTerm_dlist.t</code></dt><dd><p>Functions called before each new command.</p></dd></dl><dl><dt class="spec value" id="val-at_new_command"><a href="#val-at_new_command" class="anchor"></a><code><span class="keyword">val </span>at_new_command : (unit <span>&#45;&gt;</span> unit) <span>&#45;&gt;</span> unit</code></dt><dd><p><code>at_new_command f</code> adds <code>f</code> to the hooks executed before each new commands.</p></dd></dl></section><section><header><h6 id="parsing"><a href="#parsing" class="anchor"></a>Parsing</h6></header><dl><dt class="spec type" id="type-location"><a href="#type-location" class="anchor"></a><code><span class="keyword">type </span>location</code><code><span class="keyword"> = </span>int<span class="keyword"> * </span>int</code></dt><dd><p>Type of a string-location. It is composed of a start and stop offsets (in bytes).</p></dd></dl><dl><dt class="spec type" id="type-result"><a href="#type-result" class="anchor"></a><code><span class="keyword">type </span>'a result</code><code><span class="keyword"> = </span></code><table class="variant"><tr id="type-result.Value" class="anchored"><td class="def constructor"><a href="#type-result.Value" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Value</span><span class="keyword"> of </span><span class="type-var">'a</span></code></td><td class="doc"><p>The function succeeded and returned this value.</p></td></tr><tr id="type-result.Error" class="anchored"><td class="def constructor"><a href="#type-result.Error" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Error</span><span class="keyword"> of </span><a href="index.html#type-location">location</a> list<span class="keyword"> * </span>string</code></td><td class="doc"><p>The function failed. Arguments are a list of locations to highlight in the source and an error message.</p></td></tr></table></dt><dd><p>Result of a function processing a programx.</p></dd></dl><dl><dt class="spec exception" id="exception-Need_more"><a href="#exception-Need_more" class="anchor"></a><code><span class="keyword">exception </span></code><code><span class="exception">Need_more</span></code></dt><dd><p>Exception raised by a parser when it need more data.</p></dd></dl><dl><dt class="spec value" id="val-parse_use_file"><a href="#val-parse_use_file" class="anchor"></a><code><span class="keyword">val </span>parse_use_file : (string <span>&#45;&gt;</span> bool <span>&#45;&gt;</span> Parsetree.toplevel_phrase list <a href="index.html#type-result">result</a>) Pervasives.ref</code></dt><dt class="spec value" id="val-parse_use_file_default"><a href="#val-parse_use_file_default" class="anchor"></a><code><span class="keyword">val </span>parse_use_file_default : string <span>&#45;&gt;</span> bool <span>&#45;&gt;</span> Parsetree.toplevel_phrase list <a href="index.html#type-result">result</a></code></dt><dd><p>The default parser for toplevel regions. It uses the standard ocaml parser.</p></dd></dl><dl><dt class="spec value" id="val-parse_toplevel_phrase"><a href="#val-parse_toplevel_phrase" class="anchor"></a><code><span class="keyword">val </span>parse_toplevel_phrase : (string <span>&#45;&gt;</span> bool <span>&#45;&gt;</span> Parsetree.toplevel_phrase <a href="index.html#type-result">result</a>) Pervasives.ref</code></dt><dd><p><code>parse_toplevel_phrase</code> is the function used to parse a phrase typed in the toplevel.</p><p>Its arguments are:</p><ul><li><code>input</code>: the string to parse</li><li><code>eos_is_error</code></li></ul><p>If <code>eos_is_error</code> is <code>true</code> and the parser reach the end of input, then <code>Parse_failure</code> should be returned.</p><p>If <code>eos_is_error</code> is <code>false</code> and the parser reach the end of input, the exception <a href="index.html#exception-Need_more"><code>Need_more</code></a> must be thrown.</p><p>Except for <a href="index.html#exception-Need_more"><code>Need_more</code></a>, the function must not raise any exception.</p></dd></dl><dl><dt class="spec value" id="val-parse_toplevel_phrase_default"><a href="#val-parse_toplevel_phrase_default" class="anchor"></a><code><span class="keyword">val </span>parse_toplevel_phrase_default : string <span>&#45;&gt;</span> bool <span>&#45;&gt;</span> Parsetree.toplevel_phrase <a href="index.html#type-result">result</a></code></dt><dd><p>The default parser for toplevel phrases. It uses the standard ocaml parser.</p></dd></dl><dl><dt class="spec value" id="val-parse_default"><a href="#val-parse_default" class="anchor"></a><code><span class="keyword">val </span>parse_default : (Lexing.lexbuf <span>&#45;&gt;</span> <span class="type-var">'a</span>) <span>&#45;&gt;</span> string <span>&#45;&gt;</span> bool <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-result">result</a></code></dt><dd><p>The default parser. It uses the standard ocaml parser.</p></dd></dl><dl><dt class="spec value" id="val-input_name"><a href="#val-input_name" class="anchor"></a><code><span class="keyword">val </span>input_name : string</code></dt><dd><p>The name you must use in location to let ocaml know that it is from the toplevel.</p></dd></dl><dl><dt class="spec value" id="val-lexbuf_of_string"><a href="#val-lexbuf_of_string" class="anchor"></a><code><span class="keyword">val </span>lexbuf_of_string : bool Pervasives.ref <span>&#45;&gt;</span> string <span>&#45;&gt;</span> Lexing.lexbuf</code></dt><dd><p><code>lexbuf_of_string eof str</code> is the same as <code>Lexing.from_string
      str</code> except that if the lexer reach the end of <code>str</code> then <code>eof</code> is set to <code>true</code>.</p></dd></dl></section><section><header><h6 id="helpers"><a href="#helpers" class="anchor"></a>Helpers</h6></header><dl><dt class="spec value" id="val-get_message"><a href="#val-get_message" class="anchor"></a><code><span class="keyword">val </span>get_message : (Format.formatter <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> unit) <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> string</code></dt><dd><p><code>get_message printer x</code> applies <code>printer</code> on <code>x</code> and returns everything it prints as a string.</p></dd></dl><dl><dt class="spec value" id="val-get_ocaml_error_message"><a href="#val-get_ocaml_error_message" class="anchor"></a><code><span class="keyword">val </span>get_ocaml_error_message : exn <span>&#45;&gt;</span> <a href="index.html#type-location">location</a><span class="keyword"> * </span>string</code></dt><dd><p><code>get_ocaml_error_message exn</code> returns the location and error message for the exception <code>exn</code> which must be an exception from the compiler.</p></dd></dl><dl><dt class="spec value" id="val-check_phrase"><a href="#val-check_phrase" class="anchor"></a><code><span class="keyword">val </span>check_phrase : Parsetree.toplevel_phrase <span>&#45;&gt;</span> (<a href="index.html#type-location">location</a> list<span class="keyword"> * </span>string) option</code></dt><dd><p><code>check_phrase phrase</code> checks that <code>phrase</code> can be executed without typing or compilation errors. It returns <code>None</code> if <code>phrase</code> is OK and an error message otherwise.</p><p>If the result is <code>None</code> it is guaranteed that <code>Toploop.execute_phrase</code> won't raise any exception.</p></dd></dl><dl><dt class="spec value" id="val-collect_formatters"><a href="#val-collect_formatters" class="anchor"></a><code><span class="keyword">val </span>collect_formatters : Buffer.t <span>&#45;&gt;</span> Format.formatter list <span>&#45;&gt;</span> (unit <span>&#45;&gt;</span> <span class="type-var">'a</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p><code>collect_formatters buf pps f</code> executes <code>f</code> and redirect everything it prints on <code>pps</code> to <code>buf</code>.</p></dd></dl><dl><dt class="spec value" id="val-discard_formatters"><a href="#val-discard_formatters" class="anchor"></a><code><span class="keyword">val </span>discard_formatters : Format.formatter list <span>&#45;&gt;</span> (unit <span>&#45;&gt;</span> <span class="type-var">'a</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p><code>discard_formatters pps f</code> executes <code>f</code>, dropping everything it prints on <code>pps</code>.</p></dd></dl><dl><dt class="spec value" id="val-split_words"><a href="#val-split_words" class="anchor"></a><code><span class="keyword">val </span>split_words : string <span>&#45;&gt;</span> string list</code></dt></dl></section><section><header><h6 id="compiler-libs-reexports"><a href="#compiler-libs-reexports" class="anchor"></a>compiler-libs reexports</h6></header><dl><dt class="spec value" id="val-load_path"><a href="#val-load_path" class="anchor"></a><code><span class="keyword">val </span>load_path : string list Pervasives.ref</code></dt><dd><p><code>load_path</code> is an alias of <code>Config.load_path</code>, normally hidden in toplevel. It contains the list of directories added by findlib-required packages and <code>#directory</code> directives.</p></dd></dl></section></div></body></html>