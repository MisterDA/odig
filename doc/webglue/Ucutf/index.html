<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Ucutf (webglue.Ucutf)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../index.html">webglue</a> &#x00BB; Ucutf</nav><h1>Module <code>Ucutf</code></h1><p>Unicode input/output.</p><p><code>Ucutf</code> defines <a href="#input">input</a> and <a href="#output">output</a> abstractions to decode and encode the <a href="http://www.ietf.org/rfc/rfc3629.txt">UTF-8</a>, <a href="http://www.ietf.org/rfc/rfc2781.txt">UTF-16</a>, UTF-16LE and UTF-16BE <a href="http://unicode.org/glossary/#unicode_encoding_scheme">encoding schemes</a>. Input abstractions can track the current character line and column position in the input stream and perform new line normalization.</p><p>Functions are also provided to <a href="#stringfold">fold over</a> the characters of UTF encoded OCaml string values and to <a href="#bufferencode">directly encode</a> characters in OCaml buffer values.</p><p>See <a href="#examples">examples</a> of use.</p><p><em>Version v0.0.0-34-g4398318 - %%EMAIL%%</em></p><h4 id="references"><a href="#references" class="anchor"></a>References</h4><ul><li>The Unicode Consortium. <em><a href="http://www.unicode.org/versions/latest">The Unicode Standard</a></em>. (latest version)</li></ul><nav class="toc"><ul><li><a href="#basic">Unicode characters and encoding schemes</a></li><li><a href="#input">Input</a></li><li><a href="#output">Output</a></li><li><a href="#stringfold">String folders</a></li><li><a href="#bufferencode">Buffer encoders</a></li><li><a href="#examples">Examples</a></li></ul></nav></header><section><header><h2 id="basic"><a href="#basic" class="anchor"></a>Unicode characters and encoding schemes</h2></header><dl><dt class="spec type" id="type-encoding"><a href="#type-encoding" class="anchor"></a><code><span class="keyword">type </span>encoding</code><span class="keyword"> = </span><code>[ </code><table class="variant"><tr id="type-encoding.UTF_16" class="anchored"><td class="def constructor"><a href="#type-encoding.UTF_16" class="anchor"></a><code><span class="keyword">| </span></code><code>`UTF_16</code></td></tr><tr id="type-encoding.UTF_16BE" class="anchored"><td class="def constructor"><a href="#type-encoding.UTF_16BE" class="anchor"></a><code><span class="keyword">| </span></code><code>`UTF_16BE</code></td></tr><tr id="type-encoding.UTF_16LE" class="anchored"><td class="def constructor"><a href="#type-encoding.UTF_16LE" class="anchor"></a><code><span class="keyword">| </span></code><code>`UTF_16LE</code></td></tr><tr id="type-encoding.UTF_8" class="anchored"><td class="def constructor"><a href="#type-encoding.UTF_8" class="anchor"></a><code><span class="keyword">| </span></code><code>`UTF_8</code></td></tr></table><code> ]</code></dt><dd><p>The type for <a href="http://unicode.org/glossary/#character_encoding_scheme">encoding schemes</a>.</p></dd></dl><dl><dt class="spec type" id="type-uchar"><a href="#type-uchar" class="anchor"></a><code><span class="keyword">type </span>uchar</code><code><span class="keyword"> = </span>int</code></dt><dd><p>The type for unicode characters.</p><p>More precisely a value of this type <b>returned by <code>Ucutf</code></b> is an <a href="http://unicode.org/glossary/#unicode_scalar_value">unicode scalar value</a> i.e. an integer value in the ranges <code>0x0000</code> ... <code>0xD7FF</code> or <code>0xE000</code> ... <code>0x10FFFF</code>.</p></dd></dl><dl><dt class="spec value" id="val-u_bom"><a href="#val-u_bom" class="anchor"></a><code><span class="keyword">val </span>u_bom : <a href="index.html#type-uchar">uchar</a></code></dt><dd><p><code>u_bom</code> is the <a href="http://unicode.org/glossary/#byte_order_mark">byte order mark</a> (BOM) character <code>U+FEFF</code>.</p></dd></dl><dl><dt class="spec value" id="val-u_rep"><a href="#val-u_rep" class="anchor"></a><code><span class="keyword">val </span>u_rep : <a href="index.html#type-uchar">uchar</a></code></dt><dd><p><code>u_rep</code> is the <a href="http://unicode.org/glossary/#replacement_character">replacement</a> character <code>U+FFFD</code>.</p></dd></dl><dl><dt class="spec value" id="val-u_lf"><a href="#val-u_lf" class="anchor"></a><code><span class="keyword">val </span>u_lf : <a href="index.html#type-uchar">uchar</a></code></dt><dd><p><code>u_lf</code> is the line feed character <code>U+000A</code> (<code>'\n'</code>).</p></dd></dl><dl><dt class="spec value" id="val-is_uchar"><a href="#val-is_uchar" class="anchor"></a><code><span class="keyword">val </span>is_uchar : <a href="index.html#type-uchar">uchar</a> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>is_uchar c</code> is <code>true</code> iff <code>c</code> is an <a href="http://unicode.org/glossary/#unicode_scalar_value">unicode scalar value</a>.</p></dd></dl><dl><dt class="spec value" id="val-cp_to_string"><a href="#val-cp_to_string" class="anchor"></a><code><span class="keyword">val </span>cp_to_string : <a href="index.html#type-uchar">uchar</a> <span>&#45;&gt;</span> string</code></dt><dd><p><code>cp_to_string cp</code> represents the <a href="http://unicode.org/glossary/#code_point">code point</a> <code>cp</code> in ASCII by the string <code>&quot;U+n&quot;</code> where n is four to six capital hexadecimal digits with leading zeros omitted unless the code point has fewer than four digits. If <code>cp</code> is not a valid code point <code>&quot;U+Invalid(X)&quot;</code> is returned where <code>X</code> is the hexadecimal integer value.</p><p><b>Warning.</b> Not thread safe. Use <a href="index.html#val-print_cp"><code>print_cp</code></a> for thread safety.</p></dd></dl><dl><dt class="spec value" id="val-print_cp"><a href="#val-print_cp" class="anchor"></a><code><span class="keyword">val </span>print_cp : Format.formatter <span>&#45;&gt;</span> <a href="index.html#type-uchar">uchar</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>print_cp ppf cp</code> prints the <a href="http://unicode.org/glossary/#code_point">code point</a> <code>cp</code> on <code>ppf</code> like <a href="index.html#val-cp_to_string"><code>cp_to_string</code></a> does.</p></dd></dl></section><section><header><h2 id="input"><a href="#input" class="anchor"></a>Input</h2></header><dl><dt class="spec type" id="type-pos"><a href="#type-pos" class="anchor"></a><code><span class="keyword">type </span>pos</code><code><span class="keyword"> = </span>int<span class="keyword"> * </span>int</code></dt><dd><p>The type for input positions, line and column number.</p></dd></dl><dl><dt class="spec type" id="type-source"><a href="#type-source" class="anchor"></a><code><span class="keyword">type </span>source</code><span class="keyword"> = </span><code>[ </code><table class="variant"><tr id="type-source.Channel" class="anchored"><td class="def constructor"><a href="#type-source.Channel" class="anchor"></a><code><span class="keyword">| </span></code><code>`Channel<span class="keyword"> of </span>Pervasives.in_channel</code></td></tr><tr id="type-source.Fun" class="anchored"><td class="def constructor"><a href="#type-source.Fun" class="anchor"></a><code><span class="keyword">| </span></code><code>`Fun<span class="keyword"> of </span>unit <span>&#45;&gt;</span> int</code></td></tr><tr id="type-source.String" class="anchored"><td class="def constructor"><a href="#type-source.String" class="anchor"></a><code><span class="keyword">| </span></code><code>`String<span class="keyword"> of </span>int<span class="keyword"> * </span>string</code></td></tr></table><code> ]</code></dt><dd><p>The type for input sources. For <code>`String</code> starts reading at the given integer position. For <code>`Fun</code> the function must return the next <em>byte</em> as an <code>int</code> and raise <code>End_of_file</code> if there is no such byte.</p></dd></dl><dl><dt class="spec type" id="type-input"><a href="#type-input" class="anchor"></a><code><span class="keyword">type </span>input</code></dt><dd><p>The type for input abstractions.</p></dd></dl><dl><dt class="spec value" id="val-make_input"><a href="#val-make_input" class="anchor"></a><code><span class="keyword">val </span>make_input : ?&#8288;pos:bool <span>&#45;&gt;</span> ?&#8288;nl:<a href="index.html#type-uchar">uchar</a> <span>&#45;&gt;</span> ?&#8288;encoding:<a href="index.html#type-encoding">encoding</a> <span>&#45;&gt;</span> <a href="index.html#type-source">source</a> <span>&#45;&gt;</span> <a href="index.html#type-input">input</a></code></dt><dd><p><code>make_input pos nl encoding src</code> is an input abstraction reading from <code>src</code>.</p><p><b>Encoding and BOM handling.</b> <code>encoding</code> specifies the input encoding scheme. If unspecified it is guessed by trying to parse a <a href="http://unicode.org/glossary/#byte_order_mark">byte order mark</a> (see the <a href="http://www.unicode.org/faq/utf_bom.html#BOM">FAQ</a>). If that fails UTF-8 is assumed unless a &quot;half&quot; UTF-16 BOM was parsed in which case UTF16-BE seems a better guess.</p><p>If <code>encoding</code> is unspecified or equal to <code>`UTF_16</code> any initial <a href="http://www.unicode.org/faq/utf_bom.html#BOM">BOM</a> is removed from the stream and not counted (in that case <a href="index.html#val-removed_bom"><code>removed_bom</code></a> returns <code>true</code>). In all other cases it is returned as the first character of the stream since it should be interpreted as an initial zero width no-break space character.</p><p><b>New line normalization.</b> If <code>nl</code> is specified then carriage return (CR, <code>U+000D</code>), line feed (LF, <code>U+000A</code>), next line (NEL, <code>U+0085</code>), line separator (LS, <code>U+0x2028</code>) and the sequence carriage return, line feed (CRLF, &lt;<code>U+000D</code> <code>U+000A</code>&gt;) are all normalized to the character <code>nl</code>.</p><p><b>Position tracking.</b> If <code>pos</code> is <code>true</code> (defaults to <code>false</code>) the position and count of the last input character is returned by the functions <a href="index.html#type-pos"><code>pos</code></a> and <a href="index.html#val-count"><code>count</code></a>.</p></dd></dl><dl><dt class="spec value" id="val-input_encoding"><a href="#val-input_encoding" class="anchor"></a><code><span class="keyword">val </span>input_encoding : <a href="index.html#type-input">input</a> <span>&#45;&gt;</span> <a href="index.html#type-encoding">encoding</a></code></dt><dd><p><code>input_encoding i</code> is the encoding scheme of <code>i</code>.</p></dd></dl><dl><dt class="spec value" id="val-pos"><a href="#val-pos" class="anchor"></a><code><span class="keyword">val </span>pos : <a href="index.html#type-input">input</a> <span>&#45;&gt;</span> <a href="index.html#type-pos">pos</a></code></dt><dd><p><code>pos i</code> is the line, column position of the <em>last</em> input (or malformed) character. If position tracking is disabled <code>(0,0)</code> is returned. Otherwise before any input <code>(1,0)</code> is returned. Each <a href="index.html#input"><span>Input</span></a> only increments the column until a new line. On a new line, the line number is incremented and the column set to zero (i.e. <code>(2,0)</code> after the first new line). A new line is any sequence of characters that would be normalized as a new line (see <a href="index.html#val-make_input"><code>make_input</code></a>).</p><p>This behaviour can be understood as if <a href="index.html#input"><span>Input</span></a> was moving an insertion <em>point</em> on the right in the data.</p></dd></dl><dl><dt class="spec value" id="val-count"><a href="#val-count" class="anchor"></a><code><span class="keyword">val </span>count : <a href="index.html#type-input">input</a> <span>&#45;&gt;</span> int</code></dt><dd><p><code>count i</code> is the number of characters already input on <code>i</code> (including malformed ones). If no characters were input or position tracking is disabled, <code>0</code> is returned.</p></dd></dl><dl><dt class="spec value" id="val-removed_bom"><a href="#val-removed_bom" class="anchor"></a><code><span class="keyword">val </span>removed_bom : <a href="index.html#type-input">input</a> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>removed_bom i</code> is <code>true</code> iff an initial <a href="http://unicode.org/glossary/#byte_order_mark">byte order mark</a> was parsed and removed from the input stream. See BOM handling documentation in <a href="index.html#val-make_input"><code>make_input</code></a>.</p></dd></dl><dl><dt class="spec value" id="val-input"><a href="#val-input" class="anchor"></a><code><span class="keyword">val </span>input : <a href="index.html#type-input">input</a> <span>&#45;&gt;</span> [ `Uchar of <a href="index.html#type-uchar">uchar</a><span class="keyword"> | </span>`Eoi<span class="keyword"> | </span>`Malformed ]</code></dt><dd><p><code>input i</code> returns the next unicode scalar value in <code>i</code> or <code>`Eoi</code> if the end of input is reached or <code>`Malformed</code> if the byte stream is malformed according to the input encoding scheme. In the latter case it is possible to continue to input characters until the stream synchronizes again on valid bytes (but it may be a good idea to signal the malformed characters by adding an <a href="index.html#val-u_rep"><code>u_rep</code></a> character to the parsed data, see the <a href="#examples">examples</a>).</p></dd></dl><dl><dt class="spec value" id="val-peek"><a href="#val-peek" class="anchor"></a><code><span class="keyword">val </span>peek : <a href="index.html#type-input">input</a> <span>&#45;&gt;</span> [ `Uchar of <a href="index.html#type-uchar">uchar</a><span class="keyword"> | </span>`Eoi<span class="keyword"> | </span>`Malformed ]</code></dt><dd><p><code>peek i</code> is like <a href="index.html#input"><span>Input</span></a> but it doesn't remove the character from the stream (and the position is not updated).</p></dd></dl></section><section><header><h2 id="output"><a href="#output" class="anchor"></a>Output</h2></header><dl><dt class="spec type" id="type-dest"><a href="#type-dest" class="anchor"></a><code><span class="keyword">type </span>dest</code><span class="keyword"> = </span><code>[ </code><table class="variant"><tr id="type-dest.Channel" class="anchored"><td class="def constructor"><a href="#type-dest.Channel" class="anchor"></a><code><span class="keyword">| </span></code><code>`Channel<span class="keyword"> of </span>Pervasives.out_channel</code></td></tr><tr id="type-dest.Buffer" class="anchored"><td class="def constructor"><a href="#type-dest.Buffer" class="anchor"></a><code><span class="keyword">| </span></code><code>`Buffer<span class="keyword"> of </span>Buffer.t</code></td></tr><tr id="type-dest.Fun" class="anchored"><td class="def constructor"><a href="#type-dest.Fun" class="anchor"></a><code><span class="keyword">| </span></code><code>`Fun<span class="keyword"> of </span>int <span>&#45;&gt;</span> unit</code></td></tr></table><code> ]</code></dt><dd><p>The type for output destinations. For <code>`Buffer</code>, the buffer won't be cleared. For <code>`Fun</code> the function is called with the output <em>bytes</em> as <code>int</code>s.</p></dd></dl><dl><dt class="spec type" id="type-output"><a href="#type-output" class="anchor"></a><code><span class="keyword">type </span>output</code></dt><dd><p>The type for output abstractions.</p></dd></dl><dl><dt class="spec value" id="val-make_output"><a href="#val-make_output" class="anchor"></a><code><span class="keyword">val </span>make_output : <a href="index.html#type-encoding">encoding</a> <span>&#45;&gt;</span> <a href="index.html#type-dest">dest</a> <span>&#45;&gt;</span> <a href="index.html#type-output">output</a></code></dt><dd><p><code>make_output encoding dest</code> is an output abstraction writing to <code>dest</code>.</p><p><b>Note.</b> No initial <a href="http://unicode.org/glossary/#byte_order_mark">byte order mark</a> is output. This duty is left to the client.</p></dd></dl><dl><dt class="spec value" id="val-output_encoding"><a href="#val-output_encoding" class="anchor"></a><code><span class="keyword">val </span>output_encoding : <a href="index.html#type-output">output</a> <span>&#45;&gt;</span> <a href="index.html#type-encoding">encoding</a></code></dt><dd><p><code>output_encoding o</code> is the encoding of <code>o</code>.</p></dd></dl><dl><dt class="spec value" id="val-output"><a href="#val-output" class="anchor"></a><code><span class="keyword">val </span>output : <a href="index.html#type-output">output</a> <span>&#45;&gt;</span> <a href="index.html#type-uchar">uchar</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>output o u</code> outputs the unicode scalar value <code>u</code> on <code>o</code>.</p><p><b>Warning.</b> The function assumes that <code>u</code> is an <a href="http://unicode.org/glossary/#unicode_scalar_value">unicode scalar value</a>. If you are handling foreign data you can use <a href="index.html#val-is_uchar"><code>is_uchar</code></a> to assert that.</p></dd></dl></section><section><header><h2 id="stringfold"><a href="#stringfold" class="anchor"></a>String folders</h2></header><dl><dt class="spec value" id="val-fold_utf8"><a href="#val-fold_utf8" class="anchor"></a><code><span class="keyword">val </span>fold_utf8 : (<span class="type-var">'a</span> <span>&#45;&gt;</span> [ `Uchar of <a href="index.html#type-uchar">uchar</a><span class="keyword"> | </span>`Malformed ] <span>&#45;&gt;</span> <span class="type-var">'a</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p><code>fold_utf8 f a s</code> is <code>f (</code> ... <code>(f (f a u</code><sub>0</sub><code>) u</code><sub>1</sub><code>)</code> ... <code>)</code> ... <code>) u</code><sub>n</sub> where <code>u</code><sub>i</sub> are the <a href="http://unicode.org/glossary/#unicode_scalar_value">unicode scalar value</a> of the UTF-8 encoded string <code>s</code>.</p></dd></dl><dl><dt class="spec value" id="val-fold_utf16be"><a href="#val-fold_utf16be" class="anchor"></a><code><span class="keyword">val </span>fold_utf16be : (<span class="type-var">'a</span> <span>&#45;&gt;</span> [ `Uchar of <a href="index.html#type-uchar">uchar</a><span class="keyword"> | </span>`Malformed ] <span>&#45;&gt;</span> <span class="type-var">'a</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p><code>fold_utf16be f a s</code> is <code>f (</code> ... <code>(f (f a u</code><sub>0</sub><code>) u</code><sub>1</sub><code>)</code> ... <code>)</code> ... <code>) u</code><sub>n</sub> where <code>u</code><sub>i</sub> are the <a href="http://unicode.org/glossary/#unicode_scalar_value">unicode scalar value</a> of the UTF-16BE encoded string <code>s</code>.</p></dd></dl><dl><dt class="spec value" id="val-fold_utf16le"><a href="#val-fold_utf16le" class="anchor"></a><code><span class="keyword">val </span>fold_utf16le : (<span class="type-var">'a</span> <span>&#45;&gt;</span> [ `Uchar of <a href="index.html#type-uchar">uchar</a><span class="keyword"> | </span>`Malformed ] <span>&#45;&gt;</span> <span class="type-var">'a</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p><code>fold_utf16le f a s</code> is <code>f (</code> ... <code>(f (f a u</code><sub>0</sub><code>) u</code><sub>1</sub><code>)</code> ... <code>)</code> ... <code>) u</code><sub>n</sub> where <code>u</code><sub>i</sub> are the <a href="http://unicode.org/glossary/#unicode_scalar_value">unicode scalar value</a> of the UTF-16LE encoded string <code>s</code>.</p></dd></dl></section><section><header><h2 id="bufferencode"><a href="#bufferencode" class="anchor"></a>Buffer encoders</h2><p><b>Warning.</b> All the functions below assumes that <code>u</code> is an <a href="http://unicode.org/glossary/#unicode_scalar_value">unicode scalar value</a>. If you are handling foreign data you can use <a href="index.html#val-is_uchar"><code>is_uchar</code></a> to assert that.</p></header><dl><dt class="spec value" id="val-add_utf8"><a href="#val-add_utf8" class="anchor"></a><code><span class="keyword">val </span>add_utf8 : Buffer.t <span>&#45;&gt;</span> <a href="index.html#type-uchar">uchar</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>add_utf8 b u</code> adds the UTF-8 encoding of the <a href="http://unicode.org/glossary/#unicode_scalar_value">unicode scalar value</a> <code>u</code> to <code>b</code>.</p></dd></dl><dl><dt class="spec value" id="val-add_utf16be"><a href="#val-add_utf16be" class="anchor"></a><code><span class="keyword">val </span>add_utf16be : Buffer.t <span>&#45;&gt;</span> <a href="index.html#type-uchar">uchar</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>add_utf16be b u</code> adds the UTF-16BE encoding of the <a href="http://unicode.org/glossary/#unicode_scalar_value">unicode scalar value</a> <code>u</code> to <code>b</code>.</p></dd></dl><dl><dt class="spec value" id="val-add_utf16le"><a href="#val-add_utf16le" class="anchor"></a><code><span class="keyword">val </span>add_utf16le : Buffer.t <span>&#45;&gt;</span> <a href="index.html#type-uchar">uchar</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>add_utf16le b u</code> adds the UTF-16LE encoding of the <a href="http://unicode.org/glossary/#unicode_scalar_value">unicode scalar value</a> <code>u</code> to <code>b</code>.</p></dd></dl></section><section><header><h2 id="examples"><a href="#examples" class="anchor"></a>Examples</h2><p>The <code>recode src out_encoding dst</code> function call inputs characters from <code>src</code> and outputs the result on <code>dst</code> with the encoding <code>out_encoding</code>. If a decoding error occurs we output the replacement character <a href="index.html#val-u_rep"><code>u_rep</code></a> and continue.</p><pre><code class="ml">let recode ?nl ?encoding src out_encoding dst =
  let i = Ucutf.make_input ?nl ?encoding src in
  let o = Ucutf.make_output out_encoding dst in
  let rec copy i o = match Ucutf.input i with
    | `Uchar u -&gt; Ucutf.output o u; copy i o
    | `Malformed -&gt; Ucutf.output o Ucutf.u_rep; copy i o
    | `Eoi -&gt; ()
  in
  if out_encoding = `UTF_16 then Ucutf.output o Ucutf.u_bom;
  copy i o</code></pre><p>The <code>input_lines src</code> function call inputs unicode data from <code>src</code> and parses its lines into a list of UTF-8 encoded strings. Line breaks are determined according to the <a href="http://www.unicode.org/versions/Unicode5.2.0/">Unicode 5.2</a> recommendation R4 of section 5.8 for a <code>readline</code> function. If a decoding error occurs we add the replacement character <a href="index.html#val-u_rep"><code>u_rep</code></a> in the current line and continue.</p><pre><code class="ml">let input_lines ?encoding src =
  let u_ps = 0x2029 (* PS, paragraph separator *) in
  let u_ff = 0x000C (* FF, form feed *) in
  let i = Ucutf.make_input ?encoding ~nl:u_ps src in
  let b = Buffer.create 512 in
  let rec aux i b acc = match Ucutf.input i with
  | `Uchar u when u &lt;&gt; u_ps &amp;&amp; u &lt;&gt; u_ff -&gt;
      Ucutf.add_utf8 b u; aux i b acc
  | `Uchar _ (* PS or FF *) -&gt;
      let s = Buffer.contents b in
      Buffer.clear b; aux i b (s :: acc)
  | `Malformed -&gt; Ucutf.add_utf8 b Ucutf.u_rep; aux i b acc
  | `Eoi -&gt; List.rev (Buffer.contents b :: acc)
  in
  aux i b []</code></pre></header></section></div></body></html>