<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Zlib (zlib.Zlib)</title><link rel="stylesheet" href="../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../index.html">zlib</a> &#x00BB; Zlib</nav><h1>Module <code>Zlib</code></h1><p>Bindings to the zlib compression library providing deflate compression with or without zlib or gzip headers.</p><p>This library uses bigarrays as buffers and can therefore release the OCaml runtime during (de)compression, allowing other OCaml threads to continue.</p><dl><dt>see <a href="https://github.com/madroach/ocaml-zlib">https://github.com/madroach/ocaml-zlib</a></dt><dd><p>latest version on github</p></dd></dl><dl><dt>see <a href="http://zlib.net/manual.html">http://zlib.net/manual.html</a></dt><dd><p>Zlib manual</p></dd></dl><dl><dt>see <a href="http://zlib.net/">http://zlib.net/</a></dt><dd><p>Zlib homepage</p></dd></dl><dl><dt>author</dt><dd>Christopher Zimmermann</dd></dl></header><dl><dt class="spec type" id="type-status"><a href="#type-status" class="anchor"></a><code><span class="keyword">type</span> status</code><code> = </code><table class="variant"><tr id="type-status.Ok" class="anchored"><td class="def constructor"><a href="#type-status.Ok" class="anchor"></a><code>| </code><code><span class="constructor">Ok</span></code></td><td class="doc"><p>0</p></td></tr><tr id="type-status.Stream_end" class="anchored"><td class="def constructor"><a href="#type-status.Stream_end" class="anchor"></a><code>| </code><code><span class="constructor">Stream_end</span></code></td><td class="doc"><p>1</p></td></tr><tr id="type-status.Need_dict" class="anchored"><td class="def constructor"><a href="#type-status.Need_dict" class="anchor"></a><code>| </code><code><span class="constructor">Need_dict</span></code></td><td class="doc"><p>2</p></td></tr><tr id="type-status.Buf_error" class="anchored"><td class="def constructor"><a href="#type-status.Buf_error" class="anchor"></a><code>| </code><code><span class="constructor">Buf_error</span></code></td><td class="doc"><p>3 (zlib -5)</p></td></tr><tr id="type-status.Data_error" class="anchored"><td class="def constructor"><a href="#type-status.Data_error" class="anchor"></a><code>| </code><code><span class="constructor">Data_error</span></code></td><td class="doc"><p>4 (zlib -3)</p></td></tr></table></dt><dd><p>Zlib return codes. Only non-fatal return codes are returned. Fatal error codes are translated to the standard exceptions <code>Failure _</code>, <code>Invalid_argument _</code> or <code>Out_of_memory</code>.</p></dd></dl><dl><dt class="spec type" id="type-algo"><a href="#type-algo" class="anchor"></a><code><span class="keyword">type</span> algo</code><code> = </code><table class="variant"><tr id="type-algo.Deflated" class="anchored"><td class="def constructor"><a href="#type-algo.Deflated" class="anchor"></a><code>| </code><code><span class="constructor">Deflated</span></code></td><td class="doc"><p>Compression algorithm. Only deflate is provided by current zlib.</p></td></tr></table></dt><dt class="spec type" id="type-strategy"><a href="#type-strategy" class="anchor"></a><code><span class="keyword">type</span> strategy</code><code> = </code><table class="variant"><tr id="type-strategy.Default_strategy" class="anchored"><td class="def constructor"><a href="#type-strategy.Default_strategy" class="anchor"></a><code>| </code><code><span class="constructor">Default_strategy</span></code></td><td class="doc"><p>0</p></td></tr><tr id="type-strategy.Filtered" class="anchored"><td class="def constructor"><a href="#type-strategy.Filtered" class="anchor"></a><code>| </code><code><span class="constructor">Filtered</span></code></td><td class="doc"><p>1</p></td></tr><tr id="type-strategy.Huffman_only" class="anchored"><td class="def constructor"><a href="#type-strategy.Huffman_only" class="anchor"></a><code>| </code><code><span class="constructor">Huffman_only</span></code></td><td class="doc"><p>2</p></td></tr><tr id="type-strategy.RLE" class="anchored"><td class="def constructor"><a href="#type-strategy.RLE" class="anchor"></a><code>| </code><code><span class="constructor">RLE</span></code></td><td class="doc"><p>3</p></td></tr><tr id="type-strategy.Fixed" class="anchored"><td class="def constructor"><a href="#type-strategy.Fixed" class="anchor"></a><code>| </code><code><span class="constructor">Fixed</span></code></td><td class="doc"><p>4</p></td></tr></table></dt><dd><p>Compression strategy - see zlib manual for details.</p></dd></dl><dl><dt class="spec type" id="type-flush"><a href="#type-flush" class="anchor"></a><code><span class="keyword">type</span> flush</code><code> = </code><table class="variant"><tr id="type-flush.No_flush" class="anchored"><td class="def constructor"><a href="#type-flush.No_flush" class="anchor"></a><code>| </code><code><span class="constructor">No_flush</span></code></td><td class="doc"><p>0</p></td></tr><tr id="type-flush.Partial_flush" class="anchored"><td class="def constructor"><a href="#type-flush.Partial_flush" class="anchor"></a><code>| </code><code><span class="constructor">Partial_flush</span></code></td><td class="doc"><p>1</p></td></tr><tr id="type-flush.Sync_flush" class="anchored"><td class="def constructor"><a href="#type-flush.Sync_flush" class="anchor"></a><code>| </code><code><span class="constructor">Sync_flush</span></code></td><td class="doc"><p>2</p></td></tr><tr id="type-flush.Full_flush" class="anchored"><td class="def constructor"><a href="#type-flush.Full_flush" class="anchor"></a><code>| </code><code><span class="constructor">Full_flush</span></code></td><td class="doc"><p>3</p></td></tr><tr id="type-flush.Finish" class="anchored"><td class="def constructor"><a href="#type-flush.Finish" class="anchor"></a><code>| </code><code><span class="constructor">Finish</span></code></td><td class="doc"><p>4</p></td></tr><tr id="type-flush.Block" class="anchored"><td class="def constructor"><a href="#type-flush.Block" class="anchor"></a><code>| </code><code><span class="constructor">Block</span></code></td><td class="doc"><p>5</p></td></tr><tr id="type-flush.Trees" class="anchored"><td class="def constructor"><a href="#type-flush.Trees" class="anchor"></a><code>| </code><code><span class="constructor">Trees</span></code></td><td class="doc"><p>6</p></td></tr></table></dt><dd><p>The type of the flush parameter passed to flate. Use <code>Finish</code> when all input has been provided, otherwise use <code>No_flush</code> For the other flush values see the zlib manual.</p></dd></dl><dl><dt class="spec type" id="type-data_type"><a href="#type-data_type" class="anchor"></a><code><span class="keyword">type</span> data_type</code><code> = </code><table class="variant"><tr id="type-data_type.Binary" class="anchored"><td class="def constructor"><a href="#type-data_type.Binary" class="anchor"></a><code>| </code><code><span class="constructor">Binary</span></code></td><td class="doc"><p>0</p></td></tr><tr id="type-data_type.Text" class="anchored"><td class="def constructor"><a href="#type-data_type.Text" class="anchor"></a><code>| </code><code><span class="constructor">Text</span></code></td><td class="doc"><p>1</p></td></tr><tr id="type-data_type.Unknown" class="anchored"><td class="def constructor"><a href="#type-data_type.Unknown" class="anchor"></a><code>| </code><code><span class="constructor">Unknown</span></code></td><td class="doc"><p>2</p></td></tr></table></dt><dd><p>Best guess of flate about the type of data being compressed</p></dd></dl><dl><dt class="spec type" id="type-deflate"><a href="#type-deflate" class="anchor"></a><code><span class="keyword">type</span> deflate</code></dt><dt class="spec type" id="type-inflate"><a href="#type-inflate" class="anchor"></a><code><span class="keyword">type</span> inflate</code></dt><dd><p>Pseudo types to specify whether a zlib stream state is used to inflate or deflate.</p></dd></dl><dl><dt class="spec type" id="type-state"><a href="#type-state" class="anchor"></a><code><span class="keyword">type</span> 'a state</code></dt><dd><p>Holds the internal state of zlib and the binding library</p></dd></dl><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> 'a t</code><code> = </code><code>{</code><table class="record"><tr id="type-t.state" class="anchored"><td class="def field"><a href="#type-t.state" class="anchor"></a><code>state : <span class="type-var">'a</span> <a href="index.html#type-state">state</a>;</code></td></tr><tr id="type-t.in_ba" class="anchored"><td class="def field"><a href="#type-t.in_ba" class="anchor"></a><code><span class="keyword">mutable</span> in_ba : (char, <a href="../../ocaml/Bigarray/index.html#type-int8_unsigned_elt">Bigarray.int8_unsigned_elt</a>, <a href="../../ocaml/Bigarray/index.html#type-c_layout">Bigarray.c_layout</a>) <a href="../../ocaml/Bigarray/Array1/index.html#type-t">Bigarray.Array1.t</a>;</code></td><td class="doc"><p>bigarray input buffer</p></td></tr><tr id="type-t.out_ba" class="anchored"><td class="def field"><a href="#type-t.out_ba" class="anchor"></a><code><span class="keyword">mutable</span> out_ba : (char, <a href="../../ocaml/Bigarray/index.html#type-int8_unsigned_elt">Bigarray.int8_unsigned_elt</a>, <a href="../../ocaml/Bigarray/index.html#type-c_layout">Bigarray.c_layout</a>) <a href="../../ocaml/Bigarray/Array1/index.html#type-t">Bigarray.Array1.t</a>;</code></td><td class="doc"><p>bigarray output buffer</p></td></tr><tr id="type-t.in_ofs" class="anchored"><td class="def field"><a href="#type-t.in_ofs" class="anchor"></a><code><span class="keyword">mutable</span> in_ofs : int;</code></td><td class="doc"><p>offset into the input buffer</p></td></tr><tr id="type-t.out_ofs" class="anchored"><td class="def field"><a href="#type-t.out_ofs" class="anchor"></a><code><span class="keyword">mutable</span> out_ofs : int;</code></td><td class="doc"><p>offset into the output buffer</p></td></tr><tr id="type-t.in_len" class="anchored"><td class="def field"><a href="#type-t.in_len" class="anchor"></a><code><span class="keyword">mutable</span> in_len : int;</code></td><td class="doc"><p>Length of available input data</p></td></tr><tr id="type-t.out_len" class="anchored"><td class="def field"><a href="#type-t.out_len" class="anchor"></a><code><span class="keyword">mutable</span> out_len : int;</code></td><td class="doc"><p>Length of available output data</p></td></tr><tr id="type-t.in_total" class="anchored"><td class="def field"><a href="#type-t.in_total" class="anchor"></a><code><span class="keyword">mutable</span> in_total : int;</code></td><td class="doc"><p>Length of input data processed so far</p></td></tr><tr id="type-t.out_total" class="anchored"><td class="def field"><a href="#type-t.out_total" class="anchor"></a><code><span class="keyword">mutable</span> out_total : int;</code></td><td class="doc"><p>Length of output data processed so far</p></td></tr><tr id="type-t.data_type" class="anchored"><td class="def field"><a href="#type-t.data_type" class="anchor"></a><code><span class="keyword">mutable</span> data_type : int;</code></td><td class="doc"><p>For deflate streams a guess about the type of data is returned here: <code>0</code> for binary data, <code>1</code> for text and <code>2</code> for unknown.</p><p>For inflate streams the number of unused bits in the last byte taken from the input stream is stored here. If <a href="index.html#val-flate"><code>flate</code></a> just finished decoding the header or returned after an end-of-block code <code>128</code> is added. If <a href="index.html#val-flate"><code>flate</code></a> is currentry decoding the last block <code>64</code> is added.</p></td></tr><tr id="type-t.cksum" class="anchored"><td class="def field"><a href="#type-t.cksum" class="anchor"></a><code><span class="keyword">mutable</span> cksum : int32;</code></td><td class="doc"><p>The checksum of the decompressed data produced resp. consumed so far. When <a href="index.html#val-flate"><code>flate</code></a> returns <a href="index.html#type-status.Need_dict"><code>status.Need_dict</code></a> the adler32 checksum of the required dictionary is returned here instead.</p></td></tr></table><code>}</code></dt><dd><p>Holds the internal state of zlib and the binding library</p><p>Record holding the internal state and input / output buffers of data as well as other data returned from the zlib inflate and deflate routines.</p></dd></dl><dl><dt class="spec type" id="type-header"><a href="#type-header" class="anchor"></a><code><span class="keyword">type</span> header</code><code> = </code><code>{</code><table class="record"><tr id="type-header.text" class="anchored"><td class="def field"><a href="#type-header.text" class="anchor"></a><code>text : bool;</code></td><td class="doc"><p>Compressed data believed to be text?</p></td></tr><tr id="type-header.mtime" class="anchored"><td class="def field"><a href="#type-header.mtime" class="anchor"></a><code>mtime : int32;</code></td><td class="doc"><p>mtime of compressed file. Set to zero if unknown.</p></td></tr><tr id="type-header.os" class="anchored"><td class="def field"><a href="#type-header.os" class="anchor"></a><code>os : int;</code></td><td class="doc"><p>filesystem type on which the compressed file was stored. See <a href="https://www.ietf.org/rfc/rfc1952.txt">RFC1952</a> for possible values.</p></td></tr><tr id="type-header.xflags" class="anchored"><td class="def field"><a href="#type-header.xflags" class="anchor"></a><code>xflags : int;</code></td><td class="doc"><p>Extra flags according to <a href="https://www.ietf.org/rfc/rfc1952.txt">RFC1952</a>. For deflate compression method the compression level is stored here.</p></td></tr><tr id="type-header.extra" class="anchored"><td class="def field"><a href="#type-header.extra" class="anchor"></a><code>extra : string option;</code></td><td class="doc"><p>Extra header field according to <a href="https://www.ietf.org/rfc/rfc1952.txt">RFC1952</a>.</p></td></tr><tr id="type-header.name" class="anchored"><td class="def field"><a href="#type-header.name" class="anchor"></a><code>name : string option;</code></td><td class="doc"><p>Original file name of the compressed file translated to ISO 8859-1 (LATIN-1).</p></td></tr><tr id="type-header.comment" class="anchored"><td class="def field"><a href="#type-header.comment" class="anchor"></a><code>comment : string option;</code></td><td class="doc"><p>File comment. According to <a href="https://www.ietf.org/rfc/rfc1952.txt">RFC1952</a> only ISO 8859-1 (LATIN-1) characters are allowed. Linebreak is a single linefeed.</p></td></tr></table><code>}</code></dt><dd><p>Record holding the data in a gzip header</p></dd></dl><dl><dt class="spec value" id="val-create_inflate"><a href="#val-create_inflate" class="anchor"></a><code><span class="keyword">val</span> create_inflate : ?&#8288;window_bits:int <span>&#45;&gt;</span> unit <span>&#45;&gt;</span> <a href="index.html#type-inflate">inflate</a> <a href="index.html#type-t">t</a></code></dt><dd><p><code>inflate_init window_bits</code> Creates zlib internal state and buffer description for decompression.</p><dl><dt>parameter window_bits</dt><dd><p>the base 2 logarithm of the maximum window size. It should be in tha range 8..15 and greater or equal to the <code>window_bits</code> parameter used for compression. By default the zlib format is decoded. Use a negative value -8..-15 for raw deflate decompression without zlib or gzip header. Add <code>16</code> to <code>window_bits</code> to decode the gzip format. Add <code>32</code> to <code>window_bits</code> to decode zlib or gzip format with automatic header detection.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-create_deflate"><a href="#val-create_deflate" class="anchor"></a><code><span class="keyword">val</span> create_deflate : ?&#8288;level:int <span>&#45;&gt;</span> ?&#8288;algo:<a href="index.html#type-algo">algo</a> <span>&#45;&gt;</span> ?&#8288;window_bits:int <span>&#45;&gt;</span> ?&#8288;memory:int <span>&#45;&gt;</span> ?&#8288;strategy:<a href="index.html#type-strategy">strategy</a> <span>&#45;&gt;</span> unit <span>&#45;&gt;</span> <a href="index.html#type-deflate">deflate</a> <a href="index.html#type-t">t</a></code></dt><dd><p><code>create_inflate ()</code> Creates zlib internal <a href="index.html#type-state"><code>state</code></a> and buffer description for compression.</p><dl><dt>parameter level</dt><dd><p>the compression level must be betweed <code>-1</code> and <code>9</code>. <code>-1</code> selects default compression level, <code>1</code> gives best speed <code>9</code> gives best compression, anything in between is a compromise of speed/compression. <code>0</code> gives no compression at all.</p></dd></dl><dl><dt>parameter algo</dt><dd><p>Only <a href="index.html#type-algo.Deflated"><code>algo.Deflated</code></a> available at the moment.</p></dd></dl><dl><dt>parameter window_bits</dt><dd><p>the base 2 logarithm of the maximum window size. It should be in tha range 8..15 and greater or equal to the <code>window_bits</code> parameter used for compression. Use a negative value -8..-15 for raw deflate compression without zlib or gzip header. Add 16 to <code>window_bits</code> to write a gzip header.</p></dd></dl><dl><dt>parameter memory</dt><dd><p>selects how much memory to use for compression in the range 1..9. More memory means faster and better compression. A value of <code>9</code> uses 256kb, <code>8</code> 128kb, <code>7</code> 64kb...</p></dd></dl><dl><dt>parameter strategy</dt><dd><p>See the zlib manual for details about this parameter.</p></dd></dl></dd></dl><dl><dt class="spec external" id="val-inflate_init"><a href="#val-inflate_init" class="anchor"></a><code><span class="keyword">val</span> inflate_init : window_bits:int <span>&#45;&gt;</span> <a href="index.html#type-inflate">inflate</a> <a href="index.html#type-state">state</a></code></dt><dd><p><code>inflate_init window_bits</code> like <a href="index.html#val-create_inflate"><code>create_inflate</code></a>, but only creates the internal <a href="index.html#type-state"><code>state</code></a>.</p></dd></dl><dl><dt class="spec external" id="val-deflate_init"><a href="#val-deflate_init" class="anchor"></a><code><span class="keyword">val</span> deflate_init : level:int <span>&#45;&gt;</span> algo:<a href="index.html#type-algo">algo</a> <span>&#45;&gt;</span> window_bits:int <span>&#45;&gt;</span> memory:int <span>&#45;&gt;</span> strategy:<a href="index.html#type-strategy">strategy</a> <span>&#45;&gt;</span> <a href="index.html#type-deflate">deflate</a> <a href="index.html#type-state">state</a></code></dt><dd><p><code>inflate_init level algo window_bits memory</code> like <a href="index.html#val-create_deflate"><code>create_deflate</code></a>, but only creates the internal <a href="index.html#type-state"><code>state</code></a>.</p></dd></dl><dl><dt class="spec external" id="val-deflate_bound"><a href="#val-deflate_bound" class="anchor"></a><code><span class="keyword">val</span> deflate_bound : <a href="index.html#type-deflate">deflate</a> <a href="index.html#type-state">state</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int</code></dt><dd><p><code>deflate_bound state len</code> calculates an upper bound on the size of the compressed data. This functions assumes the zlib format is used. The resulting compressed size might be larger than the returned bound when the gzip format is being used.</p><dl><dt>returns</dt><dd><p>An upper bound on the compressed data when using the zlib format.</p></dd></dl><dl><dt>parameter state</dt><dd><p><a href="index.html#type-deflate"><code>deflate</code></a> <a href="index.html#type-state"><code>state</code></a> to be used in compression.</p></dd></dl><dl><dt>parameter len</dt><dd><p>size of the data to be compressed.</p></dd></dl></dd></dl><dl><dt class="spec external" id="val-flate"><a href="#val-flate" class="anchor"></a><code><span class="keyword">val</span> flate : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-flush">flush</a> <span>&#45;&gt;</span> <a href="index.html#type-status">status</a></code></dt><dd><p><code>flate buffers flush</code> (de)compresses data from the provided input to the output buffers.</p><dl><dt>returns</dt><dd><p><a href="index.html#type-status.Ok"><code>status.Ok</code></a> if some progress has been made but more input or output is expected. <a href="index.html#type-status.Stream_end"><code>status.Stream_end</code></a> if all data has been processed. <a href="index.html#type-status.Need_dict"><code>status.Need_dict</code></a> if a dictionary is needed when inflating zlib data. <a href="index.html#type-status.Data_error"><code>status.Data_error</code></a> if the provided data is inconsistent.</p></dd></dl><dl><dt>parameter buffers</dt><dd><p>this record is documented above. It's fields are updated by this function.</p></dd></dl><dl><dt>parameter flush</dt><dd><p>Whether and how the output should be flushed. See the type definition above and the zlib manual for details.</p></dd></dl></dd></dl><dl><dt class="spec external" id="val-inflate_set_dictionary"><a href="#val-inflate_set_dictionary" class="anchor"></a><code><span class="keyword">val</span> inflate_set_dictionary : <a href="index.html#type-inflate">inflate</a> <a href="index.html#type-state">state</a> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <a href="index.html#type-status">status</a></code></dt><dd><p><code>inflate_set_dictionary state dict</code> Sets a preset dictionary for decompression. Must be called after <a href="index.html#val-flate"><code>flate</code></a> requested a dictionary by returning <a href="index.html#type-status.Need_dict"><code>status.Need_dict</code></a>; the cksum field of <a href="index.html#type-state"><code>state</code></a> will then contain the adler32 checksum of the required dictionary.</p><dl><dt>returns</dt><dd><p><a href="index.html#type-status.Data_error"><code>status.Data_error</code></a> when the adler32 checksum of the provided dictionary doesn't match the requested checksum.</p></dd></dl><dl><dt>parameter state</dt><dd><p>A <a href="index.html#type-inflate"><code>inflate</code></a> <a href="index.html#type-state"><code>state</code></a> used for compression.</p></dd></dl></dd></dl><dl><dt class="spec external" id="val-deflate_set_dictionary"><a href="#val-deflate_set_dictionary" class="anchor"></a><code><span class="keyword">val</span> deflate_set_dictionary : <a href="index.html#type-deflate">deflate</a> <a href="index.html#type-state">state</a> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> int32</code></dt><dd><p><code>deflate_set_dictionary state dict</code> Sets a preset dictionary for compression. When using the zlib format this needs to be called before the first call to <a href="index.html#val-flate"><code>flate</code></a>. No dictionary may be used for the gzip format.</p><dl><dt>returns</dt><dd><p>the adler32 checksum of the provided dictionary.</p></dd></dl><dl><dt>parameter state</dt><dd><p>A <a href="index.html#type-deflate"><code>deflate</code></a> <a href="index.html#type-state"><code>state</code></a> used for compression.</p></dd></dl></dd></dl><dl><dt class="spec external" id="val-get_header"><a href="#val-get_header" class="anchor"></a><code><span class="keyword">val</span> get_header : <a href="index.html#type-inflate">inflate</a> <a href="index.html#type-state">state</a> <span>&#45;&gt;</span> <a href="index.html#type-header">header</a></code></dt><dd><p><code>get_header header</code> Retrieve a header after a gzip header has been read by <a href="index.html#val-flate"><code>flate</code></a>.</p><dl><dt>returns</dt><dd><p>the header read by <a href="index.html#val-flate"><code>flate</code></a>.</p></dd></dl><dl><dt>raises Failure</dt><dd><p><code>&quot;Zlib.get_header: Header not yet completed.&quot;</code> if the header has not yet been completely read.</p></dd></dl><dl><dt>raises Not_found</dt><dd><p>if not reading gzip format.</p></dd></dl></dd></dl><dl><dt class="spec external" id="val-set_header"><a href="#val-set_header" class="anchor"></a><code><span class="keyword">val</span> set_header : <a href="index.html#type-deflate">deflate</a> <a href="index.html#type-state">state</a> <span>&#45;&gt;</span> <a href="index.html#type-header">header</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>set_header header</code> Provide a header when writing the gzip format. Must be called before any call to <a href="index.html#val-flate"><code>flate</code></a>.</p><dl><dt>parameter header</dt><dd><p>fields to be stored th the header. The <a href="index.html#type-header.xflags"><code>header.xflags</code></a> field is not used when compressing.</p></dd></dl></dd></dl><dl><dt class="spec external" id="val-reset"><a href="#val-reset" class="anchor"></a><code><span class="keyword">val</span> reset : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>reset buffers</code> Prepares for a new stream of data to be (de)compressed. The parameters passed to <a href="index.html#val-inflate_init"><code>inflate_init</code></a> resp. <a href="index.html#val-deflate_init"><code>deflate_init</code></a> are left unchanged.</p><dl><dt>parameter buffers</dt><dd><p>resets all fields to sane initial values and resets the internal <a href="index.html#type-state"><code>state</code></a>.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-get_data_type"><a href="#val-get_data_type" class="anchor"></a><code><span class="keyword">val</span> get_data_type : <a href="index.html#type-deflate">deflate</a> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-data_type">data_type</a></code></dt><dd><p><code>get_data_type buffers</code> gets the data type of the data being compressed.</p><dl><dt>returns</dt><dd><p>Best guess on the data being compressed.</p></dd></dl><dl><dt>parameter buffers</dt><dd><p>The buffers of the running compression.</p></dd></dl></dd></dl><dl><dt class="spec external" id="val-adler32"><a href="#val-adler32" class="anchor"></a><code><span class="keyword">val</span> adler32 : int32 <span>&#45;&gt;</span> string <span>&#45;&gt;</span> int32</code></dt><dd><p><code>adler32 cksum buf</code> Updates the running adler32 checksum</p><dl><dt>returns</dt><dd><p>updated checksum.</p></dd></dl><dl><dt>parameter cksum</dt><dd><p>The running adler32 checksum to be updated.</p></dd></dl><dl><dt>parameter buf</dt><dd><p>The data with which to update the <code>cksum</code>.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-adler32_empty"><a href="#val-adler32_empty" class="anchor"></a><code><span class="keyword">val</span> adler32_empty : int32</code></dt><dd><p><code>adler32 cksum buf</code> Updates the running adler32 checksum</p><dl><dt>returns</dt><dd><p>updated checksum.</p></dd></dl><dl><dt>parameter cksum</dt><dd><p>The running adler32 checksum to be updated.</p></dd></dl><dl><dt>parameter buf</dt><dd><p>The data with which to update the <code>cksum</code>.</p></dd></dl><p>Initial value to be used with <a href="index.html#val-adler32"><code>adler32</code></a></p></dd></dl></div></body></html>